@node scmobj
@chapter A simple object system


The @library{scmobj} library defines an object system for Scheme that
provides: simple and multiple inheritance, generic functions,
multimethods.  It resembles @clos{} (the Common Lisp Object System), but
it does not implement a meta object protocol (@acronym{MOP}).

The library is a reorganisation and repackaging of ScmObj, an object
system for Scheme implemented by Dorai Sitaram.  The original code is
available from@footnote{@aurl{} last checked Thu Nov 13, 2008.}:

@center @url{http://www.ccs.neu.edu/home/dorai/scmobj/scmobj.html}

This library has the main purpose of keeping the source code simple and
understandable, so that it can be taken as starting point for more
sophisticated object systems.

@menu
* scmobj overview::             Overview of the library.
* scmobj example::              Objects layout examples.
* scmobj class::                Classes.
* scmobj instance::             Instances.
* scmobj inspect::              Inspecting classes and instances.
* scmobj slot::                 Accessing slots.
* scmobj generic::              Generic functions and methods.
@end menu

@c page
@node scmobj overview
@section Overview of the library


@library{scmobj} objects, that is classes and instances, are association
lists: Proper lists of pairs whose cars are symbols and whose cdrs can
be any value.

In this document: each pair is called @dfn{slot}; the symbol is called
@dfn{slot name}; the value is called @dfn{slot value}.  By convention
the slot name symbols must have name starting with a colon @code{:}.

A @dfn{class} object is an alist whose first slot's name is
@code{:class}, and the other slot names are:

@example
:class-definition-name
:class-precedence-list
:slots
@end example

An instance object is an alist whose first slot's name is @code{:class},
and the other slot names are configured by the user.


@deffn Slot :class
It must be the first slot for both class and instance objects.

For an instance object: The value must be the class of the instance.

For a class object: The value must be the predefined @class{class}
object.  So a class object is a special case of instance object.
@end deffn


@deffn Slot :class-definition-name
A class object's slot whose value is the ``public name'' of the class.
By convention it must be a symbol whose name is enclosed in angular
parentheses.  It is useful to print debug messages.
@end deffn


@deffn Slot :class-precedence-list
A class object's slot whose value is a list representing the hierarchy
of superclasses for the instance objects of the class, or @false{} if
the class has no precedence list.  It is used for dispatching of
multimethods.

Notice that the value of this slot does @strong{not} hold the class
object itself.
@end deffn


@deffn Slot :slots
A class object's slot whose value is the list of slot names for the
instances of the class, or @false{} if instances have no slots.  For the
predefined @class{class} object, the list is:

@example
(:class-definition-name :class-precedence-list :slots)
@end example

Notice that the symbol @code{:class} is @strong{not} included.
@end deffn

@c page
@node scmobj example
@section Objects layout examples


In the following it is not always convenient to show the full layout; to
highlight informations of interest, it is better to omit the layout of
class objects nested into class objects.  When this is done the string
@code{#<apple>} is included in place of the layout of the class
@class{apple}.

Let's start with the layout of @class{class} itself:

@example
((:class . #<class>)
 (:class-definition-name . <class>)
 (:class-precedence-list . #f)
 (:slots . (:class-definition-name
            :class-precedence-list
            :slots)))
@end example

@noindent
we see that the class of @class{class} is @class{class} itself.

As an example of class hierarchy, let's define a class with no
superclass and no slots:

@example
(define-class <biologic>)
@end example

@noindent
its layout is this:

@example
((:class . #<class>)
 (:class-definition-name . <biologic>)
 (:class-precedence-list . #f)
 (:slots . #f))
@end example

@noindent
now we derive a class from it, still without slots:

@example
(define-class <fruit> (<biologic>))
@end example

@noindent
@class{fruit} is a @dfn{subclass} of @class{biologic}, @class{biologic}
is a @dfn{superclass} of @class{fruit}; the layout of the subclass is:

@example
((:class . #<class>)
 (:class-definition-name . <fruit>)
 (:class-precedence-list . (#<biologic>))
 (:slots . #f))
@end example

@noindent
finally we subclass again adding slots:

@example
(define-class <apple> (<fruit>)
  :variety :colour :quality)
@end example

@noindent
and the layout is:

@example
((:class . #<class>)
 (:class-definition-name . <apple>)
 (:class-precedence-list . (#<fruit> #<biologic>))
 (:slots . (:variety :colour :quality)))
@end example

We have a usable class, so we instantiate it:

@example
(define o (make <apple>
            :variety 'renetta
            :colour  'green
            :quality 'high))
@end example

@noindent
and the layout of the instance is:

@example
((:class   . #<apple>)
 (:variety . renetta)
 (:colour  . green)
 (:quality . high))
@end example

We may want to add a price:

@example
(define-class <price> () :tag)

(define-class <priced-apple> (<apple> <price>))
@end example

@noindent
and the layout of the class with multiple inheritance is:

@example
((:class . #<class>)
 (:class-definition-name . <priced-apple>)
 (:class-precedence-list . (#<apple>
                            #<fruit>
                            #<biologic>
                            #<price>))
 (:slots . (:variety :colour :quality :tag)))
@end example

The instance of a priced apple:

@example
(define p (make <priced-apple>
            :variety 'renetta
            :colour  'green
            :quality 'high
            :tag 100))
@end example

@noindent
has layout:

@example
((:class   . #<priced-apple>)
 (:variety . renetta)
 (:colour  . green)
 (:quality . high)
 (:tag     . 100))
@end example

@c page
@node scmobj class
@section Classes


@menu
* scmobj class make::           Making classes
* scmobj class chart::          A chart for predefined classes
* scmobj class core::           Core class types.
* scmobj class list::           List types.
* scmobj class compound::       Non-list compound data types.
* scmobj class numeric::        Numeric data types.
* scmobj class port::           Port types.
* scmobj class misc::           Miscellaneous types.
@end menu

@c page
@node scmobj class make
@subsection Making classes


@deffn Syntax make-class @var{list-of-superclasses} . @var{class-slots}
Build and return a new class value.

@var{list-of-superclasses} is the list of superclasses of the new
class; acceptable values are:

@itemize
@item
The empty list, in which case @class{class} is added by default.

@item
A list containing only the @class{class} value.

@item
A list of previously defined base classes.
@end itemize

@var{class-slots} must be a list of symbols representing the slot names.
By convention their names should start with a colon character, @code{:}.
It is possible for a class to add no new slots, that is
@var{class-slots} can be the empty string: This allows subclassing for
the only purpose of method dispatching.

Notice that classes instantiated with @func{make-class} will have no
class definition name.  The @func{class-definition-name} function
applied to them will return the symbol @code{:uninitialised}.
@end deffn


@deffn Syntax define-class @var{name} @var{list-of-superclasses} . @var{class-slots}
A wrapper for @func{make-class} that defines a new variable named
@var{name} and assigns the new class to it.  The class definition name
of the class is initialised to @var{name}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Examples

Definition of a class with no superclasses and 3 slots named: @code{:a},
@code{:b} and @code{:c}:

@example
(define <one>
  (make-class () :a :b :c)
@end example

@noindent
the same with explicit selection of the base @class{class}:

@example
(define <one>
  (make-class (<class>) :a :b :c)
@end example

Simple inheritance:

@example
(let* ((<one>   (make-class ()      :a :b :c))
       (<two>   (make-class (<one>) :d :e :f))
       (<three> (make-class (<two>) :g :h :i)))
  ---)
@end example

@noindent
and multiple inheritance:

@example
(let* ((<one>   (make-class ()            :a :b :c))
       (<two>   (make-class (<one>)       :d :e :f))
       (<three> (make-class (<two> <one>) :g :h :i)))
  ---)
@end example

Defining classes using @func{define-class}:

@example
(define-class <one> ()
  :a :b :c)

(define-class <two> (<one>)
  :d :e :f)

(define-class <three> (<two>)
  :g :h :i)
@end example

@c page
@node scmobj class chart
@subsection A chart for predefined classes


@example
<class>
   |
   |                             -> <input-port>
   |                            |
   |                            +-> <output-port>
   |                            |
   |                            +-> <binary-port>
   |                            |
   |               --> <port> --+-> <textual-port>
   |              |
   |              +--> <record> --> <condition>
   |              |
   |              +--> <string>
   |              |
   |              +--> <char>
   v              |
<builtin-class> --+-------+-------+-----------+
   |              |       |       |           |
   v              v       v       v           v
<number>        <pair> <vector> <bytevector> <hashtable>
   |              |
   v              |
<complex>         +--------------+------------
   |              |              |            |
   v              v              v            v
<real-valued>   <list>    <dotted-list> <circular-list>
   |
   v
<real> ------> <flonum>
   |
   v
<rational-valued>
   |         |
   v         v
<rational> <integer-valued>
   |
   v
<integer>
   |
   v
<fixnum>
@end example

@c page
@node scmobj class core
@subsection Core class types


@deftp {Class} <class>
The base class of all the @library{scmobj} classes.
@end deftp


@deftp {Class} <builtin-class>
The base class builtin Scheme values.
@end deftp

@c page
@node scmobj class list
@subsection List types


@deftp Class @aclass{pair}
Class for values that satisfy @func{pair?}.
@end deftp


@deftp Class @aclass{list}
Class for values that satisfy @func{list?}.
@end deftp


@deftp Class @aclass{circular-list}
Class for values that satisfy @func{circular-list?}.  Notice that a pair
and a proper list are not circular lists.
@end deftp


@deftp Class @aclass{dotted-list}
Class for values that satisfy @func{dotted-list?}.  Notice that a pair
is always a dotted list, but a proper list is not a dotted list.
@end deftp

@c page
@node scmobj class compound
@subsection Non--list compound data types


@deftp Class @aclass{vector}
Class for values that satisfy @func{vector?}.
@end deftp


@deftp Class @aclass{bytevector}
Class for values that satisfy @func{bytevector?}.
@end deftp


@deftp Class @aclass{hashtable}
Class for values that satisfy @func{hashtable?}.
@end deftp


@deftp Class @aclass{record}
Class for values that satisfy @func{record?}.
@end deftp

@c page
@node scmobj class numeric
@subsection Numeric data types


@deftp Class @aclass{number}
Class for values that satisfy @func{number?}.
@end deftp


@deftp Class @aclass{complex}
Class for values that satisfy @func{complex?}.
@end deftp


@deftp Class @aclass{real-valued}
Class for values that satisfy @func{real-valued?}.
@end deftp


@deftp Class @aclass{real}
Class for values that satisfy @func{real?}.
@end deftp


@deftp Class @aclass{rational}
Class for values that satisfy @func{integer?}.
@end deftp


@deftp Class @aclass{rational-valued}
Class for values that satisfy @func{integer?}.
@end deftp


@deftp Class @aclass{integer-valued}
Class for values that satisfy @func{integer?}.
@end deftp


@deftp Class @aclass{integer}
Class for values that satisfy @func{integer?}.
@end deftp


@deftp Class @aclass{fixnum}
Class for values that satisfy @func{fixnum?}.
@end deftp


@deftp Class @aclass{flonum}
Class for values that satisfy @func{flonum?}.
@end deftp

@c page
@node scmobj class port
@subsection Port types


The following classes for input/output ports are predefined.


@deftp Class @aclass{port}
Class for values that satisfy @func{port?}.
@end deftp


@deftp Class @aclass{input-port}
Class for values that satisfy @func{input-port?}.
@end deftp


@deftp Class @aclass{output-port}
Class for values that satisfy @func{output-port?}.
@end deftp


@deftp Class @aclass{textual-port}
Class for values that satisfy @func{textual-port?}.
@end deftp


@deftp Class @aclass{binary-port}
Class for values that satisfy @func{binary-port?}.
@end deftp


The binary/textual attributes are not mututally exclusive with the
input/output attributes, so if we need it, we can use multiple
inheritance:

@example
(define-class <binary-input-port> (<binary-port> <input-port>))
@end example

@c page
@node scmobj class misc
@subsection Miscellaneous types


@deftp {Class} <condition>
Class for values that satisfy @func{condition?}.
@end deftp


@deftp {Class} <string>
Class for values that satisfy @func{string?}.
@end deftp


@deftp {Class} <char>
Class for values that satisfy @func{char?}.
@end deftp

@c page
@node scmobj instance
@section Instances


@deffn Macro make @var{class-object} . @var{init-slots}
Build and return a new instance object of class @var{class-object}.  The
optional arguments are symbol/value couples used to initialise the
slots: The symbol must be the name of a slot, the value its value.

It is @strong{not} mandatory to initialise all the slots in a class
instance.  Uninitialised slots will be initialised to the symbol
@code{:uninitialised}.
@end deffn


@subsubheading Examples

Instantiate a class with 3 slots:

@example
(let* ((<one> (make-class () :a :b :c))
       (o     (make <one>
                 :a 1 :b 2 :c 3)))
  ---)
@end example

Instantiate a class with superclasses, initialising all the slots:

@example
(let* ((<one>   (make-class () :a :b :c))
       (<two>   (make-class (<one>) :d :e :f))
       (<three> (make-class (<two>) :g :h :i))
       (o       (make <three>
                   :a 1 :b 2 :c 3
                   :d 4 :e 5 :f 6
                   :g 7 :h 8 :i 9)))
  ---)
@end example

@c page
@node scmobj inspect
@section Inspecting classes and instances


@defun class? @var{obj}
Does its best to determine if @var{obj} is a valid class object.
@end defun


@defun instance? @var{obj}
Does its best to determine if @var{obj} is a valid instance object.
@end defun


@defun class-of @var{class/instance}
Return the class of the argument.  This function can be applied to both
class objects and instance objects.  If this function is not able to
determine a class, it returns @false{}; this should never happen,
though.
@end defun


@defun is-a? @var{class/instance} @var{class}
Return true if @var{class/instance} is an object of class @var{class}.
This function can be applied to both class objects and instance objects.
@end defun


@defun subclass? @var{class-1} @var{class-2}
Return true if @var{class-1} is a subclass of @var{class-2}, false
otherwise.
@end defun


@defun class-definition-name @var{class}
Return the class definition name for @var{class}.  Note that the
definition name is set only for classes instantiated with
@func{define-class}, for classes instantiated with @func{make-class} the
return value is the symbol @code{:uninitialised}.
@end defun


@defun class-precedence-list @var{class}
Return a list of classes representing the class precendence list, used
for method dispatching.  Note that @var{class} itself is @strong{not}
part of the class precedence list.
@end defun


@defun class-slots @var{class}
Return a list of symbols representing the slot names of @var{class}.
The symbol @code{:class} is excluded.
@end defun


@defun class-direct-slots @var{class}
Return a list of symbols representing the slot names of @var{class},
excluding the slots of its superclasses.
@end defun

@c page
@node scmobj slot
@section Accessing slots


@defun slot-ref @var{object} @var{slot-name}
Return the value of @var{slot-name} in @var{object}.  @var{slot-name}
must be a symbol.  It is an error if @var{object} has no slot named
@var{slot-name}.
@end defun


@defun {slot-set!} @var{object} @var{slot-name} @var{new-value}
Overwrite the value of @var{slot-name} in @var{object} with
@var{new-value}.  @var{slot-name} must be a symbol.  It is an error if
@var{object} has no slot named @var{slot-name}.
@end defun

@c ------------------------------------------------------------

@subsubheading Examples

Basic slot access:

@example
(let* ((<one>  (make-class () :a :b :c))
       (o      (make <one>
                 :a 1 :b 2 :c 3)))

  (slot-set! o ':b 123)

  (list (slot-ref o ':b)
        (slot-ref o ':a)
        (slot-ref o ':c))) @result{} '(123 1 3)
@end example

It is possible to define simple accessors for slots like this:

@example
(define-class <one> ()
  :alpha :beta)

(define alpha
  (case-lambda
    ((o)
     (slot-ref  o ':alpha))
    ((o v)
     (slot-set! o ':alpha v))))

(define o (make <one> :alpha 123))

(alpha o)       @result{} 123
(alpha o 456)
(alpha o)       @result{} 456
@end example

@noindent
or better:

@example
(define-class <one> ()
  :alpha :beta)

(define (make-accessor slot-name)
  (case-lambda
    ((o)
     (slot-ref  o slot-name))
    ((o v)
     (slot-set! o slot-name v))))

(define o (make <one> :alpha 123))
(define alpha
  (make-accessor ':alpha))

(alpha o)       @result{} 123
(alpha o 456)
(alpha o)       @result{} 456
@end example

@noindent
and closure accessors are also possible:

@example
(define-class <one> ()
  :alpha :beta)

(define (make-accessor o slot-name)
  (case-lambda
    (()
     (slot-ref  o slot-name))
    ((v)
     (slot-set! o slot-name v))))

(define o (make <one> :alpha 123))
(define alpha
  (make-accessor o ':alpha))

(alpha)         @result{} 123
(alpha 456)
(alpha)         @result{} 456
@end example

@c page
@node scmobj generic
@section Generic functions and methods


@dfn{Generic functions} are procedures that can be specialized to the
classes of their arguments.  Each specialisation of a generic function
is called @dfn{method}.  When applying a generic function to a set of
arguments, the most specific method with respect to the arguments'
classes is chosen.

@menu
* scmobj generic application::  How generic functions and methods
                                are invoked.
* scmobj generic dispatching::  How methods are dispatched.
* scmobj generic define::       Defining generic functions and methods.
* scmobj generic next::         Invoking the next method.
* scmobj generic examples::     Examples of method dispatching.
@end menu

@c page
@node scmobj generic application
@subsection How generic functions and methods are invoked


@library{scmobj} allows the definition of four kinds of methods:
@code{:primary}, @code{:around}, @code{:before} and @code{:after}.  The
short description is that @code{:around} methods are applied first, then
@code{:before}, @code{:primary} and @code{:after} methods are applied in
this order.

When a generic function is applied to a tuple of arguments, the
following happens:

@enumerate
@item
For each argument in the tuple a class is determined.  The tuple of
classes is called @dfn{signature}.
@end enumerate

For each kind of method, the generic function maintains an internal
collection in which every method's closure is associated to a signature.

@enumerate 2
@item
For each kind of method: The internal collection is queried for all the
methods applicable to the tuple of arguments, using the signature as
search key.

@item
For each kind of method: The list of applicable methods is sorted from
the more specific to the least specific for the signature.  The list of
@code{:after} methods is reversed.
@end enumerate

From now on the lists of sorted, applicable methods are handled as
stacks; the stacks of @code{:primary}, @code{:around} and @code{:before}
methods have most specific method on the top; the stack of @code{:after}
methods has the least specific method on the top.

From now on the application of the generic function enters an implicit
loop in which more methods' closures can be applied to the same tuple of
arguments.  The loop can terminate if a method's closure throws an
exception or, for @code{:around} and @code{:primary} methods, if it does
not take the special action of calling @func{call-next-method}.

The loop is a bit articulated, so we may have to read the following
descriptions multiple times.  We split the description in two branches:
First a simplified invocation for generic functions having at least one
applicable @code{:primary} method, no @code{:around} methods, and
performing no calls to @func{call-next-method}; then the full
application algorithm.

Here is the simplified branch with no @code{:around} methods and no
calls to @func{call-next-method}:

@enumerate 4
@item
Pop all the @code{:before} methods from the stack and apply their
closures to the tuple of arguments.  The return values of these
applications are discarded.

@item
Pop the next @code{:primary} method from the stack and apply its closure
to the tuple of arguments.  The return value of this application is
saved in a temporary location.

@item
Pop all the @code{:after} methods from the stack and apply their
closures to the tuple of arguments.  The return values of these
applications are discarded.

@item
Return the saved return value of the @code{:primary} method.
@end enumerate

Here is the full application algorithm:

@enumerate 4
@item
Test if this function application originated from a call to
@func{call-next-method} from a @code{:before} or @code{:after} method.
If it has: Raise an assertion violation.

@item
Test if this function application originated from a call to
@func{call-next-method} from a @code{:primary} method.  If it has:

@enumerate a
@item
If the stack of @code{:primary} methods is empty raise an assertion
violation.

@item
Pop the next @code{:primary} method from the stack and apply its closure
to the tuple of arguments.

@item
Break out returning the return value of this application: It becomes the
return value of @func{call-next-method}.
@end enumerate

@item
If the stack of @code{:primary} methods is empty: Raise an assertion
violation.  This condition means that the generic function has no
applicable methods for the tuple of arguments.

@item
If the stack of @code{:around} methods is not empty: Pop the next
@code{:around} method and apply its closure to the tuple of arguments.
Break out returning the return value of this application.

@item
Pop all the @code{:before} methods from the stack and apply their
closures to the tuple of arguments.  The return values of these
applications are discarded.

@item
Pop the next @code{:primary} method from the stack and apply its closure
to the tuple of arguments.  The return value of this application is
saved in a temporary location.

@item
Pop all the @code{:after} methods from the stack and apply their
closures to the tuple of arguments.  The return values of these
applications are discarded.

@item
Return the saved return value of the @code{:primary} method.
@end enumerate

The @code{:primary} methods are meant to do the real work of the
function.  Only the most specific is applied to the arguments, however
it can use @func{call-next-method} to invoke a least specialised version
and use its return value.

@code{:before} and @code{:after} methods are meant to execute additional
work before and after the primary methods.  While @code{:before} methods
are applied from the most specific to the least specific, @code{:after}
methods are applied from the least specific to the most specific.
Notice that the @code{:after} methods have no access to the return value
of the @code{:primary} methods.

@code{:around} methods are yet another level for performing tasks before
and after the primary methods; only the most specific is applied to the
arguments.  It is expected, but not mandatory, that an @code{:around}
method invokes @func{call-next-method}; such invocations will consume
all the applicable @code{:around} methods, from the least to the most
specific, and then will start the application of @code{:before},
@code{:primary} and @code{:after} methods.

@c page
@node scmobj generic dispatching
@subsection How methods are dispatched


Here we attempt the formulation of the rules by which methods are
dispatched.  A method is identified by a triplet of values: a list of
classes, called signature, representing the classes or expected
arguments; a boolean value telling if the closure accepts rest
arguments; the closure.

@c ------------------------------------------------------------

@subsubheading Applicability

First we need to understand when a method is applicable to a tuple of
arguments.  Given a tuple of arguments, a method supporting no rest
arguments is applicable to it if:

@enumerate
@item
The length of the signature is equal to the length of the arguments'
tuple.

@item
Position by position, the class in the signature is @func{eq?} to the
class of the value in the tuple, or it is in the class precedence list
of the class of the value in the tuple.
@end enumerate

@noindent
a method supporting rest arguments is applicable to it if:

@enumerate
@item
The length of the signature is less than or equal to the length of the
arguments' tuple.

@item
Position by position, up to the last element in the signature, the class
in the signature is @func{eq?} to the class of the value in the tuple,
or it is in the class precedence list of the class of the value in the
tuple.
@end enumerate

@c ------------------------------------------------------------

@subsubheading Specificity

Now we can understand how to determine which one, among two applicable
methods, is more specific for a tuple of arguments.  Let's call the
methods @var{A} and @var{B}.  Notice that it is impossible for two
distinct methods, in the same generic function, to have the same
signature and the same support for rest arguments.

@enumerate
@item
If both @var{A} and @var{B} support rest arguments: The one with the
longest signature is more specific.

@item
The classes in the signatures are compared in couples, position by
position from the beginning to the end.

@enumerate a
@item
If the classes are @func{eq?}, the next couple is inspected.

@item
If the class from @var{A} is a subclass of the one from @var{B}: Then
@var{A} is more specific than @var{B}.  If no subclass relation exists
between the two, the next couple is inspected.

@item
For the current position, the class of the value in the tuple of
arguments is determined, its class precedence acquired.  The positions
of the classes from the signatures in the class precedence list is
computed: If the class from @var{A} comes first, then @var{A} is more
specific than @var{B}.
@end enumerate

@item
If the methods' signatures have the same length, and, position by
position, the classes of @var{A} are @func{eq?} to the classes of
@var{B}, but @var{A} supports rest arguments while @var{B} does not:
Then @var{B} is more specific than @var{A}.
@end enumerate

@c page
@node scmobj generic define
@subsection Defining generic functions and methods


The number of arguments (arity) of a generic function is undefined:
Every method can have a different number of arguments.


@deffn Macro define-generic @var{name}
Define a new generic function and bind it to @var{name}.
@end deffn


@defun make-generic-function
Build and return a new generic function.
@end defun


@deffn Macro declare-method @var{generic} (@var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method (@var{generic} @var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method @var{generic} :primary (@var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method @var{generic} :before (@var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method @var{generic} :after (@var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method @var{generic} :around (@var{arg-spec} ...) . @var{body}
Add a new method to an already existent generic function, @var{generic}.
A declaration is @strong{not} a definition.  @nauref{baselib definitions,
Definitions}

The qualifier specifies the kind of method; when the qualifier is not
present, it defaults to @code{:primary}.

The list of @var{arg-spec} specifies the classes of the values for which
the method specialises the function.  Notice that rest arguments are
supported and specified with the usual syntax.  A @var{arg-spec} can be:

@table @code
@item (@var{arg} @var{class})
Where @var{arg} is the formal name of the argument and @var{class} the
class of expected values.

@item @var{arg}
Where @var{arg} is the formal name of the argument.  In this case the
class defaults to @true{}, which is interpreted as superclass of every
other class.
@end table

If a method is defined with the same signature, and support for rest
arguments, of an already registered method: The old method is
overwritten by the new one.  Two methods having, position by position,
arguments of the same class, but such that one supports rest arguments
and the other does not, are different.
@end deffn


@deffn Macro add-method @var{generic} @var{signature} @var{has-rest} @var{closure}
@deffnx Macro add-method @var{generic} :primary @var{signature} @var{has-rest} @var{closure}
@deffnx Macro add-method @var{generic} :before @var{signature} @var{has-rest} @var{closure}
@deffnx Macro add-method @var{generic} :after @var{signature} @var{has-rest} @var{closure}
@deffnx Macro add-method @var{generic} :around @var{signature} @var{has-rest} @var{closure}
Add a new method to an already existent generic function, @var{generic}.
@var{signature} must be a list of classes for which the method
specialises the function.  @var{closure} must be the method's closure.
When the method qualifier is not present, it defaults to
@code{:primary}.  @var{has-rest} must be @true{} or @false{}, when
@true{} it means that the closure supports rest arguments.
@end deffn

@c page
@node scmobj generic next
@subsection Invoking the next method


@defun call-next-method
To be invoked from a @code{:primary} or @code{:around} method.  Call the
next most specific method.
@end defun


@defun next-method?
Return true if a next method is available.  Available next methods are
@code{:primary} and @code{:around} methods.  After the first
@code{:primary} method has been called, only @code{:primary} methods are
considered.

It can be invoked by any kind of method.
@end defun

@c page
@node scmobj generic examples
@subsection Examples of method dispatching.


Here we show with some examples what we have to expect from the
multimethod dispatching of @library{scmobj}.  In the following examples
the string @code{%apple} is written in place of the value bound to the
symbol @class{apple}.


@subsubheading Simple inheritance

Let's examine this example:

@example
(define-class <top> ())
(define-class <one> (<top>))
(define-class <two> (<one>))
(define-class <c>   (<two>))
@end example

@noindent
the class hierarchy is:

@example
<top> -> <one> -> <two> -> <c>
@end example

@noindent
and the full class precedence list for @class{c} is:

@example
(cons <c> (class-precedence-list <c>))
@result{} (%c %two %one %top)
@end example

@noindent
so for the generic function:

@example
(define-generic doit)
(declare-method doit ((o <one>)) 'one)
(declare-method doit ((o <two>)) 'two)
@end example

@noindent
applied to a value of class @class{c}: the method with @class{two} in
the signature is @emph{more specific} than the method with @class{one}
in the signature:

@example
(doit (make <c>)) @result{} two
@end example

@c ------------------------------------------------------------

@subsubheading Multiple inheritance


Let's examine this example:

@example
(define-class <top> ())
(define-class <one> (<top>))
(define-class <two> (<top>))
(define-class <c> (<two> <one>))
@end example

@noindent
the class hierarchy is:

@example
<top> -+-> <one> -+-> <c>
       |          |
        -> <two> -
@end example

@noindent
and given the order in which the classes where handed to
@func{define-class}, the class precedence list for @class{c} is:

@example
(cons <c> (class-precedence-list <c>))
@result{} (%c %two %one %top)
@end example

@noindent
so for the generic function:

@example
(define-generic doit)
(declare-method doit ((o <one>)) 'one)
(declare-method doit ((o <two>)) 'two)
@end example

@noindent
applied to a value of class @class{c}: The method with @class{two} in
the signature is @emph{more specific} than the method with @class{one}
in the signature:

@example
(doit (make <c>)) @result{} two
@end example

Another multiple inheritance example:

@example
(define-class <top> ())
(define-class <one> (<top>))
(define-class <two> (<top>))
(define-class <three> (<two>))
(define-class <c> (<three> <one>))
@end example

@noindent
the class hierarchy is:

@example
<top> -+-------> <one> ------+-> <c>
       |                     |
        -> <two> -> <three> -
@end example

@noindent
and given the order in which the classes where handed to
@func{define-class}, the class precedence list for @class{c} is:

@example
(cons <c> (class-precedence-list <c>))
@result{} (%c %three %two %one %top)
@end example

@noindent
so for the generic function:

@example
(define-generic doit)
(declare-method doit ((o <one>)) 'one)
(declare-method doit ((o <two>)) 'two)
@end example

@noindent
applied to a value of class @class{c}: The method with @class{two} in
the signature is @emph{more specific} than the method with @class{one}
in the signature:

@example
(doit (make <c>)) @result{} two
@end example

@c ------------------------------------------------------------

@subsubheading Other examples

Let's look at this:

@example
(define-class <top> ())
(define-class <c>   (<top>))
(define-class <one> (<c>))

(define-generic doit)
(declare-method doit ((o <one>)) 'one)

(doit (make <c>))
@end example

@noindent
this will result in a ``no method defined for these argument classes'
error because a value of class @class{c} is @strong{not} a value of
class @class{one}.  For a method to be applicable: the class from the
signature of the method has to be in in the class list of the argument,
not vice versa.  That is:

@example
(subclass? <c> <one>)
@end example

@noindent
must evaluate to true.

@c ------------------------------------------------------------

@subsubheading Kinds of methods

In the examples for the application of different kinds of methods, we
will make use of the following hierarchy of classes:

@example
(define-class <a> () :a)
(define-class <b> () :b)
(define-class <c> () :c)
(define-class <d> () :d)
(define-class <e> () :e)

(define-class <pp> (<a> <b>))
(define-class <qq> (<c> <d>))
(define-class <rr> (<pp> <e> <qq>))

(define pp (make <pp> :a 1 :b 2))
(define qq (make <qq> :c 3 :d 4))
(define rr (make <rr> :a 10 :b 20 :c 30 :d 40))
@end example

First some error case.  The following will raise an error because
@code{:before} methods are forbidden to @func{call-next-method}:

@example
(define-generic alpha)

(declare-method alpha ((o <a>))
  1)

(declare-method alpha :before ((o <a>))
  (call-next-method))

(alpha pp)
@end example

The following will raise an error because we @func{call-next-method}
when no next method is available:

@example
(define-generic alpha)

(declare-method alpha ((o <a>))
  (call-next-method))

(alpha pp)
@end example

The following will raise an error because we apply a generic function
when no @code{:primary} method has been defined:

@example
(define-generic alpha)

(declare-method alpha :around ((o <a>))
  (call-next-method))

(alpha pp)
@end example

Here is a full example showing the order of applications for all the
kinds of methods; it makes use of the @func{with-result} and
@func{add-result} forms from the @library{checks} library:

@example
(define-generic alpha)

(declare-method alpha :before ((o <rr>)) (add-result 1))
(declare-method alpha :before ((o <pp>)) (add-result 2))
(declare-method alpha :before ((o <a>))  (add-result 3))
(declare-method alpha :before ((o <b>))  (add-result 4))
(declare-method alpha :before ((o <e>))  (add-result 5))

(declare-method alpha :after  ((o <rr>)) (add-result 10))
(declare-method alpha :after  ((o <pp>)) (add-result 9))
(declare-method alpha :after  ((o <a>))  (add-result 8))
(declare-method alpha :after  ((o <b>))  (add-result 7))
(declare-method alpha :after  ((o <e>))  (add-result 6))

(declare-method alpha :around  ((o <rr>)) (cons 1 (call-next-method)))
(declare-method alpha :around  ((o <pp>)) (cons 2 (call-next-method)))
(declare-method alpha :around  ((o <a>))  (cons 3 (call-next-method)))
(declare-method alpha :around  ((o <b>))  (cons 4 (call-next-method)))
(declare-method alpha :around  ((o <e>))  (cons 5 (call-next-method)))

(declare-method alpha :primary ((o <rr>)) (cons 6 (call-next-method)))
(declare-method alpha :primary ((o <pp>)) (cons 7 (call-next-method)))
(declare-method alpha :primary ((o <a>))  (cons 8 (call-next-method)))
(declare-method alpha :primary ((o <b>))  (cons 9 (call-next-method)))
(declare-method alpha :primary ((o <e>))  10)

(with-result (alpha rr))
@result{} ((1 2 3 4 5 6 7 8 9 . 10)
    (1 2 3 4 5 6 7 8 9 10))
@end example

@noindent
notice, in particular, how multiple inheritance is handled: Methods for
the @class{b} and @class{e} classes, coming as seconds in the class
inheritance lists, are applied after the methods of the @class{a} and
@class{pp} classes.

Now let's consider a the following class hierarchy with diamond
inheritance:

@example
(define-class <t> ()    :t)   ;  <t>---+
(define-class <x> (<t>) :x)   ;        v
(define-class <y> (<x>) :y)   ;   --- <x> ---
(define-class <w> (<x>) :w)   ;  |           |
(define-class <z> (<y> <w>))  ;  v           v
                              ; <y>         <w>
                              ;  |           |
                              ;   --> <z> <--

(define z (make <z> :t 0 :x 1 :y 2 :w 3))
@end example

@noindent
and let's define and apply all the kinds of methods:

@example
(define-generic alpha)

(declare-method alpha :around ((o <z>))  (cons 1 (call-next-method)))
(declare-method alpha :around ((o <y>))  (cons 2 (call-next-method)))
(declare-method alpha :around ((o <w>))  (cons 3 (call-next-method)))
(declare-method alpha :around ((o <x>))  (cons 4 (call-next-method)))
(declare-method alpha :around ((o <t>))  (cons 5 (call-next-method)))

(declare-method alpha :primary ((o <z>)) (cons 6 (call-next-method)))
(declare-method alpha :primary ((o <y>)) (cons 7 (call-next-method)))
(declare-method alpha :primary ((o <w>)) (cons 8 (call-next-method)))
(declare-method alpha :primary ((o <x>)) (cons 9 (call-next-method)))
(declare-method alpha :primary ((o <t>)) 10)

(declare-method alpha :before ((o <z>))  (add-result 1))
(declare-method alpha :before ((o <y>))  (add-result 2))
(declare-method alpha :before ((o <w>))  (add-result 3))
(declare-method alpha :before ((o <x>))  (add-result 4))
(declare-method alpha :before ((o <t>))  (add-result 5))

(declare-method alpha :after ((o <z>))   (add-result 10))
(declare-method alpha :after ((o <y>))   (add-result 9))
(declare-method alpha :after ((o <w>))   (add-result 8))
(declare-method alpha :after ((o <x>))   (add-result 7))
(declare-method alpha :after ((o <t>))   (add-result 6))

(with-result (alpha z))
@result{} ((1 2 3 4 5 6 7 8 9 . 10)
    (1 2 3 4 5 6 7 8 9 10))
@end example

Here is yet another example with diamond inheritance:

@example
(define-class <0> () :0)        ;    <0>--+
(define-class <1> (<0>) :1)     ;         v
(define-class <2> (<1>) :2)     ;   ---- <1> ----
(define-class <3> (<1>) :3)     ;  |             |
(define-class <4> (<3>) :4)     ;  v             |
(define-class <5> (<4> <2>))    ; <3>            |
                                ;  |             |
                                ;  v             v
                                ; <4>           <2>
                                ;  |             |
                                ;   ---> <5> <---

(define n (make <5> :0 0 :1 1 :2 2 :3 3 :4 4))
@end example

@noindent
and let's define and apply all the kinds of methods:

@example
(define-generic alpha)

(declare-method alpha :around ((o <5>))  (cons 1 (call-next-method)))
(declare-method alpha :around ((o <4>))  (cons 2 (call-next-method)))
(declare-method alpha :around ((o <3>))  (cons 3 (call-next-method)))
(declare-method alpha :around ((o <2>))  (cons 4 (call-next-method)))
(declare-method alpha :around ((o <1>))  (cons 5 (call-next-method)))
(declare-method alpha :around ((o <0>))  (cons 6 (call-next-method)))

(declare-method alpha :primary ((o <5>)) (cons 7 (call-next-method)))
(declare-method alpha :primary ((o <4>)) (cons 8 (call-next-method)))
(declare-method alpha :primary ((o <3>)) (cons 9 (call-next-method)))
(declare-method alpha :primary ((o <2>)) (cons 10 (call-next-method)))
(declare-method alpha :primary ((o <1>)) (cons 11 (call-next-method)))
(declare-method alpha :primary ((o <0>)) 12)

(declare-method alpha :before ((o <5>))  (add-result 1))
(declare-method alpha :before ((o <4>))  (add-result 2))
(declare-method alpha :before ((o <3>))  (add-result 3))
(declare-method alpha :before ((o <2>))  (add-result 4))
(declare-method alpha :before ((o <1>))  (add-result 5))
(declare-method alpha :before ((o <0>))  (add-result 6))

(declare-method alpha :after ((o <5>))   (add-result 12))
(declare-method alpha :after ((o <4>))   (add-result 11))
(declare-method alpha :after ((o <3>))   (add-result 10))
(declare-method alpha :after ((o <2>))   (add-result 9))
(declare-method alpha :after ((o <1>))   (add-result 8))
(declare-method alpha :after ((o <0>))   (add-result 7))

(with-result (alpha n))
@result{} ((1 2 3 4 5 6 7 8 9 10 11 . 12)
    (1 2 3 4 5 6 7 8 9 10 11 12)))
@end example

We can conclude that, when it comes to method application:

@itemize
@item
If diamond inheritance is not present: The graph of inheritance is a
tree, which is flattened to a list representing the visit of a preorder
iterator.

@item
When diamond inheritance is present: Diamond groups are flattened to a
list with classes in the middle at the center:

@example
  -- <x> --
 |         |
 v         v
<y>       <w>       @result{}   (<z> <y> <w> <x>)
 |         |
  -> <z> <-

  ---- <1> ----
 |             |
 v             |
<3>            |
 |             |    @result{}  (<5> <4> <3> <2> <1>)
 v             v
<4>           <2>
 |             |
  ---> <5> <---
@end example

@noindent
then the graph is flattened and visited in preorder.
@end itemize

@c end of file
