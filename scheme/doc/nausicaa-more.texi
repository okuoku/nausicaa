\input texinfo.tex
@c %**start of header
@setfilename nausicaa-more.info
@settitle More Nausicaa Libraries
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro class{NAME}
@code{<\NAME\>}
@end macro

@macro aclass{NAME}
<\NAME\>
@end macro

@macro cclass{NAME}
<\NAME\>
@end macro

@macro objtype{NAME}
@code{\NAME\}
@end macro

@macro condition{NAME}
@code{&\NAME\}
@end macro

@macro rtd{}
@acronym{RTD}
@end macro

@macro uid{}
@acronym{UID}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro csv{}
@acronym{CSV}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro json{}
@acronym{JSON}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro rfc{}
@acronym{RFC}
@end macro

@macro uri{}
@acronym{URI}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro

@macro dst{}
@acronym{DST}
@end macro

@macro gmt{}
@acronym{GMT}
@end macro

@macro jdn{}
@acronym{JDN}
@end macro

@macro mjdn{}
@acronym{MJDN}
@end macro

@c ------------------------------------------------------------
@c Software acronyms.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro ip{}
@acronym{IP}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro func{NAME}
@code{\NAME\}
@end macro

@macro snull{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@c @macro rsixref{NODE, TITLE}
@c @ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@c @end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro

@macro autoconfref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,autoconf}
@end macro

@macro nauref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa}
@end macro

@macro naumoreref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,nausicaa-more}
@end macro

@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@c The following macro does not work.  It appears that it is not
@c possible to use "@cindex" in the expansion of a macro because the DVI
@c output will not work.  Texinfo output would work, though.  Tested
@c with "texi2dvi" version 1.135 (GNU Texinfo 4.13).
@c
@c @macro cindexRsixlibrary{THING}
@c @cindex @rsixlibrary{\THING\}, library
@c @cindex Library, @rsixlibrary{\THING\}
@c @end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@c ------------------------------------------------------------
@c To be used in normal text.

@macro meta{THING}
<\THING\>
@end macro

@macro metao{THING}
<\THING\0>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@macro metan{THING}
<\THING\N>
@end macro

@macro metani{THING}
<\THING\N+1>
@end macro

@c ------------------------------------------------------------
@c To be used inside @example environment and @samp directives.

@macro cmeta{THING}
<\THING\>
@end macro

@macro cmetao{THING}
<\THING\0>
@end macro

@macro cmetai{THING}
<\THING\1>
@end macro

@macro cmetaii{THING}
<\THING\2>
@end macro

@macro cmetaiii{THING}
<\THING\3>
@end macro

@macro cmetan{THING}
<\THING\N>
@end macro

@macro cmetani{THING}
<\THING\N+1>
@end macro

@c ------------------------------------------------------------
@c To be used inside argument lists.

@macro ameta{THING}
<\THING\>
@end macro

@macro ametao{THING}
<\THING\0>
@end macro

@macro ametai{THING}
<\THING\1>
@end macro

@macro ametaii{THING}
<\THING\2>
@end macro

@macro ametaiii{THING}
<\THING\3>
@end macro

@macro ametan{THING}
<\THING\N>
@end macro

@macro ametani{THING}
<\THING\N+1>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro varo{THING}
@var{\THING\0}
@end macro

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      More Nausicaa Libraries

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/Scheme

@c To be used as @value{PACKAGE_NICKNAME} whenever we need to include
@c the nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marco.maggi-ipsu@@gna.org}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2008, 2009, 2010

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes the libraries collection distributed with
version @version{} of @value{PACKAGE}, a set of Scheme libraries
defining a slightly modified @rnrs{6} Scheme language and augmenting the
features of the base and standard @rnrs{6} libraries.  @nauref{Top,
Nausicaa} for the main documentation.

The project home page of Nausicaa is at:

@center @url{http://marcomaggi.github.com/nausicaa.html}

@noindent
development of Nausicaa takes place at:

@center @url{http://github.com/marcomaggi/nausicaa/}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR}.@*
Copyright @copyright{} 1996, 1997, 2000, 2001, 2002, 2003, 2004, 2005
Free Software Foundation.@*
Copyright @copyright{} 1996, 1999-2005 Dorai Sitaram.@*
Copyright @copyright{} 1998 Oleg Kiselyov.@*
Copyright @copyright{} 1998, 1999, 2000 Olin Shivers.@*
Copyright @copyright{} 1999 John David Stone.@*
Copyright @copyright{} 1999, 2002 Marc Feeley.@*
Copyright @copyright{} 2001, 2009 Danny Dube'@*
Copyright @copyright{} 2002 Dr. Mirko Luedde.@*
Copyright @copyright{} 2002, 2003, 2005, 2006 Sebastian Egner.@*
Copyright @copyright{} 2003 Ray Dillinger.@*
Copyright @copyright{} 2003 Taylor Campbell.@*
Copyright @copyright{} 2005 Jens Axel Soegaard.@*
Copyright @copyright{} 2005-2009 Alex Shinn.@*
Copyright @copyright{} 2008 Taro Minowa (Higepon).@*
Copyright @copyright{} 2005-2008 Dominique Boucher.@*
Copyright @copyright{} 2004, 2005 Tony Garnock-Jones@*
Copyright @copyright{} 2005 LShift Ltd.@*
Copyright @copyright{} 2007, 2008 Philip L. Bewig.@*
Copyright @copyright{} 2000 Will Fitzgerald.@*
Copyright @copyright{} 2000 Neodesic Corporation.@*
Copyright @copyright{} 2000-2006 Joachim Henke.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections being ``@gnu{} Free Documentation License'' and
``@gnu{} General Public License'', no Front--Cover Texts, and no
Back--Cover Texts.  A copy of the license is included in the section
entitled ``@gnu{} Free Documentation License''.
@end quotation

This document embeds an unofficial assemblage of several documents
reformatted in Texinfo; the reformatting author and maintainer is
@value{AUTHOR} @value{AUTHOR_EMAIL}.  See the appendix ``Credits'' for
the list of original documents and their authors.  See also the
@file{README} and @file{CREDITS} files for additional attributions.
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Version @version{}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-more: (nausicaa-more). @value{TITLE}.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* generics::                    Multimethods dispatching.
* enumerations::                Enumeration sets utilities.
* lists::                       Lists library.
* char-sets::                   Character sets library.
* asciis::                      @ascii{} characters library.
* strings::                     Strings library.
* vectors::                     Vectors library.
* bytevectors::                 Bytevectors.
* arrays::                      Multidimensional arrays.
* streams::                     Streams library.
* comparisons::                 Comparison functions.
* loops::                       Loop constructs.
* random::                      Sources of random bits.
* msgcat::                      Messages catalog for internationalisation.
* time::                        Time data types and procedures.
* format::                      Formatting strings.
* checks::                      Lightweight testing.
* debugging::                   Debugging utilities.
* queues::                      Simple queues.
* stacks::                      Simple stacks.
* object-properties::           Object properties.
* cleanup-handlers::            Cleaning up.
* combinators::                 Combinators.
* keywords::                    Keyword values.
* variables::                   Defining storage locations.
* scmobj::                      A simple object system.
* sexps::                       Handling symbolic expressions.
* matches::                     Pattern matching.
* irregex::                     IrRegular expressions.
* pregexp::                     Portable regular expressions for Scheme.
* parser-tools::                Lexer and parser utilities.
* silex::                       A lexical analyser generator.
* lalr::                        A LALR(1) parser generator.
* packrat::                     Packrat parser.
* csv::                         Comma--separated values (@acronym{CSV}) utilities.
* email::                       Email processing.
* infix::                       Infix notation utilities.
* getopts::                     Parsing command line arguments.
* armor::                       @ascii{} armor encoding/decoding.
* json::                        Parsing and generating @json{} text.
* net::                         Network--related libraries.
* uri::                         Uniform resource identifiers.
* interps::                     Evaluating code in a limited environment.
* libraries::                   Libraries inspection.

Low level libraries

* kmp::                         Knuth--Morris--Pratt searching.
* one-dimension::               One dimensional extended ranges.

Appendices

* old-generics::                Old multimethods dispatching.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

Multimethods dispatching

* generics examples::           Examples of method dispatching.
* generics application::        How generic functions and methods
                                are invoked.
* generics dispatching::        How methods are dispatched.
* generics define::             Defining generic functions and methods.
* generics next::               Invoking the next method.
* generics predefined::         Predefined generic functions.

Enumeration sets utilities

* enumerations flags::          Flags and flags combinations.

List library

* lists intro::                 Introduction.
* lists conventions::           Conventions.
* lists cons::                  Constructors.
* lists pred::                  Predicates.
* lists compar::                Comparison.
* lists select::                Selectors.
* lists misc::                  Length, append, concatenate,
                                reverse, zip and count.
* lists fold::                  Fold, unfold and map.
* lists filter::                Filtering and partitioning.
* lists search::                Searching.
* lists delete::                Deletion.
* lists sorted::                Utilities for sorted lists.
* lists alist::                 Association lists.
* lists circ::                  Circular lists.
* lists set::                   Set operations on lists.
* lists low::                   Low level utilities.
* lists class::                 Class interface.

Fold, unfold and map

* lists fold examples::         Folding usage examples.
* lists fold rnrs::             Folding with @rnrs{6} style.
* lists fold traditional::      Folding with traditional style.
* lists fold derived::          Derived folding.
* lists fold pair::             Folding pairs.
* lists fold reduce::           Reducing.
* lists fold unfold::           Unfolding.
* lists fold map::              Mapping.
* lists fold foreach::          Producing side effects.

Character sets

* char-sets intro::             Introduction.
* char-sets make::              Constructors.
* char-sets pred::              Predicates.
* char-sets inspect::           Inspection.
* char-sets ops::               Operations.
* char-sets sets::              Predefined character sets.

Predefined character sets

* char-sets sets intro::        Introduction.
* char-sets sets how::          How predefined sets were defined.
* char-sets sets basic::        Basic character sets.
* char-sets sets ascii::        Sets of @ascii{} characters.
* char-sets sets blocks::       Sets corresponding to Unicode blocks.
* char-sets sets categories::   Sets corresponding to Unicode general
                                categories.

Strings library

* strings intro::               Introduction.
* strings convention::          Interface conventions.
* strings views::               Views over strings.
* strings cons::                Constructors.
* strings pred::                Predicates.
* strings compar::              Comparison.
* strings map::                 Mapping functions.
* strings case::                Case mapping.
* strings fold::                Fold and unfold.
* strings select::              Selection.
* strings pad::                 Padding and trimming.
* strings prefix::              Prefixes and suffixes.
* strings search::              Searching.
* strings filter::              Filtering and deleting.
* strings list::                List and string conversion.
* strings replicate::           Replicate and rotate.
* strings mutate::              Mutators.
* strings misc::                Miscellaneous functions.

Comparison

* strings compar lexi::         Lexicographic comparison.
* strings compar dict::         String dictionary comparison.
* strings compar number::       String and numeric parts lexicographic
                                comparison.
* strings compar dictnumber::   String and numeric parts dictionary
                                comparison.

Vectors library

* vectors intro::               Introduction.
* vectors convention::          Interface conventions.
* vectors views::               Views over vectors.
* vectors cons::                Constructors.
* vectors pred::                Predicates.
* vectors compar::              Comparison.
* vectors fold::                Fold and unfold.
* vectors select::              Selection.
* vectors pad::                 Padding and trimming.
* vectors prefix::              Prefixes and suffixes.
* vectors search::              Searching.
* vectors filter::              Filtering and deleting.
* vectors list::                List and vector conversion.
* vectors replicate::           Replicate and rotate.
* vectors mutate::              Mutators.
* vectors misc::                Miscellaneous functions.

Fold and unfold

* vectors fold rnrs::           Folding with @rnrs{6} style.
* vectors fold sub::            Folding over subvectors.
* vectors fold unfold::         Unfolding vectors.
* vectors fold map::            Mapping functions.

Bytevectors

* bytevectors u8::              Bytevectors of unsigned bytes.

Bytevectors of unsigned bytes

* bytevectors u8 intro::        Introduction.
* bytevectors u8 convention::   Interface conventions.
* bytevectors u8 views::        Views over bytevectors.
* bytevectors u8 cons::         Constructors.
* bytevectors u8 pred::         Predicates.
* bytevectors u8 compar::       Comparison.
* bytevectors u8 map::          Mapping functions.
* bytevectors u8 case::         Case mapping.
* bytevectors u8 fold::         Fold and unfold.
* bytevectors u8 select::       Selection.
* bytevectors u8 pad::          Padding and trimming.
* bytevectors u8 prefix::       Prefixes and suffixes.
* bytevectors u8 search::       Searching.
* bytevectors u8 filter::       Filtering and deleting.
* bytevectors u8 list::         List and bytevector conversion.
* bytevectors u8 replicate::    Replicate and rotate.
* bytevectors u8 mutate::       Mutators.
* bytevectors u8 misc::         Miscellaneous functions.

Comparison

* bytevectors u8 compar lexi::       Lexicographic comparison.
* bytevectors u8 compar dict::       String dictionary comparison.
* bytevectors u8 compar number::     String and numeric parts
                                     lexicographic comparison.
* bytevectors u8 compar dictnumber:: String and numeric parts
                                     dictionary comparison.

Multidimensional arrays

* arrays conventions::          Arguments conventions.
* arrays layout::               Layout of elements in the vector.
* arrays position::             Specifying the coordinates of elements.
* arrays shape::                Specifying the shape of arrays.
* arrays array::                Dealing with arrays.

Streams

* streams basic::               Basic interface.
* streams cons::                Definitions and constructors.
* streams from::                Converting objects into streams.
* streams to::                  Converting streams to objects.
* streams ops::                 Operations.
* streams select::              Selecting.
* streams range::               Range streams.
* streams of::                  Comprehensions.
* streams fold::                Folding.
* streams unfold::              Unfolding.
* streams map::                 Mapping and side effects.
* streams match::               Matching.
* streams utilities::           Utilities.
* streams examples::            Examples.

Examples

* streams examples infinite::   Infinite streams.
* streams examples generators:: Generators and co--routines.
* streams examples pipeline::   A pipeline of procedures.
* streams examples persistent:: Persistent data.
* streams examples passes::     Reducing two passes to one.
* streams examples pitfalls::   Pitfalls.

Comparison functions

* comparisons intro::           Introduction.
* comparisons examples::        Examples.
* comparisons conventions::     Terminology and conventions.
* comparisons atoms::           Comparing atoms.
* comparisons sequence::        Comparing lists and vectors.
* comparisons pair::            Comparing pairs and improper lists.
* comparisons default::         The default compare procedure.
* comparisons cons::            Constructing compare procedures.
* comparisons branch::          Branching.
* comparisons pred::            Predicates.
* comparisons minmax::          Minimum and maximum values.
* comparisons debug::           Debugging procedure.

Loop constructs

* loops intro::                 Introduction.
* loops comprehensions::        Comprehensions.
* loops qualifiers::            Qualifiers.
* loops generators::            Generators.

Comprehensions

* loops comprehensions do::     Simple loops.
* loops comprehensions list::   List accumulator loops.
* loops comprehensions string:: String accumulator loops.
* loops comprehensions vector:: Vector accumulator loops.
* loops comprehensions arith::  Arithmetic accumulator loops.
* loops comprehensions search:: Searching loops.
* loops comprehensions fold::   Folding loops.
* loops comprehensions define:: Defining new comprehensions.

Generators

* loops generators intro::      Introduction to generators.
* loops generators do::         Loop generators.
* loops generators typed::      Typed generators.
* loops generators ranges::     Range generators.
* loops generators port::       Port generators.
* loops generators dispatch::   Dispatched generators.
* loops generators let::        Let generators.
* loops generators parallel::   Parallel generators.
* loops generators cond::       Conditional generators.

Sources of random bits

* random intro::                Introduction.
* random prng::                 Notes on the algorithms.
* random numbers::              Simple random numbers.
* random source::               Randomness sources.
* random mrg32k3a::             L'Ecuyer's MRG32k3a generator
* random device::               Device--based generator.
* random utils::                Utilities.
* random generators::           Auxiliary generators.
* random dist::                 Random numbers from known distributions.

Notes on the algorithms

* random prng lcg::             Linear congruential generators.
* random prng mwc::             Multiply with carry.
* random prng csprng::          Cryptographically secure @acronym{PRNG}.
* random prng integers::        Generating integers in a specified range.
* random prng reals::           Generating real numbers.

Utilities

* random utils misc::           Miscellaneous utility functions.
* random utils lists::          Specialised list functions.
* random utils vectors::        Specialised vector functions.
* random utils strings::        Specialised string functions.

Auxiliary generators

* random generators mersenne::  The Mersenne twister.
* random generators marsaglia:: George Marsaglia's generators.
* random generators bbs::       Blum--Blum--Shub generator.
* random generators borosh::    Borosh generator.
* random generators cmrg::      Combined multiple recursive generator.

Messages catalog for internationalisation

* msgcat intro::                Introduction to messages catalogs.
* msgcat api::                  Messages catalogs @api{}.

Time data types and procedures

* time intro::                  Introduction to time scales.
* time overview::               Overview of the library.
* time system::                 Interface to the system.
* time secs::                   Seconds and nanoseconds objects.
* time duration::               Time duration objects.
* time point::                  Points in time.
* time date::                   Date object.
* time utils::                  Miscellaneous utilities.
* time const::                  Constants.
* time current::                Current time and clock resolution.
* time timeobj::                Time object and accessors.
* time timeobj compar::         Time object comparison procedures.
* time timeobj arithm::         Time object arithmetic procedures.
* time dateobj::                Date object and accessors.
* time string::                 Date to string/string to date
                                converters.

Introduction to time scales

* time intro conventions::      Miscellaneous conventions.
* time intro tai::              International Atomic Time (@tai{}).
* time intro utc::              Coordinated Universal Time (@utc{}).
* time intro gmt::              Greenwich Mean Time (@gmt{}).
* time intro zone::             Time zones and daylight saving time.
* time intro dst::              Daylight Saving Time (@dst{}).
* time intro unix::             Unix Time and Unix Epoch.
* time intro gregorian::        Gregorian calendar.
* time intro week::             Week days.
* time intro julian::           Julian Date (@acronym{JD}) and Julian Day (@acronym{JDN}).

Overview of the library

* time overview assumptions::   Basic assumptions and policies.
* time overview host::          Retrieving the current time.
* time overview time::          Time points and interval durations.
* time overview date::          Dates and calendar.
* time overview julian::        Julian dates and numbers.

Seconds and nanoseconds objects

* time secs class::             Seconds and nanoseconds class
                                type definition.
* time secs utils::             Utility fields and methods.

Time duration objects

* time duration class::         Time duration class type definition.
* time duration compar::        Comparing time durations.
* time duration arith::         Arithmetic functions.
* time duration utils::         Utility fields and methods.

Points in time

* time point class::            Point in time class type definition.
* time point compar::           Comparing time points.
* time point arith::            Arithmetic functions.
* time point utils::            Utility functions.

Miscellaneous utilities

* time utils secs::             Seconds and nanoseconds utilities.
* time utils year::             Gregorian years and weeks.
* time utils julian::           Julian calendar utilities.

Seconds and nanoseconds utilities

* time utils secs constants::   Constant values for seconds and
                                subseconds units.
* time utils secs utils::       Utilities for seconds and subseconds
                                units counts.

Gregorian years and weeks

* time utils year const::       Constants.
* time utils year year::        Year utility functions.
* time utils year week::        Week utility functions.

Formatting strings

* format output::               Formatted Output.
* format escape values::        Escape sequences for generic values.
* format escape char::          Escape sequences for characters.
* format escape integers::      Escape sequences for integers.
* format escape flonums::       Escape sequences for flonums.
* format escape complex::       Escape sequences for complex numbers.

Escape sequences for flonums

* format escape flonums fixed::        Fixed point format.
* format escape flonums exponent::     Exponential format.
* format escape flonums eng::          Engineering format.

Lightweight testing

* checks select::               Selecting tests to be run.
* checks eval::                 Evaluating code.
* checks result::               Handling multiple results.

Simple queue

* queues types::                Type definitions and constructors.
* queues pred::                 Predicates and inspection.
* queues ops::                  Basic operations.
* queues list::                 List operations.
* queues conv::                 Conversion.

Simple stacks

* stacks types::                Type definitions and constructors.
* stacks pred::                 Predicates and inspection.
* stacks ops::                  Basic operations.
* stacks list::                 List operations.
* stacks conv::                 Conversion.

A simple object system

* scmobj overview::             Overview of the library.
* scmobj example::              Objects layout examples.
* scmobj class::                Classes.
* scmobj instance::             Instances.
* scmobj inspect::              Inspecting classes and instances.
* scmobj slot::                 Accessing slots.
* scmobj generic::              Generic functions and methods.

Classes

* scmobj class make::           Making classes
* scmobj class chart::          A chart for predefined classes
* scmobj class core::           Core class types.
* scmobj class list::           List types.
* scmobj class compound::       Non-list compound data types.
* scmobj class numeric::        Numeric data types.
* scmobj class port::           Port types.
* scmobj class misc::           Miscellaneous types.

Generic functions and methods

* scmobj generic application::  How generic functions and methods
                                are invoked.
* scmobj generic dispatching::  How methods are dispatched.
* scmobj generic define::       Defining generic functions and methods.
* scmobj generic next::         Invoking the next method.
* scmobj generic examples::     Examples of method dispatching.

Handling symbolic expressions

* sexps match::                 Plain matching.
* sexps operators::             Matching operators.
* sexps transform::             Transforming S--expressions.

Matching operators

* sexps operators examples::    Operator examples.
* sexps operators variable::    Variable matching.
* sexps operators predicate::   Predicate matching.
* sexps operators logic::       Logic matching.

Pattern matching

* matches match::               Basic pattern matching.
* matches condition::           Mismatch error condition.
* matches syntax::              The pattern syntax.
* matches macros::              Syntaxes for pattern matching.

The pattern syntax

* matches syntax wildcard::     Matching anything with blind semantic
                                action.
* matches syntax literal::      Matching literal values.
* matches syntax clauses::      Multiple clauses.
* matches syntax quoted::       Matching quoted S--expressions.
* matches syntax lists::        Matching pairs and lists.
* matches syntax vectors::      Matching vectors.
* matches syntax variables::    Pattern variables.
* matches syntax pred::         Matching with predicates.
* matches syntax accessor::     Matching with accessor procedures.
* matches syntax logic::        Logic alternatives and negation.
* matches syntax quasiquote::   Matching quasiquotation.
* matches syntax getter::       Getting values out of the expression.
* matches syntax setter::       Mutating the expression's value.
* matches syntax continuation:: Continuing after mismatch.
* matches syntax ellipsis::     Matching an arbitrary number of
                                subexpressions.
* matches syntax macros::       Impossibility of using macros as
                                patterns.

Logic alternatives and negation

* matches syntax logic and::    Logical conjunction.
* matches syntax logic or::     Logical disjunction.
* matches syntax logic not::    Logical negation.

IrRegular expressions

* irregex conventions::         Conventions.
* irregex pred::                Predicates.
* irregex compile::             Compiling regular expressions.
* irregex match::               Match objects.
* irregex replace::             Replacing substrings.
* irregex chunk::               Chunked string matching.
* irregex misc::                Miscellaneous functions.
* irregex pcre::                Supported @acronym{PCRE} syntax.
* irregex sre::                 Extended @acronym{SRE} syntax.

Extended @acronym{SRE} Syntax

* irregex sre syntax::          Syntax tables.
* irregex sre basic::           Basic patterns.
* irregex sre repetition::      Repetition patterns.
* irregex sre char-sets::       Character sets.
* irregex sre assertion::       Assertion patterns.
* irregex sre utility::         Utility patterns.

Portable regular expressions for Scheme

* pregexp intro::               Introduction.
* pregexp api::                 Interface procedures.
* pregexp syntax::              The regexp pattern language.
* pregexp example::             An extended example.

The regexp pattern language

* pregexp syntax basic::        Basic assertions.
* pregexp syntax chars::        Characters and character classes.
* pregexp syntax quantifiers::  Quantifiers.
* pregexp syntax clusters::     Clusters.
* pregexp syntax alternation::  Alternation.
* pregexp syntax backtrack::    Backtracking.
* pregexp syntax look::         Looking ahead and behind.

Lexer and parser utilities

* parser-tools location::       Source location records.
* parser-tools token::          Lexical token records.

Source location records

* parser-tools location type::          The record type.
* parser-tools location makers::        Building records.
* parser-tools location pred::          Predicates.
* parser-tools location cmp::           Comparison functions.
* parser-tools location update::        Updating the location.
* parser-tools location misc::          Miscellaneous functions.

Lexical token records

* parser-tools token type::     The record type.
* parser-tools token maker::    Record makers.
* parser-tools token pred::     Predicates.

A lexical analyser generator

* silex example::               A lexer example for a calculator.
* silex tables::                Creating lexer tables.
* silex input::                 Input systems.
* silex lexer::                 Building and using lexical analysers.
* silex syntax::                Syntax of the specification.
* silex semantics::             Semantics of the specification file.
* silex format::                Tables output format.
* silex utilities::             Utility functions.

Syntax of the specification

* silex syntax macros::         Syntax of the macro definitions.
* silex syntax rules::          Syntax of the rule--action pairs.
* silex syntax regexp atomic::  Atomic regular expressions.
* silex syntax regexp compose:: Composing regular expressions.
* silex syntax regexp marker::  Markers.
* silex syntax regexp space::   White spaces in regular expressions.
* silex syntax sample::         Show some frequent mistakes.

Semantics of the specification

* silex semantics action::      What does an action do.
* silex semantics rules::       When does a regular expression
                                matches the input.

A LALR(1) parser generator

* lalr intro::                  Introduction to the LR parser.
* lalr tables::                 Creating parser tables.
* lalr lexer::                  Describing tokens.
* lalr parser::                 Running the parser.
* lalr grammar::                Defining the grammar.
* lalr glr::                    Generalised LR parsing.

Introduction to the LR parser

* lalr intro tokens::           Splitting expressions in
                                semantic tokens.
* lalr intro want::             What we want.
* lalr intro simple::           Simplified parser behaviour.
* lalr intro look::             Why the lookahead.
* lalr intro states::           From symbol sequences to states.
* lalr intro error::            Error recovering.
* lalr intro nonterm::          Non--terminal categories.

Defining the parser

* lalr grammar intro::          Introduction to grammar definition.
* lalr grammar precedence::     Operator precedence and associativity.
* lalr grammar clauses::        Writing semantic clauses.
* lalr grammar error::          Error recovery.
* lalr grammar conflict::       Conflicts resolution.
* lalr grammar examples::       Dummy examples of grammar definitions.

Error recovery

* lalr grammar error intro::    Introduction to error recovery.
* lalr grammar error single::   Dummy example: Single token parser.

Dummy examples of grammar definitions

* lalr grammar examples helpers:: Helper definitions.
* lalr grammar examples single::  Single token parser.

Packrat parser

* packrat intro::               Introduction to the algorithm.
* packrat calc::                Calculator example.
* packrat types::               Parser state and results.
* packrat comb::                Combinators.

Introduction to the algorithm

* packrat intro state::         Handling the parser state.
* packrat intro comb::          Combinator functions.

Parser state and results

* packrat types state::         The parser state.
* packrat types result::        Combinators results.

Combinators

* packrat comb terminal::       Expecting a token category.
* packrat comb sequence::       Applying combinators in sequence.
* packrat comb or::             Applying alternative combinators.
* packrat comb unless::         Applying failure combinators.
* packrat comb memoize::        Memoizing combinators.
* packrat comb error::          Returning error results.
* packrat comb grammar::        The grammar combinator.
* packrat comb left::           Left recursion problem.

Comma--separated values (@acronym{CSV}) utilities

* csv lexer::                   Low level tokenisation.
* csv parser::                  High level parsing.

Low level tokenisation

* csv lexer strings::           Tokenising strings.
* csv lexer unquoted-data::     Tokenising unquoted data.
* csv lexer full::              Full parsing.

Email processing

* email addresses::             Parsing email addresses.

Parsing email addresses

* email addresses components::  Parsed components.
* email addresses types::       Record types.
* email addresses lexer::       Splitting an address into tokens.
* email addresses parser::      Splitting an address into logical units.

Record types

* email addresses domain::              Domain.
* email addresses local-part::          Local part.
* email addresses addr-spec::           Address specification.
* email addresses route::               Route.
* email addresses mailbox::             Mailbox.
* email addresses group::               Group of mailboxes.

Infix notation utilities

* infix strings::               Converting strings.
* infix sexps::                 Converting S--expressions.
* infix syntax::                Infix notation expressions.

Parsing command line arguments

* getopts intro::               Introduction.
* getopts records::             Record types.
* getopts config::              Parser configuration.
* getopts parser::              Parsing arguments.
* getopts conditions::          Exceptions and condition objects.

@ascii{} armor encoding/decoding

* armor conditions::            Condition objects.
* armor base16::                Base 16 encoder/decoder.
* armor base32::                Base 32 encoder/decoder.
* armor base64::                Base 64 encoder/decoder.
* armor base91::                Base 91 encoder/decoder.
* armor ascii85::               @ascii{} 85 encoder/decoder.
* armor qprint::                Quoted--printable encoder/decoder.
* armor newlines::              Newline insertion/removal.
* armor examples::              Examples of encoding and decoding.

Condition objects

* armor conditions error::      Base error condition.
* armor conditions byte::       Invalid input byte error
                                condition.
* armor conditions length::     Invalid input length error
                                condition.
* armor conditions padding::    Invalid padded block error
                                condition.

Base 16 encoder/decoder

* armor base16 intro::          Introduction to base16 encoding.
* armor base16 encode::         Encoding byte streams with base16.
* armor base16 decode::         Decoding byte streams with base16.
* armor base16 utils::          Utilities for base16 encoders and
                                decoders.

Base 32 encoder/decoder

* armor base32 intro::          Introduction to base32 encoding.
* armor base32 encode::         Encoding byte streams with base32.
* armor base32 decode::         Decoding byte streams with base32.
* armor base32 utils::          Utilities for base32 encoders and
                                decoders.

Base 64 encoder/decoder

* armor base64 intro::          Introduction to base64 encoding.
* armor base64 encode::         Encoding byte streams with base64.
* armor base64 decode::         Decoding byte streams with base64.
* armor base64 utils::          Utilities for base64 encoders and
                                decoders.

Base 91 encoder/decoder

* armor base91 intro::          Introduction to base91 encoding.
* armor base91 encode::         Encoding byte streams with base91.
* armor base91 decode::         Decoding byte streams with base91.
* armor base91 utils::          Utilities for base91 encoders and
                                decoders.

@ascii{} 85 encoder/decoder

* armor ascii85 intro::         Introduction to @ascii{}85 encoding.
* armor ascii85 encode::        Encoding byte streams with @ascii{}85.
* armor ascii85 decode::        Decoding byte streams with @ascii{}85.
* armor ascii85 utils::         Utilities for @ascii{}85 encoders and
                                decoders.

Quoted--printable encoder/decoder

* armor qprint intro::          Introduction to quoted--printable
                                encoding.
* armor qprint encode::         Encoding byte streams with
                                quoted--printable.
* armor qprint decode::         Decoding byte streams with
                                quoted--printable.
* armor qprint utils::          Utilities for quoted--printable
                                encoders and decoders.

Newline insertion/removal

* armor newline insertion::     Inserting sequences of bytes.
* armor newline removal::       Removing sequences of bytes.

Examples of encoding and decoding

* armor examples encode::       Encoding example.
* armor examples decode::       Decoding example.

Parsing and generating @json{} text

* json intro::                  Introduction to @json{}.
* json decoding::               Decoding @json{} text.
* json encoding::               Encoding @json{} text.
* json error::                  Error handlers and condition objects.

Decoding @json{} text

* json decoding intro::         Introduction to decoding @json{}.
* json decoding lexer::         Lexing @json{} text.
* json decoding parser::        Parsing @json{} text.
* json decoding string::        Decoding @json{} strings.

Error handlers and condition objects

* json error conditions::       @json{}--related condition objects.
* json error handlers::         Error handlers for @json{} parsers.

Network--related libraries

* net ipv4address::             IPv4 address objects.
* net ipv6address::             IPv6 address objects.

Ipv4 address objects

* net ipv4address lexer::       Tokenising an IPv4 address.
* net ipv4address parser::      Parsing an IPv4 address.
* net ipv4address errors::      Condition objects and error handlers.
* net ipv4address class::       IPv4 address and address prefix
                                class objects.

IPv6 address objects

* net ipv6address lexer::       Tokenising an IPv6 address.
* net ipv6address parser::      Parsing an IPv6 address.
* net ipv6address utilities::   IPv6 address parsing utilities.
* net ipv6address errors::      Condition objects and error handlers.
* net ipv6address class::       IPv6 address and address prefix
                                class objects.

Uniform resource identifiers

* uri string::                  Plain conversion between strings
                                and bytevectors.
* uri percent::                 Percent encoding of characters.

Evaluating code in a limited environment

* interps conditions::          Errors in limited evaluation.
* interps class::               Interpreter objects.
* interps eval::                Semantics of code evaluation.
* interps examples::            Interpreter user examples.

Libraries inspection

* libraries jargon::            Definition of terms.
* libraries names::             Handling @rnrs{6} library names.
* libraries references::        Handling @rnrs{6} library references.
* libraries imports::           Handling @rnrs{6} library import
                                specifications.
* libraries searching::         Finding libraries on the system.
* libraries libraries::         Handling @rnrs{6} libraries.

Handling @rnrs{6} library names

* libraries names typedefs::    Type definitions.
* libraries names utilities::   Utility functions.

Handling @rnrs{6} library references

* libraries references typedefs::   Type definitions.
* libraries references utilities::  Utility functions.

Handling @rnrs{6} library import specifications

* libraries imports typedefs::  Type definitions.
* libraries imports utilities:: Utility functions.

Finding libraries on the system

* libraries searching system::  Searching libraries on file systems.

Handling @rnrs{6} libraries

* libraries libraries typedefs::    Type definitions.
* libraries libraries utilities::   Utility functions.

Knuth-Morris-Pratt searching

* kmp intro::                   Introduction.
* kmp conv::                    Conventions.
* kmp vector::                  The restart vector.
* kmp step::                    Single step of the search.
* kmp partial::                 Partial search.
* kmp full::                    Full sequence search.

One dimensional extended ranges

* one-dimension intro::         Data types and conventions.
* one-dimension make::          Constructors.
* one-dimension pred::          Predicates.
* one-dimension inspect::       Inspection.
* one-dimension ops::           Operations.

Old multimethods dispatching

* old-generics application::    How generic functions and methods
                                are invoked.
* old-generics dispatching::    How methods are dispatched.
* old-generics define::         Defining generic functions and methods.
* old-generics next::           Invoking the next method.
* old-generics examples::       Examples of method dispatching.
* old-generics predefined::     Predefined generic functions.

@end detailmenu
@end menu

@end ifnottex

@c page
@node generics
@chapter Multimethods dispatching


In the context of the @library{generics} library, @dfn{generic
functions} are interfaces to procedures that can be specialised to the
(possibly conventional) data types of their arguments; each
specialisation of a generic function is called @dfn{method}.  When
applying a generic function to a set of arguments, the most specific
method with respect to the arguments' types is chosen.

The @library{generics} library is built on top of the @library{classes}
library.

@quotation
@library{generics} has undergone @api{} and internal changes in its
development and with respect to the old infrastructure in the
@library{records} library; with the old version generic functions were
functions supporting methods with any number of arguments, with the new
version generic functions are macros supporting methods with a fixed
number of arguments.

The old version of the library is still distributed as
@library{old-generics}, @ref{old-generics} for details.  The
@library{records} library is no more distributed.
@end quotation

@menu
* generics examples::           Examples of method dispatching.
* generics application::        How generic functions and methods
                                are invoked.
* generics dispatching::        How methods are dispatched.
* generics define::             Defining generic functions and methods.
* generics next::               Invoking the next method.
* generics predefined::         Predefined generic functions.
@end menu

@c page
@node generics examples
@section Examples of method dispatching


Here we show with some examples what we have to expect from the
multimethod dispatching of @library{generics}.  In the following examples
the string @code{%apple} is written in place of the value bound to the
symbol @class{apple}.

Let's examine this example which uses the @library{classes} library:

@example
(define-class <one> (inherit <top>) (nongenerative one))
(define-class <two> (inherit <one>) (nongenerative two))
(define-class <c>   (inherit <two>) (nongenerative c))
@end example

@noindent
the record hierarchy is:

@example
<top> -> <one> -> <two> -> <c>
@end example

@noindent
the list of @uid{}s for @class{c} is:

@example
(class-uid-list <c>)
@result{} (c two one nausicaa:builtin:<top>)
@end example

@noindent
so for the generic function:

@example
(define-generic doit)
(define-method (doit (o <one>)) 'one)
(define-method (doit (o <two>)) 'two)
@end example

@noindent
applied to a value of type @class{c}: the method with @class{two} in the
signature is @emph{more specific} than the method with @class{one} in
the signature:

@example
(doit (make-<c>)) @result{} two
@end example

@noindent
also the method with @class{one} in the signature is the ``next method''
of the method with @class{two} in the signature, we can call it using
@func{call-next-method}.

The following example shows a call to the next method:

@example
(define-generic fluff)

(define-method (fluff (o <one>))
  'one)

(define-method (fluff (o <two>))
  (cons 'two (call-next-method)))

(define o (make-<c>))

(fluff o)
@result{} (two . one)
@end example

The syntax @func{define-generic} defines a macro and the syntax
@func{define-method} add a new method to the generic function; the first
method definition establishes the number of arguments for the generic
function: all the methods added afterwards must have the same number of
arguments.

It is possible to define a function accepting different numbers of
arguments as follows:

@example
(define fluff
  (case-lambda
   ((a)
    (fluff-1 a))
   ((a b)
    (fluff-2 a b))
   ((a b . rest)
    (fluff-3 a b rest))))

(define-generic fluff-1)
(define-generic fluff-2)
(define-generic fluff-3)

(define-method (fluff-1 (o <one>))
  ---)

(define-method (fluff-2 (o <one>) (p <two>))
  ---)

(define-method (fluff-3 (o <one>) (p <two>) rest)
  ---)
@end example

@noindent
this way we turn a set of macros into a single ``generic function''
which is truly a function.  If we avoid wrapping the macros into a
function we gain a bit of speed in function calls.

@c page
@node generics application
@section How generic functions and methods are invoked


@library{generics} is designed to work with class definitions from the
@library{classes} library; when a generic function is applied to a tuple
of arguments, the following happens:

@enumerate
@item
For each argument in the tuple a class type is determined, then the list
of unique @uid{}s representing the class hierarchy is acquired; the
tuple of @uid{} lists is called @dfn{signature}.  Each generic function
maintains an internal collection in which every method's closure is
associated to a signature.

@item
The internal collection of methods is queried for all the methods
applicable to the tuple of arguments, using the signature as search key.

@item
The list of applicable methods is sorted from the more specific to the
least specific for the signature.  From now on the list of sorted,
applicable methods is handled as a stack.

@item
The next method is popped from the stack and its closure applied to the
tuple of arguments; the return value of this application becomes the
return value of the generic function application.  If the function calls
the next method, recurse to step 4.
@end enumerate

@c page
@node generics dispatching
@section How methods are dispatched


Here we attempt the formulation of the rules of method dispatching.  A
method is identified by a couple of values: the signature and the
closure.

@c ------------------------------------------------------------

@subsubheading Applicability

First we need to understand when a method is applicable to a tuple of
arguments:

@enumerate
@item
Methods in a generic function have the same number of arguments, so the
tuple of arguments must match that number.

@item
Given a tuple of arguments, position by position, the class of the
method's argument is equal to, or a parent of, the class of the given
argument.
@end enumerate

@c ------------------------------------------------------------

@subsubheading Specificity

Now we can understand how to determine which one, among two applicable
methods, is more specific for a tuple of arguments.  Let's call the
methods @var{A} and @var{B}.

Notice that it is impossible for two distinct methods, in the same
generic function, to have the same signature.

Also, classes support only single inheritance, so if two methods are
applicable: the homologous lists of @uid{}s in their signatures, have at
least one @func{eq?} member (different from @class{top}).

The lists of @uid{}s in the signatures are compared in couples, position
by position from the beginning to the end.

@enumerate
@item
If the first @uid{}s are @func{eq?}: the next couple is inspected.

@item
If the @uid{} from @var{B} is a member of the list from @var{A}: @var{A}
is more specific than @var{B}.
@end enumerate

@c page
@node generics define
@section Defining generic functions and methods


@deffn Syntax define-generic @ameta{name}
Define a new generic function (a macro) and bind it to @meta{name}.  The
number of arguments is unspecified: it will be established by the first
@func{define-method} or @func{add-method} applied to @meta{name}.
@end deffn


@deffn Syntax define-generic/merge @ameta{name} @ametao{generic} @ameta{generic} ...
Define a new generic function and bind it to @meta{name}.  The internal
collection of methods holds the union of the method collections from the
@meta{generic} arguments, which must be generic function identifiers.

The union is performed visiting arguments from left to right; when two
methods have the same signature, the one from the leftmost generic
function has precedence.

Merging methods is useful when two different libraries export generic
functions bound to the same identifier.
@end deffn


@deffn Syntax define-method @ameta{generic} (@ameta{arg-spec} ...) @ameta{body}
@deffnx Syntax define-method (@ameta{generic} @ameta{arg-spec} ...) @ameta{body}
Add a new method to an already existent generic function,
@ameta{generic}.

The list of @meta{arg-spec} specifies the class of the arguments for
which this method specialises the generic function; an @meta{arg-spec}
can be:

@table @code
@item (@cmeta{arg} @cmeta{class name})
Where @meta{arg} is the formal name of the argument and @meta{class
name} the (possibly conventional) class name of expected values.

@item @cmeta{arg}
Where @meta{arg} is the formal name of the argument.  In this case the
class defaults to the conventional @class{top}, which is interpreted as
parent of every other class (and so it has the least specificity).
@end table

If a method is defined with the same signature of an already registered
method: the old method is overwritten by the new one.
@end deffn


@deffn Syntax add-method @ameta{generic} @ameta{classes} @ameta{closure}
Add a new method to an already existent generic function,
@meta{generic}.  @meta{classes} must be a list of class names for which
this method specialises the generic function.  @meta{closure} must be
the method's closure.
@end deffn

@c page
@node generics next
@section Invoking the next method


@defun call-next-method
Call the next most specific method.
@end defun


@defun next-method?
Return true if a next method is available.
@end defun

@c page
@node generics predefined
@section Predefined generic functions


The following bindings are exported by the @library{generics
object-to-string} library.


@deffn {Generic Function} object->string @var{obj}
Return a string representation for @var{obj}.  A non--specialised method
is predefined to use the following implementation:

@example
(call-with-string-output-port
   (lambda (port)
     (display obj port)))
@end example
@end deffn

@c page
@node enumerations
@chapter Enumeration sets utilities


The @library{enumerations} library defines utilities for enumeration
sets.

@menu
* enumerations flags::          Flags and flags combinations.
@end menu

@c page
@node enumerations flags
@section Flags and flags combinations


@deffn Syntax define-c-flags @ameta{name} (@ameta{flag0} @ameta{flag} ...) (@ameta{symbol0} @ameta{symbol} ...)
Define a new enumeration type and a couple of functions to convert
between enumeration sets of this type and other objects.  Usage example:

@example
(define A 1)
(define B 2)
(define C 3)

(define-c-flags things
  (A B C)
  (a b c))

(things->value (things a)) @result{} 1
(things->value (things b)) @result{} 2
(things->value (things c)) @result{} 3

(value->things 1) @result{} (things a)
(value->things 2) @result{} (things b)
(value->things 3) @result{} (things c)
@end example

@noindent
when used in a library, we can do the following to export the interface:

@example
(library (things)
  (export things things->value value->things)
  (import (rnrs))
  (define A 1)
  (define B 2)
  (define C 3)
  (define-c-flags things
    (A B C)
    (a b c)))
@end example

The typical use of this syntax is to define an interface for C language
foreign constants.

@meta{name} must be an identifier to which an enumeration set
constructor syntax is bound; the syntax accepts only a single symbol as
argument and it expands to an enumeration set with that symbol as
element.

The enumeration type is @code{enum-@cmeta{name}} and the original
constructor syntax accepting any number of arguments is
@code{%@cmeta{name}}.

The @meta{flag} arguments are meant to be identifiers bound to any
Scheme value, but they can be any value.  The @meta{symbol} arguments
must be Scheme symbols which are used to define (in the given order) the
universe of the enumeration.

The function which converts from an enumeration set (holding a single
argument) to the corresponding value is bound to
@code{@cmeta{name}->value}.  The function which converts from a value to
the enumeration set (holding a single argument) is bound to
@code{value->@cmeta{name}}.
@end deffn


@deffn Syntax define-c-ior-flags @ameta{name} (@ameta{flag0} @ameta{flag} ...) (@ameta{symbol0} @ameta{symbol} ...)
Define a new enumeration type and a couple of functions to convert
between enumeration sets of this type and a bitwise, inclusive, OR
combination of exact integers.  Usage example:

@example
(define A (bitwise-arithmetic-shift-left 1 0))
(define B (bitwise-arithmetic-shift-left 1 1))
(define C (bitwise-arithmetic-shift-left 1 2))

(define-c-ior-flags things
  (A B C)
  (a b c))

(things->value (things a))      @result{} 1
(things->value (things b))      @result{} 2
(things->value (things a b))    @result{} 3
(things->value (things c))      @result{} 4
(things->value (things a c))    @result{} 5
(things->value (things b c))    @result{} 6
(things->value (things a b c))  @result{} 7

(value->things 1) @result{} (things a)
(value->things 2) @result{} (things b)
(value->things 5) @result{} (things a c)
@end example

@noindent
when used in a library, we can do the following to export the interface:

@example
(library (things)
  (export things things->value value->things)
  (import (rnrs))
(define A (bitwise-arithmetic-shift-left 1 0))
(define B (bitwise-arithmetic-shift-left 1 1))
(define C (bitwise-arithmetic-shift-left 1 2))
  (define-c-ior-flags things
    (A B C)
    (a b c)))
@end example

The typical use of this syntax is to define an interface for C language
foreign constants used as flags in inclusive OR combinations.

@meta{name} must be an identifier to which an enumeration set
constructor syntax is bound; the syntax accepts any number of symbols as
arguments and it expands to an enumeration set with that symbols as
elements.  The enumeration type is @code{enum-@cmeta{name}}.

The @meta{flag} arguments must be identifiers bound to exact integers.
The @meta{symbol} arguments must be Scheme symbols which are used to
define (in the given order) the universe of the enumeration.

The function which converts from an enumeration set to the corresponding
bitwise, inclusive OR combination is bound to
@code{@cmeta{name}->value}.  An assertion violation is raised if this
function is applied to an enumeration set of the wrong type.

The function which converts from a bitwise, inclusive OR combination to
the enumeration set is bound to @code{value->@cmeta{name}}.  If this
function is applied to an integer holding bits outside the ones coded in
the definition of the enumeration, no error is raised.
@end deffn

@c page
@node lists
@chapter List library


The @library{lists} and @library{lists stx} libraries implement a
collection of functions and macros to manipulate lists; additionally,
@library{lists low} implements a collection of low level utilities.
These libraries have two purposes: To provide a rich set of functions
and macros and to be a source code repository from which code can be
taken and specialised.  For the last purpose, the libraries export
macros that may make little sense in most scenarios (beside the fact
that they are always inlined).

@quotation
@strong{Note} The @library{lists ---} libraries and this section of
documentation are derived from the @ansrfi{1} document and reference
implementation by Olin Shivers, but they are @strong{not} compatible
with it.  Read carefully this documentation!
@end quotation

@menu
* lists intro::                 Introduction.
* lists conventions::           Conventions.
* lists cons::                  Constructors.
* lists pred::                  Predicates.
* lists compar::                Comparison.
* lists select::                Selectors.
* lists misc::                  Length, append, concatenate,
                                reverse, zip and count.
* lists fold::                  Fold, unfold and map.
* lists filter::                Filtering and partitioning.
* lists search::                Searching.
* lists delete::                Deletion.
* lists sorted::                Utilities for sorted lists.
* lists alist::                 Association lists.
* lists circ::                  Circular lists.
* lists set::                   Set operations on lists.
* lists low::                   Low level utilities.
* lists class::                 Class interface.
@end menu

@c page
@node lists intro
@section Introduction


Scheme does not properly have a list type, just as the C language does
not have a string type.  Rather, Scheme has a binary--tuple type, from
which one can build binary trees.  There is an interpretation of Scheme
values that allows one to treat these trees as lists.  Further
complications ensue from the fact that Scheme allows side--effects to
these tuples, raising the possibility of lists of unbounded length, and
trees of unbounded depth (that is, circular data structures).

What follows is a classification of concrete values with respect to
@dfn{list} as an abstract concept.

@c ------------------------------------------------------------

@subsubheading Null value

It is a special value which can be identified with the predicate
@func{null?}.  Null is meant to represent empty lists and to be the
terminator for proper lists.

@func{length} applied to null returns zero.  In light of what follows,
it makes sense to consider null as a list of length zero for all the
list classes: proper, circular, dotted, generalised.

@c ------------------------------------------------------------

@subsubheading Proper lists

A finite, null--terminated list; more precisely a proper list is defined
as: A pair whose cdr is a proper list or null.  The opposite of proper
is @dfn{improper}; everything that is not null or a proper list, is an
improper list.

@example
(a b c)
(32)
@end example

We can build a proper list in a single function call with @func{list},
or we can do it in steps using @func{cons} and @func{cons*}; we can
detect if a list is proper with @func{list?}.

@c ------------------------------------------------------------

@subsubheading Circular list

An infinite, unterminated list; a circular list is a value such that
@func{cdr} applied any number of times always returns a pair.  The
opposite of circular is @dfn{finite}.

We can build a list having a circular tail as follows:

@example
(define end  (cons  1 '()))
(define tail (cons* 3 2 end))
(define ell  (cons* 5 4 tail))
(set-cdr! end tail)
@end example

@noindent
the list structure bound to @samp{ell} looks like this:

@example
                           cdr
                  ----------------
                 |                |
     cdr    cdr  v cdr    cdr     |
   O----->O----->O----->O----->O--
   |      |      |      |      |
car|   car|   car|   car|   car|
   v      v      v      v      v
   5      4      3      2      1
@end example

@noindent
so that the following happens:

@example
(car ell)            @result{} 5
(cadr ell)           @result{} 4
(caddr ell)          @result{} 3
(cadddr ell)         @result{} 2
(cadddr (cdr ell))   @result{} 1
(cdddr (cddr ell))   @result{} tail
(cadddr (cddr ell))  @result{} 3
(cadddr (cdddr ell)) @result{} 2
@end example

@noindent
it is impossible to build a circular list without mutating a pair.
Notice that the following is @strong{not} a circular list:

@example
                           car
           --------------------
          |                    |
     cdr  v cdr    cdr    cdr  | cdr
   O----->O----->O----->O----->O----->()
   |      |      |      |
car|   car|   car|   car|
   v      v      v      v
   5      4      3      2
@end example

@noindent
it is a proper list in which the car of the last pair references one of
the previous pairs.

We can build a circular list, a ring, with @func{circular-list} and we
can detect if a list is a ring or has a circular tail with
@func{circular-list?}.


@c ------------------------------------------------------------

@subsubheading Dotted list

A finite, non--nil terminated list, such as:

@example
(a b c . d)
(x . y)
@end example

@noindent
a dotted list is a value for which there exists an integer @math{n > 0},
such that @func{cdr} applied @math{n} times yields neither a pair nor
null.  This means that, for a dotted list, either @func{null?} or
@func{pair?} return @true{}.

Users of the @library{list ---} libraries should note that dotted lists
are not commonly used, and are considered by many Scheme programmers to
be an ugly artifact of Scheme's lack of a true list type.  However,
dotted lists do play a noticeable role in the syntax of Scheme, in the
``rest'' parameters used by n--ary lambdas:

@example
(lambda (x y . rest)
  ---)
@end example

Dotted lists are not fully supported by the list libraries; most
procedures are defined only on proper lists.  The procedures that will
also handle circular or dotted lists are specifically marked.  While
this design decision restricts the domain of possible arguments one can
pass to these procedures, it has the benefit of allowing the procedures
to catch the error cases where programmers inadvertently pass scalar
values to a list procedure by accident (for example, by switching the
arguments to a procedure call).

@c ------------------------------------------------------------

@subsubheading Improper list

A finite, non--nil terminated list, such as:

@example
(a b c . d)
(x . y)
42
george
@end example

@noindent
a improper list is a value for which there exists an integer @math{n >=
0}, such that @func{cdr} applied @math{n} times yields neither a pair
nor null.  This includes non--pair, non--null values (symbols, numbers,
etc.), which are considered to be improper lists of length @math{0}.
Dotted lists are improper lists.

@c page
@node lists conventions
@section Conventions


All the functions are exported by the @library{lists} library, while all
the macros are exported by @library{lists stx}.  Each macro has a
corresponding function version, but some functions were not translated
to macros.  Macro names always end with the suffix @samp{/stx}.

It is an error to pass a circular or dotted list to a procedure not
defined to accept such an argument; it is an error to pass a proper or
dotted list to a procedure defined for circular lists.

All the functions and macros whose main name ends with @samp{!}, are
allowed to alter their arguments.

The documentation of this library obeys the following conventions for
procedure formals:

@table @var
@item ell
A proper (finite, nil--terminated) list.

@item circ
A proper or circular list.

@item dotted
A dotted list.

@item pair
A pair.

@item n
@itemx i
A non--negative exact integer object.

@item proc
A procedure.

@item pred
A procedure whose return value is treated as a boolean.

@item item=
A boolean procedure taking two arguments.

@item fill
Can be any value; it is used to indicate values used to fill a compound
data structure.

@item obj
Any value, including dotted lists.
@end table

@c page
@node lists cons
@section Constructors


@cindex List constructors


@defun xcons @vari{obj} @varii{obj}
The name stands for ``eXchanged CONS'', it is like @func{cons} but
reverses the arguments.  Of utility only as a value to be conveniently
passed to higher--order procedures.

@example
(cons 1 2)  @result{} (1 . 2)
(xcons 1 2) @result{} (2 . 1)
@end example
@end defun


@deffn Function make-list @var{n}
@deffnx Function make-list @var{n} @var{fill}
@deffnx Syntax make-list/stx @var{n}
@deffnx Syntax make-list/stx @var{n} @var{fill}
Return an @var{n}--element list, whose elements are all the value
@var{fill}.  If @var{fill} is not given, the elements of the list may be
arbitrary values.

@example
(make-list 4 'c)
@result{} (c c c c)

(make-list 0)
@result{} ()
@end example
@end deffn


@deffn Function list-copy @var{fell}
@deffnx Syntax list-copy/stx @var{fell}
Copy the spine of the argument.
@end deffn


@deffn Function tree-copy @var{fell}
@deffnx Syntax tree-copy/stx @var{fell}
Copy the whole tree of @var{fell}, not only the spine (which is what
@func{list-copy} does).
@end deffn


@deffn Function list-tabulate @var{n} @var{init-proc}
@deffnx Function list-tabulate/reverse @var{n} @var{init-proc}
@deffnx Syntax list-tabulate/stx @var{n} @var{init-proc}
@deffnx Syntax list-tabulate/reverse/stx @var{n} @var{init-proc}
Return an @var{n}--element list.  Element @math{i} of the list, where
@math{0 <= i < n}, is produced by @code{(init-proc i)}.

The basic variants build the list from element @math{0} to element
@math{n-1}.  The @samp{/reverse} variants build the lists in reversed
order, with element @math{n-1} created first.  The @samp{/reverse}
variants may be a little faster, especially for long lists.

@example
(list-tabulate 4 values)
@result{} (0 1 2 3)
@end example
@end deffn


@deffn Function iota @var{count}
@deffnx Function iota @var{count} @var{start}
@deffnx Function iota @var{count} @var{start} @var{step}
@deffnx Syntax iota/stx @var{count}
@deffnx Syntax iota/stx @var{count} @var{start}
@deffnx Syntax iota/stx @var{count} @var{start} @var{step}
Return a list containing the elements:

@example
(start start+step ... start+(count-1)*step)
@end example

The @var{start} and @var{step} parameters default to @code{0} and
@code{1}, respectively.  @var{count} must be a non--negative number.
The resulting list is built in reverse, starting from the last element.

@example
(iota 5)
@result{} (0 1 2 3 4)

(iota 5 0 -0.1)
@result{} (0 -0.1 -0.2 -0.3 -0.4)
@end example
@end deffn

@c page
@node lists pred
@section Predicates


@defun not-pair? @var{obj}
Defined as:

@example
(lambda (x) (not (pair? x)))
@end example

@noindent
provided as a procedure as it can be useful as the termination condition
for list--processing procedures that wish to handle all finite lists,
both proper and dotted.
@end defun


@defun circular-list? @var{obj}
@defunx circular-list?/or-null @var{obj}
Return @true{} if @var{obj} is a circular list.  The @samp{/or-null}
variant returns @true{} also if @var{obj} is null.
@end defun


@defun dotted-list? @var{obj}
@defunx dotted-list?/or-null @var{obj}
Return @true{} if @var{obj} is a dotted list.  The @samp{/or-null}
variant returns @true{} also if @var{obj} is null.
@end defun

@c ------------------------------------------------------------

@deffn Function and-null? @var{ell} ...
@deffnx Syntax and-null?/stx @var{ell} ...
Return @true{} if all the @var{ell} are null or no arguments are given.
@end deffn


@deffn Function or-null? @var{ell} ...
@deffnx Syntax or-null?/stx @var{ell} ...
Return @true{} if at least one of the @var{ell} is null.  Return
@false{} if no arguments are given.
@end deffn


@deffn Function and/or-null? @var{ell} ...
@deffnx Syntax and/or-null?/stx @var{ell} ...
Return two values being the return values of @func{and-null?} and
@func{or-null?} applied to the @var{ell} arguments.
@end deffn

@c page
@node lists compar
@section Comparison


@defun list=? @var{item=} @varo{ell} ...
Determines list equality, given an element--equality procedure
@var{item=}.  Proper list @vari{ell} equals proper list @varii{ell} if:

@enumerate
@item
They are of the same length.

@item
Their corresponding elements are equal, according to @var{item=}.
@end enumerate

If there are no list arguments, or only one list argument: The return
value is @true{}.  If there are two or more list arguments they are
compared in couples: First @varo{ell} is compared to @vari{ell}, then
@vari{ell} is compared to @varii{ell}, etc.  The iteration over list
arguments stops if two list arguments are found different.

@var{item=} is applied to elements from two list arguments taken with
the same order; the first from @vari{ell}, the second from @varii{ell},
etc.  @var{item=} must be consistent with @func{eq?}:

@example
(eq? x y) @result{} (elm=? x y)
@end example

@noindent
this implies that two lists which are @func{eq?} are always
@func{list=?}, as well.

Examples:

@example
(list=? eq?)
@result{} #t

(list=? eq? '(a))
@result{} #t

(list=? = '(1 2 3 4)
          '(1 2 3 4))
@result{} #t

(list=? = '(1 2 3 4)
          '(1 9 3 4))
@result{} #f

(list=? = '(1 2 3 4)
          '(1 2 3 4)
          '(1 2 3 4))
@result{} #t

(list=? = '(1 2 3 4)
          '(1 2 3 4 5)
          '(1 2 3 4))
@result{} #f

(list=? = '())
@result{} #t

(list=? = '() '())
@result{} #t

(list=? = '() '() '())
@result{} #t
@end example
@end defun

@c page
@node lists select
@section Selectors


@cindex List selectors


@deffn Function first @var{pair}
@deffnx Function second  @var{pair}
@deffnx Function third   @var{pair}
@deffnx Function fourth  @var{pair}
@deffnx Function fifth   @var{pair}
@deffnx Function sixth   @var{pair}
@deffnx Function seventh @var{pair}
@deffnx Function eighth  @var{pair}
@deffnx Function ninth   @var{pair}
@deffnx Function tenth   @var{pair}
@deffnx Syntax fifth/stx   @var{pair}
@deffnx Syntax sixth/stx   @var{pair}
@deffnx Syntax seventh/stx @var{pair}
@deffnx Syntax eighth/stx  @var{pair}
@deffnx Syntax ninth/stx   @var{pair}
@deffnx Syntax tenth/stx   @var{pair}
Synonyms for @func{car}, @func{cadr}, @func{caddr}, ...

@example
(third '(a b c d e))
@result{} c
@end example
@end deffn


@defun {car+cdr} @var{pair}
The fundamental pair deconstructor:

@example
(lambda (p)
  (values (car p) (cdr p)))
@end example
@end defun


@deffn Function take-left @var{dotted} @var{i}
@deffnx Function drop-left @var{dotted} @var{i}
@deffnx Syntax take-left/stx @var{dotted} @var{i}
@deffnx Syntax drop-left/stx @var{dotted} @var{i}
@func{take-left} returns the first @var{i} elements of list
@var{dotted}.  @func{drop-left} returns all but the first @var{i}
elements of list @var{dotted}.

@example
(take-left '(a b c d e) 2)
@result{} (a b)

(drop-left '(a b c d e) 2)
@result{} (c d e)
@end example

@var{dotted} may be any value: a proper, circular, or dotted list:

@example
(take-left '(1 2 3 . d) 2)
@result{} (1 2)

(drop-left '(1 2 3 . d) 2)
@result{} (3 . d)

(take-left '(1 2 3 . d) 3)
@result{} (1 2 3)

(drop-left '(1 2 3 . d) 3)
@result{} d
@end example

For a legal @var{i}, @func{take-left} and @func{drop-left} partition the
list in a manner which can be inverted with append:

@example
(append (take-left x i) (drop-left x i)) = x
@end example

@func{drop-left} is exactly equivalent to performing @var{i} @func{cdr}
operations on @var{dotted}; the returned value shares a common tail with
@var{dotted}.

If the argument is a list of non--zero length, @func{take-left} is
guaranteed to return a freshly--allocated list, even in the case where
the entire list is taken: @code{(take-left dotted (length+ dotted))}.
@end deffn


@deffn Function take-right @var{dotted} @var{i}
@deffnx Function drop-right @var{dotted} @var{i}
@deffnx Syntax take-right/stx @var{dotted} @var{i}
@deffnx Syntax drop-right/stx @var{dotted} @var{i}
@func{take-right} returns the last @var{i} elements of @var{dotted}.
@func{drop-right} returns all but the last @var{i} elements of
@var{dotted}.

@example
(take-right '(a b c d e) 2)
@result{} (d e)

(drop-right '(a b c d e) 2)
@result{} (a b c)
@end example

The returned list may share a common tail with the argument list.

@var{dotted} may be any finite list, either proper or dotted:

@example
(take-right '(1 2 3 . d) 2)
@result{} (2 3 . d)

(drop-right '(1 2 3 . d) 2)
@result{} (1)

(take-right '(1 2 3 . d) 0)
@result{} d

(drop-right '(1 2 3 . d) 0)
@result{} (1 2 3)
@end example

For a legal @var{i}, @func{take-right} and @func{drop-right} partition
the list in a manner which can be inverted with append:

@example
(append (drop-right flist i) (take-right flist i)) = flist
@end example

The return value of @func{take-right} is guaranteed to share a common
tail with @var{dotted}.

If the argument is a list of non--zero length, @func{drop-right} is
guaranteed to return a freshly--allocated list, even in the case where
nothing is dropped, e.g. @code{(drop-right dotted 0)}.
@end deffn


@deffn Function take-left! @var{dotted} @var{i}
@deffnx Function drop-right! @var{dotted} @var{i}
@deffnx Syntax take-left!/stx @var{dotted} @var{i}
@deffnx Syntax drop-right!/stx @var{dotted} @var{i}
@func{take!} and @func{drop-right!} are like @func{take} and
@func{drop-right}, but they are allowed to alter the argument list to
produce the result.

An error is raised if the length of the list is less than @var{i}.
@end deffn


@deffn Function split-at @var{dotted} @var{i}
@deffnx Function split-at! @var{dotted} @var{i}
@deffnx Syntax split-at/stx @var{dotted} @var{i}
@deffnx Syntax split-at!/stx @var{dotted} @var{i}
@func{split-at} splits the list @var{dotted} at index @var{i}, returning
a list of the first @var{i} elements, and the remaining tail.  It is
equivalent to:

@example
(values (take-left x i) (drop-left x i))
@end example

@func{split-at!} is allowed to alter the argument list to produce the
result.

@example
(split-at '(a b c d e f g h) 3)
@result{} (a b c) (d e f g h)
@end example
@end deffn


@deffn Function last @var{pair}
@deffnx Function last-pair @var{pair}
@deffnx Syntax last/stx @var{pair}
@deffnx Syntax last-pair/stx @var{pair}
@func{last} returns the last element of the non--empty, finite list
@var{pair}.  @func{last-pair} returns the last pair in the non--empty,
finite list @var{pair}.

@example
(last '(a b c)) @result{} c
(last-pair '(a b c)) @result{} (c)
@end example
@end deffn

@c page
@node lists misc
@section Length, append, concatenate, reverse, zip and count


@cindex List length
@cindex List appending
@cindex List contatenation
@cindex List reversing
@cindex List zip
@cindex List counting


@defun {length+} @var{circ}
Return the length of the argument, or @false{} if @var{circ} is a
circular list.  The length of a proper list is a non--negative integer
@math{n} such that @func{cdr} applied @math{n} times to the list
produces the empty list.
@end defun


@defun append! @var{ell} ...
Return a list consisting of the elements of @var{ell} followed by the
elements of the other list arguments; it is allowed to alter cons cells
in the argument lists to construct the result list.  The last argument
is never altered; the result list shares structure with this parameter.

@example
(append! '(x) '(y))        @result{}  (x y)
(append! '(a) '(b c d))    @result{}  (a b c d)
(append! '(a (b)) '((c)))  @result{}  (a (b) (c))
(append! '(a b) '(c . d))  @result{}  (a b c . d)
(append! '() 'a)           @result{}  a
(append! '(x y))           @result{}  (x y)
(append!)                  @result{}  ()
@end example

Notice that @func{append} is implemented by @rsixlibrary{base}.
@nauref{baselib lists, Pairs and lists}
@end defun


@deffn Function concatenate @var{list-of-lists}
@deffnx Function concatenate! @var{list-of-lists}
@deffnx Syntax concatenate/stx @var{list-of-lists}
@deffnx Syntax concatenate!/stx @var{list-of-lists}
These functions append the elements of their argument together; that is,
@func{concatenate} returns:

@example
(apply append list-of-lists)
@end example

@func{concatenate!} is allowed to alter the arguments to build the
result.  As with @func{append} and @func{append!}, the last element of
the input list may be any value at all.
@end deffn


@defun reverse! @var{list}
Return a newly allocated list consisting of the elements of @var{list}
in reverse order; it is allowed to alter the argument's cons cells to
produce the reversed list.

@example
(reverse! '(a b c))              @result{}  (c b a)
(reverse! '(a (b c) d (e (f))))  @result{}  ((e (f)) d (b c) a)
@end example

Notice that @func{reverse} is implemented by @rsixlibrary{base}.
@nauref{baselib lists, Pairs and lists}
@end defun


@deffn Function append-reverse @var{rev-head} @var{tail}
@deffnx Function append-reverse! @var{rev-head} @var{tail}
@deffnx Syntax append-reverse/stx @var{rev-head} @var{tail}
@deffnx Syntax append-reverse!/stx @var{rev-head} @var{tail}
@func{append-reverse} returns:

@example
(append (reverse rev-head) tail)
@end example

It is provided because it is a common operation; a common
list--processing style calls for this exact operation to transfer values
accumulated in reverse order onto the front of another list, and because
the implementation is significantly more efficient than the simple
composition it replaces.

@quotation
But note that this pattern of iterative computation followed by a
@func{reverse} can frequently be rewritten as a recursion, dispensing
with the @func{reverse} and @func{append-reverse} steps, and shifting
temporary, intermediate storage from the heap to the stack, which is
typically a win for reasons of cache locality and eager storage
reclamation.
@end quotation

@func{append-reverse!} is allowed to alter @var{rev-head}'s cons cells
to construct the result.
@end deffn


@deffn Function zip @vari{list} @var{list} ...
@deffnx Function zip* @vari{circ} @var{circ} ...
@deffnx Syntax zip/stx @ametai{list} @ameta{list} ...
@deffnx Syntax zip*/stx @ametai{circ} @ameta{circ} ...
The function @func{zip} is defined as:

@example
(lambda ells (apply map list ells))
@end example

@noindent
while @func{zip*} is defined as:

@example
(lambda ells (apply map* list ells))
@end example

If @func{zip*} is passed @var{n} lists, it returns a list as long as the
shortest of these lists, each element of which is an @var{n}--element
list comprised of the corresponding elements from the parameter lists.

@example
(zip* '(one two three)
      '(1 2 3)
      '(odd even odd even odd even odd even))
@result{} ((one 1 odd) (two 2 even) (three 3 odd))

(zip* '(1 2 3))
@result{} ((1) (2) (3))
@end example

When applying @func{zip*}, at least one of the argument lists must be
finite:

@example
(zip* '(3 1 4 1)
      (circular-list #f #t))
@result{} ((3 #f)
    (1 #t)
    (4 #f)
    (1 #t))
@end example
@end deffn


@deffn Function unzip1 @var{ell}
@deffnx Function unzip2 @var{ell}
@deffnx Function unzip3 @var{ell}
@deffnx Function unzip4 @var{ell}
@deffnx Function unzip5 @var{ell}
@deffnx Syntax unzip1/stx @var{ell}
@deffnx Syntax unzip2/stx @var{ell}
@deffnx Syntax unzip3/stx @var{ell}
@deffnx Syntax unzip4/stx @var{ell}
@deffnx Syntax unzip5/stx @var{ell}
@func{unzip1} takes a list of lists, where every list must contain at
least one element, and returns a list containing the initial element of
each such list.  That is, it returns @code{(map car lists)}.

@func{unzip2} takes a list of lists, where every list must contain at
least two elements, and returns two values: a list of the first
elements, and a list of the second elements.

@func{unzip3} does the same for the first three elements of the lists,
and so forth.

@example
(unzip2 '((1 one) (2 two) (3 three)))
@result{} (1 2 3)
   (one two three)
@end example
@end deffn


@deffn Function count @var{pred} @var{circ} ...
@deffnx Syntax count/stx @var{pred} @var{circ} ...
@var{pred} is a procedure taking as many arguments as there are lists
and returning a single value.  It is applied element--wise to the
elements of the lists, and a count is tallied of the number of elements
that produce a true value.  This count is returned.

@func{count} is ``iterative'' in that it is guaranteed to apply
@var{pred} to the list elements in a left--to--right order.  The
counting stops when the shortest list expires.

@example
(count even? '(3 1 4 1 5 9 2 5 6))
@result{} 3

(count < '(1 2 4 8) '(2 4 6 8 10 12 14 16))
@result{} 3
@end example

At least one of the argument lists must be finite:

@example
(count < '(3 1 4 1) (circular-list 1 10))
@result{} 2
@end example
@end deffn

@c page
@node lists fold
@section Fold, unfold and map


@cindex List fold, unfold and map


The @dfn{left--folding} operator is the fundamental list iterator, the
@dfn{right--folding} operator is the fundamental list recursion
operator.

@menu
* lists fold examples::         Folding usage examples.
* lists fold rnrs::             Folding with @rnrs{6} style.
* lists fold traditional::      Folding with traditional style.
* lists fold derived::          Derived folding.
* lists fold pair::             Folding pairs.
* lists fold reduce::           Reducing.
* lists fold unfold::           Unfolding.
* lists fold map::              Mapping.
* lists fold foreach::          Producing side effects.
@end menu

@c page
@node lists fold examples
@subsection Folding usage examples


In the single list argument case, for a list of @math{4} elements, the
return value of a left--folding with @rnrs{6} style, is computed as
with:

@example
(fold-left kons knil ell) @equiv{}
  (kons (kons (kons (kons knil
                          (list-ref ell 0))
                    (list-ref ell 1))
              (list-ref ell 2))
        (list-ref ell 3))
@end example

@noindent
while with the ``traditional'' style:

@example
(fold kons knil ell) @equiv{}
  (kons (list-ref ell 3)
        (kons (list-ref ell 2)
              (kons (list-ref ell 1)
                    (kons (list-ref ell 0)
                          knil))))
@end example

@noindent
the return value of a right--folding with both @rnrs{6} style and
``traditional'' style, is computed as with:

@example
(fold-right kons knil ell) @equiv{}
     (fold* kons knil ell) @equiv{}
  (kons (list-ref ell 0)
        (kons (list-ref ell 1)
              (kons (list-ref ell 2)
                    (kons (list-ref ell 3)
                          knil))))
@end example

In the multiple list arguments case, for three lists of @math{4}
elements, the return value of a left--folding with @rnrs{6} style, is
computed as with:

@example
(fold-left kons knil ell0 ell1 ell2) @equiv{}
  (kons (kons (kons (kons knil
                          (list-ref ell0 0)
                          (list-ref ell1 0)
                          (list-ref ell2 0))
                    (list-ref ell0 1)
                    (list-ref ell1 1)
                    (list-ref ell2 1))
              (list-ref ell0 2)
              (list-ref ell1 2)
              (list-ref ell2 2))
        (list-ref ell0 3)
        (list-ref ell1 3)
        (list-ref ell2 3))
@end example

@noindent
while with the ``traditional'' style:

@example
(fold kons knil ell0 ell1 ell2) @equiv{}
  (kons (list-ref ell0 3)
        (list-ref ell1 3)
        (list-ref ell2 3)
        (kons (list-ref ell0 2)
              (list-ref ell1 2)
              (list-ref ell2 2)
              (kons (list-ref ell0 1)
                    (list-ref ell1 1)
                    (list-ref ell2 1)
                    (kons (list-ref ell0 0)
                          (list-ref ell1 0)
                          (list-ref ell2 0)
                          knil))))
@end example

@noindent
the return value of a right--folding with both @rnrs{6} style and
``traditional'' style, is computed as with:

@example
(fold-right kons knil ell0 ell1 ell2) @equiv{}
     (fold* kons knil ell0 ell1 ell2) @equiv{}
  (kons (list-ref ell0 0)
        (list-ref ell1 0)
        (list-ref ell2 0)
        (kons (list-ref ell0 1)
              (list-ref ell1 1)
              (list-ref ell2 1)
              (kons (list-ref ell0 2)
                    (list-ref ell1 2)
                    (list-ref ell2 2)
                    (kons (list-ref ell0 3)
                          (list-ref ell1 3)
                          (list-ref ell2 3)
                          knil))))
@end example

Left--folding, usage examples for @func{fold} in the single list
argument case:

@example
;; add the elements
(fold + 0 '(1 2 3))             @result{} 6

;; reverse a list
(fold cons '() '(1 2 3))        @result{} (3 2 1)

;; append in reverse order
(fold cons '(4 5 6) '(3 2 1))   @result{} (1 2 3 4 5 6)

;; how many symbols?
(fold (lambda (x count)
        (if (symbol? x)
            (+ count 1)
          count))
      0
      '(a 1 b 2 c 3))           @result{} 3
@end example

Right--folding usage examples for @func{fold*} in the single list
argument case:

@example
;; copy the list
(fold* cons '() '(1 2 3))       @result{} (1 2 3)

;; add elements
(fold* + 0 numbers)             @result{} 45

;; prepend elements
(fold* cons '(4 5 6) '(1 2 3))  @result{} (1 2 3 4 5 6)

;; filter the even numbers
(fold* (lambda (x l)
         (if (even? x)
             (cons x l)
           l))
       '()
       '(0 1 2 3 4 5 6 7 8 9))
@result{} (0 2 4 6 8)
@end example

Usage examples for @func{fold} and @func{fold*} in the multiple list
argument case:

@example
(fold (lambda (a b c knil)
        (cons (list a b c) knil))
      '()
      '(1 2 3)
      '(10 20 30)
      '(100 200 300))
@result{} '((3 30 300)
     (2 20 200)
     (1 10 100))

(fold* (lambda (a b c knil)
         (cons (list a b c)
                knil))
       '()
       '(1 2 3)
       '(10 20 30)
       '(100 200 300))
@result{} ((1 10 100)
    (2 20 200)
    (3 30 300))
@end example

@c page
@node lists fold rnrs
@subsection Folding with @rnrs{6} style


Exactly as with the @func{fold-left} and @func{fold-right} functions
defined by @rnrs{6}:

@itemize
@item
With left--folding functions and syntaxes, the @strong{first} argument
to the first call to @var{combine} is @var{knil}, then it is the return
value of the previous calls to @var{combine}.

@item
With right--folding functions and syntaxes, the @strong{last} argument
to to the first evaluated call to @var{combine} is @var{knil}, then it
is the return value of the previous calls to @var{combine}.
@end itemize


@deffn Syntax fold-left/stx @var{combine} @var{knil} @var{circ1} @var{circ2} ...
@deffnx Syntax fold-right/stx @var{combine} @var{knil} @var{circ1} @var{circ2} ...
Like @func{fold-left} and @func{fold-right}, defined by @rnrs{6}, but
implemented as syntaxes.  These syntaxes exist only for completeness.
@end deffn


@deffn Function fold-left* @var{combine} @var{knil} @var{circ1} @var{circ2} ...
@deffnx Function fold-right* @var{combine} @var{knil} @var{circ1} @var{circ2} ...
@deffnx Syntax fold-left*/stx @var{combine} @var{knil} @var{circ1} @var{circ2} ...
@deffnx Syntax fold-right*/stx @var{combine} @var{knil} @var{circ1} @var{circ2} ...
Like @func{fold-left} and @func{fold-right}, defined by @rnrs{6}, but
accept lists of different length and stop at the end of the shortest
list.  At least one of the list arguments must be finite.  The syntaxes
may be a little faster than the functions when multiple @var{circ}
arguments are involved.
@end deffn

@c page
@node lists fold traditional
@subsection Folding with traditional style


The functions @func{fold} and @func{fold*} are similar to
@func{fold-left*} and @func{fold-right*} but @var{knil} is always the
@strong{last} argument of the calls to @var{kons}.


@deffn Function fold @var{kons} @var{knil} @var{circ1} @var{circ2} ...
@deffnx Syntax fold/stx @var{kons} @var{knil} @var{circ1} @var{circ2} ...
Left fold the function @var{kons} over the elements of the list
arguments.  Accept lists of different length and stop at the end of the
shortest list.  At least one of the list arguments must be finite.  The
syntax may be a little faster than the function when multiple @var{circ}
arguments are involved.
@end deffn


@deffn Function fold* @var{kons} @var{knil} @var{circ1} @var{circ2} ...
@deffnx Syntax fold*/stx @var{kons} @var{knil} @var{circ1} @var{circ2} ...
Right fold the function @var{kons} over the elements of the list
arguments.  Accept lists of different length and stop at the end of the
shortest list.  At least one of the list arguments must be finite.  The
syntax may be a little faster than the function when multiple @var{circ}
arguments are involved.
@end deffn

@c page
@node lists fold derived
@subsection Derived folding


@deffn Function and-fold-left* @var{combine} @var{knil} @var{circ1} @var{circ2} ...
@deffnx Function and-fold-right* @var{combine} @var{knil} @var{circ1} @var{circ2} ...
@deffnx Syntax and-fold-left*/stx @var{combine} @var{knil} @var{circ1} @var{circ2} ...
@deffnx Syntax and-fold-right*/stx @var{combine} @var{knil} @var{circ1} @var{circ2} ...
Like @func{fold-left*} and @func{fold-right*}, but stop the folding if
the value returned by @var{combine} is @false{}, in which case the
return value is @false{}.
@end deffn


@defun fold-left/pred @var{pred} @var{knil} @var{circ}
Apply @var{pred} to successive couples of elements from @var{circ};
return true if all the evaluations of @var{pred} were true.  The
iteration stops at the first @false{} return value from @var{pred}.

This function is implemented as:

@example
(define (fold-left/pred pred knil ell)
  (and-fold-left*/stx (lambda (knil item)
                        (and (pred knil item) item))
                      knil ell))
@end example

@noindent
and it can be used to implement predicates for ordering like @func{<}:

@example
(fold-left/pred < 0 '(1 2 3 4 5 6))
@result{} 6

(fold-left/pred < 0 '(1 2 3 -4 5 6))
@result{} #f
@end example
@end defun

@c page
@node lists fold pair
@subsection Folding pairs


@defun pair-fold @var{kons} @var{knil} @var{circ1} @var{circ2} ...
Analogous to @func{fold}, but @var{kons} is applied to successive
sublists of the lists, rather than successive elements; that is,
@var{kons} is applied to the pairs making up the lists, giving this
(tail) recursion:

@example
(pair-fold kons knil ell) @equiv{} (let ((tail (cdr ell)))
                               (pair-fold kons
                                          (kons ell knil)
                                          tail))
(pair-fold kons knil '()) @equiv{} knil
@end example

For finite lists, the @var{kons} function may reliably apply
@func{set-cdr!} to the pairs it is given without altering the sequence
of execution.

Examples:

@example
(pair-fold (lambda (elm knil)
             (cons (car elm) knil))
           '(999)
           '(1 2 3))
@result{} (3 2 1 999)

;;; destructively reverse a list
(pair-fold (lambda (pair tail)
             (set-cdr! pair tail)
             pair)
           '()
           '(0 1 2 3 4 5))
@result{} (5 4 3 2 1 0)
@end example

At least one of the list arguments must be finite.
@end defun

@c ------------------------------------------------------------

@defun pair-fold* @var{kons} @var{knil} @var{circ1} @var{circ2} ...
Hold the same relationship with @func{fold*} that @func{pair-fold} holds
with @func{fold}; obey the recursion:

@example
(pair-fold* kons knil lis) @equiv{}
    (kons lis (pair-fold* kons knil (cdr lis)))
(pair-fold* kons knil '()) @equiv{} knil
@end example

@noindent
example:

@example
(pair-fold* cons '() '(a b c))
@result{} ((a b c) (b c) (c))
@end example

At least one of the list arguments must be finite.

Examples:

@example
(pair-fold* (lambda (elm knil)
              (cons (car elm) knil))
            '(999)
            '(1 2 3))
@result{} (1 2 3 999)

(pair-fold* (lambda (pair tail)
              (set-cdr! pair tail)
              pair)
            '()
            '(0 1 2 3 4 5))
@result{} (0 1 2 3 4 5)

(pair-fold* (lambda (a b c knil)
              (cons (list (car a)
                          (car b)
                          (car c))
                    knil))
            '(999)
            '(1 2 3)
            '(10 20 30)
            '(100 200 300))
@result{} '((1 10 100)
     (2 20 200)
     (3 30 300)
     999)
@end example
@end defun

@c page
@node lists fold reduce
@subsection Reducing


@deffn Function reduce @var{f} @var{ridentity} @var{ell}
@deffnx Syntax reduce/stx @var{f} @var{ridentity} @var{ell}
@func{reduce} is a variant of @func{fold}.  @var{ridentity} should be a
``right identity'' of the procedure @var{f}; that is, for any value
@var{x} acceptable to @var{f}:

@example
(f x ridentity) @equiv{} x
@end example

@func{reduce} has the following definition:

@example
if list = (), return ridentity;
otherwise, return (fold f (car list) (cdr list)).
@end example

@noindent
in other words, we compute @code{(fold f ridentity list)}.

Note that @var{ridentity} is used only in the empty--list case.

We typically use @func{reduce} when applying @var{f} is expensive and we
would like to avoid the extra application incurred when @func{fold}
applies @var{f} to the head of list and the identity value, redundantly
producing the same value passed in to @var{f}.  For example, if @var{f}
involves searching a file directory or performing a database query, this
can be significant.  In general, however, @func{fold} is useful in many
contexts where @func{reduce} is not.

Examples:

@example
;; take the max of a list of non-negative integers
(reduce max 0 '(1 2 3 4 5 6))
@result{} 6

(reduce + 0 '(0 1 2 3 4 5 6 7 8 9))
@result{} 45
@end example
@end deffn


@deffn Function reduce* @var{f} @var{ridentity} @var{ell}
@deffnx Syntax reduce*/stx @var{f} @var{ridentity} @var{ell}
@func{reduce*} is the @func{fold*} variant of
@func{reduce}.  It obeys the following definition:

@example
(reduce* f ridentity '()) @equiv{} ridentity
(reduce* f ridentity '(e1)) @equiv{} (f e1 ridentity)
                            @equiv{} e1
(reduce* f ridentity '(e1 e2 ...)) @equiv{}
    (f e1 (reduce f ridentity (e2 ...)))
@end example

@noindent
in other words, we compute @code{(fold* f ridentity list)}.

@example
;; append a bunch of lists together
(reduce* append
         '()
         '((1 2 3)
           (4 5)
           (6 7 8 9)
           (0)))
@result{} (1 2 3 4 5 6 7 8 9 0)
@end example
@end deffn

@c page
@node lists fold unfold
@subsection Unfolding


@deffn Function unfold @var{stop?} @var{map-to-elm} @var{seed-step} @var{first-seed}
@deffnx Function unfold @var{stop?} @var{map-to-elm} @var{seed-step} @var{first-seed} @var{tail-gen}
@deffnx Syntax unfold/stx @var{stop?} @var{map-to-elm} @var{seed-step} @var{first-seed}
@deffnx Syntax unfold/stx @var{stop?} @var{map-to-elm} @var{seed-step} @var{first-seed} @var{tail-gen}
Generate a list from a starting value; return the result.  It is is the
fundamental recursive list constructor, just as @func{fold-right} is the
fundamental recursive list consumer.  It is best described by its basic
recursion:

@example
(unfold stop? map-to-elm seed-step seed tail-gen) =
    (if (stop? seed)
        (tail-gen seed)
      (cons (map-to-elm seed)
            (unfold stop? map-to-elm
                    seed-step (seed-step seed)
                    tail-gen)))
@end example

The arguments are:

@table @var
@item stop?
Determines when to stop: it is applied to the current seed value, and if
the return value is @true{}: unfolding stops.  If it evaluates to
@true{} at the first invocation: the return value of @func{unfold} is
the return value of @var{tail-gen}.

@item map-to-elm
Maps each seed value to the corresponding list element.  It is applied
to the current seed value and must return the value to append to the
result list.

@item seed-step
Maps each seed value to next seed value.

@item first-seed
The ``state'' value for the unfold.  It is the first seed value.

@item tail-gen
Applied to the seed value that caused @func{stop?} to return @true{},
must return the tail of the result list.  Defaults to @code{(lambda (x)
'())}.
@end table

While @func{unfold} may seem a bit abstract to novice functional
programmers, it can be used in a number of ways:

@example
;; List of squares: 1^2 ... 5^2
(unfold (lambda (x) (> x 5))
        (lambda (x) (* x x))
        (lambda (x) (+ x 1))
        1)
@result{} (1 4 9 16 25)

;; Copy a proper list.
(unfold null-list? car cdr '(1 2 3 4 5))
@result{} (1 2 3 4 5)

;; Read current input port into a list of values.
(unfold eof-object? values (lambda (x) (read)) (read))

;; Copy a possibly non-proper list:
(unfold not-pair? car cdr '(1 2 3 4 . 5) values)
@result{} (1 2 3 4 . 5)

;; Append HEAD onto TAIL:
(unfold null-list? car cdr '(1 2 3) (lambda (x) '(4 5 6)))
@result{} (1 2 3 4 5 6)
@end example

@quotation
@strong{NOTE} Interested functional programmers may enjoy noting that
@func{fold-right} and @func{unfold} are in some sense inverses.  That
is, given operations @var{knull?}, @var{kar}, @var{kdr}, @var{kons}, and
@var{knil} satisfying:

@example
(kons (kar x) (kdr x)) = x and (knull? knil) = #t
@end example

@noindent
then:

@example
(fold-right kons knil (unfold knull? kar kdr x)) = x
@end example

@noindent
and:

@example
(unfold knull? kar kdr (fold-right kons knil x)) = x
@end example

This combinator sometimes is called an ``anamorphism''; when an explicit
@var{tail-gen} procedure is supplied, it is called an ``apomorphism''.
@end quotation
@end deffn

@c ------------------------------------------------------------

@deffn Function unfold-right @var{stop?} @var{map-to-elm} @var{seed-step} @var{first-seed}
@deffnx Function unfold-right @var{stop?} @var{map-to-elm} @var{seed-step} @var{first-seed} @var{tail}
@deffnx Syntax unfold-right/stx @var{stop?} @var{map-to-elm} @var{seed-step} @var{first-seed}
@deffnx Syntax unfold-right/stx @var{stop?} @var{map-to-elm} @var{seed-step} @var{first-seed} @var{tail}
Generate a list from a starting value; return the result.  It is the
fundamental iterative list constructor, just as @func{fold} is the
fundamental iterative list consumer.  Construct a list with the
following loop:

@example
(let loop ((seed seed)
           (ell  tail))
  (if (stop? seed)
      ell
    (loop (seed-step seed)
          (cons (map-to-elm seed) ell))))
@end example

Arguments are:

@table @var
@item stop?
Determine when to stop unfolding.

@item map-to-elm
Map each seed value to the corresponding list element.

@item seed-step
Map each seed value to next seed value.

@item first-seed
The ``state'' value for the unfold.

@item tail
List terminator; defaults to @code{'()}.
@end table

While @func{unfold-right} may seem a bit abstract to novice functional
programmers, it can be used in a number of ways:

@example
;; List of squares: 1^2 ... 10^2
(unfold-right zero?
              (lambda (x) (* x x))
              (lambda (x) (- x 1))
              5)
@result{} (1 4 9 16 25)

;; Reverse a proper list.
(unfold-right null-list? car cdr '(1 2 3 4 5))
@result{} (5 4 3 2 1)

;; Read current input port into a list of values.
(unfold-right eof-object? values (lambda (x) (read)) (read))

;; Equivalent to: (append-reverse rev-head tail)
(unfold-right null-list? car cdr '(3 2 1) '(4 5 6))
@result{} (1 2 3 4 5 6)
@end example

@quotation
@strong{NOTE} Interested functional programmers may enjoy noting that
@func{fold} and @func{unfold-right} are in some sense inverses.  That
is, given operations @var{knull?}, @var{kar}, @var{kdr}, @var{kons}, and
@var{knil} satisfying:

@example
(kons (kar x) (kdr x)) = x and (knull? knil) = #t
@end example

@noindent
then:

@example
(fold kons knil (unfold-right knull? kar kdr x)) = x
@end example

@noindent
and:

@example
(unfold-right knull? kar kdr (fold kons knil x)) = x.
@end example

This combinator presumably has some pretentious mathematical name;
interested readers are invited to communicate it to the author.
@end quotation
@end deffn

@c page
@node lists fold map
@subsection Mapping


@deffn Function map* @var{proc} @varo{circ} @var{circ} ...
@deffnx Syntax map*/stx @var{proc} @varo{circ} @var{circ} ...
This procedure extends the @rnrs{6} specification of @func{map} to allow
the arguments to be of unequal length; it terminates when the shortest
list runs out of elements.

@var{proc} is a procedure taking as many arguments as there are list
arguments and returning a single value.  @func{map} applies @var{proc}
element--wise to the elements of the lists and returns a list of the
results, in order.  The dynamic order in which @var{proc} is applied to
the elements of the lists is unspecified.

@example
(map* cadr '((a b)
             (d e)
             (g h)))
@result{}  (b e h)

(map* (lambda (n)
        (expt n n))
  '(1 2 3 4 5))
@result{} (1 4 27 256 3125)

(map* + '(1 2 3)
        '(4 5 6))
@result{} (5 7 9)

(let ((count 0))
  (map*
      (lambda (ignored)
        (set! count (+ count 1))
        count)
    '(a b)))
@result{} (1 2) or (2 1)
@end example

At least one of the list arguments must be a finite list:

@example
(map* +
      '(3 1 4 1)
      (circular-list 1 0))
@result{} (4 1 5 1)
@end example
@end deffn


@deffn Function map-in-order* @var{f} @varo{circ} @var{circ} ...
@deffnx Syntax map-in-order*/stx @var{f} @varo{circ} @var{circ} ...
A variant of the @func{map} procedure that guarantees to apply @var{f}
across the elements of the @var{circ} arguments in a left--to--right
order.  This is useful for mapping procedures that both have side
effects and return useful values.

At least one of the list arguments must be finite.
@end deffn


@defun append-map @var{f} @varo{circ} @var{circ} ...
@defunx append-map! @var{f} @varo{circ} @var{circ} ...
Equivalent to:

@example
(apply append (map f clist1 clist2 ...))
@end example

@noindent
and:

@example
(apply append! (map f clist1 clist2 ...))
@end example

@noindent
so it makes sense to use these functions only when the list returned by
the map process is a list of lists.

Map @var{f} over the elements of the lists, just as in the @func{map}
function.  However, the results of the applications are appended
together to make the final result.  @func{append-map} uses @func{append}
to append the results together; @func{append-map!} uses @func{append!}.

The dynamic order in which the various applications of @var{f} are made
is not specified.

Example:

@example
(append-map!
    (lambda (x)
      (list x (- x)))
  '(1 3 8))
@result{} (1 -1 3 -3 8 -8)

(append-map! list
             '(1 2 3)
             '(10 20 30))
@result{} (1 10 2 20 3 30)
@end example

At least one of the list arguments must be a finite list.
@end defun


@deffn Function map! @var{f} @varo{ell} @var{ell} ...
@deffnx Syntax map!/stx @var{f} @varo{ell} @var{ell} ...
Like @func{map} and @func{map/stx}, but they are allowed to alter the
cons cells of @varo{ell} to construct the result list.

The dynamic order in which the various applications of @var{f} are made
is not specified.  In the n--ary case, all the list arguments must have
the same number of elements.
@end deffn


@deffn Function map*! @var{f} @var{ell} @var{circ} ...
@deffnx Syntax map*!/stx @var{f} @var{ell} @var{circ} ...
Like @func{map*} and @func{map*!/stx}, but they are allowed to alter the
cons cells of @var{ell} to construct the result list.

The dynamic order in which the various applications of @var{f} are made
is not specified.  In the n--ary case, @var{circ} ... must have at least
as many elements as @var{ell}.
@end deffn


@deffn Function filter-map @var{f} @varo{ell} @var{ell} ...
@deffnx Syntax filter-map/stx @var{f} @varo{ell} @var{ell} ...
Like @func{map}, but only true values are mapped:

@example
(filter-map
    (lambda (x)
      (and (number? x)
           (* x x)))
  '(a 1 b 3 c 7))
@result{} (1 9 49)
@end example

The dynamic order in which the various applications of @var{f} are made
is not specified.  At least one of the list arguments must be finite.
@end deffn


@deffn Function filter-map* @var{f} @varo{circ} @var{circ} ...
@deffnx Syntax filter-map*/stx @var{f} @varo{circ} @var{circ} ...
Like @func{filter-map} and @func{filter-map/stx}, but accept list
arguments of different length.
@end deffn

@c page
@node lists fold foreach
@subsection Producing side effects


@deffn Function for-each* @var{proc} @varo{circ} @var{circ} ...
@deffnx Syntax for-each*/stx @var{proc} @varo{circ} @var{circ} ...
This procedure extends the @rnrs{6} specification for @func{for-each} to
allow the arguments to be of unequal length; it terminates when the
shortest list runs out of elements.

The arguments to @func{for-each*} are like the arguments to @func{map*},
but @func{for-each*} calls @var{proc} for its side effects rather than
for its values.  Unlike @func{map*}, @func{for-each*} is guaranteed to
call @var{proc} on the elements of the lists in order from the first
element(s) to the last, and the value returned by @func{for-each*} is
unspecified.

@example
(let ((v (make-vector 5)))
  (for-each*
       (lambda (i)
         (vector-set! v i (* i i)))
    '(0 1 2 3 4))
  v)
@result{} #(0 1 4 9 16)
@end example

At least one of the list arguments must be a finite list.
@end deffn


@deffn Function pair-for-each @var{f} @varo{ell} @var{ell} ...
@deffnx Syntax pair-for-each/stx @var{f} @varo{ell} @var{ell} ...
Like @func{for-each}, but @var{f} is applied to successive sublists of
the argument lists.  That is, @var{f} is applied to the cons cells of
the lists, rather than the lists' elements.  These applications occur in
left--to--right order.

The @var{f} procedure may reliably apply @func{set-cdr!} to the pairs it
is given without altering the sequence of execution.

@example
(pair-for-each
    (lambda (pair)
      (display pair)
      (newline))
  '(a b c))
@print{} (a b c)
@print{} (b c)
@print{} (c)
@end example

The list arguments must have equal length.
@end deffn


@deffn Function pair-for-each* @var{f} @varo{circ} @var{circ} ...
@deffnx Syntax pair-for-each*/stx @var{f} @varo{circ} @var{circ} ...
Like @func{for-each*}, but @var{f} is applied to successive sublists of
the argument lists.  That is, @var{f} is applied to the cons cells of
the lists, rather than the lists' elements.  These applications occur in
left--to--right order.

The @var{f} procedure may reliably apply @func{set-cdr!} to the pairs it
is given without altering the sequence of execution.

@example
(pair-for-each*
    (lambda (pair)
      (display pair)
      (newline))
  '(a b c))
@print{} (a b c)
@print{} (b c)
@print{} (c)
@end example

At least one of the list arguments must be a finite list.
@end deffn

@c page
@node lists filter
@section Filtering and partitioning


@cindex List filtering


@defun filter! @var{pred} @var{ell}
Return all the elements of @var{ell} that satisfy the predicate
@var{pred}.  The list is not disordered: Elements that appear in the
result list occur in the same order as they occur in @var{ell}.  The
returned list may share a common tail with @var{ell}.  The dynamic order
in which the various applications of @var{pred} are made is not
specified.

@example
(filter! even? '(0 7 8 8 43 -4))
@result{} (0 8 8 -4)
@end example

@func{filter!} may alter the cons cells in @var{ell} to construct the
result lists.  Notice that @func{filter} is exported by
@rsixlibrary{lists}.  @nauref{stdlib list, List utilities}
@end defun


@defun partition! @var{pred} @var{ell}
Partition the elements of @var{ell} with predicate @var{pred}, and
return two values: the list of in--elements and the list of
out--elements.  The list is not disordered: Elements occur in the result
lists in the same order as they occur in @var{ell}.  The dynamic order
in which the various applications of @var{pred} are made is not
specified.  One of the returned lists may share a common tail with
@var{ell}.

@example
(partition! symbol? '(one 2 3 four five 6))
@result{} (one four five) (2 3 6)
@end example

@func{partition!} may alter the cons cells in @var{ell} to construct the
result lists.  Notice that @func{partition} is exported by
@rsixlibrary{lists}.  @nauref{stdlib list, List utilities}
@end defun


@defun remove* @var{pred} @var{ell}
@defunx remove*! @var{pred} @var{ell}
Return @var{ell} without the elements that satisfy predicate
@var{pred}:

@example
(lambda (pred list)
  (filter (lambda (x)
            (not (pred x)))
          list))
@end example

The list is not disordered: Elements that appear in the result list
occur in the same order as they occur in @var{ell}.  The returned list
may share a common tail with @var{ell}.  The dynamic order in which the
various applications of pred are made is not specified.

@example
(remove* even? '(0 7 8 8 43 -4)) @result{} (7 43)
@end example

@func{remove*!}  is allowed to alter the cons cells in @var{ell} to
construct the result lists.

Notice that @rsixlibrary{lists} exports @func{remove}, which accepts a
Scheme object as first argument.  @nauref{stdlib list, List utilities}
@end defun

@c page
@node lists search
@section Searching


@cindex List searching
@cindex Searching in lists


The following procedures search lists for the leftmost elements
satisfying some criteria; this means they do not always examine the
entire list; thus, there is no efficient way for them to reliably detect
and signal an error when passed a dotted or circular list.  Here are the
general rules describing how these procedures work when applied to
different kinds of lists:

@table @emph
@item Proper lists
The standard, canonical behavior happens in this case.

@item Dotted lists
It is an error to pass these procedures a dotted list that does not
contain an element satisfying the search criteria.  That is, it is an
error if the procedure has to search all the way to the end of the
dotted list.  In this case the result is undefined.

@item Circular lists
It is an error to pass these procedures a circular list that does not
contain an element satisfying the search criteria.  Note that the
procedures do not detect this case, they will simply diverge.  It is,
however, acceptable to search a circular list if the search is
successful; that is, if the list contains an element satisfying the
search criteria.
@end table


@defun take-while @var{pred} @var{circ}
@defunx take-while! @var{pred} @var{circ}
Return the longest initial prefix of @var{circ} whose elements all
satisfy @var{pred}.  @func{take-while!} is allowed to alter the argument
list to produce the result.

@example
(take-while even? '(2 18 3 10 22 9))
@result{} (2 18)
@end example
@end defun


@defun drop-while @var{pred} @var{circ}
Drop the longest initial prefix of @var{circ} whose elements all satisfy
@var{pred} and return the rest of the list.

@example
(drop-while even? '(2 18 3 10 22 9))
@result{} (3 10 22 9)
@end example

The circular--list case may be viewed as ``rotating'' the list.
@end defun


@defun span @var{pred} @var{circ}
@defunx span! @var{pred} @var{ell}
@defunx break @var{pred} @var{circ}
@defunx break! @var{pred} @var{ell}
@func{span} splits the list into the longest initial prefix whose
elements all satisfy @var{pred} and the remaining tail.  @func{break}
inverts the sense of the predicate: The tail commences with the first
element of the input list that satisfies the predicate.

In other words: @func{span} finds the intial span of elements satisfying
@var{pred}, and @func{break} breaks the list at the first element
satisfying @var{pred}.

@func{span} is equivalent to:

@example
(values (take-while pred clist)
        (drop-while pred clist))
@end example

@func{span!} and @func{break!} are allowed to alter the argument list to
produce the result.

@example
(span even? '(2 18 3 10 22 9))
@result{} (2 18) (3 10 22 9)

(break even? '(3 1 4 1 5 9))
@result{} (3 1) (4 1 5 9)
@end example
@end defun


@defun any @var{pred} @varo{ell} @var{ell} ...
@defunx any* @var{pred} @varo{circ} @var{circ} ...
Apply the predicate across the lists, returning true if the predicate
returns true on any application.  If there are @math{N} list arguments,
then @var{pred} must be a procedure taking @math{N} arguments and
returning a boolean result.  If all the list arguments are empty: The
return value is @false{}.

The list arguments of @func{any} must have the same length; @func{any*}
accepts lists of different length.

@func{any} applies @var{pred} to the first elements of the list
arguments, if this application return true, @func{any} immediately
returns that value; otherwise, it iterates, applying pred to the second
elements of the lits arguments and so forth.  The iteration stops when a
true value is produced or one of the lists runs out of values; in the
latter case, @func{any} returns @false{}.  The application of @var{pred}
to the last element of the lists is a tail call.

Note the difference between @func{find} and @func{any}: @func{find}
returns the element that satisfied the predicate; @func{any} returns the
true value that the predicate produced.

The identifier @func{any} does not end with a question mark: This is to
indicate that it does not return a simple boolean (@true{} or @false{}),
but a general value.

@example
(any integer? '(a 3 b 2.7))
@result{} #t

(any integer? '(a 3.1 b 2.7))
@result{} #f

(any < '(3 1 4 1 5)
       '(2 7 1 8 2))
@result{} #t
@end example
@end defun


@defun every @var{pred} @varo{ell} @var{ell} ...
@defunx every* @var{pred} @varo{circ} @var{circ} ...
Apply the predicate across the lists, returning true if the predicate
returns true on every application.  If there are @math{N} list
arguments, then @var{pred} must be a procedure taking @math{N} arguments
and returning a boolean result.  If all the list arguments are empty:
The return value is @true{}.

The list arguments of @func{every} must have the same length;
@func{every*} accepts lists of different length.

@func{every} applies @var{pred} to the first elements of the list
arguments, if this application returns @false{}, @func{every}
immediately returns @false{}; otherwise, it iterates, applying
@var{pred} to the second elements of the list arguments and so forth.
The iteration stops when a @false{} value is produced or one of the
lists runs out of values.  In the latter case, @func{every} returns the
true value produced by its final application of @var{pred}.  The
application of @var{pred} to the last element of the lists is a tail
call.

If one of the list arguments has no elements, @func{every} simply
returns @true{}.

The identifier @func{every} does not end with a question mark: This is
to indicate that it does not return a simple boolean (@true{} or
@false{}), but a general value.
@end defun


@defun list-index @var{pred} @varo{ell} @var{ell} ...
@defunx list-index* @var{pred} @varo{circ} @var{circ} ...
Return the index of the leftmost element that satisfies @var{pred}.  If
there are @math{N} list arguments, then @var{pred} must be a function
taking @math{N} arguments and returning a boolean result.

The list arguments of @func{list-index} must have the same length;
@func{list-index*} accepts lists of different length.

@func{list-index} applies @var{pred} to the first elements of the list
arguments, if this application returns true, @func{list-index}
immediately returns zero; otherwise, it iterates, applying @var{pred} to
the second elements of the list arguments and so forth.  When it finds a
tuple of list elements that cause @var{pred} to return true, it stops
and returns the zero--based index of that position in the lists.

The iteration stops when one of the lists runs out of values; in this
case, @func{list-index} returns @false{}.

@example
(list-index even? '(3 1 4 1 5 9))
@result{} 2

(list-index < '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2))
@result{} 1

(list-index = '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2))
@result{} #f
@end example
@end defun


@defun position @var{obj} @var{ell}
@defunx position/stx @var{obj} @var{ell}
Return the index of the leftmost @var{obj} in @var{ell}.  If @var{obj}
is not present in @var{ell}, return @false{}.
@end defun


@defun member* @var{obj} @var{ell}
@defunx member* @var{obj} @var{ell} @var{item=}
Return the first sublist of @var{ell} whose car is @var{obj}, where the
sublists of @var{ell} are the non--empty lists returned by @code{(drop
ell i)} for @var{i} less than the length of @var{ell}.  If @var{obj}
does not occur in @var{ell}, then @false{} is returned.

Examples:

@example
(member* '(a) '(b (a) c))
@result{} ((a) c)
@end example

@func{member*} extends the @rnrs{6} definition of @func{member} to allow
the client to pass in an optional equality procedure @var{item=} used to
compare keys.  @var{item=} defaults to @func{equal?}.

The comparison procedure is used to compare the elements @math{Ei} of
list to the key @var{obj} in this way:

@example
(= x ei) ; list is (E1 ... En)
@end example

@noindent
that is, the first argument is always @var{obj}, and the second argument
is one of the list elements.  Thus one can reliably find the first
element of list that is greater than five with:

@example
(member* 5 ell <)
@end example

Note that fully general list searching may be performed with the
@func{find-tail} and @func{find} procedures.
@end defun


@defun find-tail @var{pred} @var{circ}
Return the first pair of @var{circ} whose car satisfies @var{pred}.  If
no pair does, return @false{}.  @func{find-tail} can be viewed as a
general--predicate variant of the @func{member*} function.

Examples:

@example
(find-tail even? '(3 1 37 -8 -5 0 0))
@result{} (-8 -5 0 0)

(find-tail even? '(3 1 37 -5))
@result{} #f
@end example

In the circular--list case, this procedure ``rotates'' the list.

@func{find-tail} is essentially @func{drop-while}, where the sense of
the predicate is inverted: @func{find-tail} searches until it finds an
element satisfying the predicate; @func{drop-while} searches until it
finds an element that doesn't satisfy the predicate.

@quotation
@strong{NOTE} The @func{find} function defined by @rnrs{6} has an
ambiguity in its lookup semantics: if @func{find} returns @false{}, we
cannot tell (in general) if it found a @false{} element that satisfied
@var{pred}, or if it did not find any element at all.

In many situations, this ambiguity cannot arise: either the list being
searched is known not to contain any @false{} elements, or the list is
guaranteed to have an element satisfying @var{pred}.

However, in cases where this ambiguity can arise, we should use
@func{find-tail} instead of @func{find}, @func{find-tail} has no such
ambiguity.
@end quotation
@end defun

@c page
@node lists delete
@section Deletion


@cindex List deletion


@defun delete @var{obj} @var{ell}
@defunx delete @var{obj} @var{ell} @var{item=}
@defunx delete! @var{obj} @var{ell}
@defunx delete! @var{obj} @var{ell} @var{item=}
Use the comparison procedure @var{item=} (which defaults to
@func{equal?})  to find all the elements of @var{ell} that are equal to
@var{obj}, and delete them from @var{ell}.  The dynamic order in which
the various applications of @var{item=} are made is not specified.

The list is not disordered: Elements that appear in the result list
occur in the same order as they occur in @var{ell}.  The result may
share a common tail with @var{ell}.

Note that fully general element deletion can be performed with the
@func{remove} and @func{remove!} procedures.

The comparison procedure is used as @code{(item= obj Ei)}, that is:
@var{obj} is always the first argument and a list element is always the
second argument.  The comparison procedure will be used to compare each
element of list exactly once; the order in which it is applied to the
various @math{Ei} is not specified.  Thus, one can reliably remove all
the numbers greater than 5 from a list with @code{(delete 5 ell <)}.

@func{delete!} is allowed to alter the cons cells in @var{ell} to
construct the result.
@end defun


@defun delete-duplicates @var{ell}
@defunx delete-duplicates @var{ell} @var{item=}
@defunx {delete-duplicates!} @var{ell}
@defunx {delete-duplicates!} @var{ell} @var{item=}
Remove duplicate elements from @var{ell}.  If there are multiple equal
elements in @var{ell}, the result list only contains the first or
leftmost of these elements in the result.  The order of these surviving
elements is the same as in the original list: @func{delete-duplicates}
does not disorder the list (hence it is useful for ``cleaning up''
association lists).

The @var{item=} parameter is used to compare the elements of the list;
it defaults to @func{equal?}.  If @math{x} comes before @math{y} in
@var{ell}, then the comparison is performed as @code{(item= x y)}.  The
comparison procedure will be used to compare each pair of elements in
@var{ell} no more than once; the order in which it is applied to the
various pairs is not specified.

The list argument may share a common tail with the returned list.

@func{delete-duplicates!}  is allowed to alter the cons cells in its
argument list to construct the result.

@example
(delete-duplicates '(a b a c a b c z)) @result{} (a b c z)

;; Clean up an alist:
(delete-duplicates '((a . 3) (b . 7) (a . 9) (c . 1))
                   (lambda (x y)
                     (eq? (car x) (car y))))
@result{} ((a . 3) (b . 7) (c . 1))
@end example
@end defun

@c page
@node lists sorted
@section Utilities for sorted lists


@defun sorted-list-insert @var{obj} @var{ell} @var{item>}
Build a new list holding the same arguments of @var{ell}, a list sorted
in increasing order, and @var{obj} inserted in such a position that the
order is preserved.  The returned list may share structure with
@var{ell}.

@var{item>} must be a predicate accepting two arguments and returning
true if the first is greater than the second.  If @var{obj} is equal to
one of the items in @var{ell}: @var{obj} is added before the item from
@var{ell}.
@end defun


@defun sorted-list-insert/uniq @var{obj} @var{ell} @var{item<} @var{item>}
Like @func{sorted-list-insert}, but if @var{obj} is equal to one of the
items in @var{ell}: @var{obj} is discarded, and @var{ell} it self is
returned.
@end defun


@defun union-of-sorted-lists @var{ell1} @var{ell2} @var{item<} @var{item>}
Build a new list representing the union of the lists arguments.
@var{ell1} and @var{ell2} are interpreted as lists sorted in
increasing order, and the result of the union is a sorted list.  The
returned list may share structure with the list arguments.

@var{item<} and @var{item>} must be predicates accepting two arguments
and returning true if the first is less than/greater than the second.

When both @var{item<} and @var{item>} return @false{}, the two items are
considered equal; in this case all the equal items are added to the
result, in such a way that the items from @var{ell1} all come before
the items from @var{ell2}.
@end defun


@defun union-of-sorted-lists/uniq @vari{ell} @varii{ell} @var{item<} @var{item>}
Like @func{union-of-sorted-lists}, but when equal items are found only
the ones from @vari{ell} are added to the result.

@example
(union-of-sorted-lists/uniq
  '(0 1   3     8 9 10)
  '(  1 2   4 5        11 23)
  < >)
@result{} '(0 1 2 3 4 5 8 9 10 11 23)
;;     ^
;; from ell1

(union-of-sorted-lists/uniq
  '(0 1 1   3)
  '(  1   2   4)
  < >)
@result{} '(0 1 1 2 3 4 5)
;;     ^ ^
;; both from ell1
@end example
@end defun

@c page
@node lists alist
@section Association lists


@cindex List, association lists
@cindex Association lists
@cindex Alists


An @dfn{association list} (or @dfn{alist}) is a list of pairs.  The car
of each pair contains a key value, and the cdr contains the associated
data value.  They can be used to construct simple look--up tables in
Scheme.  Note that association lists are probably inappropriate for
performance--critical use on large data; in these cases, hash tables or
some other alternative should be employed.


@defun assoc* @var{key} @var{alist}
@defunx assoc* @var{key} @var{alist} @var{item=}
@var{alist} must be an association list: A list of pairs.  These
procedures find the first pair in @var{alist} whose car field is
@var{key}, and returns that pair.  If no pair in @var{alist} has
@var{key} as its car, then @false{} is returned.

The functions use @func{equal?} to compare the keys and they allow the
client to pass in an optional equality procedure @var{item=} used to
compare keys.  Notice that @func{assq} and @func{assv} are exported by
@rsixlibrary{lists}.  @nauref{stdlib list, List utilities}

@example
(assoc* (list 'a) '(((a)) ((b)) ((c))))
@result{} ((a))
@end example

The comparison procedure is used to compare the elements @math{Ei} of
list to the key parameter in this way:

@example
(item= key (car Ei)) ; list is (E1 ... En)
@end example

@noindent
that is, the first argument is always @var{key}, and the second argument
is one of the list elements.  Thus one can reliably find the first entry
of @var{alist} whose @var{key} is greater than five with @code{(assoc* 5
alist <)}.

Note that fully general alist searching may be performed with the
@func{find-tail} and @func{find} procedures.
@end defun


@defun alist-cons @var{key} @var{obj} @var{alist}
Defined as:

@example
(lambda (key datum alist)
  (cons (cons key datum) alist))
@end example

@noindent
cons a new alist entry mapping @var{key} to @var{obj} onto @var{alist}.
@end defun


@defun alist-copy @var{alist}
Make a fresh copy of @var{alist}.  This means copying each pair that
forms an association as well as the spine of the list:

@example
(lambda (a)
  (map (lambda (elt)
         (cons (car elt) (cdr elt)))
       a))
@end example
@end defun


@defun alist-delete @var{key} @var{alist}
@defunx alist-delete @var{key} @var{alist} @var{item=}
@defunx alist-delete! @var{key} @var{alist}
@defunx alist-delete! @var{key} @var{alist} @var{item=}
Delete all associations from @var{alist} with the given @var{key}, using
the key--comparison procedure @var{item=}, which defaults to
@func{equal?}.  The dynamic order in which the various applications of
@var{item=} are made is not specified.

The returned value may share common tail with @var{alist}.  The alist is
not disordered: Elements that appear in the result alist occur in the
same order as they occur in @var{alist}.

The comparison procedure is used to compare the element keys @math{Ki}
of @var{alist}'s entries to the @var{key} argumentd as @code{(item= key
Ki)}; thus, one can reliably remove all entries of @var{alist} whose key
is greater than five with @code{(alist-delete 5 alist <)}.

@func{alist-delete!} is allowed to alter cons cells from the alist
parameter to construct the result.
@end defun

@c page
@node lists circ
@section Circular lists


@subsubheading Constructors

@deffn Function circular-list @vari{obj} @varii{obj} ...
@deffnx Syntax circular-list/stx @vari{obj} @varii{obj} ...
Construct a circular list (a ring) of the elements.

@example
(circular-list 'z 'q)
@result{} (z q z q z q ...)
@end example
@end deffn


@deffn Function list->circular-list! @var{ell}
@deffnx Syntax list->circular-list!/stx @var{ell}
Take a proper list and make it circular (a ring).  Return the circular
list.
@end deffn


@deffn Function circular-list->list! @var{circ}
@deffnx Function circular-list->list!/stx @var{circ}
Take a circular list and ``open it'' returning a proper list.  The car
of the returned list is the car of @var{circ}.  If @var{circ} is null,
return null.
@end deffn


@deffn Function circular-list-copy @var{circ}
@deffnx Syntax circular-list-copy/stx @var{circ}
Build and return a copy of @var{circ}.  If @var{circ} is null, return
null.
@end deffn

@c ------------------------------------------------------------

@subsubheading Inspection

@deffn Function circular-list-length @var{circ}
@deffnx Syntax circular-list-length/stx @var{circ}
Return the number of elements in @var{circ}.  The length of a circular
list is a non--negative exact integer @math{N} such that: @func{cdr}
applied @math{N} times to @var{circ}, returns the @var{circ} pair
itself.
@end deffn

@c ------------------------------------------------------------

@subsubheading Comparison

@deffn Function circular-list= @var{item=} @var{clist} ...
@deffnx Function circular-list=/stx @var{item=} @vari{clist} @varii{clist}
Compare the list arguments using @var{item=}, return true if the lists
are equal.  If all the list arguments are null, return @true{}.  If at
least one list arguments is null, but not all, return @false{}.  If the
list arguments have different length, return @false{}.
@end deffn

@c page
@node lists set
@section Set operations on lists


@cindex List set operations
@cindex Set operations on lists


These procedures implement operations on sets represented as lists of
elements.  They all take an @var{item=} argument used to compare
elements of lists; this equality procedure is required to be consistent
with @func{eq?}; that is, it must be the case that:

@example
(eq? x y) @result{} (= x y)
@end example

Note that this implies, in turn, that two lists that are @func{eq?} are
also set--equal by any legal comparison procedure.  This allows for
constant--time determination of set operations on @func{eq?} lists.

Be aware that these procedures typically run in time @math{O(n * m)} for
@math{n} and @math{m} elements list arguments.  Performance--critical
applications operating upon large sets will probably wish to use other
data structures and algorithms.


@defun lset<=? @var{item=} @var{ell} ...
Return true if, and only if, every @var{elli} is a subset of
@var{elli+1}.  List @var{AL} is a subset of list @var{BL} if every
element in @var{AL} is equal to some element of @var{BL}.  When
performing an element comparison, the @var{item=} procedure's first
argument is an element of @var{AL}, its second argument an element of
@var{BL}.

@example
(lset<=? eq? '(a) '(a b a) '(a b c c))
@result{} #t

(lset<=? eq?)
@result{} #t

(lset<=? eq? '(a))
@result{} #t
@end example

If invoked with all null lists, the return value is @true{}.
@end defun


@defun lset=? @var{item=} @var{ell} ...
Return true if, and only if, every @var{elli} is set--equal to
@var{elli+1}.  ``Set--equal'' simply means that @var{elli} is a subset
of @var{elli+1}, and @var{elli+1} is a subset of @var{elli}.  The
@var{item=} procedure's first argument is an element of @var{elli}, its
second argument is an element of @var{elli+1}.

@example
(lset=? eq? '(b e a) '(a e b) '(e e b a))
@result{} #t

(lset=? eq?)
@result{} #t

(lset=? eq? '(a))
@result{} #t
@end example
@end defun


@defun lset-adjoin @var{item=} @varo{ell} @var{ell} ...
Add the @math{Ei} elements from the @var{ell} ... arguments, not already
in @varo{ell}, to the result list.  The result shares a common tail with
the @var{ell} argument.  The new elements are added to the front of the
list, but no guarantees are made about their order.

@var{item=} is an equality procedure used to determine if an @math{Ei}
is already a member of @varo{ell}; its first argument is an element of
@varo{ell}, its second is one of the @math{Ei}.

The @varo{ell} parameter is always a suffix of the result; even if the
list parameter contains repeated elements, these are not reduced.

@example
(lset-adjoin eq? '(a b c d c e) 'a 'e 'i 'o 'u)
@result{} (u o i a b c d c e)
@end example
@end defun


@defun lset-union @var{item=} @var{ell} ...
@defunx lset-union! @var{item=} @var{ell} ...
Return the union of the lists.  The union of lists @var{AL} and @var{BL}
is constructed as follows:

@enumerate
@item
If @var{AL} is the empty list, the answer is @var{BL} (or a copy of
@var{BL}).

@item
Otherwise, the result is initialised to be list @var{AL} (or a copy of
@var{AL}).

@item
Proceed through the elements of list @var{BL} in a left--to--right
order.  If @var{b} is such an element of @var{BL}, compare every element
@var{r} of the current result list to @var{b}: @code{(item= r b)}.  If
all comparisons fail, @var{b} is consed onto the front of the result.
@end enumerate

However, there is no guarantee that @var{item=} will be applied to every
pair of arguments from @var{AL} and @var{BL}.  In particular, if
@var{AL} is @func{eq?} to @var{BL}, the operation may immediately
terminate.

In the @math{N}--ary case, the two--argument @func{list-union} operation
is simply folded across the argument lists.

@example
(lset-union eq? '(a b c d e) '(a e i o u))
@result{} (u o i a b c d e)

;; Repeated elements in the first argument are preserved.
(lset-union eq? '(a a c) '(x a x))
@result{} (x a a c)

(lset-union eq?)
@result{} ()

(lset-union eq? '(a b c))
@result{} (a b c)
@end example

@func{lset-union!} is allowed to use the cons cells in the first list
parameter to construct its answer; @func{lset-union!} is permitted to
recycle cons cells from any of its list arguments.
@end defun


@defun lset-intersection @var{item=} @varo{ell} @var{ell} ...
@defunx lset-intersection! @var{item=} @varo{ell} @var{ell} ...
Return the intersection of the lists.  The intersection of lists
@var{AL} and @var{BL} is comprised of every element of @var{AL} that is
@var{item=} to some element of @var{BL}: @code{(item= a b)}, for @var{a}
in @var{AL}, and @var{b} in @var{BL}.  Note this implies that an element
which appears in @var{BL} and multiple times in list @var{AL} will also
appear multiple times in the result.

The order in which elements appear in the result is the same as they
appear in @varo{ell}; that is, @func{lset-intersection} essentially
filters @varo{ell}, without disarranging element order.  The result may
share a common tail with @varo{ell}.

In the @math{N}--ary case, the two--argument @func{list-intersection}
operation is simply folded across the argument lists.  However, the
dynamic order in which the applications of @var{item=} are made is not
specified.

@example
(lset-intersection eq? '(a b c d e) '(a e i o u))
@result{} (a e)

;; Repeated elements in the first argument are preserved.
(lset-intersection eq? '(a x y a) '(x a x z))
@result{} '(a x a)

(lset-intersection eq? '(a b c))
@result{} (a b c)
@end example

@func{lset-intersection!}  is allowed to use the cons cells in the first
list parameter to construct its answer.
@end defun


@defun lset-difference @var{item=} @varo{ell} @var{ell} ...
@defunx lset-difference! @var{item=} @varo{ell} @var{ell} ...
Return the difference of the lists: All the elements of @varo{ell} that
are not @var{item=} to any element from one of the other @var{ell}
parameters.

The @var{item=} procedure's first argument is always an element of
@varo{ell}; its second is an element of one of the other @var{ell}.  The
dynamic order in which the applications of @var{item=} are made is not
specified.  Elements that are repeated multiple times in the @varo{ell}
parameter will occur multiple times in the result.

The order in which elements appear in the result is the same as they
appear in @varo{ell}; that is, @func{lset-difference} essentially
filters @varo{ell}, without disarranging element order.  The result may
share a common tail with @varo{ell}.

@example
(lset-difference eq? '(a b c d e) '(a e i o u))
@result{} (b c d)

(lset-difference eq? '(a b c))
@result{} (a b c)
@end example

@func{lset-difference!} is allowed to use the cons cells in the first
list parameter to construct its answer.
@end defun


@defun lset-xor @var{item=} @var{ell} ...
@defunx lset-xor! @var{item=} @var{ell} ...
Return the exclusive--or of the sets.  If there are exactly two lists,
this is all the elements that appear in exactly one of the two lists.
The operation is associative, and thus extends to the @math{N}--ary
case, in which the result is a list of the elements that appear in an
odd number of the lists.  The result may share a common tail with any of
the @var{ell} parameters.

More precisely, for two lists @var{AL} and @var{BL}, @var{AL} xor
@var{BL} is a list of:

@itemize
@item
Every element @var{a} of @var{AL} such that there is no element @var{b}
of @var{BL} such that @code{(item= a b)}, and

@item
Every element @var{b} of @var{BL} such that there is no element @var{a}
of @var{AL} such that @code{(item= b a)}.
@end itemize

In the @math{n}--ary case, the binary--xor operation is simply folded
across the lists.

@example
(lset-xor eq? '(a b c d e) '(a e i o u))
@result{} (d c b i o u)

(lset-xor eq?)
@result{} ()

(lset-xor eq? '(a b c d e))
@result{} (a b c d e)
@end example

@func{lset-xor!} is allowed to use the cons cells in the first list
parameter to construct its answer.
@end defun


@defun {lset-diff+intersection} @var{item=} @varo{ell} @var{ell} ...
@defunx {lset-diff+intersection!} @var{item=} @varo{ell} @var{ell} ...
Return two values: The difference and the intersection of the lists.  It
is equivalent to:

@example
(values (lset-difference = list1 list2 ...)
        (lset-intersection = list1
                             (lset-union = list2 ...)))
@end example

@noindent
but can be implemented more efficiently.

The @var{item=} procedure's first argument is an element of @varo{ell};
its second is an element of one of the other @var{ell} arguments.

Either of the returned lists may share a common tail with @varo{ell}.
This operation essentially partitions @varo{ell}.

@func{lset-diff+intersection!} is allowed to use the cons cells in the
first list argument to construct its answer.
@end defun

@c page
@node lists low
@section Low level utilities


The following bindings are exported by @library{lists low}.


@defun %and/or-null? @var{ell} ...
This is the implementation of @func{and/or-null?}.  Return two values
being the return values of @func{and-null?} and @func{or-null?} applied
to the @var{list} arguments.
@end defun


@defun %and/or-eq? @var{list-of-clists1} @var{list-of-clists2}
Given two lists of lists (possibly circular), compare with @func{eq?}
the sublists from the arguments, and return two boolean values:

@enumerate
@item
True if each sublist from @var{list-of-clists1} is @func{eq?} to its
homologous from @var{list-of-clists2}.

@item
True if at least one sublist from @var{list-of-clists1} is @func{eq?} to
its homologous from @var{list-of-clists2}.
@end enumerate

@var{list-of-clists1} and @var{list-of-clists2} are meant to have the
same length, but this is not tested.  The iteration will stop when the
end of the shorter list is found.

To understand how this function is used, consider the following:

@smallexample
(define (circular-list= item= . list-of-clists)
  (let-values (((and-nil or-nil)
               (apply %and/or-null? list-of-clists)))
    (cond (and-nil #t)
          (or-nil  #f)
          (else
           (let loop ((cells list-of-clists))
             (let-values (((cars cdrs) (%cars/cdrs* cells)))
               (or
                (null? cars)
                (and
                 (apply item= cars)
                 (let-values (((and-eq or-eq)
                              (%and/or-eq? list-of-clists cdrs)))
                   (cond (and-eq #t)
                         (or-eq  #f)
                         (else (loop cdrs))))))))))))
@end smallexample
@end defun


@defun %cars @var{list-of-lists}
@defunx %cars @var{list-of-lists} @var{who}
Return the list of cars of the sublists of @var{list-of-lists}, which
must be a non--empty list of lists.

If all the sublists are null: The return value is null.  If at least one
sublist, but not all, is null: Raise an assertion violation using
@var{who} as value for the @condition{who} condition.  @var{who} defaults to
@false{}.
@end defun


@defun %cars* @var{list-of-lists}
Like @var{%cars} but accept sublists of different length.  If at least
one sublist is null: The return value is null.
@end defun


@defun %cdrs @var{list-of-lists}
@defunx %cdrs @var{list-of-lists} @var{who}
Return the list of cdrs of the sublists of @var{list-of-lists}, which
must be a non--empty list of lists.

If all the sublists are null: The return value is null.  If at least one
sublist, but not all, is null: Raise an assertion violation using
@var{who} as value for the @condition{who} condition.  @var{who} defaults to
@false{}.
@end defun


@defun %cdrs* @var{list-of-lists}
Like @var{%cdrs} but accept sublists of different length.  If at least
one sublist is null: The return value is null.
@end defun


@defun %cars/cdrs @var{list-of-lists}
Given a list of sublists, return two values being the list of cars and
the list of cdrs from @var{list-of-lists}.  If the sublists are detected
not to have equal length, raise an error.
@end defun


@defun %cars/cdrs* @var{list-of-lists}
Like @func{%cars/cdrs}, but accept lists of different length.  If a list
in @var{list-of-lists} is null: Return 2 null values.
@end defun


@defun %cars+cdrs*/no-test @var{list-of-lists}
Like @func{%cars/cdrs*}, but do not test if one sublist is null.  If one
sublist is null, the behaviour is undefined.
@end defun


@defun %cars+knil @var{list-of-lists} @var{knil}
@defunx %knil+cars @var{list-of-lists} @var{knil}
@defunx %cars+knil @var{list-of-lists} @var{knil} @var{who}
@defunx %knil+cars @var{list-of-lists} @var{knil} @var{who}
Return the list of cars of the sublists of @var{list-of-lists}, which
must be a non--empty list of lists.  @func{%cars+knil} adds @var{knil}
as last value.  @func{%knil+cars} adds @var{knil} as first value.

If all the sublists are null: The return value is null.  If at least one
sublist, but not all, is null: Raise an assertion violation using
@var{who} as value for the @condition{who} condition.  @var{who} defaults to
@false{}.
@end defun


@defun %cars+knil* @var{list-of-lists} @var{knil}
@defunx %knil+cars* @var{list-of-lists} @var{knil}
Like @func{%cars+knil} and @func{%knil+cars}, but accept sublists of
different length.  If at least one sublist is null: The return value is
null.
@end defun


@defun %cars+knil/cdrs @var{list-of-lists} @var{knil}
@defunx %knil+cars/cdrs @var{list-of-lists} @var{knil}
@defunx %cars+knil/cdrs @var{list-of-lists} @var{knil} @var{who}
@defunx %knil+cars/cdrs @var{list-of-lists} @var{knil} @var{who}
Given that @var{list-of-lists} must be a non--empty list of lists,
return two values: The list of cars and the lists of cdrs of the
sublists.  @func{%cars+knil/cdrs} adds @var{knil} as last value of the
cars.  @func{%knil+cars/cdrs} adds @var{knil} as first value of the
cars.

If all the sublists are null: The return values are both null.  If at
least one sublist, but not all, is null: Raise an assertion violation
using @var{who} as value for the @condition{who} condition.  @var{who}
defaults to @false{}.
@end defun


@defun %cars+knil/cdrs* @var{list-of-lists} @var{knil}
@defunx %knil+cars/cdrs* @var{list-of-lists} @var{knil}
Like @func{%cars+knil/cdrs} and @func{%knil+cars/cdrs}, but accept
sublists of different length.  If at least one sublist is null: The
return value is null.
@end defun

@c ------------------------------------------------------------

@subsubheading Queues

The following macros handle queue values: Pairs whose car is a list and
whose cdr is the last pair in the list.  They allow user friendly
insertion of elements at the end of the list.  Experiments show that
building a list in reverse and then applying @func{reverse} to it, is
almost always faster than using these queue macros.

@example
          -----------
  queue  | car | cdr |
          -----------
            |     |
        ----       ----------------
       |                           |
       v                           v
      ---    ---    ---    ---    ---
list | | |->| | |->| | |->| | |->| | |->()
      ---    ---    ---    ---    ---
      |      |      |      |      |
      o      o      o      o      o
@end example

The following @api{} does not implement a full queue value; for that see
the @library{queues} library.  @ref{queues, Simple queues}


@deffn Syntax %make-queue @var{obj}
Build and return a new queue having @var{obj} as first argument.  Takes
care of evaluating @var{obj} only once.
@end deffn


@deffn Syntax %list->queue @var{ell}
Embed @var{list} into a queue and return it.  Takes care of evaluating
@var{ell} only once.
@end deffn


@deffn Syntax enqueue! @var{queue} @var{obj}
Enqueue @var{obj} at the end of @var{queue} and return a new queue
value.  Takes care of evaluating @var{obj} only once, but evaluates
@var{queue} multiple times.
@end deffn


@deffn Syntax %queue-list-ref @var{queue}
Return the list inside of @var{queue}.  It is a synonym of @func{car}.
@end deffn


@deffn Syntax %queue-last-pair-ref @var{queue}
Return the last pair of the list inside of @var{queue}.  It is a synonym
of @func{cdr}.
@end deffn


Examples of building a list using a queue:

@example
(define max-value+1 10)

(do ((i 1 (+ 1 i))
     (l (%make-queue 0) (%enqueue! l i)))
    ((= i max-value+1)
     (%queue-list-ref l)))
@result{} '(0 1 2 3 4 5 6 7 8 9)

(let loop ((l (%make-queue 0))
           (i 1))
  (if (= i max-value+1)
      (%queue-list-ref l)
    (loop (%enqueue! l i) (+ 1 i))))
@result{} '(0 1 2 3 4 5 6 7 8 9)
@end example

@noindent
which is the same of doing:

@example
(define max-value+1 10)

(do ((i 1 (+ 1 i))
     (l '(0) (cons i l)))
    ((= i max-value+1)
     (reverse l)))
@result{} '(0 1 2 3 4 5 6 7 8 9)

(let loop ((l '(0))
           (i 1))
  (if (= i max-value+1)
      (reverse l)
    (loop (cons i l) (+ 1 i))))
@result{} '(0 1 2 3 4 5 6 7 8 9)
@end example

@c page
@node lists class
@section Class interface


The @library{xlists} library exports the single binding @class{xlist},
which provides an interface to the @library{lists} functions through the
facilities of the @library{classes} library.


@deftp {Foreign Class} @aclass{xlist}
Foreign class interface to the list functions.  It is derived from
@class{list}.
@end deftp


All the following methods are implemented as syntaxes; in all the
following descriptions: @meta{self} is an identifier bound to the
subject list.


@defmethod @aclass{xlist} list-copy
Implement the expansion:

@example
(@cmeta{self}.list-copy)
@expansion{} (list-copy @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} tree-copy
Implement the expansion:

@example
(@cmeta{self}.tree-copy)
@expansion{} (tree-copy @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} circular-list!
Implement the expansion:

@example
(@cmeta{self}.circular-list!)
@expansion{} (set! @cmeta{self} (list->circular-list! @cmeta{self}))
@end example
@end defmethod


@defmethod @aclass{xlist} break-circular-list!
Implement the expansion:

@example
(@cmeta{self}.break-circular-list!)
@expansion{} (set! @cmeta{self} (circular-list->list! @cmeta{self}))
@end example
@end defmethod


@defmethod @aclass{xlist} circular-list-copy
Implement the expansion:

@example
(@cmeta{self}.circular-list-copy)
@expansion{} (circular-list-copy @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} circular-list-length
Implement the expansion:

@example
(@cmeta{self}.circular-list-length)
@expansion{} (circular-list-length @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} circular-list?
Implement the expansion:

@example
(@cmeta{self}.circular-list?)
@expansion{} (circular-list? @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} circular-list?/or-null
Implement the expansion:

@example
(@cmeta{self}.circular-list?/or-null)
@expansion{} (circular-list?/or-null @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} dotted-list?
Implement the expansion:

@example
(@cmeta{self}.dotted-list?)
@expansion{} (dotted-list? @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} dotted-list?/or-null
Implement the expansion:

@example
(@cmeta{self}.dotted-list?/or-null)
@expansion{} (dotted-list?/or-null @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} car+cdr
Implement the expansion:

@example
(@cmeta{self}.car+cdr)
@expansion{} (car+cdr @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} first
Implement the expansion:

@example
(@cmeta{self}.first)
@expansion{} (first @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} second
Implement the expansion:

@example
(@cmeta{self}.second)
@expansion{} (second @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} third
Implement the expansion:

@example
(@cmeta{self}.third)
@expansion{} (third @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} fourth
Implement the expansion:

@example
(@cmeta{self}.fourth)
@expansion{} (fourth @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} fifth
Implement the expansion:

@example
(@cmeta{self}.fifth)
@expansion{} (fifth @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} sixth
Implement the expansion:

@example
(@cmeta{self}.sixth)
@expansion{} (sixth @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} seventh
Implement the expansion:

@example
(@cmeta{self}.seventh)
@expansion{} (seventh @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} eighth
Implement the expansion:

@example
(@cmeta{self}.eighth)
@expansion{} (eighth @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} ninth
Implement the expansion:

@example
(@cmeta{self}.ninth)
@expansion{} (ninth @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} tenth
Implement the expansion:

@example
(@cmeta{self}.tenth)
@expansion{} (tenth @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} take-left @ameta{count}
Implement the expansion:

@example
(@cmeta{self}.take-left @cmeta{count})
@expansion{} (take-left @cmeta{self} @cmeta{count})
@end example
@end defmethod


@defmethod @aclass{xlist} take-right @ameta{count}
Implement the expansion:

@example
(@cmeta{self}.take-right @cmeta{count})
@expansion{} (take-right @cmeta{self} @cmeta{count})
@end example
@end defmethod


@defmethod @aclass{xlist} take-left! @ameta{count}
Implement the expansion:

@example
(@cmeta{self}.take-left! @cmeta{count})
@expansion{} (set! @cmeta{self} (take-left! @cmeta{self} @cmeta{count}))
@end example
@end defmethod


@defmethod @aclass{xlist} drop-left @ameta{count}
Implement the expansion:

@example
(@cmeta{self}.drop-left @cmeta{count})
@expansion{} (drop-left @cmeta{self} @cmeta{count})
@end example
@end defmethod


@defmethod @aclass{xlist} drop-right @ameta{count}
Implement the expansion:

@example
(@cmeta{self}.drop-right @cmeta{count})
@expansion{} (drop-right @cmeta{self} @cmeta{count})
@end example
@end defmethod


@defmethod @aclass{xlist} drop-right! @ameta{count}
Implement the expansion:

@example
(@cmeta{self}.drop-right! @cmeta{count})
@expansion{} (set! @cmeta{self} (drop-right! @cmeta{self} @cmeta{count}))
@end example
@end defmethod


@defmethod @aclass{xlist} split-at @ameta{count}
Implement the expansion:

@example
(@cmeta{self}.split-at @cmeta{count})
@expansion{} (split-at @cmeta{self} @cmeta{count})
@end example
@end defmethod


@defmethod @aclass{xlist} split-at! @ameta{count}
Implement the expansion:

@example
(@cmeta{self}.split-at! @cmeta{count})
@expansion{} (split-at! @cmeta{self} @cmeta{count})
@end example
@end defmethod


@defmethod @aclass{xlist} last
Implement the expansion:

@example
(@cmeta{self}.last)
@expansion{} (last @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} last-pair
Implement the expansion:

@example
(@cmeta{self}.last-pair)
@expansion{} (last-pair @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} length+
Implement the expansion:

@example
(@cmeta{self}.length+)
@expansion{} (length+ @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} append! @ameta{obj} ...
Implement the expansion:

@example
(@cmeta{self}.append! @ameta{obj} ...)
@expansion{} (set! @cmeta{self} (append! @cmeta{self} @cmeta{obj} ...))
@end example
@end defmethod


@defmethod @aclass{xlist} reverse!
Implement the expansion:

@example
(@cmeta{self}.reverse!)
@expansion{} (set! @cmeta{self} (reverse! @cmeta{self}))
@end example
@end defmethod


@defmethod @aclass{xlist} append-reverse
Implement the expansion:

@example
(@cmeta{self}.append-reverse)
@expansion{} (append-reverse @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} append-reverse!
Implement the expansion:

@example
(@cmeta{self}.append-reverse!)
@expansion{} (set! @cmeta{self} (append-reverse! @cmeta{self}))
@end example
@end defmethod


@defmethod @aclass{xlist} zip @ameta{ell} ...
Implement the expansion:

@example
(@cmeta{self}.zip @cmeta{ell} ...)
@expansion{} (zip @cmeta{self} @cmeta{ell} ...)
@end example
@end defmethod


@defmethod @aclass{xlist} zip* @ameta{ell} ...
Implement the expansion:

@example
(@cmeta{self}.zip* @ameta{ell} ...)
@expansion{} (zip* @cmeta{self} @cmeta{ell} ...)
@end example
@end defmethod


@defmethod @aclass{xlist} unzip1
Implement the expansion:

@example
(@cmeta{self}.unzip1)
@expansion{} (unzip1 @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} unzip2
Implement the expansion:

@example
(@cmeta{self}.unzip2)
@expansion{} (unzip2 @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} unzip3
Implement the expansion:

@example
(@cmeta{self}.unzip3)
@expansion{} (unzip3 @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} unzip4
Implement the expansion:

@example
(@cmeta{self}.unzip4)
@expansion{} (unzip4 @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} unzip5
Implement the expansion:

@example
(@cmeta{self}.unzip5)
@expansion{} (unzip5 @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} count @ameta{proc}
Implement the expansion:

@example
(@cmeta{self}.count @cmeta{proc})
@expansion{} (count @cmeta{proc} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} and-fold-left* @ameta{knil} @ameta{kombine}
Implement the expansion:

@example
(@cmeta{self}.and-fold-left* @cmeta{knil} @cmeta{kombine})
@expansion{} (and-fold-left* @ameta{kombine} @ameta{knil} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} and-fold-right* @ameta{knil} @ameta{kombine}
Implement the expansion:

@example
(@cmeta{self}.and-fold-right* @cmeta{knil} @cmeta{kombine})
@expansion{} (and-fold-right* @ameta{kombine} @ameta{knil} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} fold-left/pred @ameta{knil} @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.fold-left/pred @ameta{knil} @ameta{predicate})
@expansion{} (fold-left/pred @ameta{predicate} @ameta{knil} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} pair-fold @ameta{knil} @ameta{kombine}
Implement the expansion:

@example
(@cmeta{self}.pair-fold @ameta{knil} @ameta{kombine})
@expansion{} (pair-fold @ameta{kombine} @ameta{knil} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} pair-fold* @ameta{knil} @ameta{kombine}
Implement the expansion:

@example
(@cmeta{self}.pair-fold* @cmeta{knil} @cmeta{kombine})
@expansion{} (pair-fold* @cmeta{kombine} @cmeta{knil} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} reduce @ameta{knil} @ameta{kombine}
Implement the expansion:

@example
(@cmeta{self}.reduce @cmeta{knil} @cmeta{kombine})
@expansion{} (reduce @cmeta{kombine} @cmeta{knil} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} reduce* @ameta{knil} @ameta{kombine}
Implement the expansion:

@example
(@cmeta{self}.reduce* @cmeta{knil} @cmeta{kombine})
@expansion{} (reduce* @cmeta{kombine} @cmeta{knil} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} map-in-order* @ameta{proc}
Implement the expansion:

@example
(@cmeta{self}.map-in-order* @ameta{proc})
@expansion{} (map-in-order* @cmeta{proc} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} map! @ameta{proc}
Implement the expansion:

@example
(@cmeta{self}.map! @cmeta{proc})
@expansion{} (set! @cmeta{self} (map! @cmeta{proc} @cmeta{self}))
@end example
@end defmethod


@defmethod @aclass{xlist} pair-for-each @ameta{proc}
Implement the expansion:

@example
(@cmeta{self}.pair-for-each @cmeta{proc})
@expansion{} (pair-for-each @cmeta{proc} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} filter-map @ameta{proc}
Implement the expansion:

@example
(@cmeta{self}.filter-map @cmeta{proc})
@expansion{} (filter-map @cmeta{proc} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} filter! @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.filter! @cmeta{predicate})
@expansion{} (set! @cmeta{self} (filter! @cmeta{predicate} @cmeta{self}))
@end example
@end defmethod


@defmethod @aclass{xlist} remove* @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.remove* @cmeta{predicate})
@expansion{} (remove* @cmeta{predicate} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} remove*! @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.remove*! @cmeta{predicate})
@expansion{} (set! @cmeta{self} (remove*! @cmeta{predicate} @cmeta{self}))
@end example
@end defmethod


@defmethod @aclass{xlist} find-tail @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.find-tail @cmeta{predicate})
@expansion{} (find-tail @cmeta{predicate} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} take-while @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.take-while @cmeta{predicate})
@expansion{} (take-while @cmeta{predicate} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} take-while! @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.take-while! @cmeta{predicate})
@expansion{} (set! @cmeta{self} (take-while! @cmeta{predicate} @cmeta{self}))
@end example
@end defmethod


@defmethod @aclass{xlist} drop-while @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.drop-while @cmeta{predicate})
@expansion{} (drop-while @cmeta{predicate} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} drop-while! @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.drop-while! @cmeta{predicate})
@expansion{} (set! @cmeta{self} (drop-while @cmeta{predicate} @cmeta{self}))
@end example
@end defmethod


@defmethod @aclass{xlist} span @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.span @cmeta{predicate})
@expansion{} (span @cmeta{predicate} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} break @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.break @cmeta{predicate})
@expansion{} (break @cmeta{predicate} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} any @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.any @cmeta{predicate})
@expansion{} (any @cmeta{predicate} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} every @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.every @cmeta{predicate})
@expansion{} (every @cmeta{predicate} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} list-index @ameta{predicate}
Implement the expansion:

@example
(@cmeta{self}.list-index @cmeta{predicate})
@expansion{} (list-index @cmeta{predicate} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} member* @ameta{obj}
@defmethodx @aclass{xlist} member* @ameta{obj} @ameta{item=}
Implement the expansions:

@example
(@cmeta{self}.member* @cmeta{obj})
@expansion{} (member* @cmeta{obj} @cmeta{self})

(@cmeta{self}.member* @cmeta{obj} @cmeta{item=})
@expansion{} (member* @cmeta{obj} @cmeta{self} @cmeta{item=})
@end example
@end defmethod


@defmethod @aclass{xlist} position @ameta{obj}
Implement the expansion:

@example
(@cmeta{self}.position @cmeta{obj})
@expansion{} (position @cmeta{obj} @cmeta{self})
@end example
@end defmethod


@defmethod @aclass{xlist} delete @ameta{obj}
@defmethodx @aclass{xlist} delete @ameta{obj} @ameta{item=}
Implement the expansions:

@example
(@cmeta{self}.delete @cmeta{obj})
@expansion{} (delete @cmeta{obj} @cmeta{self})

(@cmeta{self}.delete @cmeta{obj} @cmeta{item=})
@expansion{} (delete @cmeta{obj} @cmeta{self} @cmeta{item=})
@end example
@end defmethod


@defmethod @aclass{xlist} delete! @ameta{obj}
@defmethodx @aclass{xlist} delete! @ameta{obj} @ameta{item=}
Implement the expansions:

@example
(@cmeta{self}.delete! @cmeta{obj})
@expansion{} (set! @cmeta{self} (delete! @cmeta{obj} @cmeta{self}))

(@cmeta{self}.delete! @cmeta{obj} @cmeta{item=})
@expansion{} (set! @cmeta{self} (delete! @cmeta{obj} @cmeta{self} @cmeta{item=}))
@end example
@end defmethod


@defmethod @aclass{xlist} delete-duplicates
@defmethodx @aclass{xlist} delete-duplicates @ameta{item=}
Implement the expansions:

@example
(@cmeta{self}.delete-duplicates)
@expansion{} (delete-duplicates @cmeta{self})

(@cmeta{self}.delete-duplicates @cmeta{item=})
@expansion{} (delete-duplicates @cmeta{self} @cmeta{item=})
@end example
@end defmethod


@defmethod @aclass{xlist} delete-duplicates!
@defmethodx @aclass{xlist} delete-duplicates! @ameta{item=}
Implement the expansions:

@example
(@cmeta{self}.delete-duplicates!)
@expansion{} (set! @cmeta{self} (delete-duplicates! @cmeta{self}))

(@cmeta{self}.delete-duplicates! @cmeta{item=})
@expansion{} (set! @cmeta{self} (delete-duplicates! @cmeta{self} @cmeta{item=}))
@end example
@end defmethod


@defmethod @aclass{xlist} sorted-list-insert @ameta{obj} @ameta{item>}
Implement the expansion:

@example
(@cmeta{self}.sorted-list-insert @cmeta{obj} @cmeta{item>})
@expansion{} (sorted-list-insert @cmeta{obj} @cmeta{self} @cmeta{item>})
@end example
@end defmethod


@defmethod @aclass{xlist} sorted-list-insert! @ameta{obj} @ameta{item>}
Implement the expansion:

@example
(@cmeta{self}.sorted-list-insert! @cmeta{obj} @cmeta{item>})
@expansion{} (set! @cmeta{self} (sorted-list-insert @cmeta{obj} @cmeta{self} @cmeta{item>}))
@end example
@end defmethod


@defmethod @aclass{xlist} sorted-list-insert/uniq @ameta{obj} @ameta{item<} @ameta{item>}
Implement the expansion:

@example
(@cmeta{self}.sorted-list-insert/uniq @cmeta{obj} @cmeta{item<} @cmeta{item>})
@expansion{} (sorted-list-insert/uniq @cmeta{obj} @cmeta{self} @cmeta{item<} @cmeta{item>})
@end example
@end defmethod


@defmethod @aclass{xlist} sorted-list-insert/uniq! @ameta{obj} @ameta{item<} @ameta{item>}
Implement the expansion:

@example
(@cmeta{self}.sorted-list-insert/uniq! @cmeta{obj} @cmeta{item<} @cmeta{item>})
@expansion{} (set! @cmeta{self} (sorted-list-insert/uniq @cmeta{obj} @cmeta{self} @cmeta{item<} @cmeta{item>}))
@end example
@end defmethod

@c page
@node char-sets
@chapter Character sets


The @library{char-sets} library handles sets of characters.

A ``character'' is every value for which the application of @func{char?}
returns @true{}.  This library does nothing that can be related to a
specific character encoding, like @ascii{}, @acronym{UCS} or Unicode.
When needed, it relies on @func{string->list} to split a string into its
character components.  @nauref{stdlib unicode,Unicode}.

@menu
* char-sets intro::             Introduction.
* char-sets make::              Constructors.
* char-sets pred::              Predicates.
* char-sets inspect::           Inspection.
* char-sets ops::               Operations.
* char-sets sets::              Predefined character sets.
@end menu

@c page
@node char-sets intro
@section Introduction


In the following procedure specifications:

@table @var
@item cs
Is a character set.

@item str
Is a string.

@item char
Is a character.

@item range
Is a pair of characters interpreted as double--closed range of
characters, the car being the lower--limit and the cdr being the
upper--limit.

@item char-list
Is a list of characters.

@item pred
Is a unary character predicate procedure, returning a boolean value when
applied to a character.

@item obj
May be any value at all.
@end table

A parameter followed by @code{...} means zero--or--more elements.

Unless otherwise noted in the specification of a procedure, procedures
always return character sets that are distinct from the parameter
character sets.

@c page
@node char-sets make
@section Constructors


@defvar char-set-lower-bound
@defvarx char-set-upper-bound
@defvarx char-set-inner-upper-bound
@defvarx char-set-inner-lower-bound
The character sets are defined by the Scheme standard to be in the
ranges @code{[0, #xD800)} and @code{(#xDFFF, #x10FFFF]}.
@library{char-sets} exports these symbols, defined as follows:

@example
(define char-set-lower-bound
  (integer->char 0))

(define char-set-inner-upper-bound
  (integer->char (- #xD800 1)))

(define char-set-inner-lower-bound
  (integer->char (+ 1 #xDFFF)))

(define char-set-upper-bound
  (integer->char #x10FFFF))
@end example
@end defvar


@defun char-set @var{char/range} ...
Build and return a new char-set.  The @var{char/range} arguments may be
the empty list or a mixed list of characters and ranges.
@end defun


@defun char-set-copy @var{cs}
Return a newly allocated char-set holding a copy of @var{cs}.
@end defun


@defun char-set-add @var{cs} @var{char/range}
@defunx char-set-add! @var{cs} @var{char/range}
Add values to an existing char-set.  @var{char/range} can be a single
character or a range.  @func{char-set-add} returns a new char-set,
@func{char-set-add!}  modifies @var{cs} itself.

The returned set may share some structure with the arguments.
@end defun

@c page
@node char-sets pred
@section Predicates


@defun char-set? @var{obj}
Return true if @var{obj} is a valid char-set.
@end defun


@defun char-set-empty? @var{cs}
Return true if the char-set is empty.
@end defun


@defun char-set-contains? @var{cs} @var{char}
Return true if @var{char} is an element of @var{cs}.
@end defun


@defun char-set=? @var{cs-a} @var{cs-b}
Return true if the arguments represent the same char-set.
@end defun


@defun char-set<? @var{cs-a} @var{cs-b}
Return true if all the elements of @var{cs-a} are strictly less than all
the elements of @var{cs-b}.  Empty sets cannot be ordered, so if an
argument is empty the return value is @false{}.
@end defun


@defun char-set-subset? @var{cs0} @var{cs} ...
@defunx char-set-subset?/strict @var{cs0} @var{cs} ...
Return @true{} if the arguments, in the given order, are subsets of each
other or strict subsets of each other.
@end defun


@defun char-set-superset? @var{cs0} @var{cs} ...
@defunx char-set-superset?/strict @var{cs0} @var{cs} ...
Return @true{} if the arguments, in the given order, are supersets of
each other or strict supersets of each other.
@end defun

@c page
@node char-sets inspect
@section Inspection


@defun char-set-size @var{cs}
Return the number of characters in @var{cs}.
@end defun


@defun char-set-write @var{cs}
@defunx char-set-write @var{cs} @var{port}
Write to @var{port} a chunk of Scheme code that, when evaluated,
generates @var{cs}.  When not given, @var{port} defaults to
@code{(current-output-port)}.
@end defun


@c page
@node char-sets ops
@section Operations


@defun char-set-intersection @var{cs0} @var{cs} ...
Return a new set representing the intersection of the arguments; the
intersection is the set of characters present in all the arguments.

The returned set may share some structure with the arguments.
@end defun


@defun char-set-union @var{cs0} @var{cs} ...
Return a new set representing the union of the arguments; the union is
the set of characters present in one and/or more arguments.

The returned set may share some structure with the arguments.
@end defun


@defun char-set-difference @var{cs0} @var{cs} ...
Return a new set representing the difference between the arguments; the
difference is the set of characters present in only one of the
arguments.

The returned set may share some structure with the arguments.
@end defun


@defun char-set-complement @var{cs}
@defunx char-set-complement @var{cs} @var{cs-universe}
Return a new set representing the complement of @var{cs} in
@var{cs-universe}.  The complement is the set of characters present in
@var{cs-universe}, which are not present in @var{cs}.

If omitted, @var{cs-universe} defaults to @code{char-set:full}.

The returned set may share some structure with the arguments.
@end defun


@defun char-set-for-each @var{proc} @var{cs}
Apply @var{proc} to each character in @var{cs}.
@end defun


@defun char-set-every @var{proc} @var{cs}
Apply @var{proc} to each character in the set and return true if all the
return values are true.  The application stops at the first @false{}
return value.
@end defun


@defun char-set-any @var{proc} @var{cs}
Apply @var{proc} to each character in the set and return true if at
least one of the returned values is true.  The application stops at the
first true return value.
@end defun


@defun char-set-fold @var{kons} @var{knil} @var{cs}
Fold @var{kons} over the characters in the set.  @var{kons} must accept
two arguments: The next character from the set and the return value of
the previous invocation of @var{kons}.  At the first application the
second argument to @var{kons} is @var{knil}.
@end defun


@defun char-set->list @var{cs}
Return a list holding all the characters in the set.  Beware that for
some character sets the resulting list can be big.
@end defun


@defun string->char-set @var{string}
Return a new character set holding all the characters in @var{string}.
@end defun

@c page
@node char-sets sets
@section Predefined character sets


Several character sets are predefined for convenience by
@library{char-sets} and other auxiliary libraries.  They are meant to
satisfy the simplest needs.

@menu
* char-sets sets intro::        Introduction.
* char-sets sets how::          How predefined sets were defined.
* char-sets sets basic::        Basic character sets.
* char-sets sets ascii::        Sets of @ascii{} characters.
* char-sets sets blocks::       Sets corresponding to Unicode blocks.
* char-sets sets categories::   Sets corresponding to Unicode general
                                categories.
@end menu

@c page
@node char-sets sets intro
@subsection Introduction


Unicode assigns a single number to each code element defined by the
Standard.  Each of these numbers is called a @dfn{code point} and, when
referred to in text, is listed in hexadecimal form following the prefix
@code{U+}.  For example, the code point @code{U+0041} is the hexadecimal
number @code{0041} (equal to the decimal number @code{65}); it
represents the character @code{A} in the Unicode Standard.

Each character is also assigned a unique name that specifies it and no
other.  For example, @code{U+0041} is assigned the character name
@code{LATIN CAPITAL LETTER A}.  @code{U+0A1B} is assigned the character
name @code{GURMUKHI LETTER CHA}.  These Unicode names are identical to
the @acronym{ISO}/@acronym{IEC} 10646 names for the same characters.

For a general overview of the Unicode Standard see@footnote{@aurl{} last
verified Tue Jun 23, 2009.}:

@center @url{http://en.wikipedia.org/wiki/Unicode}

For the complete reference of Unicode code points we should inspect the
Unicode Characters Database@footnote{@aurl{}s last verified Tue Jun 23,
2009.}:

@center @url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt}
@center @url{ftp://ftp.unicode.org/Public/UNIDATA/Blocks.txt}

@noindent
which is partly and introductorily documented by@footnote{@aurl{} last
verified Tue Jun 23, 2009.}:

@center @url{ftp://ftp.unicode.org/Public/UNIDATA/UCD.html}

@noindent
the same directory on the @url{unicode.org} site offers other documents
on the interpretation of the database.

For an explanation of @ascii{} coding, see@footnote{@aurl{} last
verified Tue Jun 23, 2009.}:

@center @url{http://en.wikipedia.org/wiki/Ascii}

@c page
@node char-sets sets how
@subsection How predefined sets were defined


The following methods were employed to define the character sets.

@itemize
@item
The @ascii{}--related sets were composed by hand reading the @ascii{}
description; they are exported by the @library{char-sets} library
itself.

@item
All the ranges defined by the @file{Blocks.txt} database file have been
converted to a set by hand; they are exported by the @library{char-sets
blocks} library (there are a lot of them).

@item
Each general category (@code{Ll}, @code{Lu}, etc.) has been converted to
a set; they are exported by the @library{char-sets categories} library
(there are a lot of them).  Notice that not all the code points accepted
by @func{char=?} are part of a general category, so the union of the
category sets is different from the full character set.
@end itemize

@c ------------------------------------------------------------

@subsubheading Inspecting the database

On a Unix--like system, the following commands can be used to inspect
the @file{UnicodeData.txt} database:

@table @command
@item wc -l <UnicodeData.txt
Count the lines in the database: One line for each code point.  Notice
that not all the code points have a line in this file; the file format
allows ranges, so some pairs of lines represent ranges of characters.

@item cut -d';' -f3 <UnicodeData.txt | sort | uniq
Print the category codes in the database (use @command{sort} first,
because @command{uniq} removes repeated lines only if they are
adjacent).  Notice that the @code{Cs} category (surrogate characters) is
present in the database, but excluded from the Nausicaa libraries,
because it describes the range @code{[#xD800, #xDFFF]} forbidden by
@rnrs{6}.

@item grep ';Cs;' <UnicodeData.txt
Print only the lines describing the surrogate characters.  They are six
lines representing the three ranges:

@table @code
@item [#xD800, #xDB7F]
Non private use high surrogate.

@item [#xDB80, #xDBFF]
Private use high surrogate.

@item [#xDC00, #xDFFF]
Low surrogate.
@end table

@noindent
Notice that these ranges are adjacent and their union is the range
@code{[#xD800, #xDFFF]}.

@item grep -v ';Cs;' <UnicodeData.txt | wc -l
Count the lines excluding the surrogate characters.  The count should be
@math{19330} (last verified with the database downloaded Wed Jun 23,
2009).

@item grep ';Ll;' <UnicodeData.txt
Extract all the lines describing the @code{Ll} category.

@item grep ', *\(First\|Last\)>' <UnicodeData.txt
Extract all the lines describing the inclusive limit of a range of
characters.

@item grep -v ', *\(First\|Last\)>' <UnicodeData.txt
Extract all the lines describing a single code point, excluding the
lines describing the limit of a range of characters.
@end table

The following Bourne shell script processes the @file{UnicodeData.txt}
database and prints a Scheme program that, when evaluated, prints the
definitions of category character sets.  The output script program makes
use of the @library{char-sets} library itself.

@smallexample
# unicode-database-extract-category-code-points.sh --
#

DATABASE=$@{1:?'missing UnicodeData.txt pathname'@}

CATEGORY_CODES=$(cut -d';' -f3 <"$DATABASE" | sort | uniq | grep -v Cs)

echo '(import (rnrs) (char-sets))'

for CATEGORY in $CATEGORY_CODES
do
    echo processing category $CATEGORY >&2
    echo -n "(define category-$CATEGORY (quote ("
    @{
        grep ";$CATEGORY;" <"$DATABASE"   | \
            grep -v ', *\(First\|Last\)>' | \
            cut -d';' -f1                 | \
            while read
        do echo -n "#\x$REPLY "
        done

        grep ";$CATEGORY;" <"$DATABASE"   | \
            grep ', *\(First\|Last\)>'    | \
            cut -d';' -f1                 | \
            while read
        do
            FIRST=$REPLY
            read
            LAST=$REPLY
            echo -n "(#\x$FIRST . #\x$LAST) "
        done
    @}
    echo ')))'
    echo "(display \"(define char-set:category/$CATEGORY\")(newline)"
    echo "(char-set-write (apply char-set category-$CATEGORY))(newline)"
    echo '(display ")")(newline)'
    echo
done

### end of file
@end smallexample

@noindent
For example, the output for the @code{Co} category, which has only
ranges, is (reformatted to look human readable):

@example
(define category-Co (quote ((#\xE000 . #\xF8FF)
                            (#\xF0000 . #\xFFFFD)
                            (#\x100000 . #\x10FFFD))))

(display "(define char-set:category/Co")
(newline)
(char-set-write (apply char-set category-Co))
(newline)
(display ")")
(newline)
@end example

@c page
@node char-sets sets basic
@subsection Basic character sets


The following character sets are defined and exported by the
@library{char-sets} library.


@defvr {Character Set} char-set:full
Contains all the characters recognised by the @rnrs{6} standard.
@end defvr


@defvr {Character Set} char-set:empty
The empty set.
@end defvr

@c page
@node char-sets sets ascii
@subsection Sets of @ascii{} characters


The following character sets are defined and exported by the
@library{char-sets} library.


@defvr {Character Set} char-set:ascii
All the characters in the @ascii{} set.  It is the set of all the
characters whose numeric code is between 0 and 127, both included.
@end defvr


@defvr {Character Set} char-set:ascii/lower-case
All the lower--case letters between @code{#\a} and @code{#\z}, included.
@end defvr


@defvr {Character Set} char-set:ascii/upper-case
All the upper--case letters between @code{#\A} and @code{#\Z}, included.
@end defvr


@defvr {Character Set} char-set:ascii/letter
All the letters: It is the union of @code{char-set:ascii/lower-case} and
@code{char-set:ascii/upper-case}.
@end defvr


@defvr {Character Set} char-set:ascii/digit
@defvrx {Character Set} char-set:ascii/dec-digit
All the decimal digits:

@example
#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
@end example
@end defvr


@defvr {Character Set} char-set:ascii/oct-digit
All the octal digits:

@example
#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7
@end example
@end defvr


@defvr {Character Set} char-set:ascii/hex-digit
All the hexadecimal digits:

@example
#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
#\a #\b #\c #\d #\e #\f
#\A #\B #\C #\D #\E #\F
@end example
@end defvr


@defvr {Character Set} char-set:ascii/letter+digit
All the letters and decimal digits: It is the union of
@code{char-set:ascii/letter} and @code{char-set:ascii/dec-digit}.
@end defvr


@defvr {Character Set} char-set:ascii/punctuation
All the punctuation characters whose numeric code is in the range
@math{[0, 127]}:

@c Yes I have verified that all of these have numeric code in the range
@c [0, 127] (Marco Maggi, Tue Jun 23, 2009).
@example
@c Keep two spaces between the characters.  Also keep an empty line
@c between them.
#\!  #\"  #\#  #\%  #\&  #\'  #\(  #\)  #\*  #\,  #\-  #\.

#\/  #\:  #\;  #\?  #\@@  #\[  #\\  #\]  #\_  #\@{  #\@}
@end example
@end defvr


@defvr {Character Set} char-set:ascii/symbol
All the symbol characters whose numeric code is in the range @math{[0,
127]}:

@c Yes I have verified that all of these have numeric code in the range
@c [0, 127] (Marco Maggi, Tue Jun 23, 2009).
@example
@c Keep two spaces between the characters.
#\$  #\+  #\<  #\=  #\>  #\^  #\`  #\|  #\~
@end example
@end defvr


@defvr {Character Set} char-set:ascii/whitespace
All the characters representing white space:

@example
#x0009  #\tab       ; HORIZONTAL TABULATION
#x000A  #\linefeed  ; LINE FEED
#x000B  #\vtab      ; VERTICAL TABULATION
#x000C  #\page      ; FORM FEED
#x000D  #\return    ; CARRIAGE RETURN
#x0020  #\space     ; SPACE
@end example
@end defvr


@defvr {Character Set} char-set:ascii/blank
A set holding @code{#\tab} and @code{#\space}.
@end defvr


@defvr {Character Set} char-set:ascii/graphic
The set of all characters that put ink on the page.  It is the union of
@code{char-set:ascii/letter+digit}, @code{char-set:ascii/punctuation}
and @code{char-set:ascii/symbol}.
@end defvr


@defvr {Character Set} char-set:ascii/printable
The set of all the printable characters.  It is the union of
@code{char-set:ascii/whitespace} and @code{char-set:ascii/graphic}.
@end defvr


@defvr {Character Set} char-set:ascii/control
All the characters whose numeric code is in the range @math{[0, 31]}
plus @math{127}.
@end defvr


@defvr {Character Set} char-set:ascii/vowels
@defvrx {Character Set} char-set:ascii/consonants
@defvrx {Character Set} char-set:ascii/vowels/lower-case
@defvrx {Character Set} char-set:ascii/consonants/lower-case
@defvrx {Character Set} char-set:ascii/vowels/upper-case
@defvrx {Character Set} char-set:ascii/consonants/upper-case
Sets of vowels and consonants.  Notice that lower case vowels are:
@code{#\a}, @code{#\e}, @code{#\i}, @code{#\o}, @code{#\u}.
@end defvr

@c page
@node char-sets sets blocks
@subsection Sets corresponding to Unicode blocks


The following character sets are defined and exported by the
@library{char-sets blocks} library.


@defvr {Character Set} char-set:block/basic-latin
@defvrx {Character Set} char-set:block/latin-1-supplement
@defvrx {Character Set} char-set:block/latin-extended-a
@defvrx {Character Set} char-set:block/latin-extended-b
@defvrx {Character Set} char-set:block/ipa-extensions
@defvrx {Character Set} char-set:block/spacing-modifier-letters
@defvrx {Character Set} char-set:block/combining-diacritical-marks
@defvrx {Character Set} char-set:block/greek-and-coptic
@defvrx {Character Set} char-set:block/cyrillic
@defvrx {Character Set} char-set:block/cyrillic-supplement
@defvrx {Character Set} char-set:block/armenian
@defvrx {Character Set} char-set:block/hebrew
@defvrx {Character Set} char-set:block/arabic
@defvrx {Character Set} char-set:block/syriac
@defvrx {Character Set} char-set:block/arabic-supplement
@defvrx {Character Set} char-set:block/thaana
@defvrx {Character Set} char-set:block/nko
@defvrx {Character Set} char-set:block/devanagari
@defvrx {Character Set} char-set:block/bengali
@defvrx {Character Set} char-set:block/gurmukhi
@defvrx {Character Set} char-set:block/gujarati
@defvrx {Character Set} char-set:block/oriya
@defvrx {Character Set} char-set:block/tamil
@defvrx {Character Set} char-set:block/telugu
@defvrx {Character Set} char-set:block/kannada
@defvrx {Character Set} char-set:block/malayalam
@defvrx {Character Set} char-set:block/sinhala
@defvrx {Character Set} char-set:block/thai
@defvrx {Character Set} char-set:block/lao
@defvrx {Character Set} char-set:block/tibetan
@defvrx {Character Set} char-set:block/myanmar
@defvrx {Character Set} char-set:block/georgian
@defvrx {Character Set} char-set:block/hangul-jamo
@defvrx {Character Set} char-set:block/ethiopic
@defvrx {Character Set} char-set:block/ethiopic-supplement
@defvrx {Character Set} char-set:block/cherokee
@defvrx {Character Set} char-set:block/unified-canadian-aboriginal-syllabics
@defvrx {Character Set} char-set:block/ogham
@defvrx {Character Set} char-set:block/runic
@defvrx {Character Set} char-set:block/tagalog
@defvrx {Character Set} char-set:block/hanunoo
@defvrx {Character Set} char-set:block/buhid
@defvrx {Character Set} char-set:block/tagbanwa
@defvrx {Character Set} char-set:block/khmer
@defvrx {Character Set} char-set:block/mongolian
@defvrx {Character Set} char-set:block/limbu
@defvrx {Character Set} char-set:block/tai-le
@defvrx {Character Set} char-set:block/new-tai-lue
@defvrx {Character Set} char-set:block/khmer-symbols
@defvrx {Character Set} char-set:block/buginese
@defvrx {Character Set} char-set:block/balinese
@defvrx {Character Set} char-set:block/sundanese
@defvrx {Character Set} char-set:block/lepcha
@defvrx {Character Set} char-set:block/ol-chiki
@defvrx {Character Set} char-set:block/phonetic-extensions
@defvrx {Character Set} char-set:block/phonetic-extensions-supplement
@defvrx {Character Set} char-set:block/combining-diacritical-marks-supplement
@defvrx {Character Set} char-set:block/latin-extended-additional
@defvrx {Character Set} char-set:block/greek-extended
@defvrx {Character Set} char-set:block/general-punctuation
@defvrx {Character Set} char-set:block/superscripts-and-subscripts
@defvrx {Character Set} char-set:block/currency-symbols
@defvrx {Character Set} char-set:block/combining-diacritical-mark-for-symbols
@defvrx {Character Set} char-set:block/letterlike-symbols
@defvrx {Character Set} char-set:block/number-forms
@defvrx {Character Set} char-set:block/arrows
@defvrx {Character Set} char-set:block/mathematical-operators
@defvrx {Character Set} char-set:block/miscellaneous-technical
@defvrx {Character Set} char-set:block/control-pictures
@defvrx {Character Set} char-set:block/optical-character-recognition
@defvrx {Character Set} char-set:block/enclosed-alphanumerics
@defvrx {Character Set} char-set:block/box-drawing
@defvrx {Character Set} char-set:block/block-elements
@defvrx {Character Set} char-set:block/geometric-shapes
@defvrx {Character Set} char-set:block/miscellaneous-symbols
@defvrx {Character Set} char-set:block/dingbats
@defvrx {Character Set} char-set:block/miscellaneous-mathematical-symbols-a
@defvrx {Character Set} char-set:block/supplemental-arrows-a
@defvrx {Character Set} char-set:block/braille-patterns
@defvrx {Character Set} char-set:block/supplemental-arrows-b
@defvrx {Character Set} char-set:block/miscellaneous-mathematical-symbols-b
@defvrx {Character Set} char-set:block/supplemental-mathematical-operators
@defvrx {Character Set} char-set:block/miscellaneous-symbols-and-arrows
@defvrx {Character Set} char-set:block/glagolitic
@defvrx {Character Set} char-set:block/latin-extended-c
@defvrx {Character Set} char-set:block/coptic
@defvrx {Character Set} char-set:block/georgian-supplement
@defvrx {Character Set} char-set:block/tifinagh
@defvrx {Character Set} char-set:block/ethiopic-extended
@defvrx {Character Set} char-set:block/cyrillic-extended-a
@defvrx {Character Set} char-set:block/supplemental-punctuation
@defvrx {Character Set} char-set:block/cjk-radicals-supplement
@defvrx {Character Set} char-set:block/kangxi-radicals
@defvrx {Character Set} char-set:block/ideographic-description-characters
@defvrx {Character Set} char-set:block/cjk-symbols-and-punctuation
@defvrx {Character Set} char-set:block/hiragana
@defvrx {Character Set} char-set:block/katakana
@defvrx {Character Set} char-set:block/bopomofo
@defvrx {Character Set} char-set:block/hangul-compatibility-jamo
@defvrx {Character Set} char-set:block/kanbun
@defvrx {Character Set} char-set:block/bopomofo-extended
@defvrx {Character Set} char-set:block/cjk-strokes
@defvrx {Character Set} char-set:block/katakana-phonetic-extensions
@defvrx {Character Set} char-set:block/enclosed-cjk-letters-and-months
@defvrx {Character Set} char-set:block/cjk-compatibility
@defvrx {Character Set} char-set:block/cjk-unified-Ideographs-extension-a
@defvrx {Character Set} char-set:block/yijing-hexagram-symbols
@defvrx {Character Set} char-set:block/cjk-unified-ideographs
@defvrx {Character Set} char-set:block/yi-syllables
@defvrx {Character Set} char-set:block/yi-radicals
@defvrx {Character Set} char-set:block/vai
@defvrx {Character Set} char-set:block/cyrillic-extended-b
@defvrx {Character Set} char-set:block/modifier-tone-letters
@defvrx {Character Set} char-set:block/latin-extended-d
@defvrx {Character Set} char-set:block/syloti-nagri
@defvrx {Character Set} char-set:block/phags-pa
@defvrx {Character Set} char-set:block/saurashtra
@defvrx {Character Set} char-set:block/kayah-li
@defvrx {Character Set} char-set:block/Rejang
@defvrx {Character Set} char-set:block/cham
@defvrx {Character Set} char-set:block/hangul-syllables
@defvrx {Character Set} char-set:block/private-use-area
@defvrx {Character Set} char-set:block/cjk-compatibility-ideographs
@defvrx {Character Set} char-set:block/alphabetic-presentation-forms
@defvrx {Character Set} char-set:block/arabic-presentation-forms-a
@defvrx {Character Set} char-set:block/variation-selectors
@defvrx {Character Set} char-set:block/vertical-forms
@defvrx {Character Set} char-set:block/combining-half-marks
@defvrx {Character Set} char-set:block/cjk-compatibility-forms
@defvrx {Character Set} char-set:block/small-form-variants
@defvrx {Character Set} char-set:block/arabic-presentation-forms-b
@defvrx {Character Set} char-set:block/halfwidth-and-fullwidth-forms
@defvrx {Character Set} char-set:block/specials
@defvrx {Character Set} char-set:block/linear-b-syllabary
@defvrx {Character Set} char-set:block/linear-b-ideograms
@defvrx {Character Set} char-set:block/aegean-numbers
@defvrx {Character Set} char-set:block/ancient-greek-numbers
@defvrx {Character Set} char-set:block/ancient-symbols
@defvrx {Character Set} char-set:block/phaistos-disc
@defvrx {Character Set} char-set:block/lycian
@defvrx {Character Set} char-set:block/carian
@defvrx {Character Set} char-set:block/old-italic
@defvrx {Character Set} char-set:block/gothic
@defvrx {Character Set} char-set:block/ugaritic
@defvrx {Character Set} char-set:block/old-persian
@defvrx {Character Set} char-set:block/deseret
@defvrx {Character Set} char-set:block/shavian
@defvrx {Character Set} char-set:block/osmanya
@defvrx {Character Set} char-set:block/cypriot-syllabary
@defvrx {Character Set} char-set:block/phoenician
@defvrx {Character Set} char-set:block/lydian
@defvrx {Character Set} char-set:block/kharoshthi
@defvrx {Character Set} char-set:block/cuneiform
@defvrx {Character Set} char-set:block/cuneiform-numbers-and-punctuation
@defvrx {Character Set} char-set:block/byzantine-musical-symbols
@defvrx {Character Set} char-set:block/musical-symbols
@defvrx {Character Set} char-set:block/ancient-greek-musical-notation
@defvrx {Character Set} char-set:block/tai-xuan-jing-symbols
@defvrx {Character Set} char-set:block/counting-rod-numerals
@defvrx {Character Set} char-set:block/mathematical-alphanumeric-symbols
@defvrx {Character Set} char-set:block/mahjong-tiles
@defvrx {Character Set} char-set:block/domino-tiles
@defvrx {Character Set} char-set:block/cjk-unified-ideographs-extension-b
@defvrx {Character Set} char-set:block/cjk-compatibility-ideographs-supplement
@defvrx {Character Set} char-set:block/tags
@defvrx {Character Set} char-set:block/variation-selectors-supplement
@defvrx {Character Set} char-set:block/supplementary-private-use-area-a
@defvrx {Character Set} char-set:block/supplementary-private-use-area-b
These are the character sets corresponding to the ranges defined in the
@file{Blocks.txt} file of the Unicode Character Database.
@end defvr

@c page
@node char-sets sets categories
@subsection Sets corresponding to Unicode general categories


The following character sets are defined and exported by the
@library{char-sets categories} library.

Notice that not all the code points accepted by @func{char=?} are part
of a general category, so the union of the category sets is different
from the full character set @code{char-set:full}.

Categories are disjoint, so the intersection of the category sets is the
empty set.


@defvr {Character Set} char-set:letter-uppercase
@defvrx {Character Set} char-set:letter-lowercase
@defvrx {Character Set} char-set:letter-titlecase
@defvrx {Character Set} char-set:letter-modifier
@defvrx {Character Set} char-set:letter-other
@defvrx {Character Set} char-set:mark-nospacing
@defvrx {Character Set} char-set:mark-spacing-combining
@defvrx {Character Set} char-set:mark-enclosing
@defvrx {Character Set} char-set:number-decimal-digit
@defvrx {Character Set} char-set:number-letter
@defvrx {Character Set} char-set:number-other
@defvrx {Character Set} char-set:puncutation-connector
@defvrx {Character Set} char-set:punctuation-dash
@defvrx {Character Set} char-set:punctuation-open
@defvrx {Character Set} char-set:punctuation-close
@defvrx {Character Set} char-set:punctuation-initial-quote
@defvrx {Character Set} char-set:punctuation-final-quote
@defvrx {Character Set} char-set:punctuation-other
@defvrx {Character Set} char-set:symbol-math
@defvrx {Character Set} char-set:symbol-currency
@defvrx {Character Set} char-set:symbol-modifier
@defvrx {Character Set} char-set:symbol-other
@defvrx {Character Set} char-set:separator-space
@defvrx {Character Set} char-set:separator-line
@defvrx {Character Set} char-set:separator-paragraph
@defvrx {Character Set} char-set:control
@defvrx {Character Set} char-set:format
@defvrx {Character Set} char-set:surrogate
@defvrx {Character Set} char-set:private-use
@defvrx {Character Set} char-set:not-assigned
One set for each general category defined by the Unicode Standard.
@end defvr

@c page
@node asciis
@chapter @ascii{} characters library


The @library{asciis} library is a small library of small functions which
deals with exact integers representing characters in @ascii{} encoding;
it is meant to be used with bytevectors representing strings.


@defun ascii-upper-case? @var{byte}
@defunx ascii-lower-case? @var{byte}
@defunx ascii-title-case?
Return true if @var{byte} represents an upper case or lower case letter
character.
@end defun


@defun ascii-cased? @var{byte}
Return true if @var{byte} represents a letter character, which can be
converted to upper or lower case.
@end defun


@defun ascii-alphabetic? @var{byte}
Return true if @var{byte} represents a letter character.
@end defun


@defun ascii-numeric? @var{byte}
Return true if @var{byte} represents a decimal digit character.
@end defun


@defun ascii-upcase @var{byte}
@defunx ascii-downcase @var{byte}
@defunx ascii-titlecase @var{byte}
Return an exact integer representing the upper case or lower case
version of @var{byte}; return @var{byte} itself if it represents an
uncased character.
@end defun

@c page
@node strings
@chapter Strings library


The @library{strings} library extends the string operations available in
the base library.  @nauref{baselib strings, Strings}.  While
@library{strings} is a high level interface, @library{strings low} is a
low level interface with the same functionalities.

@menu
* strings intro::               Introduction.
* strings convention::          Interface conventions.
* strings views::               Views over strings.
* strings cons::                Constructors.
* strings pred::                Predicates.
* strings compar::              Comparison.
* strings map::                 Mapping functions.
* strings case::                Case mapping.
* strings fold::                Fold and unfold.
* strings select::              Selection.
* strings pad::                 Padding and trimming.
* strings prefix::              Prefixes and suffixes.
* strings search::              Searching.
* strings filter::              Filtering and deleting.
* strings list::                List and string conversion.
* strings replicate::           Replicate and rotate.
* strings mutate::              Mutators.
* strings misc::                Miscellaneous functions.
@end menu

@c page
@node strings intro
@section Introduction


@subsubheading Library organisation

The functions are split in a high level library, @library{strings}, and
a low level one, @library{strings low}.  The main difference between the
two layers is that the high level library makes heavy usage of macros to
implement the @dfn{string views}, which allow accessing substrings using
a friendly syntax.

All the functions in the low level library are bound to identifiers
starting with @code{%}; for example: @func{string-prefix?} is a high
level macro, @func{%string-prefix?} is its low level function
homologous.

@subsubheading The model for strings

This library relies on the string representation of the underlying
Scheme implementation: Strings are sequences of ``code points'' or
character encodings.  Operations such as comparison or reversal are
always done code point by code point.

It's possible that a legal string might not be a sensible ``text''
sequence; for example, consider a string comprised entirely of
zero--width Unicode accent characters with no preceding base character
to modify: It is a legal string, albeit one that does not make sense
when interpreted as a sequence of natural--language text.  The routines
in @library{strings} do not handle these ``text'' concerns.

@subsubheading Direction of iteration

The library accesses the characters of a string in left--to--right or
right--to--left order depending on the convenience of the algorithm.

@subsubheading Handling side effects

Care must be taken when using functions with side effects.  One reason
for this is that some of the supported Scheme implementations will
collapse equal datum strings in the source code to the same string in
the program.  Mutating such a string in a point of the program, will
make the change visible to other points in the program.  For example:

@example
(import (rnrs)
  (rnrs mutable-strings))

(define str1 "abcd")
(define str2 "abcd")

(string-set! str1 2 #\9)
(write str2)
@end example

@noindent
when executed by Ypsilon and Larceny will print @code{"ab9d"}, while
when executed by Ikarus and Mosh will print @code{"abcd"} (last verified
with revisions checked out on Fri Jun 5, 2009).  To avoid this problem
completely, we can change the program in this way:

@example
(import (rnrs)
  (rnrs mutable-strings))

(define str1 (string-copy "abcd"))
(define str2 (string-copy "abcd"))

(string-set! str1 2 #\9)
(write str2)
@end example

@noindent
of course we may want to wrap into @func{string-copy} only the strings
that are meant to be mutated.

@c page
@node strings convention
@section Interface conventions


The following conventions hold:

@itemize
@item
Procedures whose names end in @code{-ci} are case--insensitive variants.

@item
Procedures whose names end in @code{!} are side--effecting variants.
What values these procedures return is usually not specified.

@item
The order of common arguments is consistent across the different
procedures in the high level library, and consistent across the
different procedures in the low level library.  Arguments to some
functions in the high level library have different order from the ones
of the homologous low level functions.

@item
Procedures that have left/right directional variants use the following
convention:

@multitable {right--to--left} {Suffix}
@headitem Direction @tab Suffix
@item left-to-right @tab @meta{none}
@item right-to-left @tab --right
@item both @tab --both
@end multitable
@end itemize

In the procedure specifications:

@itemize
@item
An @var{S} argument is a string view, which is expanded by a macro in a
triplet of values: the string, the index of the first char in the
selected substring, the index of the character past the last in the
selected position.  @ref{strings views} for details.

@item
A @var{str} argument is a string.

@item
A @var{char} argument is a character.

@item
The @var{start} and @var{past} arguments are half--open string indices
specifying a substring within a string argument; when unspecified, they
default to zero and the length of the string, respectively.  When
specified, it must be the case that:

@example
0 <= start <= past <= (string-length s)
@end example

@noindent
for the corresponding argument @var{str}.  They typically restrict a
procedure's action to the indicated substring; when @var{start} equals
@var{past} the selected substring is the empty string.

@item
A @var{pred} argument is a unary character predicate procedure,
returning a true/false value when applied to a character.

@item
A @var{char}/@var{char-set}/@var{pred} argument is a value used to
select/search for a character in a string.  If it is a character, it is
used in an equality test; if it is a character set, it is used in a
membership test; if it is a procedure, it is applied to the characters
as a test predicate.

@item
An @var{i} or @var{k} argument is an exact non--negative integer
specifying an index into a string.

@item
The @var{len} and @var{nchars} arguments are exact non--negative
integers specifying a length of a string or some number of characters.

@item
An @var{obj} argument can be any value.
@end itemize

An argument followed by @code{...} means zero--or--more elements.  So
the procedure with the signature:

@example
sum-squares x ...
@end example

@noindent
takes zero or more arguments (@var{x}, @dots{}), while the procedure
with signature:

@example
spell-check doc dict1 dict2 ...
@end example

@noindent
takes two mandatory arguments (@var{doc} and @var{dict1}) and zero or
more optional arguments (@var{dict2} ...).

If a procedure is said to return ``unspecified'', this means that
nothing at all is known about what the procedure returns.  Such a
procedure is not even required to be consistent from call to call.  It
is simply required to return a value (or values) that may be passed to a
command continuation, e.g. as the value of an expression appearing as a
non--terminal subform of a begin expression.

Comparison is simply done on individual code--points of the string.
Unless explicitly stated, for all the functions: Case--insensitive
comparison is done using the functions:

@example
char-ci=? char-ci<? char-ci>? char-ci<=? char-ci>=?
@end example

@noindent
provided by the underlying implementation, or by case--folding
characters with the operation:

@example
(char-downcase (char-upcase c))
@end example

@noindent
where the two case--mapping operations are assumed to be one--to--one,
locale--insensitive and context--insensitive, and compatible with the
one--to--one case mappings specified by Unicode's @file{UnicodeData.txt}
table:

@center @url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt}

@c page
@node strings views
@section Views over strings


String views are syntactic sugar to allow substring specification with
minimum overhead; views make use of auxiliary syntaxes exported by the
@library{auxiliary-syntaxes} library and reexported by the
@library{strings} library.  Many low level string functions act on
substrings specified with triplets of arguments:

@itemize
@item
The full string.

@item
The @dfn{start index}: The index of the first code point included in the
selected substring.

@item
The @dfn{past index}: The index of the code point past the last code
point included in the selected substring.
@end itemize

To select the substring @code{"hello"} from the string @code{"ciao,
hello, salut"} we have to determine the half--open range of code points,
which is @math{[6, 11)}, then apply a function to the arguments:

@example
(%the-function "ciao, hello, salut" 6 11)

;;              0123456789012345678
;;              0         1
@end example

@noindent
while to select the whole string we can do:

@example
(%the-function "ciao, hello, salut" 0 18)
@end example

@noindent
or:

@example
(let ((str "ciao, hello, salut"))
  (%the-function str 0 (string-length str)))
@end example

With the string views implemented by @library{strings}, the low level
function is wrapped by a high level syntax which can be invoked as:

@example
(the-function "ciao, hello, salut")
        ; select the whole string

(the-function (view "ciao, hello, salut"))
        ; select the whole string

(the-function (view "ciao, hello, salut"
                (start 6)))
        ; select the substring [6, 18)

(the-function (view "ciao, hello, salut"
                (start 6)
                (past 11)))
        ; select the substring [6, 11)

(the-function (view "ciao, hello, salut"
                (past 11)))
        ; select the substring [0, 11)
@end example

@noindent
instead of a triplet of arguments, the string view is a single argument
that can be:

@table @code
@item @meta{string}
@itemx (view @meta{string})
The string itself or an unquoted list holding the string itself,
prefixed by the @code{view} auxiliary syntax: It selects the whole
string.

@item (view @meta{string} (start @meta{start-index}))
An unquoted list holding the string and the start index, with auxiliary
syntaxes @code{view} and @code{start}: It selects the substring from the
start index to the end.

@item (view @meta{string} (past @meta{past-index}))
An unquoted list holding the string and the past index, with auxiliary
syntaxes @code{view} and @code{past}: It selects the substring from zero
to the selected past index.

@itemx (view @meta{string} (start @meta{start-index}) (past @meta{past-index}))
An unquoted list holding the string, the start index and the past index,
with auxiliary syntaxes @code{view}, @code{start} and @code{past}: It
selects the substring between the start and past indexes.
@end table

@noindent
@code{@meta{string}}, @code{@meta{start-index}} and
@code{@meta{past-index}} can be arbitrary Scheme expressions.  High
level macros accepting two or more substrings as arguments, support
string views for all of them.  When we are concerned with the overhead
of string views, we can use the low level functions directly.

In the following documentation: Low level functions and high level
macros are documented together; only the meaning of arguments to the low
level function are described, the meaning of high level arguments is
obvious.

@c page
@node strings cons
@section Constructors


@defun string-concatenate @var{string-list}
Append the elements of @var{string-list} together into a single string.
Guaranteed to return a freshly allocated string.
@end defun


@deffn Function %string-concatenate-reverse @var{string-list} @var{final-string} @var{nchars}
@deffnx Macro string-concatenate-reverse @var{string-list}
@deffnx Macro string-concatenate-reverse @var{string-list} @var{final-string}
@deffnx Macro string-concatenate-reverse @var{string-list} @var{final-string} @var{nchars}
Reverse @var{string-list} then concatenate the elements, which must be
strings.  The first @var{nchars} code points in @var{final-string} are
consed onto the beginning of @var{string-list} before performing the
reversal and concatenation operations.

@var{final-string} defaults to the empty string and @var{nchars}
defaults to the length of @var{final-string}.

This procedure is useful in the construction of procedures that
accumulate character data into lists of string buffers, and wish to
convert the accumulated data into a single string when done.
@end deffn


@defun string-tabulate @var{integer->char} @var{len}
Construct a string of size @var{len} by applying @var{integer->char} to
each index in the range @math{[0, @var{len})} to produce the
corresponding string element.  The order in which @var{integer->char} is
applied to the indices is not specified.
@end defun

@c page
@node strings pred
@section Predicates


@defun string-null? @var{obj}
Return @true{} if @var{obj} is the empty string, otherwise return
@false{}.
@end defun


@deffn Function %string-every @var{char/char-set/pred} @var{str} @var{start} @var{past}
@deffnx Function %string-any @var{char/char-set/pred} @var{str} @var{start} @var{past}
@deffnx Macro string-every @var{char/char-set/pred} @var{S}
@deffnx Macro string-any @var{char/char-set/pred} @var{S}
Check to see if the given criteria is true on every/any character in
@var{str}, proceeding from left (index @var{start}) to right (index
@var{past}).

If the selected substring is empty, the return value is @false{}.

If @var{char/char-set/pred} is a character, it is tested for equality
with the elements of @var{S}.

If @var{char/char-set/pred} is a character set, the elements of @var{S}
are tested for membership in the set.

If @var{char/char-set/pred} is a predicate procedure, it is applied to
the elements of @var{S}.  The predicate is ``witness--generating'':

@itemize
@item
If @func{string-any} returns true, the returned true value is the one
produced by the application of the predicate.

@item
If @func{string-every} returns true, the returned true value is the one
produced by the application of the predicate to the last code point in
the substring.
@end itemize

If the predicate is applied to the final element of the selected
substring, that final application is a tail call.

The names of these procedures do not end with a question mark; this is
to indicate that, in the predicate case, they do not return a simple
boolean (@true{} or @false{}), but a general value.
@end deffn

@c page
@node strings compar
@section Comparison


@menu
* strings compar lexi::         Lexicographic comparison.
* strings compar dict::         String dictionary comparison.
* strings compar number::       String and numeric parts lexicographic
                                comparison.
* strings compar dictnumber::   String and numeric parts dictionary
                                comparison.
@end menu

@c page
@node strings compar lexi
@subsection Lexicographic comparison


@deffn Function %string-compare @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past} @var{proc<} @var{proc=} @var{proc>}
@deffnx Function %string-compare-ci @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past} @var{proc<} @var{proc=} @var{proc>}
@deffnx Macro string-compare @var{S1} @var{S2} @var{proc<} @var{proc=} @var{proc>}
@deffnx Macro string-compare-ci @var{S1} @var{S2} @var{proc<} @var{proc=} @var{proc>}
Determine the @dfn{mismatch index} between the two substrings: the
largest index @math{i} such that for every @math{0 <= j < i},
@math{str1[j] = str2[j]}; that is, @math{i} is the first position that
does not match.

The mismatch index is always an index into @vari{str}; in the case of
equal strings, it is always @vari{past}; the functions observe the
protocol in this redundant case for uniformity.

The characters at the mismatch index are compared using @func{char<?}
or @func{char-ci<?}.  @var{proc<}, @var{proc=}, or @var{proc>} are
applied to the mismatch index (not character), depending upon whether
the substring of @vari{str} is less than, equal to, or greater than the
substring of @varii{str}.  The result of the application is returned.

If we just want to have the mismatch index as return value: We can use
@func{values} as value for @var{proc<}, @var{proc=} and @var{proc>}.
Another interesting option is to use @code{(lambda (mismatch-index) #f)}
or @code{(lambda (mismatch-index) #t)}.

Examples:

@example
(string-compare "abcd" "abcd" values values values)
@result{} 4

(string-compare "abcd" "abcd12" values values values)
@result{} 4
@end example
@end deffn


@deffn Function %string= @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past}
@deffnx Function %string-ci= @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past}
@deffnx Macro string= @var{S1} @var{S2}
@deffnx Macro string-ci= @var{S1} @var{S2}
Compare two substrings: Return true if they are equal according to
@func{char=?} or @func{char-ci=?}, @false{} otherwise.
@end deffn


@deffn Function %string<> @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past}
@deffnx Function %string-ci<> @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past}
@deffnx Macro string<> @var{S1} @var{S1}
@deffnx Macro string-ci<> @var{S1} @var{S2}
Compare two substrings: Return @false{} if they are equal according to
@func{char=?} or @func{char-ci=?}, true otherwise.
@end deffn


The following predicates are the lexicographic extensions of the
corresponding character predicates.  A string @vari{str} is
``lexicographically'' less than @varii{str} if @vari{str} would come
first in a dictionary.


@deffn Function %string< @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past}
@deffnx Function %string-ci< @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past}
@deffnx Macro string< @var{S1} @var{S2}
@deffnx Macro string-ci< @var{S1} @var{S2}
Compare two substrings: Return true if the first is lexicographically
less than the second, @false{} otherwise.  If @varii{str} is longer than
@vari{str} but the substrings are equal up to the end of @vari{str}:
Return @true{}.

@example
(string< "abcd" "abcd") @result{} #f
(string< "abc"  "abcd") @result{} #t
(string< "abcd" "abc") @result{} #f
(string< "ABcd" "abcd") @result{} #t
(string< "abcd" "a2cd") @result{} #f

(string-ci< "abcd" "abcd") @result{} #f
(string-ci< "abc"  "abcd") @result{} #t
(string-ci< "abcd" "abc") @result{} #f
(string-ci< "ABcd" "abcd") @result{} #f
(string-ci< "abcd" "a2cd") @result{} #f
@end example
@end deffn


@deffn Function %string<= @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past}
@deffnx Function %string-ci<= @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past}
@deffnx Macro string<= @var{S1} @var{S2}
@deffnx Macro string-ci<= @var{S1} @var{S2}
Compare two substrings: Return true if the first is lexicographically
less than, or equal to, the second; @false{} otherwise.  If @varii{str}
is longer than @vari{str} but the substrings are equal up to the end of
@vari{str}: Return @true{}.

@example
(string<= "abcd" "abcd") @result{} #t
(string<= "abc"  "abcd") @result{} #t
(string<= "abcd" "abc") @result{} #f
(string<= "ABcd" "abcd") @result{} #t
(string<= "abcd" "a2cd") @result{} #f

(string-ci<= "abcd" "abcd") @result{} #t
(string-ci<= "abc"  "abcd") @result{} #t
(string-ci<= "abcd" "abc") @result{} #f
(string-ci<= "ABcd" "abcd") @result{} #t
(string-ci<= "abcd" "a2cd") @result{} #f
@end example
@end deffn


@deffn Function %string> @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past}
@deffnx Function %string-ci> @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past}
@deffnx Macro string> @var{S1} @var{S2}
@deffnx Macro string-ci> @var{S1} @var{S2}
Compare two substrings: Return true if the first is lexicographically
greater than the second, @false{} otherwise.  If @vari{str} is longer
than @varii{str} but the substrings are equal up to the end of
@varii{str}: Return @true{}.

@example
(string> "abcd" "abcd") @result{} #f
(string> "abcd" "abc") @result{} #t
(string> "abc"  "abcd") @result{} #f
(string> "abcd" "ABcd") @result{} #t
(string> "a2cd" "abcd") @result{} #f

(string-ci> "abcd" "abcd") @result{} #f
(string-ci> "abcd" "abc") @result{} #t
(string-ci> "abc"  "abcd") @result{} #f
(string-ci> "abcd" "ABcd") @result{} #f
(string-ci> "a2cd" "abcd") @result{} #f
@end example
@end deffn


@deffn Function %string>= @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past}
@deffnx Function %string-ci>= @vari{str} @vari{beg} @vari{past} @varii{str} @varii{beg} @varii{past}
@deffnx Macro string>= @var{S1} @var{S2}
@deffnx Macro string-ci>= @var{S1} @var{S2}
Compare two substrings: Return true if the first is lexicographically
greater than, or equal to, the second; @false{} otherwise.  If
@vari{str} is longer than @varii{str} but the substrings are equal up to
the end of @varii{str}: Return @true{}.

@example
(string>= "abcd" "abcd") @result{} #t
(string>= "abcd" "abc") @result{} #t
(string>= "abc" "abcd") @result{} #f
(string>= "abcd" "ABcd") @result{} #t
(string>= "a2cd" "abcd") @result{} #f

(string-ci>= "abcd" "abcd") @result{} #t
(string-ci>= "abcd" "abc") @result{} #t
(string-ci>= "abc"  "abcd") @result{} #f
(string-ci>= "abcd" "ABcd") @result{} #t
(string-ci>= "a2cd" "abcd") @result{} #f
@end example
@end deffn

@c page
@node strings compar dict
@subsection String dictionary comparison


Dictionary comparison is like lexicographic string comparison, but white
space characters in the string arguments are ignored; for example, the
string @samp{foo 4bar\t3za\nb10} is equivalent to @samp{foo4bar3zab10}.
Recognised white spaces are:

@example
#\space         #\tab           #\vtab
#\linefeed      #\return        #\page
@end example


@defun string-dictionary-compare @vari{str} @varii{str}
@defunx %string-dictionary-compare @vari{str} @varii{str}
Compare the string arguments and return a ternary result: @samp{-1} if
@vari{str} is less than @varii{str}, @samp{0} if @vari{str} is equal to
@varii{str}, @samp{+1} if @vari{str} is greater than @varii{str}.  The
comparison is case sensitive.
@end defun


@defun string-dictionary=? @vari{str} @varii{str}
@defunx string-dictionary<>? @vari{str} @varii{str}
@defunx string-dictionary<? @vari{str} @varii{str}
@defunx string-dictionary<=? @vari{str} @varii{str}
@defunx string-dictionary>? @vari{str} @varii{str}
@defunx string-dictionary>=? @vari{str} @varii{str}
@defunx %string-dictionary=? @vari{str} @varii{str}
@defunx %string-dictionary<>? @vari{str} @varii{str}
@defunx %string-dictionary<? @vari{str} @varii{str}
@defunx %string-dictionary<=? @vari{str} @varii{str}
@defunx %string-dictionary>? @vari{str} @varii{str}
@defunx %string-dictionary>=? @vari{str} @varii{str}
Return @true{} or @false{}, whether the string-dictionary arguments comply with the
predicate.
@end defun


@defun string-dictionary-compare-ci @vari{str} @varii{str}
@defunx %string-dictionary-compare-ci @vari{str} @varii{str}
Compare the string arguments and return a ternary result: @samp{-1} if
@vari{str} is less than @varii{str}, @samp{0} if @vari{str} is equal to
@varii{str}, @samp{+1} if @vari{str} is greater than @varii{str}.  The
comparison is case insensitive.
@end defun


@defun string-dictionary-ci=? @vari{str} @varii{str}
@defunx string-dictionary-ci<>? @vari{str} @varii{str}
@defunx string-dictionary-ci<? @vari{str} @varii{str}
@defunx string-dictionary-ci>? @vari{str} @varii{str}
@defunx string-dictionary-ci<=? @vari{str} @varii{str}
@defunx string-dictionary-ci>=? @vari{str} @varii{str}
@defunx %string-dictionary-ci=? @vari{str} @varii{str}
@defunx %string-dictionary-ci<>? @vari{str} @varii{str}
@defunx %string-dictionary-ci<? @vari{str} @varii{str}
@defunx %string-dictionary-ci>? @vari{str} @varii{str}
@defunx %string-dictionary-ci<=? @vari{str} @varii{str}
@defunx %string-dictionary-ci>=? @vari{str} @varii{str}
Return @true{} or @false{}, whether the string arguments comply with the
predicate.  The comparison is case insensitive.
@end defun

@c page
@node strings compar number
@subsection String and numeric parts lexicographic comparison


String/numbers comparison splits the strings to compare into their
numeric and non--numeric parts and compares the parts one by one; for
example, the string @samp{foo4bar3zab10} is split into the following
list:

@example
("foo" 4 "bar" 3 "zab" 10)
@end example

@noindent
in which non--numeric parts are retained as Scheme strings and numeric
parts become exact integers; numeric parts only become @strong{exact}
integer, never flonums.  String parts are compared with the ordinary
lexicographic operators @func{string<?} and @func{string=?} (or
@func{string-ci<?} and @func{string-ci=?}), while numeric parts are
compared with the ordinary @func{<} and @func{=} operators; a string
part and a numeric part are compared by converting the number into a
string, then using @func{string<?} and @func{string=?}.

Miscellaneous examples:

@example
(string/numbers<? "123" "45")
@result{} #f

(string/numbers<? "ciao3" "ciao10")
@result{} #t

(string/numbers<? "foo4bar3zab10" "foo4bar3zab2")
@result{} #f

(string/numbers<? "foo4bar10" "foo4bar3zab")
@result{} #f
@end example



@defun string/numbers-compare @vari{str} @varii{str}
@defunx %string/numbers-compare @vari{str} @varii{str}
Compare the string and numeric parts of the arguments and return a
ternary result: @samp{-1} if @vari{str} is less than @varii{str},
@samp{0} if @vari{str} is equal to @varii{str}, @samp{+1} if @vari{str}
is greater than @varii{str}.  The comparison is case sensitive.
@end defun


@defun string/numbers=? @vari{str} @varii{str}
@defunx string/numbers<>? @vari{str} @varii{str}
@defunx string/numbers<? @vari{str} @varii{str}
@defunx string/numbers<=? @vari{str} @varii{str}
@defunx string/numbers>? @vari{str} @varii{str}
@defunx string/numbers>=? @vari{str} @varii{str}
@defunx %string/numbers=? @vari{str} @varii{str}
@defunx %string/numbers<>? @vari{str} @varii{str}
@defunx %string/numbers<? @vari{str} @varii{str}
@defunx %string/numbers<=? @vari{str} @varii{str}
@defunx %string/numbers>? @vari{str} @varii{str}
@defunx %string/numbers>=? @vari{str} @varii{str}
Return @true{} or @false{}, whether the string arguments comply with the
predicate.
@end defun


@defun string/numbers-compare-ci @vari{str} @varii{str}
@defunx %string/numbers-compare-ci @vari{str} @varii{str}
Compare the string and numeric parts of the arguments and return a
ternary result: @samp{-1} if @vari{str} is less than @varii{str},
@samp{0} if @vari{str} is equal to @varii{str}, @samp{+1} if @vari{str}
is greater than @varii{str}.  The comparison is case insensitive.
@end defun


@defun string/numbers-ci=? @vari{str} @varii{str}
@defunx string/numbers-ci<>? @vari{str} @varii{str}
@defunx string/numbers-ci<? @vari{str} @varii{str}
@defunx string/numbers-ci>? @vari{str} @varii{str}
@defunx string/numbers-ci<=? @vari{str} @varii{str}
@defunx string/numbers-ci>=? @vari{str} @varii{str}
@defunx %string/numbers-ci=? @vari{str} @varii{str}
@defunx %string/numbers-ci<>? @vari{str} @varii{str}
@defunx %string/numbers-ci<? @vari{str} @varii{str}
@defunx %string/numbers-ci>? @vari{str} @varii{str}
@defunx %string/numbers-ci<=? @vari{str} @varii{str}
@defunx %string/numbers-ci>=? @vari{str} @varii{str}
Return @true{} or @false{}, whether the string arguments comply with the
predicate.  The comparison is case insensitive.
@end defun

@c page
@node strings compar dictnumber
@subsection String and numeric parts dictionary comparison


String/numbers dictionary comparison is like string/numbers comparison,
but white space characters in the string arguments are ignored; for
example, the string @samp{foo 4bar\t3za\nb10} is split into the
following list:

@example
("foo" 4 "bar" 3 "zab" 10)
@end example

@noindent
in which non--numeric parts are retained as Scheme strings, numeric
parts become exact integers and white spaces are dropped.  Recognised
white spaces are:

@example
#\space         #\tab           #\vtab
#\linefeed      #\return        #\page
@end example


@defun string/numbers-dictionary-compare @vari{str} @varii{str}
@defunx %string/numbers-dictionary-compare @vari{str} @varii{str}
Compare the string and numeric parts of the arguments and return a
ternary result: @samp{-1} if @vari{str} is less than @varii{str},
@samp{0} if @vari{str} is equal to @varii{str}, @samp{+1} if @vari{str}
is greater than @varii{str}.  The comparison is case sensitive.
@end defun


@defun string/numbers-dictionary=? @vari{str} @varii{str}
@defunx string/numbers-dictionary<>? @vari{str} @varii{str}
@defunx string/numbers-dictionary<? @vari{str} @varii{str}
@defunx string/numbers-dictionary<=? @vari{str} @varii{str}
@defunx string/numbers-dictionary>? @vari{str} @varii{str}
@defunx string/numbers-dictionary>=? @vari{str} @varii{str}
@defunx %string/numbers-dictionary=? @vari{str} @varii{str}
@defunx %string/numbers-dictionary<>? @vari{str} @varii{str}
@defunx %string/numbers-dictionary<? @vari{str} @varii{str}
@defunx %string/numbers-dictionary<=? @vari{str} @varii{str}
@defunx %string/numbers-dictionary>? @vari{str} @varii{str}
@defunx %string/numbers-dictionary>=? @vari{str} @varii{str}
Return @true{} or @false{}, whether the string arguments comply with the
predicate.
@end defun


@defun string/numbers-dictionary-compare-ci @vari{str} @varii{str}
@defunx %string/numbers-dictionary-compare-ci @vari{str} @varii{str}
Compare the string and numeric parts of the arguments and return a
ternary result: @samp{-1} if @vari{str} is less than @varii{str},
@samp{0} if @vari{str} is equal to @varii{str}, @samp{+1} if @vari{str}
is greater than @varii{str}.  The comparison is case insensitive.
@end defun


@defun string/numbers-dictionary-ci=? @vari{str} @varii{str}
@defunx string/numbers-dictionary-ci<>? @vari{str} @varii{str}
@defunx string/numbers-dictionary-ci<? @vari{str} @varii{str}
@defunx string/numbers-dictionary-ci>? @vari{str} @varii{str}
@defunx string/numbers-dictionary-ci<=? @vari{str} @varii{str}
@defunx string/numbers-dictionary-ci>=? @vari{str} @varii{str}
@defunx %string/numbers-dictionary-ci=? @vari{str} @varii{str}
@defunx %string/numbers-dictionary-ci<>? @vari{str} @varii{str}
@defunx %string/numbers-dictionary-ci<? @vari{str} @varii{str}
@defunx %string/numbers-dictionary-ci>? @vari{str} @varii{str}
@defunx %string/numbers-dictionary-ci<=? @vari{str} @varii{str}
@defunx %string/numbers-dictionary-ci>=? @vari{str} @varii{str}
Return @true{} or @false{}, whether the string arguments comply with the
predicate.  The comparison is case insensitive.
@end defun

@c page
@node strings map
@section Mapping functions


@defun string-map @var{proc} @var{str0} @var{str} ...
Build and return a newly allocated string mapping @var{proc} over all
the characters of the string arguments, from zero to the end in
increasing order.  It is an error if the strings have different length.

@var{proc} must return a character and it is applied to the elements as:

@example
(@var{proc} @var{idx}
  (string-ref @var{str0} @var{idx})
  (string-ref @var{str}  @var{idx})
  ...)
@end example

@noindent
where @var{idx} is the current index.
@end defun


@defun string-map! @var{proc} @var{str0} @var{str} ...
@defunx string-map*! @var{proc} @var{str0} @var{str} ...
Mutate string @var{str0} mapping @var{proc} over all the elements of the
string arguments, from zero to the end in increasing order.

@func{string-map!} must be applied to strings of the same length;
@func{string-map*!} accepts strings of different length and iterates
until the end of the shorter is reached.

@var{proc} is applied to the elements as:

@example
(@var{proc} @var{idx}
  (string-ref @var{str0} @var{idx})
  (string-ref @var{str}  @var{idx})
  ...)
@end example

@noindent
where @var{idx} is the current index.
@end defun


@defun string-for-each* @var{proc} @var{str0} @var{str} ...
Apply @var{proc} over all the elements of the string arguments, from
zero to the end in increasing order.  This function accepts strings of
different length and iterates until the end of the shorter is reached.

@var{proc} is applied to the elements as:

@example
(@var{proc} @var{idx}
  (string-ref @var{str0} @var{idx})
  (string-ref @var{str}  @var{idx})
  ...)
@end example

@noindent
where @var{idx} is the current index.
@end defun


@subsubheading Mapping over substrings


@deffn Function %substring-map @var{proc} @var{str} @var{start} @var{past}
@deffnx Macro substring-map @var{proc} @var{S}
Build and return a new string mapping @var{proc} over the characters in
the selected substring of @var{str}, from index @var{start} to index
@var{past} in increasing order.  @var{proc} must be a @code{char->char}
procedure.
@end deffn


@deffn Function %substring-map! @var{proc} @var{str} @var{start} @var{past}
@deffnx Macro substring-map! @var{proc} @var{S}
Mutate the selected substring of @var{str}, mapping @var{proc} over its
characters from index @var{start} to index @var{past} in increasing
order.  @var{proc} must be a @code{char->char} procedure.
@end deffn


@deffn Function %substring-for-each @var{proc} @var{str} @var{start} @var{past}
@deffnx Macro substring-for-each @var{proc} @var{S}
Apply @var{proc} to each character in the selected substring of
@var{str}, from index @var{start} to index @var{past} in increasing
order.
@end deffn


@deffn Function %substring-for-each-index @var{proc} @var{str} @var{start} @var{past}
@deffnx Macro substring-for-each-index @var{proc} @var{S}
Apply @var{proc} to each index in the selected substring of @var{str},
from index @var{start} to index @var{past} in increasing order.  This is
simply a method of looping over a string that is guaranteed to be safe
and correct.
@end deffn

@c page
@node strings case
@section Case mapping


@deffn Function %string-titlecase*! @var{str} @var{start} @var{past}
@deffnx Macro string-titlecase* @var{s}
@deffnx Macro string-titlecase*! @var{s}
For every character @math{c} in the selected range of @var{str}, if
@math{c} is preceded by a cased character, it is downcased; otherwise it
is titlecased.

@func{string-titlecase*} returns the result string and does not alter
its s argument.  @func{string-titlecase!} is the in--place
side--effecting variant.

Examples:

@example
(string-titlecase* "--capitalize tHIS sentence.")
@result{} "--Capitalize This Sentence."

(string-titlecase* "see Spot run. see Nix run.")
@result{} "See Spot Run. See Nix Run."

(string-titlecase* "3com makes routers.")
@result{} "3Com Makes Routers."
@end example

Note that the character preceding @code{str[start]} has no effect on the
titlecase decision for character @code{str[start]}:

@example
(string-titlecase* ("greasy fried chicken" 2))
@result{} "Easy Fried Chicken"
@end example
@end deffn


@deffn Macro string-upcase* @var{s}
@deffnx Macro string-upcase*! @var{s}
@deffnx Macro string-downcase* @var{s}
@deffnx Macro string-downcase*! @var{s}
Raise or lower the case of the alphabetic characters in the string.
There are no low level functions for these macros because they are just
wrappers for @func{%string-map} and @func{%string-map!}.

@func{string-upcase} and @func{string-downcase} return the result string
and do not alter their argument.  @func{string-upcase!} and
@func{string-downcase!} are the in--place side--effecting variants.
@end deffn

@c page
@node strings fold
@section Fold and unfold


@defun string-fold-left @var{kons} @var{knil} @var{str0} @var{str} ...
@defunx string-fold-right @var{kons} @var{knil} @var{str0} @var{str} ...
The fundamental string iterator.  The string arguments must have the
same length.

@var{kons} is iterated left--to--right over each index in all of the
strings, stopping at the end of the shortest; @var{kons} is applied as:

@example
(@var{kons} @var{idx} @var{state}
  (string-ref @var{str0} @var{idx})
  (string-ref @var{str}  @var{idx})
  )
@end example

@noindent
where @var{state} is the current state value; the current state value
begins with @var{knil}, and becomes whatever @var{kons} returned at the
respective iteration; @var{idx} is the current index.

@func{string-fold-right} is similar to @func{string-fold}, but it
iterates right--to--left.

@quotation
Notice that to allow for an unspecified number of arguments, these folds
hand the state as first argument to @var{kons}, as opposed to the usual
fold arguments.
@end quotation
@end defun


@defun string-fold-left* @var{kons} @var{knil} @var{str0} @var{str} ...
@defunx string-fold-right* @var{kons} @var{knil} @var{str0} @var{str} ...
Like @func{string-fold} and @func{string-unfold} but accept strings of
different length, iterating until the end of the shortest one.
@end defun

@c ------------------------------------------------------------

@deffn Function %substring-fold-left @var{kons} @var{knil} @var{str} @var{start} @var{past}
@deffnx Function %substring-fold-right @var{kons} @var{knil} @var{str} @var{start} @var{past}
@deffnx Macro string-fold @var{kons} @var{knil} @var{S}
@deffnx Macro string-fold-right @var{kons} @var{knil} @var{S}
Fundamental iterators for substrings.  @var{kons} is iterated over each
character of the selected substring:

@example
(@var{kons}
  (string-ref @var{str} (+ @var{start} @var{idx}))
  @var{state})
@end example

@noindent
where @var{state} is the current state value; the current state value
begins with @var{knil}, and becomes whatever @var{kons} returned at the
respective iteration; @var{idx} is the current index.

The left--fold iterator, @func{%substring-fold-left}, builds the return
value as:

@example
(@var{kons}
  (string-ref @var{str} (- @var{past} 1))
  (@var{kons}
    (string-ref @var{str} (- @var{past} 2))
    ...
      (@var{kons}
        (string-ref @var{str} (+ @var{start} 2))
        (@var{kons}
           (string-ref @var{str} (+ @var{start} 1))
           (@var{kons}
              (string-ref @var{str} @var{start})
              @var{knil})))))
@end example

The right--fold iterator, @func{%substring-fold-right}, builds the
return value as:

@example
(@var{kons}
  (string-ref @var{str} @var{start}
  (@var{kons}
    (string-ref @var{str} (+ @var{start} 1))
    ...
      (@var{kons}
        (string-ref @var{str} (- @var{past} 3))
        (@var{kons}
           (string-ref @var{str} (- @var{past} 2))
           (@var{kons}
              (string-ref @var{str} (- @var{past} 1))
              @var{knil})))))
@end example

Examples:

@example
;; Convert a string to a list of chars.
(substring-fold-left cons '() "abcd")
@result{} (#\d #\c #\b #\a))

;; Count the number of upper-case characters in a string.
(substring-fold-left (lambda (c count)
                       (if (char-upper-case? c)
                           (+ count 1)
                         count))
                     0
                     "ABCdefGHi")
@result{} 5

;; Double every backslash character in S.
(let* ((str "abc\\de\\f\\ghi")
       (ans-len (string-fold
                 (lambda (c sum)
                   (+ sum (if (char=? c #\\) 2 1)))
                 0 str))
       (ans (make-string ans-len)))
  (substring-fold-left
   (lambda (c i)
     (let ((i (if (char=? c #\\)
                  (begin
                    (string-set! ans i #\\)
                    (+ i 1))
                i)))
        (string-set! ans i c)
        (+ i 1)))
    0 str)
   ans)
@result{} "abc\\\\de\\\\f\\\\ghi"
@end example
@end deffn

@c ------------------------------------------------------------

@defun string-unfold @var{stop?} @var{seed->char} @var{make-seed} @var{first-seed}
@defunx string-unfold @var{stop?} @var{seed->char} @var{make-seed} @var{first-seed} @var{base-string}
@defunx string-unfold @var{stop?} @var{seed->char} @var{make-seed} @var{first-seed} @var{base-string} @var{make-final}
This is a fundamental constructor for strings.  Arguments description
follows.

@table @var
@item make-seed
A map function used to generate a series of ``seed'' values from the
initial seed:

@example
@var{first-seed}
(@var{make-seed} @var{first-seed})            @result{} seed2
(@var{make-seed} seed2)                 @result{} seed3
(@var{make-seed} seed3)                 @result{} seed4
...
@end example

@item stop?
A predicate function telling when to stop generating characters; when it
returns true when applied to one of the seed values.

@item seed->char
Map function mapping each seed value to the corresponding character in
the result string.  These chars are assembled into the string in a
left--to--right order.

@item base-string
An optional string which is used as initial/leftmost portion of the
constructed string.  Defaults to the empty string.

@item make-final
Optional function applied to the terminal seed value (on which
@var{stop?}  returns true) to produce the final/rightmost portion of the
constructed string.  Defaults to @code{(lambda (x) "")}.
@end table

More precisely, the following (simple, inefficient) definitions hold:

@example
;; iterative
(define (string-unfold stop? seed->char make-seed
                       first-seed base-string make-final)
  (let loop ((seed    first-seed)
             (result  base-string))
    (if (stop? seed)
        (string-append result (make-final seed))
      (loop (make-seed seed)
            (string-append result
                           (string (seed->char seed)))))))

;; recursive
(define (string-unfold stop? seed->char make-seed
                       first-seed base-string make-final)
  (string-append
     base-string
     (let loop ((seed first-seed))
       (if (stop? seed)
           (make-final seed)
         (string-append (string (seed->char seed))
                        (loop (make-seed seed)))))))
@end example

This function is a fairly powerful string constructor; we can use it to
convert a list to a string, read a port into a string, reverse a string,
copy a string, and so forth.  Examples:

@example
(port->string p) = (string-unfold eof-object? values
                                  (lambda (x) (read-char p))
                                  (read-char p))

(list->string lis) = (string-unfold null? car cdr lis)

(string-tabulate f size) = (string-unfold (lambda (i)
                                            (= i size))
                                          f add1 0)
@end example

@noindent
to map @code{proc} over a list @var{lis}, producing a string:

@example
(string-unfold null? (compose proc car) cdr lis)
@end example

Interested functional programmers may enjoy noting that
@func{string-fold-right} and @func{string-unfold} are in some sense
inverses.  That is, given operations @var{knull?}, @var{kar}, @var{kdr},
@var{kons}, and @var{knil} satisfying:

@example
(kons (kar x) (kdr x)) @result{} x
(knull? knil) @result{} #t
@end example

@noindent
then:

@example
(string-fold-right kons knil
                   (string-unfold knull? kar kdr x))
@result{} x
@end example

@noindent
and:

@example
(string-unfold knull? kar kdr
               (string-fold-right kons knil s))
@result{} s
@end example

The final string constructed does not share storage with either
@var{base-string} or the value produced by @var{make-final}.
@end defun

@c ------------------------------------------------------------

@defun string-unfold-right @var{stop?} @var{seed->char} @var{make-seed} @var{first-seed}
@defunx string-unfold-right @var{stop?} @var{seed->char} @var{make-seed} @var{first-seed} @var{base-string}
@defunx string-unfold-right @var{stop?} @var{seed->char} @var{make-seed} @var{first-seed} @var{base-string} @var{make-final}
This is a fundamental constructor for strings.  The arguments are like
the ones of @func{string-unfold}.  The difference from
@func{string-unfold} is that this function builds the string from right
to left; more precisely, the following (simple, inefficient) definitions
hold:

@example
;; iterative
(define (string-unfold-right
           stop? seed->char make-seed
           first-seed base-string make-final)
  (let lp ((seed    first-seed)
           (result  base))
    (if (stop? seed)
        (string-append (make-final seed) result)
      (loop (make-seed seed)
            (string-append (string (seed->char seed))
                           result)))))

;; recursive
(define (string-unfold-right
           stop? seed->char make-seed
           first-seed base-string make-final)
  (string-append
     (let loop ((seed first-seed))
       (if (stop? seed)
           (make-final seed)
         (string-append (loop (make-seed seed))
                        (string (seed->char seed)))))
     base))
@end example

Interested functional programmers may enjoy noting that
@func{string-fold} and @func{string-unfold-right} are in some sense
inverses.  That is, given operations @var{knull?}, @var{kar}, @var{kdr},
@var{kons}, and @var{knil} satisfying:

@example
(kons (kar x) (kdr x)) @result{} x
(knull? knil) @result{} #t
@end example

@noindent
then:

@example
(string-fold kons knil
             (string-unfold-right knull? kar kdr x))
@result{} x
@end example

@noindent
and:

@example
(string-unfold-right knull? kar kdr
                     (string-fold kons knil s))
@result{} s
@end example

The final string constructed does not share storage with either
@var{base-string} or the value produced by @var{make-final}.
@end defun

@c page
@node strings select
@section Selection


@deffn Macro substring* @var{S}
Wrapper for @func{substring} accepting a string view as argument.
@end deffn


@deffn Function %string-copy* @var{str} @var{start} @var{past}
@deffnx Macro string-copy* @var{S}
The function @func{%string-copy*} is an alias for @func{substring}; the
macro @func{string-copy*} is an alias for @func{substring*}.

@quotation
These exist for symmetry with the @library{vectors} library; they allow
more confidence in converting a vector function into a string function,
and vice versa, by just replacing the string @code{vector} with the
string @code{string}, and vice versa.
@end quotation
@end deffn


@deffn Function %string-reverse-copy* @var{str} @var{start} @var{past}
@deffnx Macro string-reverse-copy* @var{S}
Like @func{%string-copy*}, but copy the elements in the reverse order
from the selected substring of @var{str}.

@example
(string-reverse-copy* (view "543210")
                        (start 1)
                        (past  5)))
@result{} "1234"
@end example
@end deffn


@deffn Function %string-copy*! @var{dst-str} @var{dst-start} @var{src-str} @var{src-start} @var{src-past}
@deffnx Macro string-copy*! @var{dst-S} @var{src-S}
Write the selected source substring into the selected destination
substring.  This function is the side--effecting variant of
@func{substring} and @func{substring*}.  This function supports copying
over the same string.

The selected destination substring starts at @var{dst-start} in
@var{dst-str} and may extend until the end of the string.  In the
destination string view @var{dst-S}: If a past index is specified, it is
ignored.
@end deffn


@deffn Function %string-reverse-copy*! @var{dst-str} @var{dst-start} @var{src-str} @var{src-start} @var{src-past}
@deffnx Macro string-reverse-copy*! @var{S-dst} @var{S-src}
Like @func{%string-copy*!}, but this copies the elements in the reverse
order.  This function supports copying over the same string.
@end deffn


@deffn Function %string-take @var{nchars} @var{str} @var{start} @var{past}
@deffnx Function %string-take-right @var{nchars} @var{str} @var{start} @var{past}
@deffnx Macro string-take @var{S} @var{nchars}
@deffnx Macro string-take-right @var{S} @var{nchars}
Return the first or last @var{nchars} of the selected substring.  These
functions always return a newly allocated string.
@end deffn


@deffn Function %string-drop @var{nchars} @var{str} @var{start} @var{past}
@deffnx Function %string-drop-right @var{nchars} @var{str} @var{start} @var{past}
@deffnx Macro string-drop @var{S} @var{nchars}
@deffnx Macro string-drop-right @var{S} @var{nchars}
Drop the first or last @var{nchars} of the selected substring and return
the resulting string.  These functions always return a newly allocated
string.
@end deffn

@c page
@node strings pad
@section Padding and trimming


@deffn Function %string-pad @var{requested-len} @var{fill-char} @var{str} @var{start} @var{past}
@deffnx Function %string-pad-right @var{requested-len} @var{fill-char} @var{str} @var{start} @var{past}
@deffnx Macro string-pad @var{S} @var{requested-len}
@deffnx Macro string-pad @var{S} @var{requested-len} @var{fill-char}
@deffnx Macro string-pad-right @var{S} @var{requested-len}
@deffnx Macro string-pad-right @var{S} @var{requested-len} @var{fill-char}
Build a string of length @var{requested-len} comprised of @var{str}
padded on the left or right by as many occurrences of the character
@var{fill-char} as needed.  Always return a newly allocated string.

If @var{str} has more than @var{requested-len} chars, it is truncated on
the left or right to length @var{requested-len}.  For the macros:
@var{fill-char} defaults to @code{#\space}.

Examples:

@example
(string-pad     "325" 5) @result{} "  325"
(string-pad   "71325" 5) @result{} "71325"
(string-pad "8871325" 5) @result{} "71325"
@end example
@end deffn


@deffn Function %string-trim @var{char/char-set/pred} @var{str} @var{start} @var{past}
@deffnx Function %string-trim-right @var{char/char-set/pred} @var{str} @var{start} @var{past}
@deffnx Function %string-trim-both @var{char/char-set/pred} @var{str} @var{start} @var{past}
@deffnx Macro string-trim @var{S} @var{char/char-set/pred}
@deffnx Macro string-trim-right @var{S} @var{char/char-set/pred}
@deffnx Macro string-trim-both @var{S} @var{char/char-set/pred}
Trim @var{str} by skipping over all characters on the left/on the
right/on both sides that satisfy the second parameter
@var{char/char-set/pred}:

@itemize
@item
If it is a character @var{char}, characters equal to @var{char} are
trimmed.

@item
If it is a char set @var{char-set}, characters contained in
@var{char-set} are trimmed.

@item
If it is a predicate @var{pred}, it is a test predicate that is applied
to the characters in @var{S}; a character causing it to return true is
skipped.
@end itemize

Always return a newly allocated string.
@end deffn

@c page
@node strings prefix
@section Prefixes and suffixes


@deffn Function %string-prefix-length @vari{str} @vari{start} @vari{past} @varii{str} @varii{start} @varii{past}
@deffnx Function %string-prefix-length-ci @vari{str} @vari{start} @vari{past} @varii{str} @varii{start} @varii{past}
@deffnx Macro string-prefix-length @vari{S} @varii{S}
@deffnx Macro string-prefix-length-ci @vari{S} @varii{S}
Return the length of the longest common prefix of the two substrings.
This is equivalent to the ``mismatch index'' for the strings (modulo the
start index offsets).
@end deffn


@deffn Function %string-suffix-length @vari{str} @vari{start} @vari{past} @varii{str} @varii{start} @varii{past}
@deffnx Function %string-suffix-length-ci @vari{str} @vari{start} @vari{past} @varii{str} @varii{start} @varii{past}
@deffnx Macro string-suffix-length @vari{S} @varii{S}
@deffnx Macro string-suffix-length-ci @vari{S} @varii{S}
Return the length of the longest common suffix of the two substrings.
@end deffn


@deffn Function %string-prefix? @vari{str} @vari{start} @vari{past} @varii{str} @varii{start} @varii{past}
@deffnx Function %string-prefix-ci? @vari{str} @vari{start} @vari{past} @varii{str} @varii{start} @varii{past}
@deffnx Macro string-prefix? @vari{S} @varii{S}
@deffnx Macro string-prefix-ci? @vari{S} @varii{S}
Return @true{} if the selected substring of @vari{str} is a prefix of
the selected substring of @varii{str}, otherwise return @false{}.  Notice
that the empty string is a prefix of every string.
@end deffn


@deffn Function %string-suffix? @vari{str} @vari{start} @vari{past} @varii{str} @varii{start} @varii{past}
@deffnx Function %string-suffix-ci? @vari{str} @vari{start} @vari{past} @varii{str} @varii{start} @varii{past}
@deffnx Macro string-suffix? @vari{S} @varii{S}
@deffnx Macro string-suffix-ci? @vari{S} @varii{S}
Return @true{} if the selected substring of @vari{str} is a suffix of
the selected substring of @varii{str}, otherwise return @false{}.  Notice
that the empty string is @strong{not} a suffix of every string.
@end deffn

@c page
@node strings search
@section Searching


@deffn Function %string-index @var{char/char-set/pred} @var{str} @var{start} @var{past}
@deffnx Function %string-index-right @var{char/char-set/pred} @var{str} @var{start} @var{past}
@deffnx Macro string-index @var{S} @var{char/char-set/pred}
@deffnx Macro string-index-right @var{S} @var{char/char-set/pred}
Search through the string from the left or right, returning the index of
the first occurrence of a character which:

@itemize
@item
Equals @var{char/char-set/pred} if it is a character.

@item
Is in @var{char/char-set/pred} if it is a character set.

@item
Satisfies the predicate @var{char/char-set/pred} if it is a procedure.
@end itemize

If no match is found: Return @false{}.
@end deffn


@deffn Function %string-skip @var{char/char-set/pred} @var{str} @var{start} @var{past}
@deffnx Function %string-skip-right @var{char/char-set/pred} @var{str} @var{start} @var{past}
@deffnx Macro string-skip @var{S} @var{char/char-set/pred}
@deffnx Macro string-skip-right @var{S} @var{char/char-set/pred}
Search through the string from the left or right, returning the index of
the first occurrence of a character which:

@itemize
@item
Does not equal @var{char/char-set/pred} if it is a character.

@item
Is not in @var{char/char-set/pred} if it is a character set.

@item
Does not satisfy the predicate @var{char/char-set/pred} if it is a
procedure.
@end itemize

If no match is found: Return @false{}.
@end deffn


@deffn Function %string-count @var{char/char-set/pred} @var{str} @var{start} @var{past}
@deffnx Macro string-count @var{S} @var{char/char-set/pred}
Return a count of the number of characters in @var{str} that satisfy the
@var{char/char-set/pred} argument:

@itemize
@item
If it is a procedure, it is applied to the character as a predicate.

@item
If it is a character set, the character is tested for membership.

@item
If it is a character, it is used in an equality test.
@end itemize
@end deffn


@deffn Function %string-contains @vari{str} @vari{start} @vari{past} @varii{str} @varii{start} @varii{past}
@deffnx Function %string-contains-ci @vari{str} @vari{start} @vari{past} @varii{str} @varii{start} @varii{past}
@deffnx Macro string-contains @var{S1} @var{S2}
@deffnx Macro string-contains-ci @var{S1} @var{S2}
Return true if the selected substring of @vari{str} contains the
selected substring of @varii{str}, else return @false{}.  The return
value is the index in @vari{str} where the substring of @varii{str}
occurs.
@end deffn

@c page
@node strings filter
@section Filtering and deleting


@deffn Function %string-filter @var{char/char-set/pred} @var{str} @var{start} @var{past}
@deffnx Macro string-filter @var{S} @var{char/char-set/pred}
Filter the selected substring, retaining only those characters that
satisfy the @var{char/char-set/pred} argument:

@itemize
@item
If it is a procedure, it is applied to the character as a predicate.

@item
If it is a character set, the character is tested for membership.

@item
If it is a character, it is used in an equality test.
@end itemize

Always return a newly allocated string.
@end deffn


@deffn Function %string-delete @var{char/char-set/pred} @var{str} @var{start} @var{past}
@deffnx Macro string-delete @var{S} @var{char/char-set/pred}
Filter the selected substring, retaining only those characters that do
@strong{not} satisfy the @var{char/char-set/pred} argument:

@itemize
@item
If it is a procedure, it is applied to the character as a predicate.

@item
If it is a character set, the character is tested for membership.

@item
If it is a character, it is used in an equality test.
@end itemize

Always return a newly allocated string.
@end deffn

@c page
@node strings list
@section List and string conversion


@deffn Function %string->list* @var{str} @var{start} @var{past}
@deffnx Macro string->list* @var{S}
Return a newly allocated list of the characters that make up the given
substring.  This is an extension of the @func{string->list} function
that adds support for substrings.
@end deffn


@deffn Function %reverse-string->list @var{str} @var{start} @var{past}
@deffnx Macro reverse-string->list @var{S}
Like @func{%string->list*} but reverses the order of the characters from
the substring.
@end deffn


@defun reverse-list->string @var{char-list}
Reverse the given list of characters, then compose a string with the
result.

@example
(reverse-list->string '(#\a #\B #\c))
@result{} "cBa"
@end example
@end defun


@deffn Function %string-tokenize @var{token-set} @var{str} @var{start} @var{past}
@deffnx Function %string-tokenise @var{token-set} @var{str} @var{start} @var{past}
@deffnx Macro string-tokenize @var{S} @var{token-set}
@deffnx Macro string-tokenise @var{S} @var{token-set}
Split the selected substring into a list of strings, where each string
is a maximal, non--empty, contiguous sequence of characters from the
character set @var{token-set}.

@example
(string-tokenize "Help make programs run, run, RUN!"
                 (char-set-complement (char-set #\space)
                                      char-set:ascii))
@result{} ("Help" "make" "programs" "run," "run," "RUN!")
@end example

@quotation
This function provides a minimal parsing facility for simple
applications.  More sophisticated parsers that handle quoting and
backslash effects can easily be constructed using regular--expression
systems; be careful not to use @func{string-tokenize} in contexts where
more serious parsing is needed.
@end quotation
@end deffn


@defun string-join @var{string-list}
@defunx string-join @var{string-list} @var{delimiter}
@defunx string-join @var{string-list} @var{delimiter} @var{grammar}
@defunx %string-join @var{string-list} @var{delimiter} @var{grammar}
This procedure is a simple unparser: It pastes strings together using
the @var{delimiter} string.  @var{delimiter} defaults to a single white
space.  @var{grammar} is a symbol that determines how the delimiter is
used, and defaults to @code{infix}.  Supported values for @var{grammar}
are:

@table @code
@item infix
Means an infix or separator grammar: Insert the delimiter between list
elements.  An empty list will produce an empty string.

@quotation
@strong{Note}: Parsing an empty string with an infix grammar is
ambiguous.  Is it an empty list, or a list of one element, the empty
string?
@end quotation

@item strict-infix
Means the same as @code{infix}, but will raise an error if given an
empty list.

@item suffix
Means a suffix or terminator grammar: Insert the delimiter after every
list element.  This grammar has no ambiguities.

@item prefix
Means a prefix grammar: Insert the delimiter before every list element.
This grammar has no ambiguities.
@end table

The delimiter is the string used to delimit elements; it defaults to a
single space.

Examples:

@example
(string-join '("foo" "bar" "baz") ":")
@result{} "foo:bar:baz"

(string-join '("foo" "bar" "baz") ":" 'suffix)
@result{} "foo:bar:baz:"

;; Infix grammar is ambiguous wrt empty list vs. empty string,
(string-join '()   ":") @result{} ""
(string-join '("") ":") @result{} ""

(string-join '("") "," 'strict-infix) @result{} ""
(string-join '("") "," 'suffix) @result{} ","
(string-join '("") "," 'prefix) @result{} ","
@end example
@end defun

@c page
@node strings replicate
@section Replicate and rotate


@deffn Function %xsubstring @var{from} @var{to} @var{str} @var{start} @var{past}
@deffnx Macro xsubstring @var{S} @var{from} @var{to}
Extended substring procedure replicating the selected substring ``up and
down'' index space, in both the positive and negative directions.

The call:

@example
(%xsubstring from to "abcdefg" 3 6)
@end example

@noindent
selects the substring @code{"def"} and defines the conceptual
bidirectionally--infinite string:

@example
...  e  f  d  e  f  d  e  f  d  e  f ...
... -5 -4 -3 -2 -1  0 +1 +2 +3 +4 +5 ...
                    ^
@end example

@noindent
that is @code{def} repeated in both directions.  @func{%xsubstring}
returns the substring of this string beginning at index @var{from}, and
ending at @var{to}.

We can use this function to perform a variety of tasks:

@itemize
@item
To replicate a string:

@example
(xsubstring "abc" 0 7) @result{} "abcabca"
@end example

@item
To rotate a string left:

@example
(xsubstring "abcdef" 1  7) @result{} "bcdefa"
(xsubstring "abcdef" 2  8) @result{} "cdefab"
(xsubstring "abcdef" 3  9) @result{} "defabc"
(xsubstring "abcdef" 4 10) @result{} "efabcd"
(xsubstring "abcdef" 5 11) @result{} "fabcde"
@end example

@item
To rotate a string right:

@example
(xsubstring "abcdef" -1 5) @result{} "fabcde"
(xsubstring "abcdef" -2 4) @result{} "efabcd"
(xsubstring "abcdef" -3 3) @result{} "defabc"
(xsubstring "abcdef" -4 2) @result{} "cdefab"
(xsubstring "abcdef" -5 1) @result{} "bcdefa"
@end example
@end itemize

Note that:

@itemize
@item
The @var{from}/@var{to} indices give a half--open range; the characters
from index @var{from} up to, but not including, index @var{to}.

@item
The @var{from}/@var{to} indices are not in terms of the index space for
string @var{str}.  They are in terms of the replicated index space of
the substring defined by @var{str}, @var{start}, and @var{past}.
@end itemize

It is an error if @var{start} equals @var{past}.
@end deffn


@deffn Function xstring-xcopy! @var{from} @var{to} @var{target} @var{target-start} @var{source} @var{source-start} @var{source-past}
@deffnx Macro string-xcopy! @var{target-S} @var{source-S} @var{from} @var{to}
Exactly the same as @func{%xsubstring}, but the extracted text is
written into the selected substring of @var{target}.

This operation is not defined if @code{(eq? target start)}; we cannot
copy a string on top of itself.
@end deffn

@c page
@node strings mutate
@section Mutators


@defun string-swap! @var{str} @var{i} @var{j}
Swap the characters in @var{str} at positions @var{i} and @var{j}.
@end defun


@deffn Function %string-fill*! @var{fill-char} @var{str} @var{start} @var{past}
@deffnx Macro string-fill*! @var{S} @var{fill-char}
Fill the selected substring with @var{fill-char}, modifying the original
string.
@end deffn

@c page
@node strings misc
@section Miscellaneous functions


@deffn Function %string-replace @vari{str} @vari{start} @vari{past} @varii{str} @varii{start} @varii{past}
@deffnx Macro string-replace @var{S1} @var{S2}
Replace the selected string in @vari{str} with the selected string in
@varii{str}.  Return a newly allocated string.
@end deffn


@deffn Function %string-reverse @var{str} @var{start} @var{past}
@deffnx Function %string-reverse! @var{str} @var{start} @var{past}
@deffnx Macro string-reverse @var{S}
@deffnx Macro string-reverse! @var{S}
Reverse the string.  @func{%string-reverse} returns the result string
and does not alter its @var{str} parameter.  @func{%string-reverse!} is
the in--place side--effecting variant.
@end deffn

@c page
@node vectors
@chapter Vectors library


The @library{vectors} library extends the vector operations available in
the base library.  @nauref{baselib vectors, Vectors}.  While
@library{vectors} is a high level interface, @library{vectors low} is a
low level interface with the same functionalities.

@menu
* vectors intro::               Introduction.
* vectors convention::          Interface conventions.
* vectors views::               Views over vectors.
* vectors cons::                Constructors.
* vectors pred::                Predicates.
* vectors compar::              Comparison.
* vectors fold::                Fold and unfold.
* vectors select::              Selection.
* vectors pad::                 Padding and trimming.
* vectors prefix::              Prefixes and suffixes.
* vectors search::              Searching.
* vectors filter::              Filtering and deleting.
* vectors list::                List and vector conversion.
* vectors replicate::           Replicate and rotate.
* vectors mutate::              Mutators.
* vectors misc::                Miscellaneous functions.
@end menu

@c page
@node vectors intro
@section Introduction


@subsubheading Library organisation

The functions are split in a high level library, @library{vectors}, and
a low level one, @library{vectors low}.  The main difference between the
two layers is that the high level library makes heavy usage of macros to
implement the @dfn{vector views}, which allow accessing subvectors using
a friendly syntax.

All the functions in the low level library are bound to identifiers
starting with @code{%}; for example: @func{vector-prefix?} is a high
level macro, @func{%vector-prefix?} is its low level function
homologous.

@subsubheading Direction of iteration

The library accesses the values of a vector in left--to--right or
right--to--left order depending on the convenience of the algorithm.

@subsubheading Handling side effects

Care must be taken when using functions with side effects.  One reason
for this is that some of the supported Scheme implementations will treat
a literal vector as a constant, so the following raises an error:

@example
(import (rnrs))

(define vec '#(0 1 2 3 4))
(vector-set! vec 2 #\9)
@end example

@noindent
To avoid this problem completely, we can change the program in this way:

@example
(import (rnrs))

(define vec (vector-copy '#(0 1 2 3 4)))
(vector-set! vec 2 #\9)
@end example

@noindent
of course we may want to wrap into @func{vector-copy} only the vectors
that are meant to be mutated.

@c page
@node vectors convention
@section Interface conventions


In order to simplify text in this documentation section, the values of a
vector are called @dfn{items}.

The following naming convention holds:

@itemize
@item
Procedures whose names end in @code{!} are side--effecting variants.
What values these procedures return is usually not specified.

@item
The order of common arguments is consistent across the different
procedures in the high level library, and consistent across the
different procedures in the low level library.  Arguments to some
functions in the high level library have different order from the one of
the homologous low level functions.

@item
Procedures that have left/right directional variants use the following
convention:

@multitable {right--to--left} {Suffix}
@headitem Direction @tab Suffix
@item left-to-right @tab @meta{none}
@item right-to-left @tab --right
@item both @tab --both
@end multitable
@end itemize

In the procedure specifications:

@itemize
@item
A @var{V} argument is a vector view, which is expanded by a macro in a
triplet of values: the vector, the index of the first value in the
selected subvector, the index of the value past the last in the selected
position.  @ref{vectors views} for details.

@item
A @var{vec} argument is a vector.

@item
The @var{start} and @var{past} arguments are half--open vector indices
specifying a subvector within a vector argument; when unspecified, they
default to zero and the length of the vector, respectively.  When
specified, it must be the case that:

@example
0 <= start <= past <= (vector-length s)
@end example

@noindent
for the corresponding argument @var{vec}.  They typically restrict a
procedure's action to the indicated subvector; when @var{start} equals
@var{past} the selected subvector is the empty vector.

@item
A @var{pred} argument is a unary value predicate procedure,
returning a true/false value when applied to a value.

@item
A @var{item=} argument is a binary function applied to two items, it
must return true when they are equal, false otherwise.

@item
A @var{item<} argument is a binary function applied to two items, it
must return true when the first is less than the second, false
otherwise.

@item
An @var{i} or @var{k} argument is an exact non--negative integer
specifying an index into a vector.

@item
The @var{len} and @var{nvalues} arguments are exact non--negative
integers specifying a length of a vector or some number of values.

@item
An @var{obj} argument can be any value.
@end itemize

An argument followed by @code{...} means zero--or--more elements.  So
the procedure with the signature:

@example
sum-squares x ...
@end example

@noindent
takes zero or more arguments (@var{x}, @dots{}), while the procedure
with signature:

@example
spell-check doc dict1 dict2 ...
@end example

@noindent
takes two mandatory arguments (@var{doc} and @var{dict1}) and zero or
more optional arguments (@var{dict2} ...).

If a procedure is said to return ``unspecified'', this means that
nothing at all is known about what the procedure returns.  Such a
procedure is not even required to be consistent from call to call.  It
is simply required to return a value (or values) that may be passed to a
command continuation, e.g. as the value of an expression appearing as a
non--terminal subform of a begin expression.

@c page
@node vectors views
@section Views over vectors


Vector views are syntactic sugar to allow subvector specification with
minimum overhead; views make use of auxiliary syntaxes exported by the
@library{auxiliary-syntaxes} library and reexported by the
@library{vectors} library.  Many low level vector functions act on
subvectors specified with triplets of arguments:

@itemize
@item
The full vector.

@item
The @dfn{start index}: The index of the first item in the selected
subvector.

@item
The @dfn{past index}: The index of the item past the last item in the
selected subvector.
@end itemize

To select the subvector @code{#(2 3 4)} from the vector @code{#(0 1 2 3
4 5 6)} we have to determine the half--open range of items, which is
@math{[2, 5)}, then apply a function to the arguments:

@example
(%the-function '#(0 1 2 3 4 5 6) 2 5)
@end example

@noindent
while to select the whole vector we can do:

@example
(%the-function '#(0 1 2 3 4 5 6) 0 7)
@end example

@noindent
or:

@example
(let ((vec '#(0 1 2 3 4 5 6)))
  (%the-function vec 0 (vector-length vec)))
@end example

With the vector views implemented by @library{vectors}, the low level
function is wrapped by a high level syntax which can be invoked as:

@example
(the-function '#(0 1 2 3 4 5 6 7))
        ; select the whole vector

(the-function (view '#(0 1 2 3 4 5 6 7)))
        ; select the whole vector

(the-function (view '#(0 1 2 3 4 5 6 7)
                (start 3)))
        ; select the subvector [3, 8)

(the-function (view '#(0 1 2 3 4 5 6 7)
                (start 3)
                (past 6)))
        ; select the subvector [3, 6)

(the-function (view '#(0 1 2 3 4 5 6 7)
                (past 5)))
        ; select the subvector [0, 5)
@end example

@noindent
instead of a triplet of arguments, the vector view is a single argument
that can be:

@table @code
@item @meta{vector}
@itemx (view @meta{vector})
The vector itself or an unquoted list holding the vector itself,
prefixed by the @code{view} auxiliary syntax: It selects the whole
vector.

@itemx (view @meta{vector} (start @meta{start-index}))
An unquoted list holding the vector and the start index, with auxiliary
syntaxes @code{view} and @code{start}: It selects the subvector from the
start index to the end.

@item (view @meta{vector} (past @meta{past-index}))
An unquoted list holding the vector and the past index, with auxiliary
syntaxes @code{view} and @code{past}: It selects the subvector from zero
to the selected past index.

@itemx (view @meta{vector} (start @meta{start-index}) (past @meta{past-index}))
An unquoted list holding the vector, the start index and the past index,
with auxiliary syntaxes @code{view}, @code{start} and @code{past}: It
selects the subvector between the start and past indexes.
@end table

@noindent
@code{@meta{vector}}, @code{@meta{start-index}} and
@code{@meta{past-index}} can be arbitrary Scheme expressions.  High
level macros accepting two or more subvectors as arguments, support
vector views for all of them.  When we are concerned with the overhead
of vector views, we can use the low level functions directly.

In the following documentation: Low level functions and high level
macros are documented together; only the meaning of arguments to the low
level function are described, the meaning of high level arguments is
obvious.

@c page
@node vectors cons
@section Constructors


@defun vector-concatenate @var{vector-list}
Append the elements of @var{vector-list} together into a single vector.
Guaranteed to return a freshly allocated vector.
@end defun


@deffn Function %vector-concatenate-reverse @var{vector-list} @var{final-vector} @var{nvalues}
@deffnx Macro vector-concatenate-reverse @var{vector-list}
@deffnx Macro vector-concatenate-reverse @var{vector-list} @var{final-vector}
@deffnx Macro vector-concatenate-reverse @var{vector-list} @var{final-vector} @var{nvalues}
Reverse @var{vector-list} then concatenate the elements, which must be
vectors.  The first @var{nvalues} items in @var{final-vector} are consed
onto the beginning of @var{vector-list} before performing the the
reversal and concatenation operations.

@var{final-vector} defaults to the empty vector and @var{nvalues}
defaults to the length of @var{final-vector}.

This procedure is useful in the construction of procedures that
accumulate data into lists of vector buffers, and wish to convert the
accumulated data into a single vector when done.
@end deffn


@defun Function vector-append @var{vec} ...
Return a newly allocated vector that contains all elements in order from
the subsequent locations in the vector arguments.

@example
(vector-append '#(x) '#(y))
@result{} #(x y)

(vector-append '#(a) '#(b c d))
@result{} #(a b c d)

(vector-append '#(a #(b)) '#(#(c)))
@result{} #(a #(b) #(c))
@end example
@end defun


@defun vector-tabulate @var{integer->item} @var{len}
Construct a vector of size @var{len} by applying @var{integer->item} to
each index from zero (included) to @var{len} (excluded), in increasing
order, to produce the corresponding vector element.
@end defun

@c page
@node vectors pred
@section Predicates


@defun vector-null? @var{obj}
Return @true{} if @var{obj} is the empty vector, otherwise return
@false{}.
@end defun


@deffn Function %vector-every @var{pred} @var{vec} @var{start} @var{past}
@deffnx Function %vector-any @var{pred} @var{vec} @var{start} @var{past}
@deffnx Macro vector-every @var{pred} @var{V}
@deffnx Macro vector-any @var{pred} @var{V}
Check to see if the given predicate is true on every/any item in
@var{vec}, proceeding from left (index @var{start}) to right (index
@var{past}).  If the selected subvector is empty, the return value is
@false{}.

The predicate is ``witness--generating'':

@itemize
@item
If @func{vector-any} returns true: The returned true value is the one
produced by the application of the predicate.

@item
If @func{vector-every} returns true: The returned true value is the one
produced by the application of the predicate to the last item in the
subvector.
@end itemize

If the predicate is applied to the final item of the selected subvector,
that final application is a tail call.

The names of these procedures do not end with a question mark; this is
to indicate that they do not return a simple boolean (@true{} or
@false{}), but a general value.
@end deffn

@c page
@node vectors compar
@section Comparison


@deffn Function %vector-compare @var{item=} @var{item<} @vari{vec} @vari{beg} @vari{past} @varii{vec} @varii{beg} @varii{past} @var{proc<} @var{proc=} @var{proc>}
@deffnx Macro vector-compare @var{item=} @var{item<} @vari{V} @varii{V} @var{proc<} @var{proc=} @var{proc>}
Determine the @dfn{mismatch index} between the two subvectors: the
largest index @math{i} such that for every @math{0 <= j < i},
@math{vec1[j] = vec2[j]}; that is, @math{i} is the first position that
does not match.

The mismatch index is always an index into @vari{vec}; in the case of
equal vectors, it is always @vari{past}; the functions observe the
protocol in this redundant case for uniformity.

The items before the mismatch index are tested for equality using
@var{item=}; the items at the mismatch index are also compared using
@var{item<}, to determine the smallest.

@var{proc<}, @var{proc=}, or @var{proc>} are applied to the mismatch
index (not item), depending upon whether the subvector of @vari{vec} is
less than, equal to, or greater than the subvector of @varii{vec}.  The
result of the application is returned.

If we just want to have the mismatch index as return value: We can use
@func{values} as value for @var{proc<}, @var{proc=} and @var{proc>}.
Another interesting option is to use @code{(lambda (mismatch-index) #f)}
or @code{(lambda (mismatch-index) #t)}.

Examples:

@example
(vector-compare '#(0 1 2 3) '#(0 1 2 3) values values values)
@result{} 4

(vector-compare '#(0 1 2 3) '#(0 1 2 3) values values values)
@result{} 4
@end example
@end deffn


@deffn Function %vector= @var{item=} @vari{vec} @vari{beg} @vari{past} @varii{vec} @varii{beg} @varii{past}
@deffnx Macro vector= @var{item=} @vari{V} @varii{V}
Compare two subvectors: Return true if they are equal according to
@var{item=}, @false{} otherwise.
@end deffn


@deffn Function %vector<> @var{item=} @vari{vec} @vari{beg} @vari{past} @varii{vec} @varii{beg} @varii{past}
@deffnx Macro vector<> @var{item=} @vari{V} @vari{V}
Compare two subvectors: Return @false{} if they are equal according to
@var{item=}, true otherwise.
@end deffn


The following predicates compare two subvectors according to the
following rules:

@enumerate
@item
Two subvectors are equal if: they have the same length and all their
items are equal according to @var{item=}.

@item
A subvector @vari{V} is less than @varii{V} if:

@itemize
@item
@vari{V} is shorter than @varii{V} and the all the items in @vari{V} are
equal to the corresponding items in @varii{V} according to @var{item=}.

@item
The items in @vari{V} and @varii{V} are equal up to a certain index
according to @var{item=}, and the item at the mismatch index in @vari{V}
is less than the corresponding item in @varii{V} according to
@var{item<}.
@end itemize

@item
A subvector @vari{V} is greater than @varii{V} if:

@itemize
@item
@vari{V} is longer than @varii{V} and the all the items in @vari{V} are
equal to the corresponding items in @varii{V} according to @var{item=}.

@item
The items in @vari{V} and @varii{V} are equal up to a certain index
according to @var{item=}, and the item at the mismatch index in @vari{V}
is greater than the corresponding item in @varii{V} according to
@var{item<}.
@end itemize
@end enumerate


@deffn Function %vector< @var{item=} @var{item<} @vari{vec} @vari{beg} @vari{past} @varii{vec} @varii{beg} @varii{past}
@deffnx Macro vector< @var{item=} @var{item<} @vari{V} @varii{V}
Compare two subvectors: Return true if the first is less than the
second, @false{} otherwise.
@end deffn


@deffn Function %vector<= @var{item=} @var{item<} @vari{vec} @vari{beg} @vari{past} @varii{vec} @varii{beg} @varii{past}
@deffnx Macro vector<= @var{item=} @var{item<} @vari{V} @varii{V}
Compare two subvectors: Return true if the first is less than, or equal
to, the second; @false{} otherwise.
@end deffn


@deffn Function %vector> @var{item=} @var{item<} @vari{vec} @vari{beg} @vari{past} @varii{vec} @varii{beg} @varii{past}
@deffnx Macro vector> @var{item=} @var{item<} @vari{V} @varii{V}
Compare two subvectors: Return true if the first is greater than the
second, @false{} otherwise.
@end deffn


@deffn Function %vector>= @var{item=} @var{item<} @vari{vec} @vari{beg} @vari{past} @varii{vec} @varii{beg} @varii{past}
@deffnx Macro vector>= @var{item=} @var{item<} @vari{V} @varii{V}
Compare two subvectors: Return true if the first is greater than, or
equal to, the second; @false{} otherwise.
@end deffn

@c page
@node vectors fold
@section Fold and unfold


@menu
* vectors fold rnrs::           Folding with @rnrs{6} style.
* vectors fold sub::            Folding over subvectors.
* vectors fold unfold::         Unfolding vectors.
* vectors fold map::            Mapping functions.
@end menu

@c page
@node vectors fold rnrs
@subsection Folding with @rnrs{6} style


@deffn Function vector-fold-left @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Function vector-fold-right @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Syntax vector-fold-left/stx @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Syntax vector-fold-right/stx @var{combine} @var{knil} @var{vec0} @var{vec} ...
Fold the function @var{combine} over the vector arguments, which must
have the same length.  The return value is the return value of the last
evaluated call to @var{combine}; if all the vector arguments are empty,
the return value is @var{knil}.  The syntaxes may be a little faster in
the multiple vector arguments case.

The left--folding variants iterate @var{combine} left--to--right over each
element of equal index in all the vectors; @var{combine} is applied as:

@example
(@var{combine} @var{state}
  (vector-ref @var{vec0} @var{idx})
  (vector-ref @var{vec}  @var{idx})
  )
@end example

@noindent
where @var{state} is the current state value, and it is the
@strong{first} argument; the current state value begins with @var{knil},
and becomes whatever @var{combine} returned at the respective iteration.

The right--folding variants iterate @var{combine} right--to--left over each
element of equal index in all the vectors; @var{combine} is applied as:

@example
(@var{combine}
  (vector-ref @var{vec0} @var{idx})
  (vector-ref @var{vec}  @var{idx})
  
  @var{state})
@end example

@noindent
in which @var{state} is the @strong{last} argument.
@end deffn


@deffn Function vector-fold-left* @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Function vector-fold-right* @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Syntax vector-fold-left*/stx @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Syntax vector-fold-right*/stx @var{combine} @var{knil} @var{vec0} @var{vec} ...
Like the above functions, but accept vectors of different length,
iterating until the end of the shortest.
@end deffn


@defun vector-fold-left/with-index @var{combine} @var{knil} @var{vec0} @var{vec} ...
@defunx vector-fold-left*/with-index @var{combine} @var{knil} @var{vec0} @var{vec} ...
@defunx vector-fold-right/with-index @var{combine} @var{knil} @var{vec0} @var{vec} ...
@defunx vector-fold-right*/with-index @var{combine} @var{knil} @var{vec0} @var{vec} ...
Folding operators variants which apply @var{combine} using the index of the
current elements as first argument.  For the left--folding operators:

@example
(@var{combine} @var{idx} @var{state}
  (vector-ref @var{vec0} @var{idx})
  (vector-ref @var{vec}  @var{idx})
  )
@end example

@noindent
for the right--folding operators:

@example
(@var{combine} @var{idx}
  (vector-ref @var{vec0} @var{idx})
  (vector-ref @var{vec}  @var{idx})
  
  @var{state})
@end example

Here is a possible implementation for @func{vector-map!}:

@example
(define (vector-map! proc vec0 . vectors)
  (apply vector-fold-left/with-index
         (lambda (index state . items)
           (vector-set! state index (apply proc index items))
           state)
         vec0 vec0 vectors))
@end example
@end defun

@c ------------------------------------------------------------

@deffn Function vector-and-fold-left @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Function vector-and-fold-left* @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Function vector-and-fold-right @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Function vector-and-fold-right* @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Syntax vector-and-fold-left/stx @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Syntax vector-and-fold-left*/stx @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Syntax vector-and-fold-right/stx @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Syntax vector-and-fold-right*/stx @var{combine} @var{knil} @var{vec0} @var{vec} ...
Like the functions above, but stop the iteration if @var{combine}
returns @false{}.  The return value is the return value of the last
evaluated call to @var{combine}; if all the vector arguments are empty,
the return value is @var{knil}.

These functions can be used to implement functions like
@func{vector-every}:

@example
(define (vector-every pred vec0 . vectors)
  (apply vector-and-fold-left (lambda (state . items)
                                (apply pred items))
         #t ;must be true
         (cons vec0 vectors)))
@end example
@end deffn


@deffn Function vector-or-fold-left @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Function vector-or-fold-left* @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Function vector-or-fold-right @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Function vector-or-fold-right* @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Syntax vector-or-fold-left/stx @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Syntax vector-or-fold-left*/stx @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Syntax vector-or-fold-right/stx @var{combine} @var{knil} @var{vec0} @var{vec} ...
@deffnx Syntax vector-or-fold-right*/stx @var{combine} @var{knil} @var{vec0} @var{vec} ...
Like the functions above, but stop the iteration if @var{combine}
returns true as state.  The return value is the return value of the last
evaluated call to @var{combine}.  If all the vectors are empty, the
return value is @var{knil}.

These functions can be used to implement functions like
@func{vector-any}:

@example
(define (vector-any pred vec0 . vectors)
  (apply vector-or-fold-left (lambda (state . items)
                               (apply pred items))
         #f ;must be false
         (cons vec0 vectors)))
@end example
@end deffn


@defun vector-fold-left/pred @var{pred} @var{knil} @var{vec}
Apply @var{pred} to adjacent couples of elements from @var{vec}; return
true if all the evaluations of @var{pred} were true.  The iteration
stops at the first @false{} return value from @var{pred}.

This function is implemented as:

@example
(define (fold-left/pred pred knil ell)
  (vector-and-fold-left/stx (lambda (state item)
                              (and (pred state item) item))
     knil ell))
@end example

@noindent
and it can be used to implement predicates for ordering like @func{<}:

@example
(vector-fold-left/pred < 0 '(1 2 3 4 5 6))
@result{} 6

(vector-fold-left/pred < 0 '(1 2 3 -4 5 6))
@result{} #f
@end example
@end defun

@c page
@node vectors fold sub
@subsection Folding over subvectors


@deffn Function %subvector-fold-left @var{combine} @var{knil} @var{vec} @var{start} @var{past}
@deffnx Function %subvector-fold-right @var{combine} @var{knil} @var{vec} @var{start} @var{past}
@deffnx Macro subvector-fold-left @var{combine} @var{knil} @var{S}
@deffnx Macro subvector-fold-right @var{combine} @var{knil} @var{S}
Fold @var{combine} over each item of the selected subvector, return the
return value of the last evaluated call to @var{combine}; if the
selected subvector is empty, the return value is @var{knil}.  The
left--fold operator builds the return value as:

@example
(@var{combine}
  (@var{combine}
        ...
        (@var{combine}
           (@var{combine}
              (vector-ref @var{vec} @var{start})
              @var{knil})
           (vector-ref @var{vec} (+ @var{start} 1)))
        ...
    (vector-ref @var{vec} (- @var{past} 2)))
    ...
  (vector-ref @var{vec} (- @var{past} 1)))
@end example

@noindent
the right--fold iterator builds the return value as:

@example
(@var{combine}
  (vector-ref @var{vec} @var{start}
  (@var{combine}
    (vector-ref @var{vec} (+ @var{start} 1))
    ...
      (@var{combine}
        (vector-ref @var{vec} (- @var{past} 3))
        (@var{combine}
           (vector-ref @var{vec} (- @var{past} 2))
           (@var{combine}
              (vector-ref @var{vec} (- @var{past} 1))
              @var{knil})))))
@end example
@end deffn

@c page
@node vectors fold unfold
@subsection Unfolding vectors


@defun vector-unfold @var{stop?} @var{seed->item} @var{make-seed} @var{first-seed}
@defunx vector-unfold @var{stop?} @var{seed->item} @var{make-seed} @var{first-seed} @var{base-vector}
@defunx vector-unfold @var{stop?} @var{seed->item} @var{make-seed} @var{first-seed} @var{base-vector} @var{make-final}
This is a fundamental constructor for vectors.  Arguments description
follows.

@table @var
@item make-seed
A map function used to generate a series of ``seed'' values from the
initial seed:

@example
@var{first-seed}
(@var{make-seed} @var{first-seed})            @result{} seed2
(@var{make-seed} seed2)                 @result{} seed3
(@var{make-seed} seed3)                 @result{} seed4
...
@end example

@item stop?
A predicate function telling when to stop generating items: When it
returns true when applied to one of the seed values.

@item seed->item
Map function mapping each seed value to the corresponding item in
the result vector.  These items are assembled into the vector in a
left--to--right order.

@item base
An optional vector which is used as initial/leftmost portion of the
constructed vector.  Defaults to the empty vector.

@item make-final
Optional function applied to the terminal seed value (on which
@var{stop?}  returns true) to produce the final/rightmost portion of the
constructed vector.  Defaults to @code{(lambda (x) '#())}.
@end table

More precisely, the following (simple, inefficient) definitions hold:

@example
;; iterative
(define (vector-unfold stop? seed->item make-seed
                       first-seed base-vector make-final)
  (let loop ((seed    first-seed)
             (result  base-vector))
    (if (stop? seed)
        (vector-append result (make-final seed))
      (loop (make-seed seed)
            (vector-append result
                           (vector (seed->item seed)))))))

;; recursive
(define (vector-unfold stop? seed->item make-seed
                       first-seed base-vector make-final)
  (vector-append
     base-vector
     (let loop ((seed first-seed))
       (if (stop? seed)
           (make-final seed)
         (vector-append (vector (seed->item seed))
                        (loop (make-seed seed)))))))
@end example

This function is a fairly powerful vector constructor; we can use it to
convert a list to a vector, read a port into a vector, reverse a vector,
copy a vector, and so forth.  Examples:

@example
(port->vector p) = (vector-unfold eof-object? values
                                  (lambda (x) (read-item p))
                                  (read-item p))

(list->vector lis) = (vector-unfold null? car cdr lis)

(vector-tabulate f size) = (vector-unfold (lambda (i)
                                            (= i size))
                                          f add1 0)
@end example

@noindent
to map @code{proc} over a list @var{lis}, producing a vector:

@example
(vector-unfold null? (compose proc car) cdr lis)
@end example

Interested functional programmers may enjoy noting that
@func{vector-fold-right} and @func{vector-unfold} are in some sense
inverses.  That is, given operations @var{knull?}, @var{kar}, @var{kdr},
@var{combine}, and @var{knil} satisfying:

@example
(combine (kar x) (kdr x)) @result{} x
(knull? knil) @result{} #t
@end example

@noindent
then:

@example
(vector-fold-right combine knil
                   (vector-unfold knull? kar kdr x))
@result{} x
@end example

@noindent
and:

@example
(vector-unfold knull? kar kdr
               (vector-fold-right combine knil s))
@result{} s
@end example

The final vector constructed does not share storage with either
@var{base-vector} or the value produced by @var{make-final}.
@end defun

@c ------------------------------------------------------------

@defun vector-unfold-right @var{stop?} @var{seed->item} @var{make-seed} @var{first-seed}
@defunx vector-unfold-right @var{stop?} @var{seed->item} @var{make-seed} @var{first-seed} @var{base-vector}
@defunx vector-unfold-right @var{stop?} @var{seed->item} @var{make-seed} @var{first-seed} @var{base-vector} @var{make-final}
This is a fundamental constructor for vectors.  The arguments are like
the ones of @func{vector-unfold}.  The difference from
@func{vector-unfold} is that this function builds the vector from right
to left; more precisely, the following (simple, inefficient) definitions
hold:

@example
;; iterative
(define (vector-unfold-right
           stop? seed->item make-seed
           first-seed base-vector make-final)
  (let lp ((seed    first-seed)
           (result  base))
    (if (stop? seed)
        (vector-append (make-final seed) result)
      (loop (make-seed seed)
            (vector-append (vector (seed->item seed))
                           result)))))

;; recursive
(define (vector-unfold-right
           stop? seed->item make-seed
           first-seed base-vector make-final)
  (vector-append
     (let loop ((seed first-seed))
       (if (stop? seed)
           (make-final seed)
         (vector-append (loop (make-seed seed))
                        (vector (seed->item seed)))))
     base))
@end example

Interested functional programmers may enjoy noting that
@func{vector-fold} and @func{vector-unfold-right} are in some sense
inverses.  That is, given operations @var{knull?}, @var{kar}, @var{kdr},
@var{kons}, and @var{knil} satisfying:

@example
(kons (kar x) (kdr x)) @result{} x
(knull? knil) @result{} #t
@end example

@noindent
then:

@example
(vector-fold kons knil
             (vector-unfold-right knull? kar kdr x))
@result{} x
@end example

@noindent
and:

@example
(vector-unfold-right knull? kar kdr
                     (vector-fold kons knil s))
@result{} s
@end example

The final vector constructed does not share storage with either
@var{base-vector} or the value produced by @func{make-final}.
@end defun

@c page
@node vectors fold map
@subsection Mapping functions


All the functions described here map their @var{proc} function argument
over all the elements of the vector arguments, or the subvector
argument, from zero to the end in increasing order.  In all the
following descriptions:

@itemize
@item
Functions and syntaxes whose main name portion ends without a @code{!},
build and return a new vector, storing into it the results of mapping
@var{proc}.

@item
Functions and syntaxes whose main name portion ends with a @code{!},
mutate their @var{vec0} vector argument, storing into it the results of
mapping @var{proc}.

@item
Functions and syntaxes whose main name portion ends without a @code{*},
accept only vector arguments of equal length.

@item
Functions and syntaxes whose main name portion ends with a @code{*},
accept vector arguments of different length, stopping the iteration at
the end of the shortest.

@item
Functions whose name ends without the @code{/with-index} suffix, apply
their @var{proc} function argument as:

@example
(@var{proc}
  (vector-ref @var{vec0} @var{idx})
  (vector-ref @var{vec}  @var{idx})
  ...)
@end example

@item
Functions whose name ends with the @code{/with-index} suffix, apply
their @var{proc} function argument as:

@example
(@var{proc} @var{idx}
  (vector-ref @var{vec0} @var{idx})
  (vector-ref @var{vec}  @var{idx})
  ...)
@end example

@noindent
where @var{idx} is the index current element.
@end itemize


@defun vector-map* @var{proc} @var{vec0} @var{vec} ...
@defunx vector-map/with-index @var{proc} @var{vec0} @var{vec} ...
@defunx vector-map*/with-index @var{proc} @var{vec0} @var{vec} ...
Build and return a new vector holding the return values of mapping
@var{proc} over all the elements of the vector arguments.
@end defun


@defun vector-map! @var{proc} @var{vec0} @var{vec} ...
@defunx vector-map*! @var{proc} @var{vec0} @var{vec} ...
@defunx vector-map!/with-index @var{proc} @var{vec0} @var{vec} ...
@defunx vector-map*!/with-index @var{proc} @var{vec0} @var{vec} ...
Mutate @var{vec0} setting its elements to the return values of mapping
@var{proc} over all the elements of the vector arguments.
@end defun


@defun vector-for-each* @var{proc} @var{vec0} @var{vec} ...
@defunx vector-for-each*/with-index @var{proc} @var{vec0} @var{vec} ...
Apply @var{proc} over all the elements of the vector arguments.
@end defun

@c ------------------------------------------------------------

@subsubheading Mapping over subvectors

@deffn Function %subvector-map @var{proc} @var{vec} @var{start} @var{past}
@deffnx Function %subvector-map/with-index @var{proc} @var{vec} @var{start} @var{past}
@deffnx Macro subvector-map @var{proc} @var{S}
@deffnx Macro subvector-map/with-index @var{proc} @var{S}
Build and return a new vector mapping @var{proc} over the items in the
selected subvector of @var{vec}, from index @var{start} to index
@var{past} in increasing order.
@end deffn


@deffn Function %subvector-map! @var{proc} @var{vec} @var{start} @var{past}
@deffnx Function %subvector-map!/with-index @var{proc} @var{vec} @var{start} @var{past}
@deffnx Macro subvector-map! @var{proc} @var{S}
@deffnx Macro subvector-map!/with-index @var{proc} @var{S}
Mutate the selected subvector of @var{vec}, mapping @var{proc} over its
items from index @var{start} to index @var{past} in increasing order.
@end deffn


@deffn Function %subvector-for-each @var{proc} @var{vec} @var{start} @var{past}
@deffnx Function %subvector-for-each/with-index @var{proc} @var{vec} @var{start} @var{past}
@deffnx Macro subvector-for-each @var{proc} @var{V}
@deffnx Macro subvector-for-each/with-index @var{proc} @var{V}
Apply @var{proc} to each item in the selected subvector of @var{vec},
from index @var{start} to index @var{past} in increasing order.
@end deffn


@deffn Function %subvector-for-each-index @var{proc} @var{vec} @var{start} @var{past}
@deffnx Macro subvector-for-each-index @var{proc} @var{V}
Apply @var{proc} to each index in the selected subvector of @var{vec},
from index @var{start} to index @var{past} in increasing order.  This is
simply a method of looping over a vector that is guaranteed to be safe
and correct.
@end deffn

@c ------------------------------------------------------------

@subsubheading Syntax variants

The following syntaxes are like the corresponding functions.  They can
be a little faster when multiple vector arguments are present.


@deffn Syntax vector-map/stx @var{proc} @var{vec0} @var{vec} ...
@deffnx Syntax vector-map*/stx @var{proc} @var{vec0} @var{vec} ...
Like @func{vector-map} and @func{vector-map*}, but implemented as a
syntax.
@end deffn


@deffn Syntax vector-map!/stx @var{proc} @var{vec0} @var{vec} ...
@deffnx Syntax vector-map*!/stx @var{proc} @var{vec0} @var{vec} ...
Like @func{vector-map!} and @func{vector-map*!}, but implemented as a
syntax.
@end deffn


@deffn Syntax vector-for-each/stx @var{proc} @var{vec0} @var{vec} ...
@deffnx Syntax vector-for-each*/stx @var{proc} @var{vec0} @var{vec} ...
Like @func{vector-for-each} and @func{vector-for-each*}, but implemented
as a syntax.
@end deffn

@c page
@node vectors select
@section Selection


@deffn Function %vector-copy @var{vec} @var{start} @var{past}
@deffnx Function subvector @var{vec} @var{start} @var{past}
@deffnx Macro subvector* @var{V}
@deffnx Macro vector-copy @var{V}
Build and return a new vector holding the selected subvector of
@var{vec}.
@end deffn


@deffn Function %vector-reverse-copy @var{vec} @var{start} @var{past}
@deffnx Macro vector-reverse-copy @var{V}
Like @func{%vector-copy}, but copy the elements in the reverse order
from the selected subvector of @var{vec}.

@example
(vector-reverse-copy (view '#(5 4 3 2 1 0)
                       (start 1)
                       (past  5)))
@result{} #(1 2 3 4)
@end example
@end deffn


@deffn Function %vector-copy! @var{dst-vec} @var{dst-start} @var{src-vec} @var{src-start} @var{src-past}
@deffnx Macro vector-copy! @var{dst-V} @var{src-V}
Write the selected source subvector into the selected destination
subvector.  This function supports copying over the same vector.

The selected destination subvector starts at @var{dst-start} in
@var{dst-vec} and may extend until the end of the vector.  In the
destination vector view @var{dst-V}: If a past index is specified, it is
ignored.
@end deffn


@deffn Function %vector-reverse-copy! @var{dst-vec} @var{dst-start} @var{src-vec} @var{src-start} @var{src-past}
@deffnx Macro vector-reverse-copy! @var{V-dst} @var{V-src}
Like @func{%vector-copy!}, but this copies the elements in the reverse
order.  This function supports copying over the same vector.
@end deffn


@deffn Function %vector-take @var{nitems} @var{vec} @var{start} @var{past}
@deffnx Function %vector-take-right @var{nitems} @var{vec} @var{start} @var{past}
@deffnx Macro vector-take @var{V} @var{nitems}
@deffnx Macro vector-take-right @var{V} @var{nitems}
Return the first or last @var{nitems} of the selected subvector.  These
functions always return a newly allocated vector.
@end deffn


@deffn Function %vector-drop @var{nitems} @var{vec} @var{start} @var{past}
@deffnx Function %vector-drop-right @var{nitems} @var{vec} @var{start} @var{past}
@deffnx Macro vector-drop @var{V} @var{nitems}
@deffnx Macro vector-drop-right @var{V} @var{nitems}
Drop the first or last @var{nitems} of the selected subvector and return
the resulting vector.  These functions always return a newly allocated
vector.
@end deffn

@c page
@node vectors pad
@section Padding and trimming


@deffn Function %vector-pad @var{requested-len} @var{fill-item} @var{vec} @var{start} @var{past}
@deffnx Function %vector-pad-right @var{requested-len} @var{fill-item} @var{vec} @var{start} @var{past}
@deffnx Macro vector-pad @var{V} @var{requested-len}
@deffnx Macro vector-pad @var{V} @var{requested-len} @var{fill-item}
@deffnx Macro vector-pad-right @var{V} @var{requested-len}
@deffnx Macro vector-pad-right @var{V} @var{requested-len} @var{fill-item}
Build a vector of length @var{requested-len} comprised of @var{vec}
padded on the left or right by as many occurrences of the item
@var{fill-item} as needed.  Always return a newly allocated vector.

If @var{vec} has more than @var{requested-len} items, it is truncated on
the left or right to length @var{requested-len}.  For the macros:
@var{fill-item} defaults to @false{}.

@example
(vector-pad '#(1 2 3))           @result{} #(#f #f 1 2 3)
(vector-pad '#(1 2 3 4 5) 5)     @result{} #(1 2 3 4 5)
(vector-pad '#(9 9 1 2 3 4 5) 5) @result{} #(1 2 3 4 5)
@end example
@end deffn


@deffn Function %vector-trim @var{pred} @var{vec} @var{start} @var{past}
@deffnx Function %vector-trim-right @var{pred} @var{vec} @var{start} @var{past}
@deffnx Function %vector-trim-both @var{pred} @var{vec} @var{start} @var{past}
@deffnx Macro vector-trim @var{V} @var{pred}
@deffnx Macro vector-trim-right @var{V} @var{pred}
@deffnx Macro vector-trim-both @var{V} @var{pred}
Trim the selected subvector of @var{vec} by skipping over all items on
the left/on the right/on both sides that satisfy @var{pred}: A test
predicate that is applied to the items in @var{vec}, an item causing it
to return true is skipped.

Always return a newly allocated vector.
@end deffn

@c page
@node vectors prefix
@section Prefixes and suffixes


@deffn Function %vector-prefix-length @vari{vec} @vari{start} @vari{past} @varii{vec} @varii{start} @varii{past}
@deffnx Macro vector-prefix-length @vari{V} @varii{V}
Return the length of the longest common prefix of the two subvectors.
This is equivalent to the mismatch index for the vectors (modulo the
start index offsets).
@end deffn


@deffn Function %vector-suffix-length @vari{vec} @vari{start} @vari{past} @varii{vec} @varii{start} @varii{past}
@deffnx Macro vector-suffix-length @vari{V} @varii{V}
Return the length of the longest common suffix of the two subvectors.
@end deffn


@deffn Function %vector-prefix? @vari{vec} @vari{start} @vari{past} @varii{vec} @varii{start} @varii{past}
@deffnx Macro vector-prefix? @vari{V} @varii{V}
Return @true{} if the selected subvector of @vari{vec} is a prefix of
the selected subvector of @varii{vec}, otherwise return @false{}.  Notice
that the empty vector is a prefix of every vector.
@end deffn


@deffn Function %vector-suffix? @vari{vec} @vari{start} @vari{past} @varii{vec} @varii{start} @varii{past}
@deffnx Macro vector-suffix? @vari{V} @varii{V}
Return @true{} if the selected subvector of @vari{vec} is a suffix of
the selected subvector of @varii{vec}, otherwise return @false{}.  Notice
that the empty vector is @strong{not} a suffix of every vector.
@end deffn

@c page
@node vectors search
@section Searching


@deffn Function %vector-index @var{pred} @var{vec} @var{start} @var{past}
@deffnx Function %vector-index-right @var{pred} @var{vec} @var{start} @var{past}
@deffnx Macro vector-index @var{V} @var{pred}
@deffnx Macro vector-index-right @var{V} @var{pred}
Search through the subvector from the left or right, returning the index
of the first occurrence of an item which satisfies the predicate
@var{pred}.  If no match is found: Return @false{}.
@end deffn


@deffn Function %vector-skip @var{pred} @var{vec} @var{start} @var{past}
@deffnx Function %vector-skip-right @var{pred} @var{vec} @var{start} @var{past}
@deffnx Macro vector-skip @var{V} @var{pred}
@deffnx Macro vector-skip-right @var{V} @var{pred}
Search through the vector from the left or right, returning the index of
the first occurrence of an item which does not satisfy the predicate
@var{pred}.  If no match is found: Return @false{}.
@end deffn


@deffn Function %vector-count @var{pred} @var{vec} @var{start} @var{past}
@deffnx Macro vector-count @var{V} @var{pred}
Return a count of the number of items in @var{vec} that satisfy the
@var{pred} argument.
@end deffn


@deffn Function %vector-contains @vari{vec} @vari{start} @vari{past} @varii{vec} @varii{start} @varii{past}
@deffnx Macro vector-contains @vari{V} @varii{V}
Return true if the selected subvector of @vari{vec} contains the
selected subvector of @varii{vec}, else return @false{}.  The return
value is the index in @vari{vec} where the subvector of @varii{vec}
occurs.
@end deffn


@deffn Function %vector-binary-search @var{obj} @var{cmp} @var{vec} @var{start} @var{past}
@deffnx Macro vector-binary-search @var{V} @var{obj} @var{cmp}
Similar to @func{vector-index} and @func{vector-index-right}, but
instead of searching left to right or right to left, perform a binary
search.  @var{cmp} should be a procedure of two arguments and return:

@itemize
@item
A negative integer, indicating that its first argument is less than its
second.

@item
Zero, indicating that they are equal.

@item
A positive integer, indicating that the first argument is greater than
the second argument.
@end itemize

An example @var{cmp} might be:

@example
(lambda (char1 char2)
  (cond ((char<? char1 char2) -1)
        ((char=? char1 char2)  0)
        (else                  1)))
@end example
@end deffn

@c page
@node vectors filter
@section Filtering and deleting


@deffn Function %vector-filter @var{pred} @var{vec} @var{start} @var{past}
@deffnx Macro vector-filter @var{V} @var{pred}
Filter the selected subvector, retaining only those characters that
satisfy the @var{pred} argument.  Always return a newly allocated
vector.
@end deffn


@deffn Function %vector-delete @var{pred} @var{vec} @var{start} @var{past}
@deffnx Macro vector-delete @var{V} @var{pred}
Filter the selected subvector, retaining only those characters that do
@strong{not} satisfy the @var{pred} argument.  Always return a newly
allocated vector.
@end deffn

@c page
@node vectors list
@section List and vector conversion


@deffn Function %vector->list* @var{vec} @var{start} @var{past}
@deffnx Macro vector->list* @var{V}
Return a newly allocated list of the items that make up the given
subvector.  This is an extension of the @func{vector->list} function
that adds support for subvectors.
@end deffn


@deffn Function %reverse-vector->list @var{vec} @var{start} @var{past}
@deffnx Macro reverse-vector->list @var{V}
Like @func{%vector->list*} but reverses the order of the items from the
subvector.
@end deffn


@defun reverse-list->vector @var{char-list}
Reverse the given list of items, then compose a vector with the
result.

@example
(reverse-list->vector '(#\a #\B #\c))
@result{} #(#\c #\B #\a)
@end example
@end defun

@c page
@node vectors replicate
@section Replicate and rotate


@deffn Function %xsubvector @var{from} @var{to} @var{vec} @var{start} @var{past}
@deffnx Macro xsubvector @var{V} @var{from} @var{to}
Extended subvector procedure replicating the selected subvector ``up and
down'' index space, in both the positive and negative directions.

The call:

@example
(%xsubvector from to '#(#\a #\b #\c #\d #\e #\f #\g) 3 6)
@end example

@noindent
selects the subvector @code{#(#\d #\e #\f)} and defines the conceptual
bidirectionally--infinite vector:

@example
...  e  f  d  e  f  d  e  f  d  e  f ...
... -5 -4 -3 -2 -1  0 +1 +2 +3 +4 +5 ...
                    ^
@end example

@noindent
that is @code{#(#\d #\e #\f)} repeated in both directions.
@func{%xsubvector} returns the subvector of this vector beginning at
index @var{from}, and ending at @var{to}.

We can use this function to perform a variety of tasks:

@itemize
@item
To replicate a vector:

@example
(xsubvector '#(#\a #\b #\c) 0 7)
@result{} #(#\a #\b #\c #\a #\b #\c #\a)
@end example

@item
To rotate a vector left:

@example
(xsubvector '#(#\a #\b #\c #\d #\e #\f) 1  7)
@result{} #(#\b #\c #\d #\e #\f #\a)

(xsubvector '#(#\a #\b #\c #\d #\e #\f) 2  8)
@result{} #(#\c #\d #\e #\f #\a #\b)

(xsubvector '#(#\a #\b #\c #\d #\e #\f) 3  9)
@result{} #(#\d #\e #\f #\a #\b #\c)

(xsubvector '#(#\a #\b #\c #\d #\e #\f) 4 10)
@result{} #(#\e #\f #\a #\b #\c #\d)

(xsubvector '#(#\a #\b #\c #\d #\e #\f) 5 11)
@result{} #(#\f #\a #\b #\c #\d #\e)
@end example

@item
To rotate a vector right:

@example
(xsubvector '#(#\a #\b #\c #\d #\e #\f) -1 5)
@result{} #(#\f #\a #\b #\c #\d #\e)

(xsubvector '#(#\a #\b #\c #\d #\e #\f) -2 4)
@result{} #(#\e #\f #\a #\b #\c #\d)

(xsubvector '#(#\a #\b #\c #\d #\e #\f) -3 3)
@result{} #(#\d #\e #\f #\a #\b #\c)

(xsubvector '#(#\a #\b #\c #\d #\e #\f) -4 2)
@result{} #(#\c #\d #\e #\f #\a #\b)

(xsubvector '#(#\a #\b #\c #\d #\e #\f) -5 1)
@result{} #(#\b #\c #\d #\e #\f #\a)
@end example
@end itemize

Note that:

@itemize
@item
The @var{from}/@var{to} indices give a half--open range; the items from
index @var{from} up to, but not including, index @var{to}.

@item
The @var{from}/@var{to} indices are not in terms of the index space for
vector @var{vec}.  They are in terms of the replicated index space of
the subvector defined by @var{vec}, @var{start}, and @var{past}.
@end itemize

It is an error if @var{start} equals @var{past}.
@end deffn


@deffn Function xvector-xcopy! @var{from} @var{to} @var{target} @var{target-start} @var{source} @var{source-start} @var{source-past}
@deffnx Macro vector-xcopy! @var{target-S} @var{source-S} @var{from} @var{to}
Exactly the same as @func{%xsubvector}, but the extracted text is
written into the selected subvector of @var{target}.

This operation is not defined if @code{(eq? target start)}; we cannot
copy a vector on top of itself.
@end deffn

@c page
@node vectors mutate
@section Mutators


@defun vector-swap! @var{vec} @var{i} @var{j}
Swap the items in @var{vec} at positions @var{i} and @var{j}.
@end defun


@deffn Function %vector-fill*! @var{fill-item} @var{vec} @var{start} @var{past}
@deffnx Macro vector-fill*! @var{V} @var{fill-item}
Fill the selected subvector with @var{fill-item}, modifying the original
vector.
@end deffn

@c page
@node vectors misc
@section Miscellaneous functions


@deffn Function %vector-replace @vari{vec} @vari{start} @vari{past} @varii{vec} @varii{start} @varii{past}
@deffnx Macro vector-replace @vari{V} @varii{V}
Replace the selected subvector in @vari{vec} with the selected subvector
in @varii{vec}.  Return a newly allocated vector.
@end deffn


@deffn Function %vector-reverse @var{vec} @var{start} @var{past}
@deffnx Function %vector-reverse! @var{vec} @var{start} @var{past}
@deffnx Macro vector-reverse @var{V}
@deffnx Macro vector-reverse! @var{V}
Reverse the vector.  @func{%vector-reverse} returns the result vector
and does not alter its @var{vec} parameter.  @func{%vector-reverse!} is
the in--place side--effecting variant.
@end deffn

@c page
@node bytevectors
@chapter Bytevectors

@menu
* bytevectors u8::              Bytevectors of unsigned bytes.
@end menu

@c page
@node bytevectors u8
@section Bytevectors of unsigned bytes


The @library{bytevectors u8} and @library{bytevectors u8low} libraries
extend the bytevector operations available in the base library;
@nauref{stdlib bytevector, Bytevectors}.  While @library{bytevectors u8}
is a high level interface, @library{bytevectors u8low} is a low level
interface with the same functionalities; there is special support for
bytevectors representing strings in @ascii{} encoding.

While the library focuses on bytevectors of unsigned bytes, it can be
used also with bytevectors of signed bytes; when using bytevectors of
signed bytes: the only operations we have to care about are
@func{bytevector-s8-ref} and @func{bytevector-s8-set!}, when the bytes
extracted or inserted are used outside of these libraries.

@menu
* bytevectors u8 intro::        Introduction.
* bytevectors u8 convention::   Interface conventions.
* bytevectors u8 views::        Views over bytevectors.
* bytevectors u8 cons::         Constructors.
* bytevectors u8 pred::         Predicates.
* bytevectors u8 compar::       Comparison.
* bytevectors u8 map::          Mapping functions.
* bytevectors u8 case::         Case mapping.
* bytevectors u8 fold::         Fold and unfold.
* bytevectors u8 select::       Selection.
* bytevectors u8 pad::          Padding and trimming.
* bytevectors u8 prefix::       Prefixes and suffixes.
* bytevectors u8 search::       Searching.
* bytevectors u8 filter::       Filtering and deleting.
* bytevectors u8 list::         List and bytevector conversion.
* bytevectors u8 replicate::    Replicate and rotate.
* bytevectors u8 mutate::       Mutators.
* bytevectors u8 misc::         Miscellaneous functions.
@end menu

@c page
@node bytevectors u8 intro
@subsection Introduction


@subsubheading Library organisation

The functions are split in a high level library, @library{bytevectors
u8}, and a low level one, @library{bytevectors u8low}.  The main
difference between the two layers is that the high level library makes
heavy usage of macros to implement the @dfn{bytevector views}, which
allow accessing subvectors using a friendly syntax.

All the functions in the low level library are bound to identifiers
starting with @code{%}; for example: @func{bytevector-u8-prefix?} is a
high level macro, @func{%bytevector-u8-prefix?} is its low level
function homologous.

@subsubheading Direction of iteration

The library accesses the bytes of a vector in left--to--right or
right--to--left order depending on the convenience of the algorithm.

@subsubheading Handling side effects

Care must be taken when using functions with side effects.  One reason
for this is that some of the supported Scheme implementations may
collapse equal datum bytevectors in the source code to the same
bytevector in the program.  Mutating such a bytevector in a point of the
program, will make the change visible to other points in the program.

@c page
@node bytevectors u8 convention
@subsection Interface conventions


The following conventions hold:

@itemize
@item
Procedures whose names end in @code{-ci} are case--insensitive variants;
they interpret bytevectors as strings of characters in @ascii{}
encoding: when doing comparisons they use @func{char-ci=?} and
@func{char-ci<?} and the like.

@item
Procedures whose names end in @code{!} are side--effecting variants.
What values these procedures return is usually not specified.

@item
The order of common arguments is consistent across the different
procedures in the high level library, and consistent across the
different procedures in the low level library.  Arguments to some
functions in the high level library have different order from the ones
of the homologous low level functions.

@item
Procedures that have left/right directional variants use the following
convention:

@multitable {right--to--left} {Suffix}
@headitem Direction @tab Suffix
@item left-to-right @tab @meta{none}
@item right-to-left @tab --right
@item both @tab --both
@end multitable
@end itemize

In the procedure specifications:

@itemize
@item
A @var{B} argument is a bytevector view, which is expanded by a macro in
a triplet of values: the bytevector, the index of the first byte in the
selected subvector, the index of the byte past the last in the selected
position;  @ref{bytevectors u8 views} for details.

@item
A @var{bv} argument is a bytevector.

@item
A @var{byte} argument is an exact integer representing an unsigned byte,
that is in the range @math{[0, 256)}.

@item
A @var{char} argument is a character.

@item
The @var{start} and @var{past} arguments are half--open bytevector
indices specifying a subvector within a bytevector argument; when
unspecified, they default to zero and the length of the bytevector,
respectively.  When specified, it must be the case that:

@example
0 <= start <= past <= (bytevector-length bv)
@end example

@noindent
for the corresponding argument @var{bv}.  They typically restrict a
procedure's action to the indicated subvector; when @var{start} equals
@var{past} the selected subvector is the empty bytevector.

@item
A @var{pred} argument is a unary predicate procedure, returning a
true/false value when applied to an exact integer representing a byte.

@item
A @var{criterion} orn @var{byte/char/char-set/pred} argument is a value
used to select/search for a byte in a bytevector:

@itemize -
@item
If it is a byte, it is used in an equality test with @func{=}.

@item
If it is a character, it is used in an equality test with @func{=} after
having been converted to an exact integer with @func{char->integer}.

@item
If it is a character set, it is used in a membership test after the byte
has been converted to a character with @func{integer->char}.

@item
If it is a procedure, it is applied to the bytes as a test predicate.
@end itemize

@item
An @var{i} or @var{k} argument is an exact non--negative integer
specifying an index into a bytevector.

@item
The @var{len} and @var{nbytes} arguments are exact non--negative
integers specifying a length of a bytevector or some number of bytes.

@item
An @var{obj} argument can be any value.
@end itemize

An argument followed by @code{...} means zero--or--more elements.  So
the procedure with the signature:

@example
sum-squares x ...
@end example

@noindent
takes zero or more arguments (@var{x}, @dots{}), while the procedure
with signature:

@example
spell-check doc dict1 dict2 ...
@end example

@noindent
takes two mandatory arguments (@var{doc} and @var{dict1}) and zero or
more optional arguments (@var{dict2} ...).

If a procedure is said to return ``unspecified'', this means that
nothing at all is known about what the procedure returns; such a
procedure is not even required to be consistent from call to call; it is
simply required to return a value (or values) that may be passed to a
command continuation, e.g. as the value of an expression appearing as a
non--terminal subform of a begin expression.

Unless explicitly stated: comparison is simply done on individual bytes
of the bytevector, case--insensitive comparison is done converting the
bytes to characters with @func{integer->char} and then using the
functions:

@example
char-ci=? char-ci<? char-ci>? char-ci<=? char-ci>=?
@end example

@noindent
provided by the underlying implementation, or by case--folding
characters with the operation:

@example
(char-downcase (char-upcase (integer->char byte)))
@end example

@noindent
where the two case--mapping operations are assumed to work for
characters in the range allowed by @ascii{} encoding.

@c page
@node bytevectors u8 views
@subsection Views over bytevectors


Bytevector views are syntactic sugar to allow subvector specification
with minimum overhead; views make use of auxiliary syntaxes exported by
the @library{auxiliary-syntaxes} library and reexported by the
@library{bytevectors u8} library.  Many low level bytevector functions
act on subvectors specified with triplets of arguments:

@itemize
@item
The full bytevector.

@item
The @dfn{start index}: the index of the first byte included in the
selected subvector.

@item
The @dfn{past index}: the index of the byte past the last byte included
in the selected subvector.
@end itemize

To select the subvector @code{#vu8(6 7 8 9)} from the bytevector
@code{#vu8(0 1 2 3 4 5 6 7 8 9)} we have to determine the half--open
range of bytes, which is @math{[6, 10)}, then apply a function to the
arguments:

@example
(%the-function '#vu8(0 1 2 3 4 5 6 7 8 9) 6 10)
@end example

@noindent
while to select the whole bytevector we can do:

@example
(%the-function '#vu8(0 1 2 3 4 5 6 7 8 9) 0 10)
@end example

@noindent
or:

@example
(let ((bv '#vu8(0 1 2 3 4 5 6 7 8 9)))
  (%the-function bv 0 (bytevector-length bv)))
@end example

With the bytevector views implemented by @library{bytevectors u8}, the
low level function is wrapped by a high level syntax which can be
invoked as:

@example
(the-function '#vu8(0 1 2 3 4 5 6 7 8 9))
        ; select the whole bytevector

(the-function (view '#vu8(0 1 2 3 4 5 6 7 8 9)))
        ; select the whole bytevector

(the-function (view '#vu8(0 1 2 3 4 5 6 7 8 9)
                (start 6)))
        ; select the subvector [6, 10)

(the-function (view '#vu8(0 1 2 3 4 5 6 7 8 9)
                (start  6)
                (past  11)))
        ; select the subvector [6, 10)

(the-function (view '#vu8(0 1 2 3 4 5 6 7 8 9)
                (past 10)))
        ; select the subvector [0, 10)
@end example

@noindent
instead of a triplet of arguments, the bytevector view is a single
argument that can be:

@table @code
@item @meta{bytevector}
@itemx (view @meta{bytevector})
The bytevector itself or an unquoted list holding the bytevector itself,
prefixed by the @code{view} auxiliary syntax: it selects the whole
bytevector.

@item (view @meta{bytevector} (start @meta{start-index}))
An unquoted list holding the bytevector and the start index, with
auxiliary syntaxes @code{view} and @code{start}: it selects the
subvector from the start index to the end.

@item (view @meta{bytevector} (past @meta{past-index}))
An unquoted list holding the bytevector and the past index, with
auxiliary syntaxes @code{view} and @code{past}: it selects the subvector
from zero to the selected past index.

@itemx (view @meta{bytevector} (start @meta{start-index}) (past @meta{past-index}))
An unquoted list holding the bytevector, the start index and the past
index, with auxiliary syntaxes @code{view}, @code{start} and
@code{past}: it selects the subvector between the start and past
indexes.
@end table

@noindent
@cmeta{bytevector}, @cmeta{start-index} and @cmeta{past-index} can be
arbitrary Scheme expressions.  High level macros accepting two or more
subvectors as arguments, support bytevector views for all of them.  When
we are concerned with the overhead of bytevector views, we can use the
low level functions directly.

In the following documentation: low level functions and high level
macros are documented together; only the meaning of arguments to the low
level function are described, the meaning of high level arguments is
obvious.

@c page
@node bytevectors u8 cons
@subsection Constructors


@defun bytevector-u8-append @varo{bv} @var{bv} ...
Return a newly allocated bytevector whose bytes form the concatenation
of the given bytevectors.
@end defun


@defun bytevector-u8-concatenate @var{bvs-list}
Append the elements of @var{bvs-list} together into a single bytevector.
Guaranteed to return a freshly allocated bytevector.
@end defun


@deffn Function %bytevector-u8-concatenate-reverse @var{bvs-list} @var{final-bv} @var{nbytes}
@deffnx Macro bytevector-u8-concatenate-reverse @var{bvs-list}
@deffnx Macro bytevector-u8-concatenate-reverse @var{bvs-list} @var{final-bv}
@deffnx Macro bytevector-u8-concatenate-reverse @var{bvs-list} @var{final-bv} @var{nbytes}
Reverse @var{bvs-list} then concatenate the elements, which must be
bytevectors.  The first @var{nbytes} bytes in @var{final-bv} are consed
onto the beginning of @var{bvs-list} before performing the reversal and
concatenation operations.

@var{final-bv} defaults to the empty bytevector and @var{nbytes}
defaults to the length of @var{final-bv}.

This procedure is useful in the construction of procedures that
accumulate byte data into lists of byte buffers, and wish to convert the
accumulated data into a single bytevector when done.
@end deffn


@defun bytevector-u8-tabulate @var{integer->byte} @var{len}
Construct a bytevector of size @var{len} by applying @var{integer->byte}
to each index in the range @math{[0, @var{len})} to produce the
corresponding byte element.  The order in which @var{integer->byte} is
applied to the indices is not specified.
@end defun

@c page
@node bytevectors u8 pred
@subsection Predicates


@defun bytevector-u8-null? @var{obj}
Return @true{} if @var{obj} is the empty bytevector, otherwise return
@false{}.
@end defun


@deffn Function %bytevector-u8-every @var{byte/char/char-set/pred} @var{bv} @var{start} @var{past}
@deffnx Function %bytevector-u8-any @var{byte/char/char-set/pred} @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-every @var{byte/char/char-set/pred} @var{B}
@deffnx Macro bytevector-u8-any @var{byte/char/char-set/pred} @var{B}
Check to see if the given criteria is true on every/any byte in
@var{bv}, proceeding from left (index @var{start}) to right (index
@var{past}).

If the selected subvector is empty: the return value is @false{}.

If @var{byte/char/char-set/pred} is a byte, it is tested for equality
with the elements of @var{B}.

If @var{byte/char/char-set/pred} is a character, it is tested for
equality with the elements of @var{B}.

If @var{byte/char/char-set/pred} is a character set, the elements of
@var{B} are tested for membership in the set.

If @var{byte/char/char-set/pred} is a predicate procedure, it is applied
to the elements of @var{B}.  The predicate is ``witness--generating'':

@itemize
@item
If @func{bytevector-u8-any} returns true, the returned true value is the
one produced by the application of the predicate.

@item
If @func{bytevector-u8-every} returns true, the returned true value is
the one produced by the application of the predicate to the last byte in
the subvector.
@end itemize

If the predicate is applied to the final element of the selected
subvector, that final application is a tail call.

The names of these procedures do not end with a question mark; this is
to indicate that, in the predicate case, they do not return a simple
boolean (@true{} or @false{}), but a general value.
@end deffn

@c page
@node bytevectors u8 compar
@subsection Comparison


@menu
* bytevectors u8 compar lexi::       Lexicographic comparison.
* bytevectors u8 compar dict::       String dictionary comparison.
* bytevectors u8 compar number::     String and numeric parts
                                     lexicographic comparison.
* bytevectors u8 compar dictnumber:: String and numeric parts
                                     dictionary comparison.
@end menu

@c page
@node bytevectors u8 compar lexi
@subsubsection Lexicographic comparison


@deffn Function %bytevector-u8-compare @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past} @var{proc<} @var{proc=} @var{proc>}
@deffnx Function %bytevector-u8-compare-ci @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past} @var{proc<} @var{proc=} @var{proc>}
@deffnx Macro bytevector-u8-compare @vari{B} @varii{B} @var{proc<} @var{proc=} @var{proc>}
@deffnx Macro bytevector-u8-compare-ci @vari{B} @varii{B} @var{proc<} @var{proc=} @var{proc>}
Determine the @dfn{mismatch index} between the two subvectors: the
largest index @math{i} such that for every @math{0 <= j < i},
@math{bv1[j] = bv2[j]}; that is, @math{i} is the first position that
does not match.

The mismatch index is always an index into @vari{bv}; in the case of
equal bytevectorss, it is always @vari{past}; the functions observe the
protocol in this redundant case for uniformity.

@var{proc<}, @var{proc=}, or @var{proc>} are applied to the mismatch
index (not byte), depending upon whether the subvector of @vari{bv} is
less than, equal to, or greater than the subvector of @varii{bv}.  The
result of the application is returned.

If we just want to have the mismatch index as return value: we can use
@func{values} as value for @var{proc<}, @var{proc=} and @var{proc>}.
Another interesting option is to use @code{(lambda (mismatch-index) #f)}
or @code{(lambda (mismatch-index) #t)}.

Examples:

@example
(define S string->utf8)

(bytevector-u8-compare (S "abcd") (S "abcd")
                       values values values)
@result{} 4

(bytevector-u8-compare (S "abcd") (S "abcd12")
                       values values values)
@result{} 4
@end example
@end deffn


@deffn Function %bytevector-u8= @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past}
@deffnx Function %bytevector-u8-ci= @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past}
@deffnx Macro bytevector-u8= @vari{B} @varii{B}
@deffnx Macro bytevector-u8-ci= @vari{B} @varii{B}
Compare two subvectors: return true if they are equal, @false{}
otherwise.
@end deffn


@deffn Function %bytevector-u8<> @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past}
@deffnx Function %bytevector-u8-ci<> @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past}
@deffnx Macro bytevector-u8<> @vari{B} @vari{B}
@deffnx Macro bytevector-u8-ci<> @vari{B} @varii{B}
Compare two subvectors: return @false{} if they are equal, true
otherwise.
@end deffn


The following predicates are the lexicographic extensions of the
corresponding integer and character predicates.  A bytevector @vari{bv}
is ``lexicographically'' less than @varii{bv} if, after conversion to
strings in @ascii{} encoding, @vari{bv} would come first in a
dictionary.


@deffn Function %bytevector-u8< @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past}
@deffnx Function %bytevector-u8-ci< @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past}
@deffnx Macro bytevector-u8< @vari{B} @varii{B}
@deffnx Macro bytevector-u8-ci< @vari{B} @varii{B}
Compare two subvectors: return true if the first is lexicographically
less than the second, @false{} otherwise.  If @varii{bv} is longer than
@vari{bv} but the subvectors are equal up to the end of @vari{bv}:
return @true{}.
@end deffn


@deffn Function %bytevector-u8<= @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past}
@deffnx Function %bytevector-u8-ci<= @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past}
@deffnx Macro bytevector-u8<= @vari{B} @varii{B}
@deffnx Macro bytevector-u8-ci<= @vari{B} @varii{B}
Compare two subvectors: return true if the first is lexicographically
less than, or equal to, the second; @false{} otherwise.  If @varii{bv}
is longer than @vari{bv} but the subvectors are equal up to the end of
@vari{bv}: return @true{}.
@end deffn


@deffn Function %bytevector-u8> @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past}
@deffnx Function %bytevector-u8-ci> @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past}
@deffnx Macro bytevector-u8> @vari{B} @varii{B}
@deffnx Macro bytevector-u8-ci> @vari{B} @varii{B}
Compare two subvectors: return true if the first is lexicographically
greater than the second, @false{} otherwise.  If @vari{bv} is longer
than @varii{bv} but the subvectors are equal up to the end of
@varii{bv}: return @true{}.
@end deffn


@deffn Function %bytevector-u8>= @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past}
@deffnx Function %bytevector-u8-ci>= @vari{bv} @vari{beg} @vari{past} @varii{bv} @varii{beg} @varii{past}
@deffnx Macro bytevector-u8>= @vari{B} @varii{B}
@deffnx Macro bytevector-u8-ci>= @vari{B} @varii{B}
Compare two subvectors: return true if the first is lexicographically
greater than, or equal to, the second; @false{} otherwise.  If @vari{bv}
is longer than @varii{bv} but the subvectors are equal up to the end of
@varii{bv}: return @true{}.
@end deffn

@c page
@node bytevectors u8 compar dict
@subsubsection Bytevector dictionary comparison


Dictionary comparison is like lexicographic bytevector comparison, but
bytes representing white space characters in @ascii{} encoding are
ignored.  Recognised white spaces are:

@example
#\space         #\tab           #\vtab
#\linefeed      #\return        #\page
@end example

@noindent
that is bytes with value:

@example
32              9               11
10              13              12
@end example


@defun bytevector-u8-dictionary-compare @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary-compare @vari{bv} @varii{bv}
Compare the bytevector arguments and return a ternary result: @samp{-1}
if @vari{bv} is less than @varii{bv}, @samp{0} if @vari{bv} is equal to
@varii{bv}, @samp{+1} if @vari{bv} is greater than @varii{bv}.  The
comparison is case sensitive.
@end defun


@defun bytevector-u8-dictionary=? @vari{bv} @varii{bv}
@defunx bytevector-u8-dictionary<>? @vari{bv} @varii{bv}
@defunx bytevector-u8-dictionary<? @vari{bv} @varii{bv}
@defunx bytevector-u8-dictionary<=? @vari{bv} @varii{bv}
@defunx bytevector-u8-dictionary>? @vari{bv} @varii{bv}
@defunx bytevector-u8-dictionary>=? @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary=? @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary<>? @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary<? @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary<=? @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary>? @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary>=? @vari{bv} @varii{bv}
Return @true{} or @false{}, depending on whether the arguments comply
with the predicate.  The comparison is case sensitive.
@end defun


@defun bytevector-u8-dictionary-compare-ci @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary-compare-ci @vari{bv} @varii{bv}
Compare the bytevector arguments and return a ternary result: @samp{-1}
if @vari{bv} is less than @varii{bv}, @samp{0} if @vari{bv} is equal to
@varii{bv}, @samp{+1} if @vari{bv} is greater than @varii{bv}.  The
comparison is case insensitive.
@end defun


@defun bytevector-u8-dictionary-ci=? @vari{bv} @varii{bv}
@defunx bytevector-u8-dictionary-ci<>? @vari{bv} @varii{bv}
@defunx bytevector-u8-dictionary-ci<? @vari{bv} @varii{bv}
@defunx bytevector-u8-dictionary-ci>? @vari{bv} @varii{bv}
@defunx bytevector-u8-dictionary-ci<=? @vari{bv} @varii{bv}
@defunx bytevector-u8-dictionary-ci>=? @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary-ci=? @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary-ci<>? @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary-ci<? @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary-ci>? @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary-ci<=? @vari{bv} @varii{bv}
@defunx %bytevector-u8-dictionary-ci>=? @vari{bv} @varii{bv}
Return @true{} or @false{}, depending on whether the arguments comply
with the predicate.  The comparison is case insensitive.
@end defun

@c page
@node bytevectors u8 compar number
@subsubsection Bytevector and numeric parts lexicographic comparison


Bytevector/numbers comparison splits the bytevectors to compare into
their numeric and non--numeric parts and compares the parts one by one;
numeric parts are sequences of bytes which correspond to number digits
in @ascii{} encoding.  For example, the string @samp{foo4bar3zab10} is
the bytevector:

@example
#vu8(102 111 111 52 98 97 114 51 122 97 98 49 48)
@end example

@noindent
and it is split into the following list:

@example
(#vu8(102 111 111) 4
 #vu8(98 97 114)   3
 #vu8(122 97 98)   10)
@end example

@noindent
in which non--numeric parts are retained as Scheme bytevectors and
numeric parts become exact integers; numeric parts only become
@strong{exact} integer, never flonums.  Bytevector parts are compared
with the ordinary lexicographic operators @func{bytevector-u8<} and
@func{bytevector=?}  (or @func{bytevector-u8-ci<} and
@func{bytevector-u8-ci=}), while numeric parts are compared with the
ordinary @func{<} and @func{=} operators; a bytevector part and a
numeric part are compared by comparing the bytevectors.


@defun bytevector-u8/numbers-compare @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-compare @vari{bv} @varii{bv}
Compare the bytevector and numeric parts of the arguments and return a
ternary result: @samp{-1} if @vari{bv} is less than @varii{bv}, @samp{0}
if @vari{bv} is equal to @varii{bv}, @samp{+1} if @vari{bv} is greater
than @varii{bv}.  The comparison is case sensitive.
@end defun


@defun bytevector-u8/numbers=? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers<>? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers<? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers<=? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers>? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers>=? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers=? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers<>? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers<? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers<=? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers>? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers>=? @vari{bv} @varii{bv}
Return @true{} or @false{}, depending on whether the arguments comply
with the predicate.
@end defun


@defun bytevector-u8/numbers-compare-ci @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-compare-ci @vari{bv} @varii{bv}
Compare the string and numeric parts of the arguments and return a
ternary result: @samp{-1} if @vari{bv} is less than @varii{bv}, @samp{0}
if @vari{bv} is equal to @varii{bv}, @samp{+1} if @vari{bv} is greater
than @varii{bv}.  The comparison is case insensitive.
@end defun


@defun bytevector-u8/numbers-ci=? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-ci<>? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-ci<? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-ci>? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-ci<=? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-ci>=? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-ci=? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-ci<>? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-ci<? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-ci>? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-ci<=? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-ci>=? @vari{bv} @varii{bv}
Return @true{} or @false{}, depending on whether the arguments comply
with the predicate.  The comparison is case insensitive.
@end defun

@c page
@node bytevectors u8 compar dictnumber
@subsubsection Bytevector and numeric parts dictionary comparison


Bytevector/numbers dictionary comparison is like bytevector/numbers
comparison, but white space characters in the bytevector arguments are
ignored.  White spaces are:

@example
#\space         #\tab           #\vtab
#\linefeed      #\return        #\page
@end example


@defun bytevector-u8/numbers-dictionary-compare @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary-compare @vari{bv} @varii{bv}
Compare the bytevector and numeric parts of the arguments and return a
ternary result: @samp{-1} if @vari{bv} is less than @varii{bv}, @samp{0}
if @vari{bv} is equal to @varii{bv}, @samp{+1} if @vari{bv} is greater
than @varii{bv}.  The comparison is case sensitive.
@end defun


@defun bytevector-u8/numbers-dictionary=? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-dictionary<>? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-dictionary<? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-dictionary<=? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-dictionary>? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-dictionary>=? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary=? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary<>? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary<? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary<=? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary>? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary>=? @vari{bv} @varii{bv}
Return @true{} or @false{}, depending on whether the arguments comply
with the predicate.
@end defun


@defun bytevector-u8/numbers-dictionary-compare-ci @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary-compare-ci @vari{bv} @varii{bv}
Compare the bytevector and numeric parts of the arguments and return a
ternary result: @samp{-1} if @vari{bv} is less than @varii{bv}, @samp{0}
if @vari{bv} is equal to @varii{bv}, @samp{+1} if @vari{bv} is greater
than @varii{bv}.  The comparison is case insensitive.
@end defun


@defun bytevector-u8/numbers-dictionary-ci=? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-dictionary-ci<>? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-dictionary-ci<? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-dictionary-ci>? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-dictionary-ci<=? @vari{bv} @varii{bv}
@defunx bytevector-u8/numbers-dictionary-ci>=? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary-ci=? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary-ci<>? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary-ci<? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary-ci>? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary-ci<=? @vari{bv} @varii{bv}
@defunx %bytevector-u8/numbers-dictionary-ci>=? @vari{bv} @varii{bv}
Return @true{} or @false{}, depending on whether the arguments comply
with the predicate.  The comparison is case insensitive.
@end defun

@c page
@node bytevectors u8 map
@subsection Mapping functions


@defun bytevector-u8-map @var{proc} @varo{bv} @var{bv} ...
Build and return a newly--allocated bytevector mapping @var{proc} over
all the bytes of the bytevector arguments, from zero to the end in
increasing order.  It is an error if the bytevectorss have different
length.

@var{proc} must return an exact integer representing a byte and it is
applied to the elements as:

@example
(@var{proc} @var{idx}
  (bytevector-u8-ref @varo{bv} @var{idx})
  (bytevector-u8-ref @var{bv}  @var{idx})
  ...)
@end example

@noindent
where @var{idx} is the current index.
@end defun


@defun bytevector-u8-map! @var{proc} @varo{bv} @var{bv} ...
@defunx bytevector-u8-map*! @var{proc} @varo{bv} @var{bv} ...
Mutate bytevector @varo{bv} mapping @var{proc} over all the elements of
the bytevector arguments, from zero to the end in increasing order.

@func{bytevector-u8-map!} must be applied to bytevectorss of the same
length; @func{bytevector-u8-map*!} accepts bytevectorss of different
length and iterates until the end of the shorter is reached.

@var{proc} is applied to the elements as:

@example
(@var{proc} @var{idx}
  (bytevector-u8-ref @varo{bv} @var{idx})
  (bytevector-u8-ref @var{bv}  @var{idx})
  ...)
@end example

@noindent
where @var{idx} is the current index.
@end defun


@defun bytevector-u8-for-each* @var{proc} @varo{bv} @var{bv} ...
Apply @var{proc} over all the elements of the bytevector arguments, from
zero to the end in increasing order.  This function accepts bytevectorss
of different length and iterates until the end of the shorter is
reached.

@var{proc} is applied to the elements as:

@example
(@var{proc} @var{idx}
  (bytevector-u8-ref @varo{bv} @var{idx})
  (bytevector-u8-ref @var{bv}  @var{idx})
  ...)
@end example

@noindent
where @var{idx} is the current index.
@end defun


@subsubheading Mapping over subvectors


@deffn Function %subbytevector-u8-map @var{proc} @var{bv} @var{start} @var{past}
@deffnx Macro subbytevector-u8-map @var{proc} @var{B}
Build and return a new bytevector mapping @var{proc} over the bytes in
the selected subvector of @var{bv}, from index @var{start} to index
@var{past} in increasing order.  @var{proc} must be a byte--to--byte
procedure.
@end deffn


@deffn Function %subbytevector-u8-map! @var{proc} @var{bv} @var{start} @var{past}
@deffnx Macro subbytevector-u8-map! @var{proc} @var{B}
Mutate the selected subvector of @var{bv}, mapping @var{proc} over its
bytes from index @var{start} to index @var{past} in increasing order.
@var{proc} must be a byte--to--byte procedure.
@end deffn


@deffn Function %subbytevector-u8-for-each @var{proc} @var{bv} @var{start} @var{past}
@deffnx Macro subbytevector-u8-for-each @var{proc} @var{B}
Apply @var{proc} to each byte in the selected subvector of @var{bv},
from index @var{start} to index @var{past} in increasing order.
@end deffn


@deffn Function %subbytevector-u8-for-each-index @var{proc} @var{bv} @var{start} @var{past}
@deffnx Macro subbytevector-u8-for-each-index @var{proc} @var{B}
Apply @var{proc} to each index in the selected subvector of @var{bv},
from index @var{start} to index @var{past} in increasing order.  This is
simply a method of looping over a bytevector that is guaranteed to be
safe and correct.
@end deffn

@c page
@node bytevectors u8 case
@subsection Case mapping


@deffn Function %bytevector-u8-titlecase*! @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-titlecase* @var{B}
@deffnx Macro bytevector-u8-titlecase*! @var{B}
For every byte @math{b}, interpreted in @ascii{} encoding, in the
selected range of @var{B}: if @math{b} is preceded by a byte
representing a cased character in @ascii{} encoding, @math{b} is
downcased; otherwise it is titlecased.

@func{bytevector-u8-titlecase*} returns the result string and does not
alter its argument.  @func{bytevector-u8-titlecase!} is the in--place
side--effecting variant.

Note that the byte preceding @code{bv[start]} has no effect on the
titlecase decision for byte @code{bv[start]}.
@end deffn


@deffn Macro bytevector-u8-upcase* @var{B}
@deffnx Macro bytevector-u8-upcase*! @var{B}
@deffnx Macro bytevector-u8-downcase* @var{B}
@deffnx Macro bytevector-u8-downcase*! @var{B}
Interpret the bytes in the selected subvector in @ascii{} encoding:
raise or lower the case of the alphabetic characters.  There are no low
level functions for these macros because they are just wrappers for
@func{%bytevector-u8-map} and @func{%bytevector-u8-map!}.

@func{bytevector-u8-upcase} and @func{bytevector-u8-downcase} return the
result string and do not alter their argument.
@func{bytevector-u8-upcase!} and @func{bytevector-u8-downcase!} are the
in--place side--effecting variants.
@end deffn

@c page
@node bytevectors u8 fold
@subsection Fold and unfold


@defun bytevector-u8-fold-left @var{kons} @var{knil} @varo{bv} @var{bv} ...
@defunx bytevector-u8-fold-right @var{kons} @var{knil} @varo{bv} @var{bv} ...
The fundamental bytevector iterator.  The bytevector arguments must have
the same length.

@var{kons} is iterated left--to--right over each index in all of the
bytevectors, stopping at the end of the shortest; @var{kons} is applied
as:

@example
(@var{kons} @var{idx} @var{state}
  (bytevector-u8-ref @varo{bv} @var{idx})
  (bytevector-u8-ref @var{bv}  @var{idx})
  )
@end example

@noindent
where @var{state} is the current state value; the current state value
begins with @var{knil}, and becomes whatever @var{kons} returned at the
respective iteration; @var{idx} is the current index.

@func{bytevector-u8-fold-right} is similar to @func{bytevector-u8-fold}, but it
iterates right--to--left.

@quotation
Notice that to allow for an unspecified number of arguments, these folds
hand the state as first argument to @var{kons}, as opposed to the usual
fold arguments.
@end quotation
@end defun


@defun bytevector-u8-fold-left* @var{kons} @var{knil} @varo{bv} @var{bv} ...
@defunx bytevector-u8-fold-right* @var{kons} @var{knil} @varo{bv} @var{bv} ...
Like @func{bytevector-u8-fold} and @func{bytevector-u8-unfold} but
accept bytevectors of different length, iterating until the end of the
shortest one.
@end defun

@c ------------------------------------------------------------

@deffn Function %subbytevector-u8-fold-left @var{kons} @var{knil} @var{bv} @var{start} @var{past}
@deffnx Function %subbytevector-u8-fold-right @var{kons} @var{knil} @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-fold @var{kons} @var{knil} @var{S}
@deffnx Macro bytevector-u8-fold-right @var{kons} @var{knil} @var{S}
Fundamental iterators for subvectors.  @var{kons} is iterated over each
byte of the selected subvector:

@example
(@var{kons}
  (bytevector-u8-ref @var{bv} (+ @var{start} @var{idx}))
  @var{state})
@end example

@noindent
where @var{state} is the current state value; the current state value
begins with @var{knil}, and becomes whatever @var{kons} returned at the
respective iteration; @var{idx} is the current index.

The left--fold iterator, @func{%subbytevector-u8-fold-left}, builds the return
value as:

@example
(@var{kons}
  (bytevector-u8-ref @var{bv} (- @var{past} 1))
  (@var{kons}
    (bytevector-u8-ref @var{bv} (- @var{past} 2))
    ...
      (@var{kons}
        (bytevector-u8-ref @var{bv} (+ @var{start} 2))
        (@var{kons}
           (bytevector-u8-ref @var{bv} (+ @var{start} 1))
           (@var{kons}
              (bytevector-u8-ref @var{bv} @var{start})
              @var{knil})))))
@end example

The right--fold iterator, @func{%subbytevector-u8-fold-right}, builds the
return value as:

@example
(@var{kons}
  (bytevector-u8-ref @var{bv} @var{start}
  (@var{kons}
    (bytevector-u8-ref @var{bv} (+ @var{start} 1))
    ...
      (@var{kons}
        (bytevector-u8-ref @var{bv} (- @var{past} 3))
        (@var{kons}
           (bytevector-u8-ref @var{bv} (- @var{past} 2))
           (@var{kons}
              (bytevector-u8-ref @var{bv} (- @var{past} 1))
              @var{knil})))))
@end example
@end deffn

@c ------------------------------------------------------------

@defun bytevector-u8-unfold @var{stop?} @var{seed->char} @var{make-seed} @var{first-seed}
@defunx bytevector-u8-unfold @var{stop?} @var{seed->char} @var{make-seed} @var{first-seed} @var{base-bv}
@defunx bytevector-u8-unfold @var{stop?} @var{seed->char} @var{make-seed} @var{first-seed} @var{base-bv} @var{make-final}
This is a fundamental constructor for bytevectors.  Arguments description
follows.

@table @var
@item make-seed
A map function used to generate a series of ``seed'' values from the
initial seed:

@example
@var{first-seed}
(@var{make-seed} @var{first-seed})            @result{} seed2
(@var{make-seed} seed2)                 @result{} seed3
(@var{make-seed} seed3)                 @result{} seed4
...
@end example

@item stop?
A predicate function telling when to stop generating bytes; when it
returns true when applied to one of the seed values.

@item seed->char
Map function mapping each seed value to the corresponding byte in the
result bytevector.  These bytes are assembled into the bytevector in a
left--to--right order.

@item base-bv
An optional bytevector which is used as initial/leftmost portion of the
constructed bytevector.  Defaults to the empty bytevector.

@item make-final
Optional function applied to the terminal seed value (on which
@var{stop?}  returns true) to produce the final/rightmost portion of the
constructed bytevector.  Defaults to @code{(lambda (x) "")}.
@end table

The final bytevector constructed does not share storage with either
@var{base-bv} or the value produced by @var{make-final}.
@end defun

@c ------------------------------------------------------------

@defun bytevector-u8-unfold-right @var{stop?} @var{seed->char} @var{make-seed} @var{first-seed}
@defunx bytevector-u8-unfold-right @var{stop?} @var{seed->char} @var{make-seed} @var{first-seed} @var{base-bv}
@defunx bytevector-u8-unfold-right @var{stop?} @var{seed->char} @var{make-seed} @var{first-seed} @var{base-bv} @var{make-final}
This is a fundamental constructor for bytevectors.  The arguments are like
the ones of @func{bytevector-u8-unfold}.  The difference from
@func{bytevector-u8-unfold} is that this function builds the bytevector from right
to left.

The final bytevector constructed does not share storage with either
@var{base-bv} or the value produced by @var{make-final}.
@end defun

@c page
@node bytevectors u8 select
@subsection Selection


@defun subbytevector-u8 @var{bv} @var{start} @var{past}
Build and return a new bytevector holding a copy of the subvector
selected in @var{bv}.
@end defun


@deffn Macro subbytevector-u8* @var{B}
Wrapper for @func{subbytevector-u8} accepting a bytevector view as
argument.
@end deffn


@deffn Function %bytevector-u8-copy* @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-copy* @var{B}
The function @func{%bytevector-u8-copy*} is an alias for
@func{subbytevector-u8}; the macro @func{bytevector-u8-copy*} is an
alias for @func{subbytevector-u8*}.

@quotation
These exist for symmetry with the @library{vectors} library; they allow
more confidence in converting a vector function into a bytevector
function, and vice versa, by just replacing the string @code{vector} in
the function names with the string @code{bytevector-u8}, and vice versa.
@end quotation
@end deffn


@deffn Function %bytevector-u8-reverse-copy* @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-reverse-copy* @var{B}
Like @func{%bytevector-u8-copy*}, but copy the elements in the reverse
order from the selected subvector.
@end deffn


@deffn Function %bytevector-u8-copy*! @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
@deffnx Macro bytevector-u8-copy*! @var{dst-S} @var{src-S}
Write the selected source subvector into the selected destination
subvector.  This function is the side--effecting variant of
@func{subbytevector-u8} and @func{subbytevector-u8*}.  This function
supports copying over the same bytevector.

The selected destination subvector starts at @var{dst-start} in
@var{dst-bv} and may extend until the end of the bytevector.  In the
destination bytevector view @var{dst-S}: if a past index is specified,
it is ignored.
@end deffn


@deffn Function %bytevector-u8-reverse-copy*! @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
@deffnx Macro bytevector-u8-reverse-copy*! @var{B-dst} @var{B-src}
Like @func{%bytevector-u8-copy*!}, but this copies the elements in the reverse
order.  This function supports copying over the same bytevector.
@end deffn


@deffn Function %bytevector-u8-take @var{nbytes} @var{bv} @var{start} @var{past}
@deffnx Function %bytevector-u8-take-right @var{nbytes} @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-take @var{B} @var{nbytes}
@deffnx Macro bytevector-u8-take-right @var{B} @var{nbytes}
Return the first or last @var{nbytes} of the selected subvector.  These
functions always return a newly allocated bytevector.
@end deffn


@deffn Function %bytevector-u8-drop @var{nbytes} @var{bv} @var{start} @var{past}
@deffnx Function %bytevector-u8-drop-right @var{nbytes} @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-drop @var{B} @var{nbytes}
@deffnx Macro bytevector-u8-drop-right @var{B} @var{nbytes}
Drop the first or last @var{nbytes} of the selected subvector and return
the resulting bytevector.  These functions always return a newly
allocated bytevector.
@end deffn

@c page
@node bytevectors u8 pad
@subsection Padding and trimming


@deffn Function %bytevector-u8-pad @var{requested-len} @var{fill} @var{bv} @var{start} @var{past}
@deffnx Function %bytevector-u8-pad-right @var{requested-len} @var{fill} @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-pad @var{B} @var{requested-len}
@deffnx Macro bytevector-u8-pad @var{B} @var{requested-len} @var{fill}
@deffnx Macro bytevector-u8-pad-right @var{B} @var{requested-len}
@deffnx Macro bytevector-u8-pad-right @var{B} @var{requested-len} @var{fill}
Build a bytevector of length @var{requested-len} comprised of @var{bv}
padded on the left or right by as many occurrences of the byte or
character @var{fill} as needed.  Always return a newly allocated
bytevector.

If @var{bv} has more than @var{requested-len} bytes, it is truncated on
the left or right to length @var{requested-len}.  For the macros:
@var{fill} defaults to the byte representing @code{#\space} in @ascii{}
encoding.
@end deffn


@deffn Function %bytevector-u8-trim @var{byte/char/char-set/pred} @var{bv} @var{start} @var{past}
@deffnx Function %bytevector-u8-trim-right @var{byte/char/char-set/pred} @var{bv} @var{start} @var{past}
@deffnx Function %bytevector-u8-trim-both @var{byte/char/char-set/pred} @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-trim @var{B} @var{byte/char/char-set/pred}
@deffnx Macro bytevector-u8-trim-right @var{B} @var{byte/char/char-set/pred}
@deffnx Macro bytevector-u8-trim-both @var{B} @var{byte/char/char-set/pred}
Trim @var{bv} by skipping over all bytes on the left/on the
right/on both sides that satisfy the second parameter
@var{byte/char/char-set/pred}:

@itemize
@item
If it is an exact integer @var{byte}, bytes equal to @var{byte} are
trimmed.

@item
If it is a character @var{char}, bytes equal to the @ascii{}
representation of @var{char} are trimmed.

@item
If it is a char set @var{char-set}, bytes representing @ascii{}
characters contained in @var{char-set} are trimmed.

@item
If it is a predicate @var{pred}, it is a test predicate that is applied
to the bytes in @var{B}; a byte causing it to return true is skipped.
@end itemize

Always return a newly allocated bytevector.
@end deffn

@c page
@node bytevectors u8 prefix
@subsection Prefixes and suffixes


@deffn Function %bytevector-u8-prefix-length @vari{bv} @vari{start} @vari{past} @varii{bv} @varii{start} @varii{past}
@deffnx Function %bytevector-u8-prefix-length-ci @vari{bv} @vari{start} @vari{past} @varii{bv} @varii{start} @varii{past}
@deffnx Macro bytevector-u8-prefix-length @vari{B} @varii{B}
@deffnx Macro bytevector-u8-prefix-length-ci @vari{B} @varii{B}
Return the length of the longest common prefix of the two subvectors.
This is equivalent to the ``mismatch index'' for the bytevectors (modulo
the start index offsets).
@end deffn


@deffn Function %bytevector-u8-suffix-length @vari{bv} @vari{start} @vari{past} @varii{bv} @varii{start} @varii{past}
@deffnx Function %bytevector-u8-suffix-length-ci @vari{bv} @vari{start} @vari{past} @varii{bv} @varii{start} @varii{past}
@deffnx Macro bytevector-u8-suffix-length @vari{B} @varii{B}
@deffnx Macro bytevector-u8-suffix-length-ci @vari{B} @varii{B}
Return the length of the longest common suffix of the two subvectors.
@end deffn


@deffn Function %bytevector-u8-prefix? @vari{bv} @vari{start} @vari{past} @varii{bv} @varii{start} @varii{past}
@deffnx Function %bytevector-u8-prefix-ci? @vari{bv} @vari{start} @vari{past} @varii{bv} @varii{start} @varii{past}
@deffnx Macro bytevector-u8-prefix? @vari{B} @varii{B}
@deffnx Macro bytevector-u8-prefix-ci? @vari{B} @varii{B}
Return @true{} if the subvector @vari{B} is a prefix of the subvector
@varii{B}, otherwise return @false{}.  Notice that the empty bytevector
is a prefix of every bytevector.
@end deffn


@deffn Function %bytevector-u8-suffix? @vari{bv} @vari{start} @vari{past} @varii{bv} @varii{start} @varii{past}
@deffnx Function %bytevector-u8-suffix-ci? @vari{bv} @vari{start} @vari{past} @varii{bv} @varii{start} @varii{past}
@deffnx Macro bytevector-u8-suffix? @vari{B} @varii{B}
@deffnx Macro bytevector-u8-suffix-ci? @vari{B} @varii{B}
Return @true{} if the subvector @vari{B} is a suffix of the subvector
@varii{B}, otherwise return @false{}.  Notice that the empty bytevector
is @strong{not} a suffix of every bytevector.
@end deffn

@c page
@node bytevectors u8 search
@subsection Searching


@deffn Function %bytevector-u8-index @var{criterion} @var{bv} @var{start} @var{past}
@deffnx Function %bytevector-u8-index-right @var{criterion} @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-index @var{B} @var{criterion}
@deffnx Macro bytevector-u8-index-right @var{B} @var{criterion}
Search through the bytevector from the left or right, returning the
index of the first occurrence of a byte which matches the
@var{criterion}:

@itemize
@item
If @var{criterion} is an exact integer: the byte has to be equal to it.

@item
If @var{criterion} is a character: the byte has to be equal to it.

@item
If @var{criterion} is a character set: the byte, interpreted as @ascii{}
character, has to be contained in it.

@item
If @var{criterion} is a procedure: the procedure applied to the byte
must return true.
@end itemize

If no match is found: return @false{}.
@end deffn


@deffn Function %bytevector-u8-skip @var{criterion} @var{bv} @var{start} @var{past}
@deffnx Function %bytevector-u8-skip-right @var{criterion} @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-skip @var{B} @var{criterion}
@deffnx Macro bytevector-u8-skip-right @var{B} @var{criterion}
Search through the bytevector from the left or right, returning the
index of the first occurrence of a byte which does not match the
@var{criterion}:

@itemize
@item
If @var{criterion} is an exact integer: the byte has to be different
from it.

@item
If @var{criterion} is a character: the byte has to be different from it.

@item
If @var{criterion} is a character set: the byte, interpreted as @ascii{}
character, must not be contained in it.

@item
If @var{criterion} is a procedure: the procedure applied to the byte
must return false.
@end itemize

If no match is found: Return @false{}.
@end deffn


@deffn Function %bytevector-u8-count @var{criterion} @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-count @var{B} @var{criterion}
Return a count of the number of bytes in @var{bv} that satisfy the
@var{criterion} argument:

@itemize
@item
If @var{criterion} is an exact integer: the byte has to be equal to it.

@item
If @var{criterion} is a character: the byte has to be equal to it.

@item
If @var{criterion} is a character set: the byte, interpreted as @ascii{}
character, has to be contained in it.

@item
If @var{criterion} is a procedure: the procedure applied to the byte
must return true.
@end itemize
@end deffn


@deffn Function %bytevector-u8-contains @vari{bv} @vari{start} @vari{past} @varii{bv} @varii{start} @varii{past}
@deffnx Function %bytevector-u8-contains-ci @vari{bv} @vari{start} @vari{past} @varii{bv} @varii{start} @varii{past}
@deffnx Macro bytevector-u8-contains @vari{B} @varii{B}
@deffnx Macro bytevector-u8-contains-ci @vari{B} @varii{B}
Return true if the subvector @vari{B} contains the subvector @varii{B},
else return @false{}.  The return value is the index in the bytevector,
not in the subvector.
@end deffn

@c page
@node bytevectors u8 filter
@subsection Filtering and deleting


@deffn Function %bytevector-u8-filter @var{criterion} @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-filter @var{B} @var{criterion}
Filter the selected subvector, retaining only those bytes that satisfy
the @var{criterion} argument; a byte is retained when:

@itemize
@item
If @var{criterion} is an exact integer: the byte has to be equal to it.

@item
If @var{criterion} is a character: the byte has to be equal to it.

@item
If @var{criterion} is a character set: the byte, interpreted as @ascii{}
character, has to be contained in it.

@item
If @var{criterion} is a procedure: the procedure applied to the byte
must return true.
@end itemize

Always return a newly allocated bytevector.
@end deffn


@deffn Function %bytevector-u8-delete @var{criterion} @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-delete @var{B} @var{criterion}
Filter the selected subvector, retaining only those bytes that do
@strong{not} satisfy the @var{criterion} argument; a byte is deleted
when:

@itemize
@item
If @var{criterion} is an exact integer: the byte has to be different
from it.

@item
If @var{criterion} is a character: the byte has to be different from it.

@item
If @var{criterion} is a character set: the byte, interpreted as @ascii{}
character, must not be contained in it.

@item
If @var{criterion} is a procedure: the procedure applied to the byte
must return false.
@end itemize

Always return a newly allocated bytevector.
@end deffn

@c page
@node bytevectors u8 list
@subsection List and string conversion


@deffn Function %bytevector->u8-list* @var{bv} @var{start} @var{past}
@deffnx Macro bytevector->u8-list* @var{B}
Return a newly allocated list of the bytes that make up the given
subvector.
@end deffn


@deffn Function %reverse-bytevector->u8-list @var{bv} @var{start} @var{past}
@deffnx Macro reverse-bytevector->u8-list @var{B}
Like @func{%bytevector->u8-list*} but reverses the order of the bytes
from the subvector.
@end deffn


@defun reverse-u8-list->bytevector-u8 @var{char-list}
Reverse the given list of characters, then compose a bytevector with the
result.
@end defun


@deffn Function %bytevector-u8-tokenize @var{token-set} @var{bv} @var{start} @var{past}
@deffnx Function %bytevector-u8-tokenise @var{token-set} @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-tokenize @var{B} @var{token-set}
@deffnx Macro bytevector-u8-tokenise @var{B} @var{token-set}
Split the selected subvector into a list of bytevectors, where each
bytevector is a maximal, non--empty, contiguous sequence of bytes whose
character interpretation in @ascii{} encoding is in the character set
@var{token-set}.
@end deffn


@defun bytevector-u8-join @var{bytevector-u8-list}
@defunx bytevector-u8-join @var{bytevector-u8-list} @var{delimiter}
@defunx bytevector-u8-join @var{bytevector-u8-list} @var{delimiter} @var{grammar}
@defunx %bytevector-u8-join @var{bytevector-u8-list} @var{delimiter} @var{grammar}
This procedure is a simple unparser: it pastes strings together using
the @var{delimiter} bytevector.  @var{delimiter} defaults to a single
byte representing a white space in @ascii{} encoding.  @var{grammar} is
a symbol that determines how the delimiter is used, and defaults to
@code{infix}.  Supported values for @var{grammar} are:

@table @code
@item infix
Means an infix or separator grammar: insert the delimiter between list
elements.  An empty list will produce an empty string.

@quotation
@strong{Note}: Parsing an empty string with an infix grammar is
ambiguous.  Is it an empty list, or a list of one element, the empty
string?
@end quotation

@item strict-infix
Means the same as @code{infix}, but will raise an error if given an
empty list.

@item suffix
Means a suffix or terminator grammar: insert the delimiter after every
list element.  This grammar has no ambiguities.

@item prefix
Means a prefix grammar: insert the delimiter before every list element.
This grammar has no ambiguities.
@end table
@end defun

@c page
@node bytevectors u8 replicate
@subsection Replicate and rotate


@deffn Function %xsubbytevector-u8 @var{from} @var{to} @var{str} @var{start} @var{past}
@deffnx Macro xsubbytevector-u8 @var{S} @var{from} @var{to}
Extended subvector procedure replicating the selected subvector ``up and
down'' index space, in both the positive and negative directions.

The call:

@example
(%xsubstring from to 'vu8(0 1 2 3 4 5 6) 3 6)
@end example

@noindent
selects the subvector @code{3 4 5} and defines the conceptual
bidirectionally--infinite bytevector:

@example
...  4  5  3  4  5  3  4  5  3  4  5 ...
... -5 -4 -3 -2 -1  0 +1 +2 +3 +4 +5 ...
                    ^
@end example

@noindent
that is @code{3 4 5} repeated in both directions.  This function returns
the subvector of this bytevector beginning at index @var{from}, and
ending at @var{to}.

Note that:

@itemize
@item
The @var{from}/@var{to} indices give a half--open range; the bytes from
index @var{from} up to, but not including, index @var{to}.

@item
The @var{from}/@var{to} indices are not in terms of the index space for
the bytevector @var{bv}.  They are in terms of the replicated index
space of the subvector defined by @var{bv}, @var{start}, and @var{past}.
@end itemize

It is an error if @var{start} equals @var{past}.
@end deffn


@deffn Function xbytevector-u8-xcopy! @var{from} @var{to} @var{target} @var{target-start} @var{source} @var{source-start} @var{source-past}
@deffnx Macro bytevector-u8-xcopy! @var{target-B} @var{source-B} @var{from} @var{to}
Exactly the same as @func{%xsubbytevector-u8}, but the extracted data is
written into the selected subvector of @var{target}.

This operation is not defined if @code{(eq? target start)}; we cannot
copy a bytevector on top of itself.
@end deffn

@c page
@node bytevectors u8 mutate
@subsection Mutators


@defun bytevector-u8-swap! @var{bv} @var{i} @var{j}
Swap the bytes in @var{bv} at positions @var{i} and @var{j}.
@end defun


@deffn Function %bytevector-u8-fill*! @var{fill} @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-fill*! @var{B} @var{fill}
Fill the selected subvector with @var{fill}, a byte or character,
modifying the original bytevector.
@end deffn

@c page
@node bytevectors u8 misc
@subsection Miscellaneous functions


@deffn Function %bytevector-u8-replace @vari{bv} @vari{start} @vari{past} @varii{bv} @varii{start} @varii{past}
@deffnx Macro bytevector-u8-replace @vari{B} @varii{B}
Replace the subvector in @vari{B} with the selected subvector in
@varii{B}.  Return a newly allocated bytevector.
@end deffn


@deffn Function %bytevector-u8-reverse @var{bv} @var{start} @var{past}
@deffnx Function %bytevector-u8-reverse! @var{bv} @var{start} @var{past}
@deffnx Macro bytevector-u8-reverse @var{B}
@deffnx Macro bytevector-u8-reverse! @var{B}
Reverse the bytevector.  @func{%bytevector-u8-reverse} returns the
result bytevector and does not alter its @var{bv} argument.
@func{%bytevector-u8-reverse!} is the in--place side--effecting variant.
@end deffn

@c page
@node arrays
@chapter Multidimensional arrays


The @library{arrays} library implements mutidimensional arrays on top of
builtin Scheme vectors.


@menu
* arrays conventions::          Arguments conventions.
* arrays layout::               Layout of elements in the vector.
* arrays position::             Specifying the coordinates of elements.
* arrays shape::                Specifying the shape of arrays.
* arrays array::                Dealing with arrays.
@end menu

@c page
@node arrays conventions
@section Arguments conventions


In the documentation of @library{arrays} we call:

@table @dfn
@item items
The values collected in Scheme's builtin lists and vectors.

@item elements
The values collected in the arrays.
@end table

The following conventions are used in the documentation of arguments to
the functions of @library{arrays}:

@table @var
@item array
A proper @code{array} object.

@item shape
A proper @code{shape} object.

@item position
A proper @code{position} object.

@item position-step
A builtin Scheme vector used to represent the difference between two
@code{position} values.

@item dimension
A strictly positive, exact integer representing the extension of a
dimension in an @code{array}.

@item index
A non--negative, exact integer representing the coordinate of an
element.

@item start
@itemx past
@itemx last
When specifying a range of items or elements: @var{start} is the
left--included bound, @var{past} is the right--included bound,
@var{last} is the right--excluded bound.

@item obj
Can be any value.
@end table

@c page
@node arrays layout
@section Layout of elements in the vector


If we fill the underlying vector with integers representing the index of
the elements, for an array of one dimension and four elements, the
vector is:

@example
#(0 1 2 3)
@end example

For an array of two dimensions with @math{3} rows and @math{4} columns,
we can compute the vector index by multiplying the row coordinate by the
number of columns, then adding the column coordinate:

@example
;;     coordinates   formula
#( 0   ; 0 0         0 * 4 + 0 * 1
   1   ; 0 1         0 * 4 + 1 * 1
   2   ; 0 2         0 * 4 + 2 * 1
   3   ; 0 3         0 * 4 + 3 * 1
   4   ; 1 0         1 * 4 + 0 * 1
   5   ; 1 1         1 * 4 + 1 * 1
   6   ; 1 2         1 * 4 + 2 * 1
   7   ; 1 3         1 * 4 + 3 * 1
   8   ; 2 0         2 * 4 + 0 * 1
   9   ; 2 1         2 * 4 + 1 * 1
  10   ; 2 2         2 * 4 + 2 * 1
  11)  ; 2 3         2 * 4 + 3 * 1
@end example

For an array of three dimensions with @math{2} planes, @math{3} rows and
@math{4} columns, we can compute the vector index by multiplying the
plane, row and column coordinates by the appropriate factor:

@example
;;     coordinates    formula
#( 0   ; 0 0 0        0 * (3 * 4) + 0 * 4 + 0 * 1
   1   ; 0 0 1        0 * (3 * 4) + 0 * 4 + 1 * 1
   2   ; 0 0 2        0 * (3 * 4) + 0 * 4 + 2 * 1
   3   ; 0 0 3        0 * (3 * 4) + 0 * 4 + 3 * 1
   4   ; 0 1 0        0 * (3 * 4) + 1 * 4 + 0 * 1
   5   ; 0 1 1        0 * (3 * 4) + 1 * 4 + 1 * 1
   6   ; 0 1 2        0 * (3 * 4) + 1 * 4 + 2 * 1
   7   ; 0 1 3        0 * (3 * 4) + 1 * 4 + 3 * 1
   8   ; 0 2 0        0 * (3 * 4) + 2 * 4 + 0 * 1
   9   ; 0 2 1        0 * (3 * 4) + 2 * 4 + 1 * 1
  10   ; 0 2 2        0 * (3 * 4) + 2 * 4 + 2 * 1
  11   ; 0 2 3        0 * (3 * 4) + 2 * 4 + 3 * 1
  12   ; 1 0 3        1 * (3 * 4) + 0 * 4 + 0 * 1
  13   ; 1 0 3        1 * (3 * 4) + 0 * 4 + 1 * 1
  14   ; 1 0 3        1 * (3 * 4) + 0 * 4 + 2 * 1
  15   ; 1 0 3        1 * (3 * 4) + 0 * 4 + 3 * 1
  16   ; 1 1 3        1 * (3 * 4) + 1 * 4 + 0 * 1
  17   ; 1 1 3        1 * (3 * 4) + 1 * 4 + 1 * 1
  18   ; 1 1 3        1 * (3 * 4) + 1 * 4 + 2 * 1
  19   ; 1 1 3        1 * (3 * 4) + 1 * 4 + 3 * 1
  20   ; 1 2 3        1 * (3 * 4) + 2 * 4 + 0 * 1
  21   ; 1 2 3        1 * (3 * 4) + 2 * 4 + 1 * 1
  22   ; 1 2 3        1 * (3 * 4) + 2 * 4 + 2 * 1
  23)  ; 1 2 3        1 * (3 * 4) + 2 * 4 + 3 * 1
@end example

@noindent
that is:

@example
index = plane * (3 * 4) + row * 4 + column * 1
@end example

Generalising: the rightmost coordinate is always multiplied by @math{1},
while the other are multiplied by a product between the length of the
dimensions.

Precisely, let's call @math{N} the number of dimensions of an array, and
let's index the dimensions with @math{0 <= k < N}; then: @math{D(k)} is
the length of the @math{k}-th dimension; @math{C(k)} is the @math{k}-th
coordinate of an element and @math{F(k)} is its factor.  The index
of the element is computed with:

@example
index = F(0) * C(0) + F(1) * C(1) + ... + F(N-1) * C(N-1)
@end example

@noindent
being:

@example
0 <= k < N-2   =>   F(k) = D(k+1) * D(k+2) * ... * D(N-1)

     k = N-1   =>   F(N-1) = 1
@end example

@noindent
we note explicitly that @math{D(0)} is @strong{never} used in the
computation of the factors, and that @math{D(k)} is @strong{not} used in
the computation of @math{F(k)}.

If @code{dimensions} is the list of dimensions of an array, the
following function will compute and return the list of factors:

@example
(define (%compute-factors dimensions)
  (let loop ((dims    (cdr dimensions))
             (factors '()))
    (if (null? dims)
        (reverse (cons 1 factors))
      (loop (cdr dims)
            (cons (apply * dims) factors)))))
@end example

@c page
@node arrays position
@section Specifying the coordinates of elements


The elements' positions in arrays are represented by builtin Scheme
vectors holding exact integers.


@subsubheading Constructors


@defun array-position @var{index0} @var{index} ...
Build and return a new Scheme vector holding the @var{index} arguments.
The indexes are checked to be exact integers.  The number of arguments
is meant to be equal to the number of dimensions of the array with which
the position value will be used.
@end defun


@subsubheading Predicates and assertions


@defun array-position? @var{obj}
Return @true{} if @var{obj} is a Scheme vector holding exact integers.
@end defun


@defun assert-array-position @var{obj} @var{func-name}
@defunx assert-array-position/or-false @var{obj} @var{func-name}
Raise an assertion violation exception if @var{obj} satisfies
@func{array-position?}, or it is @false{}.  @var{func-name} is used
@code{who} argument for the exception.  Return @true{} if no exception
is raised.
@end defun


@subsubheading Conversion


@defun array-position->string @var{position}
Return a string representation of @var{position}, specialised for array
positions.
@end defun


@subsubheading Port output


@defun array-position-display @var{position}
@defunx array-position-display @var{position} @var{port}
Write to @var{port} a human readable string representation of
@var{position}.  @var{port} defaults to the current output port.
@end defun


@defun array-position-write @var{position}
@defunx array-position-write @var{position} @var{port}
Write to @var{port} a string representation of @var{position} such that
it can be read back with @func{read}.  @var{port} defaults to the
current output port.
@end defun

@c page
@node arrays shape
@section Specifying the shape of arrays


Values of type @code{shape} represent the shape of an array, that is:
the number of dimensions, the start index of each dimension, the past
index of each dimension.  @code{shape} values are disjoint from the
other values.


@subsubheading Constructors


@defun array-shape @var{start-list} @var{past-list}
Build and return a new @code{shape} describing an array or array view
through the list of start indexes in @var{start-list} and the list of
past indexes in @var{past-list}.

The arguments must have the same length and be composed by
non--negative, exact integers.  Indexes from the arguments are taken in
couples: The first start with the first past, the second start with the
second past, and so on.  Each couple describes the range of valid
indexes for each dimension of an array.
@end defun


@subsubheading Predicates and assertions


@defun array-shape? @var{obj}
Return @true{} if @var{obj} is a @code{shape} value.
@end defun


@defun assert-array-shape @var{obj} @var{func-name}
@defunx assert-array-shape/or-false @var{obj} @var{func-name}
Raise an assertion violation exception if @var{obj} is not a
@code{shape} value, or @false{}.  @var{func-name} is used @code{who}
argument for the exception.  Return @true{} if no exception is raised.
@end defun


@subsubheading Comparison and set operations


@defun array-shape=? @var{shape0} @var{shape} ...
Return @true{} if the arguments have equal number of dimensions and hold
the same indexes.
@end defun


@defun array-supershape? @var{shape0} @var{shape} ...
@defunx array-supershape?/strict @var{shape0} @var{shape} ...
Return @true{} if the arguments, in the given order, are supershapes of
each other or strict supershapes of each other.  The shape @var{a} is
supershape of @var{b} if:

@enumerate
@item
They have the same number of dimensions.

@item
For each dimension, the range of elements in @var{b} is a subset of the
range of elements in @var{a}.
@end enumerate

The following two forms are equivalent:

@example
(array-supershape? a b c d)
(and (array-supershape? a b)
     (array-supershape? b c)
     (array-supershape? c d))
@end example
@end defun


@defun array-subshape? @var{shape0} @var{shape} ...
@defunx array-subshape?/strict @var{shape0} @var{shape} ...
Return @true{} if the arguments, in the given order, are subshapes of
each other or strict subshapes of each other.  These functions are like
the supershape functions with the arguments reversed.
@end defun


@defun array-shape-contains? @var{shape} @var{position}
Return @true{} if @var{position} selects an array element in the range
of elements described by @var{shape}.
@end defun


@subsubheading Inspection


@defun array-shape-number-of-dimensions @var{shape}
Return the number of dimensions of the array with which the shape
value will be used.
@end defun


@defun array-shape-number-of-elements @var{shape}
Return the number of elements in the range described by @var{shape}.
@end defun


@defun array-shape-index-start @var{shape} @var{dimension}
@defunx array-shape-index-past @var{shape} @var{dimension}
@defunx array-shape-index-last @var{shape} @var{dimension}
Return the start, past or last value for position indexes in @var{shape}
for the selected @var{dimension} (zero based).  Examples:

@example
(define s (array-shape '(-1  2 5)
                       '( 5 18 7)))

(array-shape-index-start s 0) @result{} -1
(array-shape-index-past  s 0) @result{}  5
(array-shape-index-last  s 0) @result{}  4

(array-shape-index-start s 1) @result{}  2
(array-shape-index-past  s 1) @result{} 18
(array-shape-index-last  s 1) @result{} 17

(array-shape-index-start s 2) @result{}  5
(array-shape-index-past  s 2) @result{}  7
(array-shape-index-last  s 3) @result{}  6
@end example
@end defun


@subsubheading Conversion


@defun array-shape->string @var{shape}
Return a string representation of @var{shape}.
@end defun


@subsubheading Port output


@defun array-shape-display @var{shape}
@defunx array-shape-display @var{shape} @var{port}
Write to @var{port} a human readable string representation of
@var{shape}.  @var{port} defaults to the current output port.
@end defun


@defun array-shape-write @var{shape}
@defunx array-shape-write @var{shape} @var{port}
Write to @var{port} a string representation of @var{shape} such that
it can be read back with @func{read}.  @var{port} defaults to the
current output port.
@end defun


@c page
@node arrays array
@section Dealing with arrays


Values of type @code{array} represent an array, a collection of values
that can be accessed by specifying a multidimensional position.  The
elements of an @code{array} are stored in a vector in row major order.

The @code{array} values are disjoint from all the other values, but the
@code{shape}; an @code{array} value represents itself its own
@code{shape}.  All the functions that can be applied to a @code{shape},
can also be applied to an @code{array}.


@subsubheading Constructors


@defun make-array @var{shape}
@defunx make-array @var{shape} @var{fill-value}
Build and return a new @code{array} described by @var{shape}.
@var{fill-value} is used as initialisation value for all the slots of
the array; it defaults to @false{}.
@end defun


@defun array @var{shape} @var{element} ...
Build and return a new @code{array} described by @var{shape}.  The
elements are stored in the slots of the underlying vector, in the given
order; there must be enough elements to fill the vector.
@end defun


@defun array-copy @var{array}
Build and return a deep clone of @var{array}.
@end defun


@defun array-view @var{array} @var{mapper}
Build and return a new @code{array} value sharing all the data with
@var{array} and using the closure @var{mapper} to map position
coordinates.

@var{mapper} must take a position value as argument and return a
position value as argument.  There is no constraint on what @var{mapper}
can do on the position.  @var{mapper} is composed with whatever mapper
function @var{array} already uses.
@end defun


@subsubheading Predicates and assertions


@defun array? @var{obj}
Return @true{} if @var{obj} is an @code{array} value.
@end defun


@defun assert-array @var{obj} @var{func-name}
@defunx assert-array/or-false @var{obj} @var{func-name}
Raise an assertion violation exception if @var{obj} is not an
@code{array} value, or @false{}.  @var{func-name} is used @code{who}
argument for the exception.  Return @true{} if no exception is raised.
@end defun


@subsubheading Accessors


@defun array-set! @var{array} @var{position} @var{element}
Store @var{element} at @var{position} in @var{array}, overwriting the
old value.
@end defun


@defun array-ref @var{array} @var{position}
Return the element at @var{position} in @var{array}.
@end defun


@subsubheading Comparison


@defun array=? @var{pred=} @var{array0} @var{array} ...
Return @true{} if the arguments have equal number of dimensions and hold
the same elements according to @var{pred=}.  The predicate function
@var{pred=} should behave like @func{eqv?}.
@end defun


@subsubheading Conversion


@defun array->string @var{array}
Return a string representation of @var{array}.
@end defun


@subsubheading Port output


@defun array-display @var{array}
@defunx array-display @var{array} @var{port}
Write to @var{port} a human readable string representation of
@var{array}.  @var{port} defaults to the current output port.
@end defun


@defun array-write @var{array}
@defunx array-write @var{array} @var{port}
Write to @var{port} a string representation of @var{array} such that it
can be read back with @func{read}.  @var{port} defaults to the current
output port.
@end defun

@c page
@node streams
@chapter Streams


The @library{streams} library implements @dfn{streams}; sometimes called
``lazy lists'', streams are a sequential data structure containing
elements computed only on demand.  A stream is either null or is a pair
with a stream in its cdr.  Since elements of a stream are computed only
when accessed, streams can be infinite.  Once computed, the value of a
stream element is cached in case it is needed again.

@menu
* streams basic::               Basic interface.
* streams cons::                Definitions and constructors.
* streams from::                Converting objects into streams.
* streams to::                  Converting streams to objects.
* streams ops::                 Operations.
* streams select::              Selecting.
* streams range::               Range streams.
* streams of::                  Comprehensions.
* streams fold::                Folding.
* streams unfold::              Unfolding.
* streams map::                 Mapping and side effects.
* streams match::               Matching.
* streams utilities::           Utilities.
* streams examples::            Examples.
@end menu

@c page
@node streams basic
@section Basic interface


The basic @api{} provides two mutually--recursive abstract data types:
An object of the @samp{stream} abstract data type is a promise that,
when forced, is either @samp{stream-null} or is an object of type
@samp{stream-pair}.  An object of the @samp{stream-pair} abstract data
type contains a @dfn{kar} and a @dfn{kdr}, which must be a
@samp{stream}.  The essential feature of streams is the systematic
suspensions of the recursive promises between the two data types.

@example
alpha stream
  :: (promise stream-null)
  |  (promise (alpha stream-pair))

alpha stream-pair
  :: (promise alpha) x (promise (alpha stream))
@end example

The object stored in the kar of a @samp{stream-pair} is a promise that
is forced the first time the kar is accessed; its value is cached in
case it is needed again.  The object may have any type, and different
stream elements may have different types.  If the kar is never accessed,
the object stored there is never evaluated.  Likewise, the kdr is a
promise to return a stream, and is only forced on demand.

This @api{} provides eight operators: constructors for
@samp{stream-null} and @samp{stream-pair}, type recognisers for streams
and the two kinds of streams, accessors for both fields of a
@samp{stream-pair}, a lambda that creates procedures that return
streams.


@deffn Constant stream-null
Return a promise that, when forced, is a single object, distinguishable
from all other objects, that represents the null stream.
@func{stream-null} is immutable and unique.
@end deffn


@deffn Syntax stream-cons @var{obj} @var{stream}
Accept an object and a stream and create a newly--allocated stream
containing a promise that, when forced, is a @samp{stream-pair} with the
object in its kar and the stream in its @func{stream-cdr}.

Once created, a @samp{stream-pair} is immutable; there is @strong{no}
@func{stream-set-kar!} or @func{stream-set-kdr!} that modifies an
existing @samp{stream-pair}.  There is no dotted--pair or improper
stream as with lists.
@end deffn


@defun stream? @var{obj}
Return @true{} if @var{obj} is a @samp{stream} and @false{} otherwise.
If @var{obj} is a @samp{stream}, @func{stream?} does not force its
promise.

If @code{(stream? obj)} is @true{}, then one of @code{(stream-null?
obj)} and @code{(stream-pair? obj)} will be @true{} and the other will
be @false{}; if @code{(stream? obj)} is @false{}, both
@code{(stream-null?  obj)} and @code{(stream-pair?  obj)} will be
@false{}.
@end defun


@defun stream-null? @var{obj}
Return @true{} if the @var{obj} is the distinguished null stream and
@false{} otherwise.  If @var{obj} is a @samp{stream},
@func{stream-null?} must force its promise in order to distinguish
@samp{stream-null} from @samp{stream-pair}.
@end defun


@defun stream-pair? @var{obj}
Take an @var{obj} and return @true{} if it is a @samp{stream-pair}
constructed by @func{stream-cons} and @false{} otherwise.  If @var{obj}
is a @samp{stream}, @func{stream-pair?} must force its promise in order
to distinguish @samp{stream-null} from @samp{stream-pair}.
@end defun


@defun stream-car @var{stream}
Return the object stored in the kar of @var{stream}.  @func{stream-car}
signals an error if the object passed to it is not a @samp{stream-pair}.
Calling @func{stream-car} causes the object stored there to be evaluated
if it has not yet been; the object's value is cached in case it is
needed again.
@end defun


@defun stream-cdr @var{stream}
Return the stream stored in the kdr of @var{stream}.  @func{stream-cdr}
signals an error if the object passed to it is not a @samp{stream-pair}.
Calling @func{stream-cdr} does not force the promise containing the
stream stored in the kdr of the stream.
@end defun


@deffn Syntax stream-lambda @var{formals} . @var{body}
Create a procedure that returns a promise to evaluate the body of the
procedure.  The last body expression to be evaluated must yield a
stream.

As with normal @func{lambda}, @var{formals} may be a single variable
name, in which case all the formal arguments are collected into a single
list, or a list of variable names, which may be null if there are no
arguments, proper if there are an exact number of arguments, or dotted
if a fixed number of arguments is to be followed by zero or more
arguments collected into a list.

@var{body} must contain at least one expression, and may contain
internal definitions preceding any expressions to be evaluated.
@end deffn


Examples:

@example
(define strm123
  (stream-cons 1
    (stream-cons 2
      (stream-cons 3
        stream-null))))

(stream-car strm123)
@result{} 1

(stream-car (stream-cdr strm123))
@result{} 2

(stream-pair?
  (stream-cdr
    (stream-cons (/ 1 0) stream-null)))
@result{} #f

(stream? (list 1 2 3))
@result{} #f

(define iter
  (stream-lambda (f x)
    (stream-cons x (iter f (f x)))))

(define nats
  (iter (lambda (x)
          (+ x 1))
        0))

(stream-car (stream-cdr nats))
@result{} 1

(define stream-add
  (stream-lambda (s1 s2)
    (stream-cons
      (+ (stream-car s1) (stream-car s2))
      (stream-add (stream-cdr s1)
                  (stream-cdr s2)))))

(define evens
  (stream-add nats nats))

(stream-car evens)
@result{} 0

(stream-car (stream-cdr evens))
@result{} 2

(stream-car (stream-cdr (stream-cdr evens)))
@result{} 4
@end example

@c page
@node streams cons
@section Definitions and constructors


@deffn Syntax stream @var{object} ...
Take zero or more objects and create a newly--allocated @samp{stream}
containing in its elements the objects, in order.  Since @func{stream}
is syntactic, the objects are evaluated when they are accessed, not when
the @samp{stream} is created.  If no objects are given, as in
@code{(stream)}, the null stream is returned.  See also
@func{list->stream}.

Example:

@example
(define strm123 (stream 1 2 3))

; (/ 1 0) not evaluated when stream is created
(define s (stream 1 (/ 1 0) -1))
@end example
@end deffn


@defun stream-constant @var{object} ...
Take one or more objects and return a newly--allocated @samp{stream}
containing in its elements the objects, repeating the objects in
succession forever.

Example:

@example
(stream-constant 1)
@result{} 1 1 1 ...

(stream-constant #t #f)
@result{} #t #f #t #f #t #f ...
@end example
@end defun


@deffn Syntax define-stream (@var{name} @var{formals}) . @var{body}
Create a procedure that returns a @samp{stream}, and may appear anywhere
a normal @func{define} may appear, including an internal definition, and
may have internal definitions of its own, including other
@func{define-streams}.  The defined procedure takes arguments in the
same way as @func{stream-lambda}.

@func{define-stream} is syntactic sugar on @func{stream-lambda}; see
also @func{stream-let}.

The following example is a simple version of @func{stream-map} that
takes only a single input stream and calls itself recursively:

@example
(define-stream (stream-map proc strm)
  (if (stream-null? strm)
      stream-null
    (stream-cons
      (proc (stream-car strm))
      (stream-map proc (stream-cdr strm)))))
@end example
@end deffn


@deffn Syntax stream-let @var{name} ((@var{var} @var{expr}) ...) @var{body}
Create a local scope that binds each variable to the value of its
corresponding expression.  Additionally bind @var{name} to a procedure
which takes the bound variables as arguments and @var{body} as its
defining expressions, binding the tag with @func{stream-lambda}.
@var{name} is in scope within @var{body}, and may be called recursively.

When the expanded expression defined by @func{stream-let} is evaluated,
@func{stream-let} evaluates the expressions in its body in an
environment containing the newly--bound variables, returning the value
of the last expression evaluated, which must yield a stream.

@func{stream-let} provides syntactic sugar on @func{stream-lambda}, in
the same manner as normal @func{let} provides syntactic sugar on normal
@func{lambda}.  However, unlike normal @func{let}, the @var{name} is
required, not optional, because unnamed @func{stream-let} is
meaningless.

Example: @func{stream-member} returns the first @samp{stream-pair} of
the input @var{strm} with a kar @var{x} that satisfies @code{(eqv? obj
x)}, or the null stream if @var{x} is not present in @var{strm}.

@example
(define-stream (stream-member eql? obj strm)
  (stream-let loop ((strm strm))
    (cond ((stream-null? strm)
           strm)
          ((eqv? obj (stream-car strm))
           strm)
          (else
           (loop (stream-cdr strm))))))
@end example
@end deffn

@c page
@node streams from
@section Converting objects into streams


@defun list->stream @var{list-of-objects}
Return a newly--allocated @samp{stream} containing in its elements the
objects in the list.  Since the objects are given in a list, they are
evaluated when @func{list->stream} is called, before the @samp{stream}
is created.  If the list of objects is null, as in @code{(list->stream
'())}, the null @samp{stream} is returned.  See also @func{stream}.

Example:

@example
(define strm123
  (list->stream '(1 2 3)))

;; fails with divide-by-zero error
(define s
  (list->stream (list 1 (/ 1 0) -1)))
@end example
@end defun


@defun port->stream
@defunx port->stream @var{port}
Return a newly--allocated @samp{stream} containing in its elements the
characters on the @var{port}.  If @var{port} is not given it defaults to
the current input port.  The returned @samp{stream} has finite length
and is terminated by @samp{stream-null}.

It looks like one use of @func{port->stream} would be this:

@example
(define s               ;wrong!
  (with-input-from-file filename
    (lambda ()
      (port->stream))))
@end example

@noindent
but that fails, because @func{with-input-from-file} is eager, and closes
the input port prematurely, before the first character is read.  To read
a file into a stream, use:

@example
(define-stream (file->stream filename)
  (let ((p (open-input-file filename)))
    (stream-let loop ((c (read-char p)))
      (if (eof-object? c)
          (begin (close-input-port p)
                 stream-null)
          (stream-cons c
            (loop (read-char p)))))))
@end example
@end defun

@c page
@node streams to
@section Converting streams to objects


@defun stream->list @var{stream}
@defunx stream->list @var{stream} @var{n}
Take a natural number @var{n} and a @var{stream} and return a
newly--allocated list containing in its elements the first @var{n} items
in the @var{stream}.  If the @var{stream} has less than @var{n} items
all the items in the @var{stream} will be included in the returned list.
If @var{n} is not given it defaults to infinity, which means that unless
@var{stream} is finite @func{stream->list} will never return.

Example:

@example
(stream->list 10
  (stream-map (lambda (x) (* x x))
    (stream-from 0)))
  => (0 1 4 9 16 25 36 49 64 81)
@end example
@end defun

@c page
@node streams ops
@section Operations


@defun stream-length @var{stream}
Take an input stream and return the number of elements in the stream; it
does not evaluate its elements.  @func{stream-length} may only be used
on finite streams; it enters an infinite loop with infinite streams.

Example:

@example
(define strm123
  (stream 1 2 3))

(stream-length strm123)
@result{} 3
@end example
@end defun


@defun stream-ref @var{stream} @var{n}
Return the @var{n}-th element of @var{stream}, counting from zero.  An
error is signaled if @var{n} is greater than or equal to the length of
@var{stream}.

Example:

@example
(define (fact n)
  (stream-ref
    (stream-scan * 1 (stream-from 1))
    n))
@end example
@end defun


@defun stream-reverse @var{stream}
Return a newly--allocated stream containing the elements of the input
@var{stream} but in reverse order.  @func{stream-reverse} may only be
used with finite streams; it enters an infinite loop with infinite
streams.  @func{stream-reverse} does not force evaluation of the
elements of the stream.

@example
(define s (stream 1 (/ 1 0) -1))
(define r (stream-reverse s))

(stream-ref r 0)
(stream-ref r 2)        @result{} 1
(stream-ref r 1)        @error{} division by zero
@end example
@end defun


@defun stream-append @var{stream} ...
Return a newly--allocated @samp{stream} containing in its elements those
elements contained in its input streams, in order of input.  If any of
the input streams is infinite, no elements of any of the succeeding
input streams will appear in the output stream; thus, if @var{x} is
infinite, @code{(stream-append x y)} is identical to @var{x}.  See also
@func{stream-concat}.

Example: quicksort can be used to sort a @samp{stream}, using
@func{stream-append} to build the output; the sort is lazy; so if only
the beginning of the output stream is needed, the end of the stream is
never sorted.

@example
(define-stream (qsort lt? strm)
  (if (stream-null? strm)
      stream-null
      (let ((x (stream-car strm))
            (xs (stream-cdr strm)))
        (stream-append
          (qsort lt?
            (stream-filter
              (lambda (u) (lt? u x))
              xs))
          (stream x)
          (qsort lt?
            (stream-filter
              (lambda (u) (not (lt? u x)))
              xs))))))
@end example

Note also that, when used in tail position as in @func{qsort},
@func{stream-append} does not suffer the poor performance of
@func{append} on lists.  The list version of @func{append} requires
re--traversal of all its list arguments except the last each time it is
called.  But @func{stream-append} is different.  Each recursive call to
@func{stream-append} is suspended; when it is later forced, the
preceding elements of the result have already been traversed, so
tail--recursive loops that produce streams are efficient even when each
element is appended to the end of the result stream.  This also implies
that during traversal of the result only one promise needs to be kept in
memory at a time.
@end defun


@defun stream-concat @var{stream}
Take a @var{stream} consisting of one or more streams and return a
newly--allocated stream containing all the elements of the input
streams.  If any of the streams in the input stream is infinite, any
remaining streams in the input stream will never appear in the output
stream.  See also @func{stream-append}.

Example:

@example
(stream->list
  (stream-concat
    (stream
      (stream 1 2) (stream) (stream 3 2 1))))
@result{} (1 2 3 2 1)
@end example

Example: the permutations of a finite stream can be determined by
interleaving each element of the stream in all possible positions within
each permutation of the other elements of the stream; @func{interleave}
returns a stream of streams with @var{x} inserted in each possible
position of @var{yy}:

@example
(define-stream (interleave x yy)
  (stream-match yy
    (() (stream (stream x)))
    ((y .  ys)
      (stream-append
        (stream (stream-cons x yy))
        (stream-map
          (lambda (z) (stream-cons y z))
          (interleave x ys))))))

(define-stream (perms xs)
  (if (stream-null? xs)
      (stream (stream))
    (stream-concat
      (stream-map
        (lambda (ys)
          (interleave (stream-car xs) ys))
        (perms (stream-cdr xs))))))
@end example
@end defun


@defun stream-zip @var{stream} ...
Take one or more input streams and return a newly--allocated stream in
which each element is a list (not a stream) of the corresponding
elements of the input streams.  The output stream is as long as the
shortest input stream, if any of the input streams is finite, or is
infinite if all the input streams are infinite.

A common use of @func{stream-zip} is to add an index to a stream, as in:

@example
(stream-finds eqv? obj strm)
@end example

@noindent
which returns all the zero--based indices in @var{strm} at which
@var{obj} appears; @code{(stream-find eqv? obj strm)} returns the first
such index, or @false{} if @var{obj} is not in @var{strm}.

@example
(define-stream (stream-finds item= obj strm)
  (stream-of (car x)
    (x in (stream-zip (stream-from 0) strm))
    (item= obj (cadr x))))

(define (stream-find item= obj strm)
  (stream-car
    (stream-append
      (stream-finds item= obj strm)
      (stream #f))))

(stream-find char=? #\l
  (list->stream
    (string->list "hello")))
@result{} 2

(stream-find char=? #\l
  (list->stream
    (string->list "goodbye")))
@result{} #f
@end example

@func{stream-find} is not as inefficient as it looks; although it calls
@func{stream-finds}, which finds all matching indices, the matches are
computed lazily, and only the first match is needed for
@func{stream-find}.
@end defun

@c page
@node streams select
@section Selecting


@defun stream-drop @var{n} @var{stream}
Return the suffix of the input stream that starts at the next element
after the first @var{n} elements.  The output stream shares structure
with the input stream; thus, promises forced in one instance of the
stream are also forced in the other instance of the stream.  If the
input stream has less than @var{n} elements, @func{stream-drop} returns
the null stream.  See also @func{stream-take}.

Example:

@example
(define (stream-split n strm)
  (values (stream-take n strm)
          (stream-drop n strm)))
@end example
@end defun


@defun stream-drop-while @var{pred} @var{stream}
Return the suffix of the input stream that starts at the first element
@var{x} for which @code{(pred x)} is @false{}.  The output stream
shares structure with the input stream.  See also
@func{stream-take-while}.

Example: @func{stream-unique} creates a new stream that retains only the
first of any sub--sequences of repeated elements.

@example
(define-stream (stream-unique item= strm)
  (if (stream-null? strm)
      stream-null
    (stream-cons (stream-car strm)
      (stream-unique item=
        (stream-drop-while
          (lambda (x)
            (item= (stream-car strm) x))
          strm)))))
@end example
@end defun


@defun stream-take @var{n} @var{stream}
Take a non--negative exact integer @var{n} and a @var{stream} and return
a newly--allocated stream containing the first @var{n} elements of the
input stream.  If the input stream has less than @var{n} elements, so
does the output stream.  See also @func{stream-drop}.

Example: @func{merge-sort} splits a stream into two equal--length
pieces, sorts them recursively and merges the results:

@example
(define-stream (merge-sort lt? strm)
  (let* ((n     (div (stream-length strm) 2))
         (ts    (stream-take n strm))
         (ds    (stream-drop n strm)))
    (if (zero? n)
        strm
      (stream-merge lt? (merge-sort < ts) (merge-sort < ds)))))
@end example
@end defun


@defun stream-take-while @var{pred} @var{stream}
Take a predicate and a stream and return a newly--allocated stream
containing those elements @var{x} that form the maximal prefix of the
input stream for which @code{(pred x)} is non--@false{}.  See also
@func{stream-drop-while}.

@example
(stream-car
  (stream-reverse
    (stream-take-while
      (lambda (x) (< x 1000))
      primes)))
@result{} 997
@end example
@end defun


@defun stream-filter @var{pred} @var{stream}
Return a newly--allocated stream that contains only those elements
@var{x} of the input stream for which @code{(pred x)} is true.

Example:

@example
(stream-filter odd? (stream-from 0))
@result{} 1 3 5 7 9 ...
@end example
@end defun

@c page
@node streams range
@section Range streams


@defun stream-from @var{first}
@defunx stream-from @var{first} @var{step}
Create a newly--allocated stream that contains @var{first} as its first
element and increments each succeeding element by @var{step}, which
defaults to @samp{1}.  @var{first} and @var{step} may be of any numeric
type.

@func{stream-from} is frequently useful as a generator in
@func{stream-of} expressions.  See also @func{stream-range} for a
similar procedure that creates finite streams.

@func{stream-from} could be implemented as:

@example
(stream-iterate
    (lambda (x)
      (+ x step))
  first)
@end example

Example:

@example
(define nats (stream-from 0))
@result{} 0 1 2 ...

(define odds (stream-from 1 2))
@result{} 1 3 5 ...
@end example
@end defun


@defun stream-range @var{first} @var{past}
@defunx stream-range @var{first} @var{past} @var{step}
Create a newly--allocated stream that contains @var{first} as its first
element and increments each succeeding element by @var{step}.  The
stream is finite and ends before @var{past}, which is not an element of
the stream.  If @var{step} is not given it defaults to @samp{1} if
@var{first} is less than @var{past} and @samp{-1} otherwise.

@var{first}, @var{past} and @var{step} may be of any numeric type.

@func{stream-range} is frequently useful as a generator in
@func{stream-of} expressions.  See also @func{stream-from} for a similar
procedure that creates infinite streams.

Examples:

@example
(stream-range 0 10)
@result{} 0 1 2 3 4 5 6 7 8 9

(stream-range 0 10 2)
@result{} 0 2 4 6 8
@end example

Successive elements of the stream are calculated by adding @var{step} to
@var{first}, so if any of @var{first}, @var{past} or @var{step} are
inexact, the length of the output stream may differ from:

@example
(ceiling (- (/ (- past first) step) 1)
@end example
@end defun

@c page
@node streams of
@section Comprehensions


@deffn Syntax stream-of @var{expr} @var{clause} ...
Provide the syntax of stream comprehensions, which generate streams by
means of looping expressions.  The result is a stream of objects of the
type returned by @var{expr}.  There are four types of @var{clause}
arguments:

@table @code
@item (var in stream-expr)
Loop over the elements of @var{stream-expr}, in order from the start of
the stream, binding each element of the stream in turn to @var{var}.
@func{stream-from} and @func{stream-range} are frequently useful as
generators for @var{stream-expr}.

@item (var is expr)
Bind @var{var} to the value obtained by evaluating @var{expr}.

@item (pred expr)
Include in the output stream only those elements @var{x} for which
@code{(pred x)} is true.
@end table

The scope of variables bound in the stream comprehension is the clauses
to the right of the binding clause (but not the binding clause itself)
plus the result expression.

When two or more generators are present, the loops are processed as if
they are nested from left to right; that is, the rightmost generator
varies fastest.  A consequence of this is that only the first generator
may be infinite and all subsequent generators must be finite.  If no
generators are present, the result of a stream comprehension is a stream
containing the result expression; thus, @code{(stream-of 1)} produces a
finite stream containing only the element @code{1}.

@example
(stream-of (* x x)
  (x in (stream-range 0 10))
  (even? x))
@result{} 0 4 16 36 64

(stream-of (list a b)
  (a in (stream-range 1 4))
  (b in (stream-range 1 3)))
@result{} (1 1) (1 2) (2 1) (2 2) (3 1) (3 2)

(stream-of (list i j)
  (i in (stream-range 1 5))
  (j in (stream-range (+ i 1) 5)))
@result{} (1 2) (1 3) (1 4) (2 3) (2 4) (3 4)
@end example
@end deffn

@c page
@node streams fold
@section Folding


@defun stream-iterate @var{proc} @var{base}
Create a newly--allocated stream containing @var{base} in its first
element and apply @var{proc} to each element in turn to determine the
succeeding element.  See also @func{stream-unfold} and
@func{stream-unfolds}.

Examples:

@example
(stream-iterate (lambda (x) (+ x 1)) 0)
  => 0 1 2 3 4 ...

(stream-iterate (lambda (x) (* x 2)) 1)
  => 1 2 4 8 16 ...
@end example

Given a seed between 0 and 232, exclusive, the following expression
creates a stream of pseudo--random integers between 0 and 232,
exclusive, beginning with seed, using the method described by Stephen
Park and Keith Miller:

@example
(stream-iterate
  (lambda (x) (modulo (* x 16807) 2147483647))
  seed)
@end example

Example: successive of the following stream approach the value of the
``golden ratio'' 1.618...:

@example
(stream-iterate (lambda (x) (+ 1 (/ x))) 1)
@end example
@end defun


@defun stream-fold @var{proc} @var{base} @var{stream}
Apply a binary procedure to @var{base} and the first element of
@var{stream} to compute a new base, then apply the procedure to the new
base and the next element of @var{stream} to compute a succeeding base,
and so on, accumulating a value that is finally returned as the value of
@func{stream-fold} when the end of the @var{stream} is reached.

@var{stream} must be finite, or @func{stream-fold} will enter an
infinite loop.  See also @func{stream-scan}, which is similar to
@func{stream-fold}, but useful for infinite streams.

For readers familiar with other functional languages, this is a
left--fold; there is no corresponding right--fold, since right--fold
relies on finite streams that are fully--evaluated, at which time they
may as well be converted to a list.

@func{stream-fold} is often used to summarize a stream in a single
value, for instance, to compute the maximum element of a stream.

@example
(define (stream-maximum item< strm)
  (stream-fold
    (lambda (x y)
      (if (item< x y) y x))
    (stream-car strm)
    (stream-cdr strm)))
@end example

Sometimes, it is useful to have @func{stream-fold} defined only on
non--null streams:

@example
(define (stream-fold-one proc strm)
  (stream-fold proc
    (stream-car strm)
    (stream-cdr strm)))
@end example

@noindent
@func{stream-minimum} can then be defined as:

@example
(define (stream-minimum item< strm)
  (stream-fold-one
    (lambda (x y)
      (if (item< x y) x y))
    strm))
@end example

@func{stream-fold} can also be used to build a stream:

@example
(define-stream (isort item< strm)
  (define-stream (insert strm x)
    (stream-match strm
      (() (stream x))
      ((y .  ys)
        (if (item< y x)
            (stream-cons y (insert ys x))
          (stream-cons x strm)))))
  (stream-fold insert stream-null strm))
@end example
@end defun


@defun stream-scan @var{proc} @var{base} @var{stream}
Accumulate the partial folds of an input @var{stream} into a
newly--allocated output stream.  The output stream is the @var{base}
followed by:

@example
(stream-fold proc base (stream-take i stream))
@end example

@noindent
for each of the first @math{i} elements of @var{stream}.

Examples:

@example
(stream-scan + 0 (stream-from 1))
@result{} (stream 0 1 3 6 10 15 ...)

(stream-scan * 1 (stream-from 1))
@result{} (stream 1 1 2 6 24 120 ...)
@end example
@end defun

@c page
@node streams unfold
@section Unfolding


@defun stream-unfold @var{map} @var{pred} @var{gen} @var{base}
@func{stream-unfold} is the fundamental recursive stream constructor.
It constructs a stream by repeatedly applying @var{gen} to successive
values of @var{base}, in the manner of @func{stream-iterate}, then
applying @var{map} to each of the values so generated, appending each of
the mapped values to the output stream as long as @code{(pred base)} is
non--@false{}.  See also @func{stream-iterate} and
@func{stream-unfolds}.

For example, the expression below creates the finite stream:

@example
0 1 4 9 16 25 36 49 64 81
@end example

@noindent
initially the base is @code{0}, which is less than @code{10}, so
@var{map} squares the base and the mapped value becomes the first
element of the output stream; then @var{gen} increments the base by
@code{1}, so it becomes @code{1}; this is less than @code{10}, so
@var{map} squares the new base and @code{1} becomes the second element
of the output stream; and so on, until the base becomes @code{10}, when
@var{pred?}  stops the recursion and @code{stream-null} ends the output
stream.

@example
(stream-unfold
  (lambda (x) (expt x 2)) ; map
  (lambda (x) (< x 10))   ; pred
  (lambda (x) (+ x 1))    ; gen
  0)                      ; base
@end example
@end defun


@defun stream-unfolds @var{proc} @var{seed}
Return @var{n} newly--allocated streams containing those elements
produced by successive calls to the generator @var{proc}, which takes
the current @var{seed} as its argument and returns @code{n+1} values:

@example
(proc seed) -> seed R0 ...  R(n-1)
@end example

@noindent
where the returned @var{seed} is the input @var{seed} to the next call
to the generator and @math{R(i)} indicates how to produce the next
element of the @math{i}-th result stream:

@table @code
@item (value)
@var{value} is the next car of the result stream;

@item #f
no value produced by this iteration of the generator @var{proc} for the
result stream;

@item ()
the end of the result stream.
@end table

It may require multiple calls of @var{proc} to produce the next element
of any particular result stream.  See also @func{stream-iterate} and
@func{stream-unfold}.

@func{stream-unfolds} is especially useful when writing expressions that
return multiple streams.  For instance, with reference to the
definitions below:

@example
(stream-partition pred strm)
@end example

@noindent
is equivalent to:

@example
(values
  (stream-filter pred strm)
  (stream-filter
      (lambda (x)
        (not (pred x)))
     strm))
@end example

@noindent
but only tests @func{pred} once for each element of @var{strm}.

@example
(define (stream-partition pred strm)
  (stream-unfolds
    (lambda (s)
      (if (stream-null? s)
          (values s '() '())
        (let ((a (stream-car s))
              (d (stream-cdr s)))
          (if (pred a)
              (values d (list a) #f)
            (values d #f (list a))))))
    strm))

(call-with-values
  (lambda ()
    (stream-partition odd?
      (stream-range 1 6)))
  (lambda (odds evens)
    (list (stream->list odds)
          (stream->list evens))))
@result{} ((1 3 5) (2 4))
@end example
@end defun

@c page
@node streams map
@section Mapping and side effects


@defun stream-map @var{proc} @var{stream} ...
Apply a procedure element--wise to corresponding elements of the input
streams, returning a newly--allocated stream containing elements that
are the results of those procedure applications.  The output stream has
as many elements as the minimum--length input stream, and may be
infinite.

Example:

@example
(define (square x)
  (* x x))

(stream-map square (stream 9 3))
@result{} 81 9

(define (sigma f m n)
  (stream-fold + 0
    (stream-map f (stream-range m (+ n 1)))))

(sigma square 1 100)
@result{} 338350
@end example
@end defun


@defun stream-for-each @var{proc} @var{stream} ...
Apply a procedure element--wise to corresponding elements of the input
streams for its side--effects; return nothing.  @func{stream-for-each}
stops as soon as any of its input streams is exhausted.

Example, the following procedure displays the contents of a file:

@example
(define (display-file filename)
  (stream-for-each display
    (file->stream filename)))
@end example
@end defun

@c page
@node streams match
@section Matching


@deffn Syntax stream-match @var{stream} @var{clause} ...
Provide the syntax of pattern--matching for streams.  The input
@var{stream} is an expression that evaluates to a stream.  @var{clause}
arguments are of the form:

@example
(@cmeta{pattern} @cmeta{expr})
(@cmeta{pattern} @cmeta{fender} @cmeta{expr})
@end example

@noindent
consisting of a @meta{pattern} that matches a stream of a particular
shape, an optional @meta{fender} that must succeed if the @meta{pattern}
is to match, and an @meta{expr} that is evaluated if the @meta{pattern}
matches.  There are four types of patterns:

@table @code
@item ()
Matches the null stream.

@item (pat0 pat1 ...)
Matches a finite stream with length exactly equal to the number of
pattern elements.

@item (pat0 pat1 ...  . patrest)
Matches an infinite stream, or a finite stream with length at least as
great as the number of pattern elements before the literal dot.

@item pat
Matches an entire stream; should always appear last in the list of
clauses; it's not an error to appear elsewhere, but subsequent clauses
could never match.
@end table

Each @meta{pattern} element may be either:

@table @emph
@item An identifier
Matches any stream element; additionally, the value of the stream
element is bound to the variable named by the identifier, which is in
scope in the fender and expression of the corresponding clause; each
identifier in a single pattern must be unique.

@item A literal underscore
Matches any stream element, but creates no bindings.
@end table

The patterns are tested in order, left--to--right, until a matching
pattern is found; if @meta{fender} is present, it must evaluate as true
for the match to be successful.  Pattern variables are bound in the
corresponding fender and expression.  Once the matching pattern is
found, the corresponding expression is evaluated and returned as the
result of the match.  An error is signaled if no pattern matches the
input stream.

@func{stream-match} is often used to distinguish null streams from
non--null streams, binding head and tail:

@example
(define (len strm)
  (stream-match strm
    (()                 0)
    ((head . tail)      (+ 1 (len tail)))))
@end example

Fenders can test the common case where two stream elements must be
identical; the else pattern is an identifier bound to the entire stream,
not a keyword as in @func{cond}.

@example
(stream-match strm
  ((x y . _) (equal? x y)
   'ok)
  (else
   'error))
@end example

A more complex example uses two nested matchers to match two different
stream arguments; @code{(stream-merge lt? .  strms)} stably merges two
or more streams ordered by the @var{lt?} predicate:

@example
(define-stream (stream-merge lt? . strms)

  (define-stream (merge xx yy)
    (stream-match xx
      (() yy)
      ((x . xs)
       (stream-match yy
         (() xx)
         ((y . ys)
          (if (lt? y x)
              (stream-cons y (merge xx ys))
            (stream-cons x (merge xs yy))))))))

  (stream-let loop ((strms strms))
    (cond ((null? strms)
           stream-null)
          ((null? (cdr strms))
           (car strms))
          (else
           (merge (car strms)
                  (apply stream-merge lt?
                  (cdr strms)))))))
@end example
@end deffn

@c page
@node streams utilities
@section Utilities


@cindex @srfi{} streams utilities


Streams, being the signature structured data type of functional
programming languages, find useful expression in conjunction with
higher--order functions.  Some of these higher--order functions, and
their relationship to streams, are described below.

The identity and constant procedures are frequently useful as the
recursive base for maps and folds; @code{(identity obj)} always returns
@var{obj}, and @code{(const obj)} creates a procedure that takes any
number of arguments and always returns the same @var{obj}, no matter its
arguments:

@example
(define (identity obj)
  obj)

(define (const obj)
  (lambda x obj))
@end example

Many of the stream procedures take a unary predicate that accepts an
element of a stream and returns a boolean.  Procedure @code{(negate
pred)} takes a unary predicate and returns a new unary predicate that,
when called, returns the opposite boolean value as the original
predicate.

@example
(define (negate pred)
  (lambda (x) (not (pred x))))
@end example

@func{negate} is useful for procedures like @func{stream-take-while}
that take a predicate, allowing them to be used in the opposite
direction from which they were written; for instance, with the predicate
reversed, @func{stream-take-while} becomes @func{stream-take-until}.
@func{stream-remove} is the opposite of @func{stream-filter}:

@example
(define-stream (stream-remove pred strm)
  (stream-filter (negate pred) strm))
@end example

A section is a procedure which has been partially applied to some of its
arguments; for instance, @code{(double x)}, which returns twice its
argument, is a partial application of the multiply operator to the
number 2.  Sections come in two kinds:

@itemize
@item
Left sections partially apply arguments starting from the left.

@item
Right sections partially apply arguments starting from the right.
@end itemize

The procedure @func{lsec} takes a procedure and some prefix of its
arguments and returns a new procedure in which those arguments are
partially applied; the procedure @func{rsec} takes a procedure and some
reversed suffix of its arguments and returns a new procedure in which
those arguments are partially applied:

@example
(define (lsec proc . args)
  (lambda x
    (apply proc (append args x))))

(define (rsec proc . args)
  (lambda x
    (apply proc (reverse (append (reverse args)
                                 (reverse x))))))
@end example

Since most of the stream procedures take a stream as their last
(rightmost) argument, left sections are particularly useful in
conjunction with streams.

@example
(define stream-sum (lsec stream-fold + 0))
@end example

Function composition creates a new function by partially applying
multiple functions, one after the other.  In the simplest case there are
only two functions, @var{f} and @var{g}, composed as @code{(compose f
g)}; the composition can be bound to create a new function, as in:

@example
(define fg (compose f g))
@end example

@noindent
the procedure @func{compose} takes one or more procedures and returns a
new procedure that performs the same action as the individual procedures
would if called in succession:

@example
(define (compose . fns)
  (let comp ((fns fns))
    (cond
      ((null? fns) 'error)
      ((null? (cdr fns)) (car fns))
      (else
        (lambda args
          (call-with-values
            (lambda ()
              (apply
                (comp (cdr fns))
                args))
            (car fns)))))))
@end example

@func{compose} works with sections to create succinct but highly
expressive procedure definitions.  The expression to compute the squares
of the integers from 1 to 10 given above at @func{stream-unfold} could
be written by composing @func{stream-map}, @func{stream-take-while}, and
@func{stream-iterate}:

@example
((compose
  (lsec stream-map (rsec expt 2))
  (lsec stream-take-while (negate (rsec > 10)))
  (lsec stream-iterate (rsec + 1)))
 1)
@end example

@c page
@node streams examples
@section Examples


@cindex @srfi{} streams examples


The examples below show a few of the myriad ways streams can be
exploited, as well as a few ways they can trip the unwary user.  All the
examples are drawn from published sources; it is instructive to compare
the Scheme versions to the originals in other languages.

@menu
* streams examples infinite::   Infinite streams.
* streams examples generators:: Generators and co--routines.
* streams examples pipeline::   A pipeline of procedures.
* streams examples persistent:: Persistent data.
* streams examples passes::     Reducing two passes to one.
* streams examples pitfalls::   Pitfalls.
@end menu


@c page
@node streams examples infinite
@subsection Infinite streams


As a simple illustration of infinite streams, consider this definition
of the natural numbers:

@example
(define nats
  (stream-cons 0
    (stream-map add1 nats)))
@end example

@noindent
the recursion works because it is offset by one from the initial
@func{stream-cons}.  Another sequence that uses the offset trick is this
definition of the Fibonacci numbers:

@example
(define fibs
  (stream-cons 1
    (stream-cons 1
      (stream-map +
        fibs
        (stream-cdr fibs)))))
@end example

Yet another sequence that uses the same offset trick is the Hamming
numbers, named for the mathematician and computer scientist Richard
Hamming, defined as all numbers that have no prime factors greater than
5; in other words, Hamming numbers are all numbers expressible as

@example
2i x 3j x 5k
@end example

@noindent
where @var{i}, @var{j} and @var{k} are non--negative integers.  The
Hamming sequence starts with 1 2 3 4 5 6 8 9 10 12 and is computed
starting with 1, taking 2, 3 and 5 times all the previous elements with
@func{stream-map}, then merging @func{sub-streams} and eliminating
duplicates:

@example
(define hamming
  (stream-cons 1
    (stream-unique =
      (stream-merge <
        (stream-map (lsec * 2) hamming)
        (stream-map (lsec * 3) hamming)
        (stream-map (lsec * 5) hamming)))))
@end example

It is possible to have an infinite stream of infinite streams. Consider
the definition of @func{power-table}:

@example
(define power-table
  (stream-of
    (stream-of (expt m n)
      (m in (stream-from 1)))
      (n in (stream-from 2))))
@end example

@noindent
which evaluates to an infinite stream of infinite streams:

@example
(stream
  (stream 1 4 9 16 25 ...)
  (stream 1 8 27 64 125 ...)
  (stream 1 16 81 256 625 ...)
  ...)
@end example

But even though it is impossible to display @func{power-table} in its
entirety, it is possible to select just part of it:

@example
(stream->list 10 (stream-ref power-table 1))
  => (1 8 27 64 125 216 343 512 729 1000)
@end example

This example clearly shows that the elements of a stream are computed
lazily, as they are needed; @code{(stream-ref power-table 0)} is not
computed, even when its successor is displayed, since computing it would
enter an infinite loop.

Chris Reade shows how to calculate the stream of prime numbers according
to the sieve of Eratosthenes, using a method that eliminates multiples
of the sifting base with addition rather than division:

@example
(define primes (let ()
  (define-stream (next base mult strm)
    (let ((first (stream-car strm))
          (rest (stream-cdr strm)))
      (cond ((< first mult)
              (stream-cons first
                (next base mult rest)))
            ((< mult first)
              (next base (+ base mult) strm))
            (else (next base
                    (+ base mult) rest)))))
  (define-stream (sift base strm)
    (next base (+ base base) strm))
  (define-stream (sieve strm)
    (let ((first (stream-car strm))>
          (rest (stream-cdr strm)))
      (stream-cons first
        (sieve (sift first rest)))))
  (sieve (stream-from 2))))
@end example

A final example of infinite streams is a functional pearl from Jeremy
Gibbons, David Lester and Richard Bird that enumerates the positive
rational numbers without duplicates:

@example
(define rats
  (stream-iterate
    (lambda (x)
      (let* ((n (floor x)) (y (- x n)))
        (/ (- n -1 y))))
    1))
@end example

@c page
@node streams examples generators
@subsection Generators and co--routines


It is possible to model generators and co--routines using streams.
Consider the task, due to Carl Hewitt, of determining if two trees have
the same sequence of leaves:

@example
(same-fringe? = '(1 (2 3)) '((1 2) 3))  => #t

(same-fringe? = '(1 2 3) '(1 (3 2)))    => #f
@end example

The simplest solution is to flatten both trees into lists and compare
them element--by--element:

@example
(define (flatten tree)
  (cond [(null? tree) '()]
        [(pair? (car tree))
         (append (flatten (car tree))
                 (flatten (cdr tree)))]
        [else (cons (car tree)
                    (flatten (cdr tree)))]))

(define (same-fringe? eql? tree1 tree2)
  (let loop ([t1 (flatten tree1)]
             [t2 (flatten tree2)])
    (cond [(and (null? t1) (null? t2)) #t]
          [(or (null? t1) (null? t2)) #f]
          [(not (eql? (car t1) (car t2))) #f]
          [else (loop (cdr t1) (cdr t2))])))
@end example

That works, but requires time to flatten both trees and space to store
the flattened versions; if the trees are large, that can be a lot of
time and space, and if the fringes differ, much of that time and space
is wasted.

Hewitt used a generator to flatten the trees one element at a time,
storing only the current elements of the trees and the machines needed
to continue flattening them, so @func{same-fringe?} could stop early if
the trees differ.  Dorai Sitaram presents both the generator solution
and a co--routine solution, which both involve tricky calls to
@func{call-with-current-continuation} and careful coding to keep them
synchronized.

An alternate solution flattens the two trees to streams instead of
lists, which accomplishes the same savings of time and space, and
involves code that looks little different than the list solution
presented above:

@example
(define-stream (flatten tree)
  (cond [(null? tree) stream-null]
        [(pair? (car tree))
         (stream-append
           (flatten (car tree))
           (flatten (cdr tree)))]
        [else (stream-cons
                (car tree)
                (flatten (cdr tree)))]))

(define (same-fringe? eql? tree1 tree2)
  (let loop ([t1 (flatten tree1)]
             [t2 (flatten tree2)])
    (cond [(and (stream-null? t1)
                (stream-null? t2)) #t]
          [(or  (stream-null? t1)
                (stream-null? t2)) #f]
          [(not (eql? (stream-car t1)
                      (stream-car t2))) #f]
          [else (loop (stream-cdr t1)
                      (stream-cdr t2))])))
@end example

Note that streams, a data structure, replace generators or co--routines,
which are control structures, providing a fine example of how lazy
streams enhance modularity.

@c page
@node streams examples pipeline
@subsection A pipeline of procedures


Another way in which streams promote modularity is enabling the use of
many small procedures that are easily composed into larger programs, in
the style of Unix pipelines, where streams are important because they
allow a large dataset to be processed one item at a time.  Bird and
Wadler provide the example of a text formatter.  Their example uses
right--folds:

@example
(define (stream-fold-right f base strm)
  (if (stream-null? strm)
      base
    (f (stream-car strm)
       (stream-fold-right f base
         (stream-cdr strm)))))

(define (stream-fold-right-one f strm)
  (stream-match strm
    [(x) x]
    [(x . xs)
     (f x (stream-fold-right-one f xs))]))
@end example

Bird and Wadler define text as a stream of characters, and develop a
standard package for operating on text, which they derive mathematically
(this assumes the line--separator character is a single
@code{#\newline}):

@example
(define (breakon a)
  (stream-lambda (x xss)
    (if (equal? a x)
        (stream-append (stream (stream)) xss)
      (stream-append
        (stream (stream-append
            (stream x) (stream-car xss)))
        (stream-cdr xss)))))

(define-stream (lines strm)
  (stream-fold-right
    (breakon #\newline)
    (stream (stream))
    strm))

(define-stream (words strm)
  (stream-filter stream-pair?
    (stream-fold-right
      (breakon #\space)
      (stream (stream))
      strm)))

(define-stream (paras strm)
  (stream-filter stream-pair?
    (stream-fold-right
      (breakon stream-null)
      (stream (stream))
      strm)))

(define (insert a)
  (stream-lambda (xs ys)
    (stream-append xs (stream a) ys)))

(define unlines
  (lsec stream-fold-right-one
    (insert #\newline)))

(define unwords
  (lsec stream-fold-right-one
    (insert #\space)))

(define unparas
  (lsec stream-fold-right-one
    (insert stream-null)))
@end example

These versatile procedures can be composed to count words, lines and
paragraphs; the @func{normalize} procedure squeezes out multiple spaces
and blank lines:

@example
(define countlines
  (compose stream-length lines))

(define countwords
  (compose stream-length
           stream-concat
           (lsec stream-map words)
           lines))

(define countparas
  (compose stream-length paras lines))

(define parse
  (compose (lsec stream-map
             (lsec stream-map words))
           paras
           lines))

(define unparse
  (compose unlines
           unparas
           (lsec stream-map
             (lsec stream-map unwords))))

(define normalize (compose unparse parse))
@end example

More useful than normalization is text--filling, which packs as many
words onto each line as will fit.

@example
(define (greedy m ws)
  (- (stream-length
       (stream-take-while (rsec <= m)
         (stream-scan
           (lambda (n word)
             (+ n (stream-length word) 1))
           -1
           ws))) 1))

(define-stream (fill m ws)
  (if (stream-null? ws)
      stream-null
    (let* ([n (greedy m ws)]
           [fstline (stream-take n ws)]
           [rstwrds (stream-drop n ws)])
      (stream-append
        (stream fstline)
        (fill m rstwrds)))))

(define linewords
  (compose stream-concat
           (lsec stream-map words)))

(define textparas
  (compose (lsec stream-map linewords)
           paras
           lines))

(define (filltext m strm)
  (unparse (stream-map (lsec fill m) (textparas strm))))
@end example

To display filename in lines of @var{n} characters, say:

@example
(stream-for-each display
  (filltext n (file->stream filename)))
@end example

Though each operator performs only a single task, they can be composed
powerfully and expressively.  The alternative is to build a single
monolithic procedure for each task, which would be harder and involve
repetitive code.  Streams ensure procedures are called as needed.

@c page
@node streams examples persistent
@subsection Persistent data


Queues are one of the fundamental data structures of computer science.
In functional languages, queues are commonly implemented using two
lists, with the front half of the queue in one list, where the head of
the queue can be accessed easily, and the rear half of the queue in
reverse order in another list, where new items can easily be added to
the end of a queue.  The standard form of such a queue holds that the
front list can only be null if the rear list is also null:

@example
(define queue-null (cons '() '())

(define (queue-null? obj)
  (and (pair? obj) (null? (car obj))))

(define (queue-check f r)
  (if (null? f)
      (cons (reverse r) '())
    (cons f r)))

(define (queue-snoc q x)
  (queue-check (car q) (cons x (cdr q))))

(define (queue-head q)
  (if (null? (car q))
      (error "empty queue: head")
    (car (car q))))

(define (queue-tail q)
  (if (null? (car q))
      (error "empty-head: tail")
    (queue-check (cdr (car q)) (cdr q))))
@end example

This queue operates in amortized constant time per operation, with two
conses per element, one when it is added to the rear list, and another
when the rear list is reversed to become the front list.
@func{queue-snoc} and @func{queue-head} operate in constant time;
@func{queue-tail} operates in worst--case linear time when the front
list is empty.

Chris Okasaki points out that, if the queue is used persistently, its
time--complexity rises from linear to quadratic since each persistent
copy of the queue requires its own linear--time access.  The problem can
be fixed by implementing the front and rear parts of the queue as
streams, rather than lists, and rotating one element from rear to front
whenever the rear list is larger than the front list:

@example
(define queue-null
  (cons stream-null stream-null))

(define (queue-null? x)
  (and (pair? x) (stream-null (car x))))

(define (queue-check f r)
  (if (< (stream-length r) (stream-length f))
      (cons f r)
    (cons (stream-append f (stream-reverse r))
          stream-null)))

(define (queue-snoc q x)
  (queue-check (car q) (stream-cons x (cdr q))))

(define (queue-head q)
  (if (stream-null? (car q))
      (error "empty queue: head")
    (stream-car (car q))))

(define (queue-tail q)
  (if (stream-null? (car q))
      (error "empty queue: tail")
    (queue-check (stream-cdr (car q)) (cdr q))))
@end example

Memoization solves the persistence problem; once a queue element has
moved from rear to front, it needs never be moved again in subsequent
traversals of the queue.  Thus, the linear time--complexity to access
all elements in the queue, persistently, is restored.

@c page
@node streams examples passes
@subsection Reducing two passes to one


The final example is a lazy dictionary, where definitions and uses may
occur in any order; in particular, uses may precede their corresponding
definitions.  This is a common problem.

Many programming languages allow procedures to be used before they are
defined.  Macro processors must collect definitions and emit uses of
text in order.  An assembler needs to know the address that a linker
will subsequently give to variables.  The usual method is to make two
passes over the data, collecting the definitions on the first pass and
emitting the uses on the second pass.  But Chris Reade shows how streams
allow the dictionary to be built lazily, so that only a single pass is
needed.  Consider a stream of requests:

@example
(define requests
  (stream
    '(get 3)
    '(put 1 "a")    ; use follows definition
    '(put 3 "c")    ; use precedes definition
    '(get 1)
    '(get 2)
    '(put 2 "b")    ; use precedes definition
    '(put 4 "d")))  ; unused definition
@end example

We want a procedure that will display cab, which is the result of
@code{(get 3)}, @code{(get 1)}, and @code{(get 2)}, in order.  We first
separate the request stream into gets and puts:

@example
(define (get? obj) (eq? (car obj) 'get))

(define-stream (gets strm)
  (stream-map cadr (stream-filter get? strm)))

(define-stream (puts strm)
  (stream-map cdr  (stream-remove get? strm)))
@end example

Now, @func{run-dict} inserts each element of the puts stream into a lazy
dictionary, represented as a stream of key/value pairs (an association
stream), then looks up each element of the gets stream with
@func{stream-assoc}:

@example
(define-stream (run-dict requests)
  (let ([dict (build-dict (puts requests))])
    (stream-map (rsec stream-assoc dict)
      (gets requests))))

(define (stream-assoc key dict)
    (cond [(stream-null? dict) #f]
          [(equal? key (car (stream-car dict)))
           (stream-car dict)]
          [else (stream-assoc key
                  (stream-cdr dict))]))
@end example

@var{dict} is created in the @func{let}, but nothing is initially added
to it.  Each time @func{stream-assoc} performs a lookup, enough of
@var{dict} is built to satisfy the lookup, but no more.  We are assuming
that each item is defined once and only once.  All that is left is to
define the procedure that inserts new items into the dictionary, lazily:

@example
(define-stream (build-dict puts)
  (if (stream-null? puts)
      stream-null
    (stream-cons
      (stream-car puts)
      (build-dict (stream-cdr puts)))))

@end example

Now we can run the requests and print the result:

@example
(stream-for-each display
  (stream-map cadr (run-dict requests)))
@end example

The @code{(put 4 "d")} definition is never added to the dictionary
because it is never needed.

@c page
@node streams examples pitfalls
@subsection Pitfalls


Programming with streams, or any lazy evaluator, can be tricky, even for
programmers experienced in the genre.  Programming with streams is even
worse in Scheme than in a purely functional language, because, though
the streams are lazy, the surrounding Scheme expressions in which they
are embedded are eager.  The impedance between lazy and eager can
occasionally lead to astonishing results.  Thirty--two years ago,
William Burge warned:

@quotation
Some care must be taken when a stream is produced to make sure that its
elements are not really a list in disguise, in other words, to make sure
that the stream elements are not materialized too soon.
@end quotation

For example, a simple version of @func{stream-map} that returns a stream
built by applying a unary procedure to the elements of an input stream
could be defined like this:

@example
(define-stream (stream-map proc strm) ;wrong!
  (let loop ([strm strm])
    (if (stream-null? strm)
        stream-null
      (stream-cons
        (proc (stream-car strm))
        (loop (stream-cdr strm))))))
@end example

That looks right.  It properly wraps the procedure in
@func{stream-lambda}, and the two legs of the @func{if} both return
streams, so it type--checks.  But it fails because the named @func{let}
binds @var{loop} to a procedure using normal @func{lambda} rather than
@func{stream-lambda}, so even though the first element of the result
stream is lazy, subsequent elements are eager.  @func{stream-map} can be
written using @func{stream-let}:

@example
(define-stream (stream-map proc strm)
  (stream-let loop ([strm strm])
    (if (stream-null? strm)
        stream-null
      (stream-cons
        (proc (stream-car strm))
        (loop (stream-cdr strm))))))
@end example

Here, @func{stream-let} assures that each element of the result stream
is properly delayed, because each is subject to the @func{stream-lambda}
that is implicit in @func{stream-let}, so the result is truly a stream,
not a ``list in disguise''.  Another version of this procedure was given
previously at the description of @func{define-stream}.

Another common problem occurs when a stream--valued procedure requires
the next stream element in its definition.  Consider this definition of
@func{stream-unique}:

@example
(define-stream (stream-unique eql? strm) ;wrong!
  (stream-match strm
    [() strm]
    [(_) strm]
    [(a b . _)
     (if (eql? a b)
         (stream-unique eql?
           (stream-cdr strm))
       (stream-cons a
         (stream-unique eql?
           (stream-cdr strm))))]))
@end example

@noindent
the @code{(a b . _)} pattern requires the value of the next stream
element after the one being considered.  Thus, to compute the nth
element of the stream, one must know the n+1st element, and to compute
the n+1st element, one must know the n+2nd element, and to compute...
The correct version, given above in the description of
@func{stream-drop-while}, only needs the current stream element.

A similar problem occurs when the stream expression uses the previous
element to compute the current element:

@example
(define (nat n)
  (stream-ref
    (stream-let loop ([s (stream 0)])
      (stream-cons (stream-car s)
        (loop (stream (add1 (stream-car s))))))
    n))
@end example

@noindent
this program traverses the stream of natural numbers, building the
stream as it goes.  The definition is correct: @code{(nat 15)} evaluates
to 15; but it needlessly uses unbounded space because each stream
element holds the value of the prior stream element in the binding to
@var{s}.

When traversing a stream, it is easy to write the expression in such a
way that evaluation requires unbounded space, even when that is not
strictly necessary.  During the discussion of @ansrfi{40}, Joe Marshall
created this infamous procedure:

@example
(define (times3 n)
  (stream-ref
    (stream-filter
      (lambda (x)
        (zero? (modulo x n)))
      (stream-from 0))
    3))
@end example

@noindent
@code{(times3 5)} evaluates to 15 and @code{(times3 #e1e9)} evaluates to
three billion, though it takes a while.  In either case, @func{times3}
should operate in bounded space, since each iteration mutates the
promise that holds the next value.  But it is easy to write
@func{times3} so that it does not operate in bounded space, as the
follies of @ansrfi{40} showed.

The common problem is that some element of the stream (often the first
element) is bound outside the expression that is computing the stream,
so it holds the head of the stream, which holds the second element, and
so on.  In addition to testing the programmer, this procedure tests the
stream primitives (it caught several errors during development) and also
tests the underlying Scheme system (it found a bug in one
implementation).

Laziness is no defense against an infinite loop; for instance, the
expression below never returns, because the @func{odd?} predicate never
finds an odd stream element.

@example
(stream-null?
  (stream-filter odd?
    (stream-from 0 2)))
@end example

Ultimately, streams are defined as promises, which are implemented as
thunks (lambda with no arguments).  Since a stream is a procedure,
comparisons such as @func{eq?}, @func{eqv?} and @func{equal?} are not
meaningful when applied to streams.  For instance, the expression

@example
(define s ((stream-lambda () stream-null)))
@end example

@noindent
defines @var{s} as the null stream, and @code{(stream-null? s)} is
@true{}, but @code{(eq?  s stream-null)} is @false{}.

To determine if two streams are equal, it is necessary to evaluate the
elements in their common prefixes, reporting @false{} if two elements
ever differ and @true{} if both streams are exhausted at the same time.

@example
(define (stream-equal? eql? xs ys)
  (cond [(and (stream-null? xs)
              (stream-null? ys)) #t]
        [(or (stream-null? xs)
             (stream-null? ys)) #f]
        [(not (eql? (stream-car xs)
                    (stream-car ys))) #f]
        [else (stream-equal? eql?
                (stream-cdr xs)
                (stream-cdr ys))]))
@end example

It is generally not a good idea to mix lazy streams with eager
side--effects, because the order in which stream elements are evaluated
determines the order in which the side--effects occur.  For a simple
example, consider this side--effecting version of @func{strm123}:

@example
(define strm123-with-side-effects
  (stream-cons (begin (display "one") 1)
    (stream-cons (begin (display "two") 2)
      (stream-cons (begin (display "three") 3)
        stream-null))))
@end example

The stream has elements @code{1 2 3}.  But depending on the order in
which stream elements are accessed, @code{"one"}, @code{"two"} and
@code{"three"} could be printed in any order.

Since the performance of streams can be very poor, normal (eager) lists
should be preferred to streams unless there is some compelling reason to
the contrary.  For instance, computing pythagorean triples with streams:

@example
(stream-ref
  (stream-of (list a b c)
    (n in (stream-from 1))
    (a in (stream-range 1 n))
    (b in (stream-range a n))
    (c is (- n a b))
    (= (+ (* a a) (* b b)) (* c c)))
  50)
@end example

@noindent
is about two orders of magnitude slower than the equivalent expression
using loops:

@example
(do ([n 1 (+ n 1)]) ([> n 228])
  (do ([a 1 (+ a 1)]) ([> a n])
    (do ([b a (+ b 1)]) ([> b n])
      (let ([c (- n a b)])
        (if (= (+ (* a a) (* b b)) (* c c))
            (display (list a b c)))))))
@end example

@c page
@node comparisons
@chapter Comparison functions


The @library{comparisons} library implements an infrastructure for
comparison functions; it can be seen as an extension of the standard
procedures @func{=}, @func{<}, @func{char<?} etc.  The primary design
aspect is the separation of representing a total order and using it.

Since the compare procedures are often optional, comparing built in
types is as convenient as using built in function, sometimes more
convenient: For example, testing if the integer index @code{i} lies in
the integer range @math{[0, n)} can be written as @code{(<=/<? 0 i n)}.

@menu
* comparisons intro::           Introduction.
* comparisons examples::        Examples.
* comparisons conventions::     Terminology and conventions.
* comparisons atoms::           Comparing atoms.
* comparisons sequence::        Comparing lists and vectors.
* comparisons pair::            Comparing pairs and improper lists.
* comparisons default::         The default compare procedure.
* comparisons cons::            Constructing compare procedures.
* comparisons branch::          Branching.
* comparisons pred::            Predicates.
* comparisons minmax::          Minimum and maximum values.
* comparisons debug::           Debugging procedure.
@end menu

@c page
@node comparisons intro
@section Introduction


The @library{comparisons} library defines a mechanism for comparing
Scheme values with respect to a total order (aka linear order).  The
mechanism provides operations for:

@enumerate
@item
Comparing objects of the built-in types.

@item
Using a total order in situations that arise in programs.

@item
Facilitating the definition of a new total order.
@end enumerate

Traditionally, a total order is represented in Scheme by an order
predicate, like @func{<} or @func{char<?}.  In the context of
@library{comparisons}, however, a total order is represented by a Scheme
procedure comparing its two arguments and returning either @math{-1},
@math{0}, or @math{1} depending on whether the first argument is
considered smaller, equal, or greater than the second argument
respectively.  Examples of such compare procedures include:

@example
(lambda (x y)
  (sign (- x y)))
@end example

@noindent
for comparing real numbers, but also:

@example
(lambda (x y) 0)
@end example

@noindent
comparing anything.

The primary reason for using @math{3}--valued compare procedures
(instead of @math{2}--valued order predicates) is efficiency: When
comparison is computationally expensive, it is wasteful if two
predicates are evaluated where a single @math{3}--valued comparison
would suffice.

But dealing directly with @math{3}--valued comparisons in the
application program is inconvenient and obscures intention: For testing
@math{x < y} one would have to write:

@example
(= (compare x y) -1)
@end example

@noindent
for this reason, an operation @func{<?} is supplied which allows to
phrase the same test as:

@example
(<? compare x y)
@end example

This is an example of mapping the three possible outcomes of a
comparison into the two boolean values @true{} and @false{}.  Since
@func{<?}  takes the total order as an explicit parameter, a comfortably
large arsenal of tests can be made available for each and every total
order.  This deviates from the approach of @rnrs{6}, in which there are
only five operations (@func{=}, @func{<}, @func{>}, @func{<=},
@func{>=}) and for each total order (real/number, char, char--ci,
string, string--ci) a complete set of these five operations is provided.

But still, using @func{<?} would be inconvenient if the compare
procedure would have to be supplied explicitly every time.  For this
reason, the argument @var{compare} is often made optional and the
procedure @func{default-compare} is used whenever no @var{compare}
procedure is passed explicitly.  @func{default-compare} defines some
resonable total order on the builtin types of @rnrs{6}.

For the definition of comparison procedures, special control structures
(macros) are provided.  These control structures can be used in the
definition of a (potentially recursive) comparison procedure.

@c page
@node comparisons examples
@section Examples


Assume there is a type @samp{length} representing physical length;  the
type has an accessor procedure @func{meters} returning the length in
meters (a real number):

@example
(define-record-type length
  (fields (immutable meters     meters)))
@end example

A compare procedure for lengths can then be defined in terms of
@func{real-compare} as:

@example
(define (length-compare length1 length2)
  (real-compare (meters length1) (meters length2)))
@end example

@noindent
now:

@example
(<? length-compare x y)
@end example

@noindent
tests if length @var{x} is shorter than length @var{y}.  Also,

@example
(<=/<? length-compare a x b)
@end example

@noindent
tests if length @var{x} lies between length @var{a} (included) and
length @var{b} (excluded).  The expression:

@example
(min-compare length-compare x y z)
@end example

@noindent
is the shortest of the lengths @var{x}, @var{y}, and @var{z}.  Likewise,

@example
(chain<? length-compare x1 x2 x3 x4)
@end example

@noindent
tests if the lengths @var{x1}, @var{x2}, @var{x3}, @var{x3} are strictly
increasing, and so on.

Furthermore, assume there is another type @code{box} representing a
physical box; the type has procedures @func{width}, @func{height}, and
@func{depth} accessing the dimension (each giving a length):

@example
(define-record-type box
  (fields (immutable width      width)
          (immutable height     height)
          (immutable depth      depth)))
@end example

A comparison procedure for boxes, comparing first by width then by
height and then by depth, can be defined using the control structure
@func{refine-compare} as:

@example
(define (box-compare box1 box2)
  (refine-compare
    (length-compare (width  box1) (width  box2))
    (length-compare (height box1) (height box2))
    (length-compare (depth  box1) (depth  box2))))
@end example

@noindent
so:

@example
(<? box-compare b1 b2)
@end example

@noindent
tests if box @var{b1} is smaller than box @var{b2}, in the sense of the
order defined.  Of course, all the other tests, minimum, maximum etc.
are available, too.

As a final complication, assume that there is also a type @code{bowl}
with accessors @func{radius} (a @samp{length}) and @func{open?} (a
boolean):

@example
(define-record-type bowl
  (fields (immutable radius   radius)
          (immutable open?    open?)))
@end example

Bowls are to be compared first by whether they are open or closed, and
then by radius.  However, bowls and boxes also need to be compared to
each other, ordered such that a bowl is considered ``smaller'' than a
box.  (There are type--test predicates @func{box?} and @func{bowl?}).
Using the control structure @func{select-compare} this can be expressed
as:

@example
(define (container-compare c1 c2)
  (select-compare c1 c2
    (bowl? (boolean-compare (open?  c1) (open?  c2))
           (length-compare  (radius c1) (radius c2)))
    (box?  (box-compare c1 c2))
    (else "neither bowls nor boxes" c1 c2)))
@end example

This is an example of ``hierarchical extension'' of compare procedures.
Also note the implicit use of @func{refine-compare} in the @func{bowl?}
case.


@c page
@node comparisons conventions
@section Terminology and conventions


A @dfn{comparison procedure} is a Scheme procedure of two arguments
returning an exact integer in @math{@{-1, 0, 1@}} such that the valid
input values are ordered according to some total order.  A comparison
procedure, together with a set of Scheme values to which it is
applicable, represents a comparison function.

A @dfn{comparison} is either an expression applying a comparison
procedure to two values, or the result of such an expression.

Each operation (macro or procedure) processing the value of a comparison
checks if the value is indeed an exact integer in the set @math{@{-1, 0,
1@}}.  If this is not the case, an error is signalled.

Comparison procedures expecting certain types of arguments should raise
an error in case the arguments are not of this type.

@c page
@node comparisons atoms
@section Comparing atoms


This section describes comparison procedures for most of the atomic
types of @rnrs{6}: booleans, characters, strings, symbols, and numbers.
As a general naming convention, a procedure named:

@example
@var{type}-compare-@var{order}
@end example

@noindent
compares two objects of the type @var{type} with respect to a total
order for which @var{order} is a mnemonic hint (e.g. @samp{-ci} for
case--insensitive).  Of course, @samp{-@var{order}} may be absent if
there is just one order or the order is obvious.  It is an error if a
comparison procedure accepting objects of a certain type is called with
one or two arguments not of that type.


@defun boolean-compare @var{bool1} @var{bool2}
Compare two booleans, ordered by @false{} < @true{}.  A non--false value
is not interpreted as a ``true value,'' but rather an error will be
signalled.
@end defun


@defun char-compare @var{char1} @var{char2}
@defunx char-compare-ci @var{char1} @var{char2}
Compare characters as @func{char<=?} and @func{char-ci<=?}
respectively.  The suffix @code{-ci} means ``case insensitive.''
@end defun


@defun string-compare @var{string1} @var{string2}
@defunx string-compare-ci @var{string1} @var{string2}
Compare strings as @func{string<=} and @func{string-ci<=?}.  The suffix
@code{-ci} means ``case insensitive.''
@end defun


@defun symbol-compare @var{symbol1} @var{symbol2}
Compares symbols as @func{string<=} on the names returned by
@func{symbol->string}.
@end defun


@defun integer-compare @var{x} @var{y}
@defunx rational-compare @var{x} @var{y}
@defunx real-compare @var{x} @var{y}
@defunx complex-compare @var{x} @var{y}
@defunx number-compare @var{x} @var{y}
Compare two numbers using the @rnrs{6} functions @func{=} and @func{<}.
It is an error if an argument is not of the type specified by the name
of the procedure.

Complex numbers are ordered based on their magnitude:

@example
(real-compare (magnitude x) (magnitude y))
@end example

If at least one among @var{x} and @var{y} is a complex number:
@func{number-compare} defaults to @func{complex-compare}, else it
defaults to @func{real-compare}.

If one or both the arguments is @samp{+nan.0}:

@table @func
@item integer-compare
@itemx rational-compare
Raise an error because @samp{+nan.0} is neither integer nor rational.

@item real-compare
@itemx complex-compare
@itemx number-compare
Return @samp{+nan.0}.
@end table
@end defun

@c page
@node comparisons sequence
@section Comparing lists and vectors


This section describes comparison procedures for Scheme lists, vectors
and objects that can be accessed like lists or like vectors.

An object @var{x} can be accessed like a vector if there are procedures
@func{size} and @func{ref} such that @samp{(size x)} is a non--negative
integer @math{n} indicating the number of elements, and @code{(ref x i)}
is the @math{i}-th element of @var{x} for @math{i} in @math{@{0, ...,
n-1@}}.

The default vector access procedures are @func{vector-length} and
@func{vector-ref}.

An object @var{x} can be accessed like a (proper) list if there are
procedures @func{empty?}, @func{head} and @func{tail} such that
@code{(empty? x)} is a boolean indicating that there are no elements in
@var{x}, @func{(head x)} is the first element of @var{x}, and
@func{(tail x)} is an object representing the residual elements of
@var{x}.

The default list access procedures are @func{null?}, @func{car} and
@func{cdr}.

Independently of the way the elements are accessed, the natural ordering
of vectors and lists differs.  The following comparison policies are
defined:

@table @emph
@item As vectors
The shorter sequence is always smaller than the longer one, no matter
the elements in it.  Sequences of the same size are compared
lexicographically (element by element, stopping at the first different
one).

@item As lists
The empty sequence is smallest.  Two non--empty sequences are compared
by their first elements, and only if the first elements are equal the
residual sequences are compared, recursively.
@end table


@defun vector-compare @var{x} @var{y}
@defunx vector-compare @var{compare} @var{x} @var{y}
@defunx vector-compare @var{compare} @var{x} @var{y} @var{size} @var{ref}
@defunx vector-compare-as-list @var{x} @var{y}
@defunx vector-compare-as-list @var{compare} @var{x} @var{y}
@defunx vector-compare-as-list @var{compare} @var{x} @var{y} @var{size} @var{ref}
@defunx list-compare @var{x} @var{y}
@defunx list-compare @var{compare} @var{x} @var{y}
@defunx list-compare @var{compare} @var{x} @var{y} @var{empty?} @var{head} @var{tail}
@defunx list-compare-as-vector @var{x} @var{y}
@defunx list-compare-as-vector @var{compare} @var{x} @var{y}
@defunx list-compare-as-vector @var{compare} @var{x} @var{y} @var{empty?} @var{head} @var{tail}
Compare two sequences @var{x} and @var{y}, using @var{compare} for
comparing elements.  The result is an exact integer in @math{@{-1, 0,
1@}}.  If @var{compare} is not supplied, @func{default-compare} is used.

The procedure named @func{@var{access}-compare-as-@var{order}} accesses
the objects like @var{access} and compares them with respect to the
order given by @var{order}. The names @func{@var{type}-compare} are
abbreviations for @code{@var{type}-compare-as-@var{type}}.

In the following examples the difference between comparison as list and
comparison as vector does not show:

@example
(list-compare '()  '())                    @result{} 0
(list-compare '(1) '())                    @result{} +1
(list-compare '()  '(1))                   @result{} -1

(list-compare '(1) '(1))                   @result{} 0
(list-compare '(1) '(2))                   @result{} -1
(list-compare '(2) '(1))                   @result{} +1

(list-compare '(1 1) '(1 1))               @result{} 0
(list-compare '(1 1) '(1 2))               @result{} -1
(list-compare '(1 2) '(1 1))               @result{} +1

(list-compare '(1 1 1) '(1 1))             @result{} +1
(list-compare '(1 1)   '(1 1 1))           @result{} -1

(list-compare-as-vector '()  '())          @result{} 0
(list-compare-as-vector '(1) '())          @result{} +1
(list-compare-as-vector '()  '(1))         @result{} -1

(list-compare-as-vector '(1) '(1))         @result{} 0
(list-compare-as-vector '(1) '(2))         @result{} -1
(list-compare-as-vector '(2) '(1))         @result{} +1

(list-compare-as-vector '(1 1) '(1 1))     @result{} 0
(list-compare-as-vector '(1 1) '(1 2))     @result{} -1
(list-compare-as-vector '(1 2) '(1 1))     @result{} +1

(list-compare-as-vector '(1 1 1) '(1 1))   @result{} +1
(list-compare-as-vector '(1 1)   '(1 1 1)) @result{} -1
@end example

In the following examples the difference shows:

@example
(vector-compare         '#(1 1 1) '#(2 1)) @result{} +1
(vector-compare-as-list '#(1 1 1) '#(2 1)) @result{} -1
@end example
@end defun

@c page
@node comparisons pair
@section Comparing pairs and improper lists


This section describes comparison procedures for Scheme pairs and
(possibly) improper lists.


@defun pair-compare-car @var{compare}
@defunx pair-compare-cdr @var{compare}
Construct a compare procedure on pairs which only uses the car (or,
respectively, the cdr), and ignores the other.  One could define:

@example
(define (pair-compare-car compare)
  (lambda (x y)
    (compare (car x) (car y))))
@end example

@func{pair-compare-car} can be used to turn a search data structure
(e.g. a heap) into a dictionary: Store @samp{(key . value)} pairs and
compare them using the compare procedure @code{(pair-compare-car
compare-key)}.
@end defun


@defun pair-compare @var{compare-car} @var{compare-cdr} @var{pair1} @var{pair2}
@defunx pair-compare @var{compare} @var{obj1} @var{obj2}
@defunx pair-compare @var{obj1} @var{obj2}
Compare two pairs, or (possibly improper) lists.

The quaternary form compares @var{pair1} and @var{pair2} by comparing
their cars using @func{compare-car}, and if the cars are equal the cdrs
are compared using @func{compare-cdr}.

The ternary form compares two objects by type using the ordering of
types:

@example
null < pair < neither-null-nor-pair
@end example

Two objects of type neither--null--nor--pair are compared using
@var{compare}.  Two pairs are compared by using @var{compare} on the
cars, and if the cars are equal by recursing on the cdrs.

The binary form uses @func{default-compare} as @var{compare}.

@example
(pair-compare '() 'foo)
@result{} -1

(pair-compare '() '(1 . 2)))
@result{} -1

(pair-compare '(1 . 2) 'foo)
@result{} -1

(pair-compare 3 4)
@result{} -1
@end example
@end defun


@c page
@node comparisons default
@section The default compare procedure


It is convenient to have a compare procedure readily available for
comparing most builtin types.


@defun default-compare @var{obj1} @var{obj2}
Compare the arguments by type using the ordering:

@example
null < pair   < boolean < char   < string
     < symbol < number  < vector < other
@end example

Two objects of the same type @var{type} are compared as
@func{@var{type}-compare} would, if there is such a procedure.  The type
@var{null} consists of the empty list.  The effect of comparing two
other objects or of comparing cyclic structures (made from lists or
vectors) is unspecified.
@end defun

@c page
@node comparisons cons
@section Constructing compare procedures


The syntactic extensions defined in this section are the primary
utilities for defining new compare procedures as conveniently as
possible.


@deffn Syntax refine-compare @var{expr} ...
The arguments, if any, must be expressions; they are evaluated from left
to right until a non--zero value is found (which then is the value) or
until there are no more arguments to evaluate (in which case the value
is @samp{0}).  If no arguments are supplied, the return value is
@samp{0}.
@end deffn


@deffn Syntax select-compare @var{expr1} @var{expr2} @var{clause} ...
Each @var{clause}, with the possible exception of the last, is of the
form:

@example
(@meta{type?} @meta{c1} ...)
@end example

@noindent
where @meta{type?} is an expression evaluating to a predicate procedure,
and @meta{ci} are expressions evaluating to an exact integer in
@math{@{-1, 0, 1@}}.  The last @var{clause} may be an ``else clause'',
which has the form:

@example
(else @meta{c1} ...)
@end example

@func{select-compare} is a conditional for defining hierarchical
extensions and refinements of compare procedures.  It compares the
values of @var{expr1} and @var{expr2} by trying the type tests in order,
and applies an implict @func{refine-compare} on the consequences upon a
match.

In more detail, evaluation proceeds as follows: First @var{expr1} and
@var{expr2} are evaluated in unspecified order, resulting in values
@var{x1} and @var{x2}, respectively.  Then the clauses are evaluated one
by one, from left to right.

For clause:

@example
(@meta{type?} @meta{c1} ...)
@end example

@noindent
first @meta{type?} is evaluated resulting in a predicate procedure
@var{type?}  and then the expressions @code{(@var{type?} @var{x1})} and
@code{(@var{type?}  @var{x2})} are evaluated and interpreted as
booleans:

@enumerate
@item
If both booleans are true then the overall value is:

@example
(refine-compare @meta{c1} ...)
@end example

@item
If only the first is true the result is @samp{-1}.

@item
If only the second is true the result is @samp{+1}.

@item
If neither is true the next clause is considered.
@end enumerate

An else clause is treated as if both tests where true.  If there are no
clauses left, the result is @samp{0}.

@func{select-compare} evaluates @var{expr1} and @var{expr2} exactly
once, even in the absence of any clauses.  Moreover, each @meta{type?}
is evaluated at most once and the resulting procedure @var{type?} is
called at most twice.
@end deffn


@deffn Syntax cond-compare @meta{clause} ...
Each @meta{clause}, with the possible exception of the last, is of the
form:

@example
((@meta{t1} @meta{t2}) @meta{c1} ...)
@end example

@noindent
where @meta{t1} and @meta{t2} are expressions evaluating to booleans,
and @meta{ci} are expressions evaluating to an exact integer in
@math{@{-1, 0, 1@}}.

The last @var{clause} may be an ``else clause'', which has the form:

@example
(else @meta{c1} ...)
@end example

@func{cond-compare} is another conditional for defining hierarchical
extensions and refinements of compare procedures.

Evaluation proceeds as follows: The clauses are evaluated one by one,
from left to right.  For clause:

@example
((@meta{t1} @meta{t2}) @meta{c1} ...)
@end example

@noindent
first @meta{t1} and @meta{t2} are evaluated and the results are
interpreted as boolean values:

@enumerate
@item
If both booleans are true then the overall value is:

@example
(refine-compare @meta{c1} ...)
@end example

@item
If only the first is true the result is @samp{-1}.

@item
If only the second is true the result is @samp{+1}.

@item
If neither is true the next clause is considered.
@end enumerate

An else clause is treated as if both booleans where true.  If there are
no clauses left (or there are no clauses to begin with), the result is
@samp{0}.

@func{cond-compare} evaluates each expression at most once.
@end deffn

@c page
@node comparisons branch
@section Branching


The facilities described in this section provide a mechanism for using a
compare procedure (passed as a parameter) in the different situations
arising in applications.

@deffn Syntax if3 @meta{c} @meta{less} @meta{equal} @meta{greater}
@meta{c}, @meta{less}, @meta{equal}, and @meta{greater} are expressions.

@func{if3} is the 3--way conditional for comparisons.  First @meta{c} is
evaluated, resulting in value @var{c}.  The value @var{c} must be an
exact integer in @code{@{-1, 0, 1@}}, otherwise an error is signalled.

@table @math
@item @var{c} = -1
The value of the @func{if3} expression is obtained by evaluating
@meta{less}.

@item @var{c} = 0
@meta{equal} is evaluated.

@item @var{c} = 1
@meta{greater} is evaluated.
@end table
@end deffn


@deffn Syntax if=? @meta{c} @meta{consequent}
@deffnx Syntax if=? @meta{c} @meta{consequent} @meta{alternate}
@deffnx Syntax if<? @meta{c} @meta{consequent}
@deffnx Syntax if<? @meta{c} @meta{consequent} @meta{alternate}
@deffnx Syntax if>? @meta{c} @meta{consequent}
@deffnx Syntax if>? @meta{c} @meta{consequent} @meta{alternate}
@deffnx Syntax if<=? @meta{c} @meta{consequent}
@deffnx Syntax if<=? @meta{c} @meta{consequent} @meta{alternate}
@deffnx Syntax if>=? @meta{c} @meta{consequent}
@deffnx Syntax if>=? @meta{c} @meta{consequent} @meta{alternate}
@deffnx Syntax if-not=? @meta{c} @meta{consequent}
@deffnx Syntax if-not=? @meta{c} @meta{consequent} @meta{alternate}
@meta{c}, @meta{consequent}, and @meta{alternate} are expressions.  If
@meta{alternate} is not provided, @code{(if #f #f)} is used.

These six macros are 2--way conditionals for comparisons.  First
@meta{c} is evaluated, resulting in value @var{c}.  The value @var{c}
must be an exact integer in @math{@{-1, 0, 1@}}, otherwise an error is
signalled.  Then, depending on the value of @var{c} and the name of the
macro, either @meta{consequence} or @meta{alternate} is evaluated, and
the resulting value is the value of the conditional expression.

The branch is chosen according to the following table:

@multitable {@func{if-not=?}} {@meta{consequent}012} {@meta{alternate}0}
@headitem @tab @meta{consequent} @tab @meta{alternate}
@item @func{if=?} @tab @code{c = 0} @tab @code{c in @{-1, 1@}}
@item @func{if<?} @tab @code{c = -1} @tab @code{c in @{0, 1@}}
@item @func{if>?} @tab @code{c = 1} @tab @code{c in @{-1, 0@}}
@item @func{if<=?} @tab @code{c in @{-1, 0@}} @tab @code{c = 1}
@item @func{if>=?} @tab @code{c in @{0, 1@}} @tab @code{c = -1}
@item @func{if-not=?} @tab @code{c in @{-1, 1@}} @tab @code{c = 0}
@end multitable
@end deffn

@c page
@node comparisons pred
@section Predicates


@defun =? [@var{compare}] [@var{x} @var{y}]
@defunx <? [@var{compare}] [@var{x} @var{y}]
@defunx >? [@var{compare}] [@var{x} @var{y}]
@defunx <=? [@var{compare}] [@var{x} @var{y}]
@defunx >=? [@var{compare}] [@var{x} @var{y}]
@defunx not=? [@var{compare}] [@var{x} @var{y}]
If the values @var{x} and @var{y} are given, test if @var{x} and @var{y}
are in the relation specified by the name of the procedure @func{rel?},
with respect to compare procedure @var{compare}; otherwise construct a
predicate procedure.

In the forms:

@example
(rel? [@var{compare}] @var{x} @var{y})
@end example

@noindent
the result is a boolean depending on @code{(@var{compare} @var{x}
@var{y})} and the test @func{rel?} as specified for @func{if<?} etc.  If
@var{compare} is not supplied, @func{default-compare} is used.

In the form:

@example
(rel? [@var{compare}])
@end example

@noindent
the predicate procedure:

@example
(lambda (x y)
  (rel? @var{compare} @var{x} @var{y}))
@end example

@noindent
is constructed.  Again, if @var{compare} is not supplied,
@func{default-compare} is used.

A few examples for illustration:

@example
(>? "laugh" "LOUD")
@result{} #t

(<? string-compare-ci "laugh" "LOUD")
@result{} #t

(define char<=?
  (<=? char-compare))

(sort-by-less '(1 a "b") (<?))
@result{} '("b" a 1)

(sort-by-less '(1 a "b") (>?))
@result{} '(1 a "b")
@end example

@quotation
@emph{Warning:} A common mistake is writing @code{(<=? x y z)} where
@code{(<=/<=? x y z)} is meant; this will most likely manifest itself at
the time the expression @code{(x y z)} is evaluated.
@end quotation
@end defun


@defun </<? [@var{compare}] [@var{x} @var{y} @var{z}]
@defunx </<=? [@var{compare}] [@var{x} @var{y} @var{z}]
@defunx <=/<? [@var{compare}] [@var{x} @var{y} @var{z}]
@defunx <=/<=? [@var{compare}] [@var{x} @var{y} @var{z}]
@defunx >/>? [@var{compare}] [@var{x} @var{y} @var{z}]
@defunx >/>=? [@var{compare}] [@var{x} @var{y} @var{z}]
@defunx >=/>? [@var{compare}] [@var{x} @var{y} @var{z}]
@defunx >=/>=? [@var{compare}] [@var{x} @var{y} @var{z}]
Test if @var{x}, @var{y}, and @var{z} form a chain with the two
relations specified by the name of the procedure @func{rel1/rel2?}, with
respect to the compare procedure @var{compare}.

If @var{compare} is not provided, @func{default-compare} is used.

If @var{x}, @var{y} and @var{z} are not provided, a predicate procedure
of three arguments is constructed.  The order in which the values are
compared is unspecified, but each value is compared at least once.

@quotation
@strong{NOTE}

@example
(<=/<? real-compare 0 x 1)
@end example

@noindent
tests if @var{x} is a real number in the half open interval @code{[0,
1)}.
@end quotation
@end defun


@defun chain=? @var{compare} @var{x1} ...
@defunx chain<? @var{compare} @var{x1} ...
@defunx chain>? @var{compare} @var{x1} ...
@defunx chain<=? @var{compare} @var{x1} ...
@defunx chain>=? @var{compare} @var{x1} ...
Test if the values @var{x1} @dots{} (zero or more values) form a chain
with respect to the relation specified by the name of the procedure, and
with respect to the compare procedure @var{compare}.  The result is a
boolean.

The order in which the values are compared is unspecified, but each
value is compared at least once (even if there is just one).

A sequence of values @var{x1}, @dots{}, @var{xn} forms a chain with
respect to the relation @func{rel?} if:

@example
(rel? @var{compare} @var{xi} @var{xj})
@end example

@noindent
for all @math{1 < i < j < n}.  In particular, this is the case for
@math{n \in @{0, 1@}}.

Since the relations @func{=}, @func{<}, @func{>}, @func{<}, and @func{>}
are transitive, it is sufficient to test:

@example
(rel? @var{compare} @var{xi} @var{xi+1})
@end example

@noindent
for @math{1 < i < n}.

@quotation
@strong{NOTE} The reason every @var{xi} participates in at least one
comparison is type--checking: After testing if the values form a chain,
these value may be assumed to be of the type comparable by compare---
and this holds irrespectively of the number of values, or whether they
form a chain.
@end quotation
@end defun


@defun pairwise-not=? @var{compare} @var{x1} ...
Tests if the values @var{x1} ... (zero or more values) are pairwise
unequal with respect to the compare procedure @var{compare}.  The result
is a boolean.

The order in which the values are compared is unspecified, but each
value is compared at least once (even if there is just one).

The values @var{x1}, ..., @var{xn} are pairwise unequal if:

@example
(not=? @var{compare} @var{xi} @var{xj})
@end example

@noindent
for all @math{i} different from @math{j}.  In particular, this is the
case for @math{n \in @{0, 1@}}.

Since compare defines a total ordering on the values, the property can
be checked in time @math{O(n log n)}.
@end defun


@defun compare-by< @var{lt-pred} [@var{x} @var{y}]
@defunx compare-by> @var{gt-pred} [@var{x} @var{y}]
@defunx compare-by<= @var{le-pred} [@var{x} @var{y}]
@defunx compare-by>= @var{ge-pred} [@var{x} @var{y}]
@defunx compare-by=/< @var{eq-pred} @var{lt-pred} [@var{x} @var{y}]
@defunx compare-by=/> @var{eq-pred} @var{gt-pred} [@var{x} @var{y}]
If optional arguments @var{x} and @var{y} are present then these are
compared with respect to the total order defined by the predicate(s)
given; the result is in @math{@{-1, 0, 1@}}.  If @var{x} and @var{y} are
not present then a procedure comparing its two arguments using the
predicate(s) given is constructed and returned.

The predicate procedures mean the following:

@table @var
@item lt-pred
Test if @math{x < y}.

@item le-pred
Test for @math{<=}.

@item gt-pred
Test for @math{>}.

@item ge-pred
Test for @math{>=}.

@item eq-pred
Test if @var{x} and @var{y} are equivalent.
@end table

The result returned by a predicate procedure is interpreted as a Scheme
truth value (i.e. @false{} is false and non--@false{} is true).

The purpose of the procedures compare-by-predicate(s) is to define a
compare procedure from an order predicate, and possibly an additional
equivalence predicate.  If an equivalence predicate eq-pred is given, it
is called before the order predicate because the equivalence may be
coarser than the total ordering, and it may also be cheaper.

@quotation
@strong{NOTE} @func{char-compare} could be defined in terms of
@func{char<=?} as:

@example
(define char-compare
  (compare-by<= char<=?))
@end example
@end quotation
@end defun

@c page
@node comparisons minmax
@section Minimum and maximum values


@defun min-compare @var{compare} @var{x1} ...
@defunx max-compare @var{compare} @var{x1} ...
A minimum or maximum of the values @var{x1} ... (one or more values)
with respect to the compare procedure compare.

The result is the first value that is minimal (maximal, respectively).
The order in which the values are compared is unspecified, but each
value is compared at least once (even if there is just one value).
@end defun


@defun kth-largest @var{compare} @var{k} @var{x0} ...
The @var{k}-th largest element of values @var{x0} ... (one or more
values) with respect to the compare procedure @var{compare}.

More precisely:

@example
(kth-largest @var{compare} @var{k} @var{x0} ... @var{xn-1})
@end example

@noindent
returns the @code{(modulo k n)}-th element of the unique sequence
obtained by stably sorting @var{x0}, @dots{}, @var{xn-1}.  (Recall that
a sorting algorithm is stable if it does not permute items with equal
key, i.e. equivalent w.r.t. @var{compare}).

The argument @var{k} is an exact integer, and @math{n > 1}.  The order
in which the values @var{xi} are compared is unspecified, but each value
is compared at least once (even if there is just one value).

@quotation
@strong{NOTE} The @math{0}--th largest element is the minimum, the
@math{(n-1)}-th largest element is the maximum.  The median is the
@math{((n - 1)/2)}-th largest element if @math{n} is odd, and the
average of the @math{(n/2 - 1)}-th and @math{n/2}-th largest elements if
@math{n} is even.
@end quotation
@end defun

@c page
@node comparisons debug
@section Debugging procedure


@defun debug-compare @var{compare}
Constructs a compare procedure equivalent to @var{compare} but with
debugging code wrapped around the calls to compare.  The debugging code
signals an error if it detects a violation of the axioms of a compare
function.  For this it is assumed that @var{compare} has no
side--effects.

More specifically, @code{(debug-compare @var{compare})} evaluates to a
compare procedure @var{compare1} which checks reflexivity, antisymmetry,
and transitivity of compare based on the arguments on which
@var{compare1} is called:

The procedure @var{compare1} checks reflexivity on any value passed to
compare, antisymmetry on any pair of values on which compare is called,
and transitivity on triples where two of the arguments are from the
current call to @var{compare1} and the third is a pseudo--random
selection from the two arguments of the previous call to @var{compare1}.
@end defun

@c page
@node loops
@chapter Loop constructs


The @library{loops} library provides extensions to the Scheme language
to loop over general sequences of values.

@menu
* loops intro::                 Introduction.
* loops comprehensions::        Comprehensions.
* loops qualifiers::            Qualifiers.
* loops generators::            Generators.
@end menu

@c page
@node loops intro
@section Introduction


An eager comprehension is a convenient notation for one or more nested
or parallel loops generating a sequence of values, and accumulating this
sequence into a result.  In its most simple form, a comprehension looks
like this:

@example
(list-ec (: i 5)
  (* i i))
@result{} (0 1 4 9 16)
@end example

@noindent
where @var{i} is a local variable that is sequentially bound to the
values 0, 1, @dots{}, 4, and the squares of these numbers are collected
in a list.  The following example illustrates most conventions with
respect to nesting and syntax:

@example
(list-ec (: n 1 4)
         (: i n)
  (list n i))
@result{} ((1 0) (2 0) (2 1)
    (3 0) (3 1) (3 2))
@end example

@noindent
the variable @var{n} is first bound to 1 then to 2 and finally to 3, and
for each binding of @var{n} the variable @var{i} is bound to the values
0, 1, ..., @var{n}-1 in turn.  The expression @code{(list n i)}
constructs a two--element list for each binding, and the comprehension
@func{list-ec} collects all these results in a list.

@c page
@node loops comprehensions
@section Comprehensions


@menu
* loops comprehensions do::     Simple loops.
* loops comprehensions list::   List accumulator loops.
* loops comprehensions string:: String accumulator loops.
* loops comprehensions vector:: Vector accumulator loops.
* loops comprehensions arith::  Arithmetic accumulator loops.
* loops comprehensions search:: Searching loops.
* loops comprehensions fold::   Folding loops.
* loops comprehensions define:: Defining new comprehensions.
@end menu

@c page
@node loops comprehensions do
@subsection Simple loops


@deffn Syntax do-ec @meta{qualifier} ... @var{command}
Evaluate the @var{command} exactly once for each binding in the sequence
defined by the qualifiers.  If there are no qualifiers @var{command} is
evaluated exactly once.  The expression is evaluated for its
side--effects only.  The result of the comprehension is unspecified.

@example
(let ((x 0))
  (do-ec                ;no qualifiers
    (set! x (+ x 1)))
  x)
@result{} 1

(let ((x 0))
  (do-ec (:range i 10)  ;i from 0 to 9
    (set! x (+ x 1)))
  x)
@result{} 10

(let ((x 0))
  (do-ec (:range i 0)   ;loops zero times
    (set! x (+ x 1)))
  x)
@result{} 0

(let ((x 0))
  (do-ec (:range n 10)  ;n from 0 to 9
         (:range k n)   ;k from 0 to n
    (set! x (+ x 1)))
  x)
@result{} 45
@end example
@end deffn

@c page
@node loops comprehensions list
@subsection List accumulator loops


@deffn Syntax list-ec @meta{qualifier} ... @var{expression}
The list of values obtained by evaluating @var{expression} once for each
binding in the sequence defined by the qualifiers.  If there are no
qualifiers the result is the list with the value of @var{expression}.

@example
(list-ec                ;no qualifiers
  1)
@result{} (1)

(list-ec (:range i 4)   ;i from 0 to 3
  i)
@result{} (0 1 2 3)

(list-ec (:range n 3)
         (:range k (+ n 1))
  (list n k))
@result{} ((0 0)
    (1 0) (1 1)
    (2 0) (2 1) (2 2))
@end example
@end deffn


@deffn Syntax append-ec @meta{qualifier} ... @var{expression}
The list obtained by appending all values of @var{expression}, which
must all be lists.  Think of it as:

@example
(apply append (list-ec @meta{qualifier} ... @var{expression}))
@end example

Examples:

@example
(append-ec              ;no qualifiers
  '(a b))
@result{} (a b)

(append-ec (:range i 0) ;loops zero times
  '(a b))
@result{} '()

(append-ec (:range i 1)
  '(a b))
@result{} (a b)

(append-ec (:range i 2)
  '(a b))
@result{} '(a b a b)
@end example
@end deffn

@c page
@node loops comprehensions string
@subsection String accumulator loops


@deffn Syntax string-ec @meta{qualifier} ... @var{expression}
The string of all values of @var{expression}.  Think of it as:

@example
(list->string (list-ec @meta{qualifier} ... @var{expression}))
@end example

Examples:

@example
(string-ec              ;no qualifiers
  #\a)
@result{} (string #\a)

(string-ec (:range i 0)
  #\a)
@result{} ""

(string-ec (:range i 1)
  #\a)
@result{} "a"

(string-ec (:range i 2)
  #\a)
@result{} "aa"
@end example
@end deffn


@deffn Syntax string-append-ec @meta{qualifier} ... @var{expression}
The string obtained by appending all values of @var{expression}, which
must all be strings.  Think of it as:

@example
(apply string-append (list-ec @meta{qualifier} ... @var{expression}))
@end example

Examples:

@example
(string-append-ec
  "ab")
@result{} "ab"

(string-append-ec (:range i 0)
  "ab")
@result{} ""

(string-append-ec (:range i 1)
  "ab")
@result{} "ab"

(string-append-ec (:range i 2)
  "ab")
@result{} "abab"
@end example
@end deffn

@c page
@node loops comprehensions vector
@subsection Vector accumulator loops


@deffn Syntax vector-ec @meta{qualifier} ... @var{expression}
The vector of all values of @var{expression}.  Think of it as:

@example
(list->vector (list-ec @meta{qualifier} ... @var{expression}))
@end example

Examples:

@example
(vector-ec              ;no qualifiers
  1)
@result{} (vector 1)

(vector-ec (:range i 0)
  i)
@result{} (vector)

(vector-ec (:range i 1)
  i)
@result{} (vector 0)

(vector-ec (:range i 2)
  i)
@result{} (vector 0 1)
@end example
@end deffn


@deffn Syntax vector-of-length-ec @var{k} @meta{qualifier} ... @var{expression}
The vector of all values of @var{expression}, of which there must be
exactly @var{k}.  This comprehension behaves like @func{vector-ec} but
can be implemented more efficiently.

@example
(vector-of-length-ec 1
  1)
@result{} (vector 1)

(vector-of-length-ec 0 (:range i 0)
  i)
@result{} (vector)

(vector-of-length-ec 1 (:range i 1)
  i)
@result{} (vector 0)

(vector-of-length-ec 2 (:range i 2)
  i)
@result{} (vector 0 1)
@end example
@end deffn

@c page
@node loops comprehensions arith
@subsection Arithmetic accumulator loops


@deffn Syntax sum-ec @meta{qualifier} ... @var{expression}
The sum of all values of @var{expression}.  Think of it as:

@example
(apply + (list-ec @meta{qualifier} ... @var{expression}))
@end example

Examples:

@example
(sum-ec                 ;no qualifiers
  1)
@result{} 1

(sum-ec (:range i 0)
  i)
@result{} 0

(sum-ec (:range i 1)
  i)
@result{} 0

(sum-ec (:range i 2)
  i)
@result{} 1

(sum-ec (:range i 3)
  i)
@result{} 3
@end example
@end deffn


@deffn Syntax product-ec @meta{qualifier} ... @var{expression}
The product of all values of @var{expression}.  Think of it as:

@example
(apply * (list-ec @meta{qualifier} ... @var{expression}))
@end example

Examples:

@example
(product-ec             ;no qualifiers
  1)
@result{} 1

(product-ec (:range i 1 0)      ;i from 1 to 1
  i)
@result{} 1

(product-ec (:range i 1 1)      ;loop zero times
  i)
@result{} 1

(product-ec (:range i 9 9)      ;loop zero times
  i)
@result{} 1

(product-ec (:range i 1 2)      ;i from 1 to 1
  i)
@result{} 1

(product-ec (:range i 1 3)      ;i from 1 to 2
  i)
@result{} 2

(product-ec (:range i 1 4)      ;i from 1 to 3
  i)
@result{} 6
@end example
@end deffn


@deffn Syntax min-ec @meta{qualifier} ... @var{expression}
@deffnx Syntax max-ec @meta{qualifier} ... @var{expression}
The minimum and maximum of all values of @var{expression}.  The sequence
of values must be non-empty.  Think of these as

@example
(apply min (list-ec @meta{qualifier} ... @var{expression}))
(apply max (list-ec @meta{qualifier} ... @var{expression}))
@end example

If we want to return a default value in case the sequence is empty we
may want to consider:

@example
(fold3-ec 'infinity @meta{qualifier} ... @var{expression} min min)
@end example
@end deffn

@c page
@node loops comprehensions search
@subsection Searching loops


@deffn Syntax any?-ec @meta{qualifier} ... @var{test}
Tests whether any value of @var{test} in the sequence of bindings
specified by the qualifiers is non--@false{}.  If this is the case:
@true{} is returned, otherwise @false{}.  If there are no bindings at
all, in the sequence specified by the qualifiers, then the result is
@false{}.  The enumeration of values stops after the first non--@false{}
encountered.
@end deffn


@deffn Syntax every?-ec @meta{qualifier} ... @var{test}
Tests whether all values of @var{test} are non--@false{}.  If this is
the case: @true{} is returned, otherwise @false{}.  If the sequence is
empty the result is @true{}.  Enumeration stops after the first
@false{}.
@end deffn


@deffn Syntax first-ec @var{default} @meta{qualifier} ... @var{expression}
@deffnx Syntax last-ec  @var{default} @meta{qualifier} ... @var{expression}
The first or last value of @var{expression} in the sequence of bindings
specified by the qualifiers.  Before enumeration, the result is
initialized with the value of @var{default}; so this will be the result
if the sequence is empty.  Enumeration is terminated in @func{first-ec}
when the first value has been computed.
@end deffn

@c page
@node loops comprehensions fold
@subsection Folding loops


@deffn Syntax fold-ec @var{x0} @meta{qualifier} ... @var{expression} @var{f2}
@deffnx Syntax fold3-ec @var{x0} @meta{qualifier} ... @var{expression} @var{f1} @var{f2}
Reduce the sequence @math{x[1], x[2], @dots{}, x[n-1]} of values
obtained by evaluating @var{expression} once for each binding as
specified by the @meta{qualifier} syntaxes.  The arguments @var{x0},
@var{f2} and @var{f1}, all syntactically equivalent to @var{expression},
specify the reduction process.

@example
(define (f2 expr knil)
  (+ knil (* expr expr)))

(fold-ec 0              ;knil
         (:range k 1 5) ;qualifier, k from 1 to 4
  k                     ;expression
  f2)
@result{} 30 ;(+ 0 (* 1 1) (* 2 2) (* 3 3) (* 4 4))
@end example

The reduction process for @func{fold-ec} is defined as follows.  A
reduction variable @var{x} is initialized to the value of @var{x0}, and
for each @math{k \in @{1, ..., n-1@}} the command:

@example
(set! x[k+1] (f2 x[k] x[k-1]))
@end example

@noindent
is evaluated.  Finally, @math{x[n]} is returned as the value of the
comprehension.

The reduction process for @func{fold3-ec} is different:

@enumerate
@item
If and only if the sequence is empty: @var{x0} is evaluated and returned
as the value of the comprehension.

@item
If the sequence in non--empty: A reduction variable @var{x} is
initialized to the value of @code{(f1 x[1])}, and for each @math{k \in
@{2, ..., n-1@}} the command:

@example
(set! x[k+1] (f2 x[k] x[k-1]))
@end example

@noindent
is evaluated; finally, @math{x[n]} is returned as the value of the
comprehension.
@end enumerate

Example:

@example
(define (f2 expr knil)
  (+ knil (* expr expr)))

(define (f1 x)
  x)

(fold3-ec 1234                  ;never used
          (:range k 2 5)        ;k from 2 to 4
  k                             ;expression
  f1
  f2)
@result{} 27 ;(+ (f1 2) (* 3 3) (* 4 4))

(fold3-ec 1234
          (:range k 2 2)        ;loop zero times
  k
  f1
  f2)
@result{} 1234
@end example

As the order of the arguments suggests, @var{x0} is evaluated outside
the scope of the qualifiers, whereas the reduction expressions involving
@var{f1} and @var{f2} are inside the scope of the qualifiers (so they
may depend on any variable introduced by the qualifiers).  Note that
@var{f2} is evaluated repeatedly, with any side--effect or overhead this
might have.

The main purpose of these comprehensions is implementing other
comprehensions as special cases.  They are generalizations of the
procedures @func{fold-left} and @func{reduce}.  Note that
@func{fold3-ec} is defined such that @var{x0} is only evaluated in case
the sequence is empty.  This allows raising an error for the empty
sequence.
@end deffn

@c page
@node loops comprehensions define
@subsection Defining new comprehensions


To create a new comprehension a hygienic macro with that name is
defined.  The macro transforms the new comprehension patterns into
instances of @func{do-ec}, which is the most fundamental eager
comprehension, or any other comprehension already defined.

For example, the following code defines @func{list-ec} and @func{min-ec}
in terms of @func{fold-ec} and @func{fold3-ec}:

@example
(define-syntax list-ec
  (syntax-rules ()
    ((_ ?etc1 ?etc ...)
     (reverse (fold-ec '() ?etc1 ?etc ... cons)))))

(define-syntax min-ec
  (syntax-rules ()
    ((_ ?etc1 ?etc ...)
     (fold3-ec (min) ?etc1 ?etc ... min min))))
@end example

Note that the pattern @samp{?etc1 ...} matches @var{qualifier*} and
@var{expression} without separate access to @var{qualifier*} and
@var{expression}.  In order to define a comprehension that does need
explicit access to the @var{expression} part, the following method is
used.

First, all qualifiers are collected into a nested--qualifier, and then
the ``exactly one qualifier'' case is implemented.  For illustration,
the following code defines @func{fold3-ec} in terms of @func{do-ec}:

@example
(define-syntax fold3-ec
  (syntax-rules (nested)

    ((fold3-ec x0 (nested q1 ...) q etc1 etc2 etc3 etc ...)
     (fold3-ec x0 (nested q1 ... q) etc1 etc2 etc3 etc ...))

    ((fold3-ec x0 q1 q2 etc1 etc2 etc3 etc ...)
     (fold3-ec x0 (nested q1 q2) etc1 etc2 etc3 etc ...))

    ((fold3-ec x0 expression f1 f2)
     (fold3-ec x0 (nested) expression f1 f2))

    ((fold3-ec x0 qualifier expression f1 f2)
     (let ((result #f)
           (empty  #t))
       (do-ec qualifier
         (let ((value expression)) ; don't duplicate code
           (if empty
               (begin
                 (set! result (f1 value))
                 (set! empty #f))
             (set! result (f2 value result)))))
       (if empty x0 result)))))
@end example

Finally, observe that the newly defined @func{fold3-ec} comprehension
inherits all types of qualifiers supported by @func{do-ec}, including
all application--specific generators; no further definitions are
necessary.

@c page
@node loops qualifiers
@section Qualifiers


This section defines the syntax @meta{qualifier}.  The nesting of
qualifiers is from left (outer) to right (inner).  In other words, the
rightmost generator ``spins faster''.  The nesting also defines the
region of the variables introduced by the generators.  This implies that
inner generators may depend on the variables of outer generators.  The
sequence of enumeration of values is strictly depth first.  These
conventions are illustrated by the first example.

The syntax @meta{qualifier} consists of the following alternatives.

@deffn {Qualifier Syntax} @meta{generator}
Enumerate a sequence of bindings of one or more variables.  The region
of the variables starts at the generator and extends over all subsequent
qualifiers and expressions in the comprehension.  @ref{loops generators,
Generators}
@end deffn


@deffn {Qualifier Syntax} if @var{test}
Filter the sequence of bindings by testing if @var{test} evaluates to
non--@false{}.  Only for those bindings for which this is the case, the
subsequent qualifiers of the comprehension are evaluated.

@example
(list-ec (:range i 10)
         (if (even? i))
  i)
@result{} (0 2 4 6 8)

(list-ec (:range i 5)
         (if (even? i))
         (:let j (+ 1 i))
  j)
@result{} (1 3 5)
@end example
@end deffn


@deffn {Qualifier Syntax} not @var{test}
@deffnx {Qualifier Syntax} and @var{test} ...
@deffnx {Qualifier Syntax} or @var{test} ...
Abbreviated notations for filters of the form:

@example
(if (not @var{test}))
(if (and @var{test} ...))
(if (or  @var{test} ...))
@end example
@end deffn


@deffn {Qualifier Syntax} begin @var{sequence}
Evaluate @var{sequence}, consisting of @samp{@var{command} ...
@var{expression}}, once for each binding of the variables defined by the
previous qualifiers in the comprehension.  Using this qualifier, side
effects can be inserted into the body of a comprehension.

@example
(let* ((ans '())
       (ell (list-ec (:range i 5)
                     (begin
                       (set! ans (cons i ans)))
                     i)))
  (list ans ell))
@result{} ((4 3 2 1 0)
    (0 1 2 3 4))
@end example
@end deffn


@deffn {Qualifier Syntax} nested @meta{qualifier} ...
A syntactic construct to group qualifiers.  The meaning of a qualifier
according to the @samp{nested} syntax is the same as inserting the
@meta{qualifier} syntaxes into the enclosing comprehension.

This construct can be used to reduce comprehensions with several
qualifiers into a form with exactly one qualifier.

@example
(list-ec (nested (:range i 5)
                 (if (even? i))
                 (:let j (+ 1 i)))
  j)
@result{} (1 3 5)

(list-ec (:range i 5)
         (nested (if (even? i))
                 (:let j (+ 1 i)))
  j)
@result{} (1 3 5)

(list-ec (:range i 5)
         (if (even? i))
         (nested (:let j (+ 1 i)))
  j)
@result{} (1 3 5)

(list-ec (:range i 5)
         (if (even? i))
         (:let j (+ 1 i))
         (nested)
  j)
@result{} (1 3 5)
@end example
@end deffn

@c page
@node loops generators
@section Generators


@menu
* loops generators intro::      Introduction to generators.
* loops generators do::         Loop generators.
* loops generators typed::      Typed generators.
* loops generators ranges::     Range generators.
* loops generators port::       Port generators.
* loops generators dispatch::   Dispatched generators.
* loops generators let::        Let generators.
* loops generators parallel::   Parallel generators.
* loops generators cond::       Conditional generators.
@end menu

@c page
@node loops generators intro
@subsection Introduction to generators


This section defines the syntax @meta{generator}.  Each generator defines
a sequence of bindings through which one or more variables are run.  The
scope of the variables begins after the closing parenthesis of the
generator expression and extends to the end of the comprehension it is
part of.

The variables defined by the generators are specified using the syntax:

@example
<vars> -> <variable1>
       |  <variable1> (index <variable2>)
@end example

@noindent
where @var{variable1} runs through the values in the sequence defined by
the generator, and the optional @var{variable2} is an exact
integer--valued index variable counting the values (starting from
@math{0}).  The names of the variables must be distinct.  The following
example illustrates the index variable:

@example
(list-ec (: x (index i) "abc")
   (list x i))
@result{} ((#\a 0) (#\b 1) (#\c 2))
@end example

Unless defined otherwise, all generators make sure that the expressions
provided for their syntactic arguments are evaluated exactly once,
before enumeration begins.  Moreover, it may be assumed that the
generators do not copy the code provided for their arguments, because
that could lead to exponential growth in code size.

Finally, it is possible to assign a value to the variables defined by a
generator, but the effect of this assignment is unspecified; example:

@example
(list-ec (:range i 5)
  (set! i #\a)          ;undefined behaviour because of this
  ---)
@end example

@c page
@node loops generators do
@subsection Loop generators


@deffn {Generator Syntax} :do (@meta{lb} ...) @meta{ne1?} (@meta{ls} ...)
@deffnx {Generator Syntax} :do (let (@meta{ob} ...) @meta{oc} ...) (@meta{lb} ...) @meta{ne1?} (let (@meta{ib} ...) @meta{ic} ...) @meta{ne2?} (@meta{ls} ...)
Defines a generator in terms of a named @func{let}, optionally decorated
with inner and outer @func{let}.  This generator is for defining other
generators.  (In fact, the reference implementation transforms any other
generator into an instance of fully decorated @code{:do}.)

The generator is a compromise between expressive power (more flexible
loops) and fixed structure (necessary for merging and modifying
generators).

In the fully decorated form, the following syntactic variables are
present:

@table @meta
@item ob
Outer binding.

@item oc
Outer command.

@item lb
Loop binding.

@item ne1?
Not end predicate.

@item ib
Inner binding.

@item ic
Inner command.

@item ne2?
Not end predicate.

@item ls
Loop step.
@end table

They define the following loop skeleton:

@example
(let (@meta{ob} ...)
  @meta{oc} ...
  (let loop (@meta{lb} ...)
    (when @meta{ne1?}
      (let (@meta{ib} ...)
        @meta{ic} ...
        payload
        (when @meta{ne2?}
          (loop @meta{ls} ...))))))
@end example

@noindent
where @meta{oc} and @meta{ic} are syntactically equivalent to forms in
the body of a @func{begin}, i.e. they do not begin with a
@meta{definition}.  The latter requirement allows the code generator to
produce more efficient code for special cases by removing empty
@func{let} expressions altogether.
@end deffn

@c page
@node loops generators typed
@subsection Typed generators


@deffn {Generator Syntax} {:list} @var{vars} @var{arg0} @var{arg} ...
@deffnx {Generator Syntax} {:string} @var{vars} @var{arg0} @var{arg} ...
@deffnx {Generator Syntax} {:vector} @var{vars} @var{arg0} @var{arg} ...
Run through one or more lists, strings, or vectors.  First all the
@var{arg} expressions are evaluated and then all elements of the
resulting values are enumerated from left to right.  One can think of it
as first appending all arguments and then enumerating the combined
object.

@example
(list-ec (:string c (index i) "a" "b")
  (cons c i))
@result{} ((#\a . 0) (#\b . 1))

(list-ec (:string c (index i) "ciao" "mamma")
  (cons c i))
@result{} ((#\c . 0) (#\i . 1) (#\a . 2) (#\o . 3)
    (#\m . 4) (#\a . 5) (#\m . 6) (#\m . 7) (#\a . 8))
@end example
@end deffn


@deffn {Generator Syntax} {:integers} @var{vars}
Runs through the sequence @math{0, 1, 2, @dots{}} of non--negative
integers.  This is most useful in combination with @samp{:parallel},
@samp{:while}, and @samp{:until} or with a non--local exit in the body
of the comprehension.
@end deffn

@c ------------------------------------------------------------

@subsubheading Application specific typed generator


To define a new typed generator a hygienic referentially transparent
macro of the same name is defined to transform the generator pattern
into an instance of the @samp{:do} generator.  The extension is fully
modular, meaning that no other macro has to be modified to add the new
generator.  This is achieved by defining the new macro in Continuation
Passing Style.

Technically, this works as follows.  Assume the generator syntax:

@example
(:mygen @var{var} @var{arg})
@end example

@noindent
is to be implemented, for example running the variable @var{var} through
the list @code{(reverse @var{arg})}.  The following definition
implements @code{:mygen} in terms of @samp{:list} using the additional
syntactic variable @var{cc} (read current continuation):

@example
(define-syntax :mygen
  (syntax-rules ()
    ((:mygen cc var arg)
     (:list cc var (reverse arg)))))
@end example

After this definition, any comprehension will accept the @code{:mygen}
generator and produce the proper code for it.  This works as follows.
When a comprehension sees something of the form @code{(@var{g} @var{arg}
...)} in the position of a @meta{qualifier} then it will transform the
entire comprehension into:

@example
(@var{g} (continue ...) @var{arg} ...)
@end example

This effectively ``transfers control'' to the macro @var{g}, for example
@samp{:mygen}.  The macro @var{g} has full control of the
transformation, but eventually it should transform the expression into:

@example
(:do (continue ...)  etc ...)
@end example

In the @samp{:mygen} example this is done by the @samp{:list} macro.
The macro @samp{:do} finally transforms into:

@example
(continue ... (:do etc ...))
@end example

As @samp{continue} has been chosen by the macro implementing the
comprehension, it can regain control and proceed with other qualifiers.

In order to ensure consistency of new generators with the ones defined
in @library{loops}, a few conventions are in order.

@itemize
@item
The generator patterns begin with one or more variables followed by
arguments defining the sequence.

@item
Each generator except @samp{:do} can handle an optional index variable.
This is most easily implemented using @samp{:parallel} together with
@samp{:integers}.  In case the payload generator needs an index anyhow
(e.g. @samp{:vector}) it is more efficient to add an index variable if
none is given and to implement the indexed case.

@item
Make sure that no syntactic variable of the generator pattern ever gets
duplicated in the code (to avoid exponential code size in nested
application), and introduce sufficient intermediate variables to make
sure expressions are evaluated at the correct time.
@end itemize

@c page
@node loops generators ranges
@subsection Range generators


@deffn {Generator Syntax} {:range} @var{vars} @var{stop}
@deffnx {Generator Syntax} {:range} @var{vars} @var{start} @var{stop}
@deffnx {Generator Syntax} {:range} @var{vars} @var{start} @var{stop} @var{step}
Runs through a range of exact rational numbers.

@table @code
@item (:range @var{vars} @var{stop})
Evaluate the expression @var{stop}, which must result in an exact
integer @math{N}, and runs through the finite sequence @math{0, 1, 2,
@dots{}, N-1}.  If @math{N} is zero or negative the sequence is empty.

@item (:range @var{vars} @var{start} @var{stop})
Evaluate the expressions @var{start} and @var{stop}, which must result
in exact integers @math{A} and @math{B}, and runs through the finite
sequence @math{A, A+1, A+2, @dots{}, B-1}.  If @math{B} is less or equal
@math{A} then the sequence is empty.

@item (:range @var{vars} @var{start} @var{stop} @var{step})
First evaluates the expressions @var{start}, @var{stop} and @var{step},
which must result in exact integers @math{A}, @math{B} and @math{S} such
that @math{S} is non--zero.  Then the sequence @math{A, A+S, A+2*S,
@dots{}, A+(N-1)*S} is enumerated where: @math{N = ceil((B-A)/S)}.

In other words, the sequence starts at @math{A}, increments by @math{S},
and stops when the next value would reach or cross @math{B}.  If
@math{N} is zero or negative the sequence is empty.
@end table
@end deffn


@deffn {Generator Syntax} {:real-range} @var{vars} @var{stop}
@deffnx {Generator Syntax} {:real-range} @var{vars} @var{start} @var{stop}
@deffnx {Generator Syntax} {:real-range} @var{vars} @var{start} @var{stop} @var{step}
Runs through a range of real numbers using an explicit index variable.
This form of range enumeration avoids accumulation of rounding errors
and is the one to use if any of the numbers defining the range is
inexact, not an integer, or a bignum of large magnitude.

Providing default values @math{0} for @var{start} and @math{1} for
@var{step}, the generator first evaluates @var{start}, @var{stop} and
@var{step}, which must result in reals @math{A}, @math{B} and @math{S}
such that @math{N = (B-A)/S} is also representable as a real.  Then the
sequence @math{0, 1, 2, @dots{}, N-1} is enumerated while the current
value @math{I} is less than @math{N}, and the variable in @var{vars} is
bound to the value @math{A+I*S}.  If any of the values @math{A},
@math{B} or @math{S} is non--exact then all values in the sequence are
non--exact.
@end deffn


@deffn {Generator Syntax} {:char-range} @var{vars} @var{min} @var{max}
Run through a range of characters.  First @var{min} and @var{max} are
evaluated, which must result in two characters @math{A} and @math{B}.
Then the sequence of characters @math{A, A+1, A+2, @dots{}, B} is
enumerated in the order defined by @func{char<=?}.  If @math{B} is
smaller than @math{A} then the sequence is empty.  Note that @math{B} is
included in the sequence.
@end deffn

@c page
@node loops generators port
@subsection Port generators


@deffn {Generator Syntax} {:port} @var{vars} @var{port}
@deffnx {Generator Syntax} {:port} @var{vars} @var{port} @var{read-proc}
Read from the port until the eof--object is read.  If a port reader
procedure @var{read-proc} is supplied: The generator first evaluates
@var{port} and @var{read-proc}, which must result in an input port
@var{p} and a procedure @var{r}.  Then the variable is run through the
sequence obtained by @code{(@var{r} @var{p})} while the result does not
satisfy @func{eof-object?}.
@end deffn

@c page
@node loops generators dispatch
@subsection Dispatched generators


@deffn {Generator Syntax} {:} @var{vars} @var{arg0} @var{arg} ...
First the @var{arg} expressions are evaluated into @math{a[1], a[2],
@dots{}, a[n]} and then a global dispatch procedure is used to dispatch
on the number and types of the arguments and run the resulting
generator.  Initially the following cases are recognized, with @math{i
\in @{1, @dots{}, n@}}:

@table @samp
@item :list
If for all @math{i}:

@example
(list? a[i]) @result{} #t
@end example

@item :string
If for all @math{i}:

@example
(string? a[i]) @result{} #t
@end example

@item :vector
If for all @math{i}:

@example
(vector? a[i]) @result{} #t
@end example

@item :range
If @math{n \in @{1, @dots{}, 3@}} and for all @math{i \in @{1, @dots{},
n@}}:

@example
(and (integer? a[i])
     (exact?   a[i]))
@result{} #t
@end example

@item :real-range
If @math{n \in @{1, @dots{}, 3@}} and for all @math{i \in @{1, @dots{},
n@}}:

@example
(real? a[i]) @result{} #t
@end example

@item :char-range
If @math{n = 2} and for all @math{i \in @{1, 2@}}:

@example
(char? a[i]) @result{} #t
@end example

@item :port
If @math{n \in @{1, 2@}} and:

@example
(and (input-port? a[1])
     (procedure?  a[2]))
@result{} #t
@end example
@end table

The current dispatcher can be retrieved as @code{(:-dispatch-ref)}, a
new dispatcher @samp{d} can be installed by @code{(:-dispatch-set! d)}
yielding an unspecified result, and a copy of the initial dispatcher can
be obtained as @code{(make-initial-:-dispatch)}.  Please refer to the
section below for recommendation how to add cases to the dispatcher.
@end deffn


@deffn {Generator Syntax} {:dispatched} @var{vars} @var{dispatch} @var{arg0} @var{arg} ...
Runs the variables through a sequence defined by @var{dispatch} and the
@var{arg} expressions.  The purpose of @samp{:dispatched} is
implementing dispatched generators, in particular the predefined
dispatching generator @samp{:}.

The working of @samp{:dispatched} is as follows: First @var{dispatch}
and the @var{arg} expressions are evaluated, resulting in a procedure
@var{d} (the ``dispatcher'') and the values @math{a[1], a[2], @dots{},
a[n]}.  Then:

@example
(d (list a[1] a[2] ... a[n]))
@end example

@noindent
is evaluated, resulting in a value @var{g}.  If @var{g} is not a
procedure then the dispatcher did not recognize the argument list and an
error is raised.  Otherwise the ``generator procedure'' @var{g} is used
to run @var{vars} through a sequence of values.

The sequence defined by @var{g} is obtained by repeated evaluation of
@code{(@var{g} @var{empty})} until the result is @var{empty}.  In other
words, @var{g} indicates the end of the sequence by returning its only
argument, for which the caller has provided an object distinct from
anything @var{g} can produce.

The definition of dispatchers is greatly simplified by the macro
@code{:generator-proc} that constructs a generator procedure from a
typed generator.  Let @code{(@var{g} @var{var} @var{arg0} @var{arg}
...)} be an instance of the @meta{generator} syntax, for example an
application--specific typed generator, with a single variable @var{var}
and no index variable.  Then:

@example
(:generator-proc (g arg0 arg ...))
@result{} g
@end example

@noindent
where the generator procedure @var{g} runs through the list:

@example
(list-ec (g var arg0 arg ...) var)
@end example

In order to define a new dispatching generator (say @code{:my}) first a
dispatching procedure (say @code{:my-dispatch}) is defined.  The
dispatcher will be called with a single (!) argument containing the list
of all values to dispatch on.  To enable informative error messages, the
dispatcher should return a descriptive object (e.g.  a symbol for the
module name) when it is called with the empty list.  Otherwise (if there
is at least one value to dispatch on), the dispatcher must either return
a generator procedure or @false{} (which means: no interest).  As an
example, the following skeleton code defines a dispatcher similar to the
initial dispatcher of @code{:}:

@example
(define (:my-dispatch args)
  (case (length args)
    ((1) (let ((a1 (car args)))
           (cond
            ((list? a1)
             (:generator-proc (:list a1)))
            ((string? a1)
             (:generator-proc (:string a1)))
            ...more unary cases...
            (else
             #f))))
    ((2) (let ((a1 (car args))
               (a2 (cadr args)))
           (cond
            ((and (list? a1) (list? a2))
             (:generator-proc (:list a1 a2)))
            ...more binary cases...
            (else
             #f))))
    ...more arity cases...
    (else
     (cond
      ((every?-ec (:list a args) (list? a))
       (:generator-proc (:list (apply append args))))
      ...more large variable arity cases...
      (else
       #f)))))
@end example

Once the dispatcher has been defined, the following macro implements the
new dispatching generator:

@example
(define-syntax :my
  (syntax-rules (index)
    ((:my cc var (index i) arg0 arg ...)
     (:dispatched cc var (index i) :my-dispatch arg0 arg ...))
    ((:my cc var arg0 arg ...)
     (:dispatched cc var :my-dispatch arg0 arg ...))))
@end example

This method of extension yields complete control of the dispatching
process.  Other modules can only add cases to @samp{:my} if they have
access to @samp{:my-dispatch}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Extending the predefined dispatched generator

An alternative to adding a new dispatched generator is to extend the
predefined generator @samp{:}.  Technically, extending @samp{:} means
installing a new global dispatching procedure using
@samp{:-dispatch-set!} as described above.  In most cases, however, the
already installed dispatcher should be extended by new cases.  The
following procedure is a utility for doing so:

@example
(dispatch-union d1 d2)
@result{} d
@end example

@noindent
where the new dispatcher @var{d} recognizes the union of the cases
recognized by the dispatchers @var{d1} and @var{d2}.  The new dispatcher
always tries both component dispatchers and raises an error in case of
conflict.  The identification returned by @code{(d)} is the
concatenation of the component identifications @code{(d1)} and
@code{(d2)}, enclosed in lists if necessary.  For illustration, consider
the following code:

@example
(define (example-dispatch args)
  (cond
   ((null? args)
    'example)
   ((and (= (length args) 1) (symbol? (car args)) )
    (:generator-proc (:string (symbol->string (car args)))))
   (else
    #f)))

(:-dispatch-set! (dispatch-union (:-dispatch-ref) example-dispatch))
@end example

After evaluation of this code, the following example will work:

@example
(list-ec (: c 'abc)
  c)
@result{} (#\a #\b #\c)
@end example

Adding cases to @samp{:} is particularly useful for frequent cases of
interactive input.  Be warned, however, that the advantage of global
extension also carries the danger of conflicts, unexpected
side--effects, and slow dispatching.

@c page
@node loops generators let
@subsection Let generators


@deffn {Generator Syntax} :let @var{vars} @var{expression}
Run through the sequence consisting of the value of @var{expression},
only.  This is the same as:

@example
(:list @var{vars} (list @var{expression}))
@end example

If an index variable is specified, its value is @math{0}.  The
@samp{:let} generator can be used to introduce an intermediate variable
depending on outer generators.
@end deffn

@c page
@node loops generators parallel
@subsection Parallel generators


@deffn {Generator Syntax} :parallel @meta{generator} ...
Run several generators in parallel.  This means that the next binding in
the sequence is obtained by advancing each generator by one step.  The
parallel generator terminates when any of its component generators
terminate.  The generators share a common scope for the variables they
introduce.  This implies that the names of the variables introduced by
the various generators must be distinct.
@end deffn

@c page
@node loops generators cond
@subsection Conditional generators


@deffn {Generator Syntax} :while @meta{generator} @var{expression}
Run @meta{generator} while @var{expression} evaluates to non--@false{}.
The guarding expression is included in the region of the variables
introduced by the generator.

Note the distinction between the filter @code{if} and the modified
generator expressed by @code{:while}.
@end deffn


@deffn {Generator Syntax} :until @meta{generator} @var{expression}
Run @meta{generator} until after @var{expression} has evaluated to
non--@false{}.  The guarding expression is included in the region of the
variables introduced by the generator.
@end deffn

Note the distinction between @code{:while}, stopping at a certain
condition, and @code{:until}, stopping after a certain condition has
occurred.  The latter implies that the binding that has triggered
termination has been processed by the comprehension.

@c page
@node random
@chapter Sources of random bits


The @library{randomisations} library provides an @api{} to access
sources of random and pseudo--random bits, or ``randomness sources'' for
brevity.  Other, auxiliary libraries provide access to miscellaneous
randomness generators and utilities.

@menu
* random intro::                Introduction.
* random prng::                 Notes on the algorithms.
* random numbers::              Simple random numbers.
* random source::               Randomness sources.
* random mrg32k3a::             L'Ecuyer's MRG32k3a generator
* random device::               Device--based generator.
* random utils::                Utilities.
* random generators::           Auxiliary generators.
* random dist::                 Random numbers from known distributions.
@end menu

@c page
@node random intro
@section Introduction


There are three different ways to use the interface, with varying
demands on the quality of the source and the amount of control over the
production process:

@itemize
@item
The ``no fuss'' interface specifies that @code{(random-integer U)}
produces the next random integer number @math{X} such that @math{0 <= X
< U} and @func{(random-real)} produces the next random real number
@math{X} such that @math{0 < X < 1}.  Details about how these random
values are produced may not be very relevant, as long as they appear to
be sufficiently random.

@item
For simulation purposes, on the contrary, it is usually necessary to
know that the numbers are produced deterministically by a pseudo--random
number generator of high quality and to have explicit access to its
state.  In addition, one might want to use several independent sources
of random numbers at the same time and it can be useful to have some
simple form of randomization.

@item
For security applications a serious form of true randomization is
essential, in the sense that it is difficult for an adversary to exploit
or introduce imperfections into the distribution of random bits.
Moreover, the linear complexity of the stream of random bits is more
important than its statistical properties.  In these applications, an
entropy source (producing truly random bits at a low rate) can be used
to randomize a pseudo random number generator to increase the rate of
available bits.
@end itemize

Once randomness sources provide the infrastructure to obtain random
bits, these can be used to construct other random deviates.  Most
important are floating point numbers of various distributions and random
discrete structures, such as permutations or graphs.

@c page
@node random prng
@section Notes on the algorithms


Pseudo--random number generators (@acronym{PRNG}s) are algorithms that
can automatically create long sequences of numbers (for example,
millions of numbers) with good random properties; eventually the
sequence repeats itself or memory usage grows without
bound@footnote{Wikipedia contributors, ``Random number generation,''
Wikipedia, The Free Encyclopedia,
@url{http://en.wikipedia.org/wiki/@/Random_number_generator} (accessed
June 28, 2009).}.

We examine some notes on @acronym{PRNG}s with the purpose of gaining
basic understanding of the code, and to reverese engineer the basic
steps of source code available on the Internet.  This section is meant
to help people new to the @acronym{PRNG} algorithms.

@menu
* random prng lcg::             Linear congruential generators.
* random prng mwc::             Multiply with carry.
* random prng csprng::          Cryptographically secure @acronym{PRNG}.
* random prng integers::        Generating integers in a specified range.
* random prng reals::           Generating real numbers.
@end menu

@c page
@node random prng lcg
@subsection Linear congruential generators


One of the most common @acronym{PRNG} is the @dfn{linear congruential
generator} (@acronym{LCG}), which uses the recurrence:

@example
N' = (a N + b) mod M      0 <= N', N < M
@end example

@noindent
to generate a new integer number @math{N'} from an initial state
@math{N}, @math{a} and @math{b} being known, fixed, recursion
coefficients.  The maximum number of integers the formula can produce is
the modulus @math{M}.

To avoid certain non--random properties of a single linear congruential
generator, several such generators with slightly different values of the
multiplier coeffient are typically used in parallel, with a ``master''
generator that selects among them.

The most efficient LCGs have an @math{M} equal to a power of @math{2},
most often @math{2^32} or @math{2^64}, because this allows the modulus
operation to be computed by merely truncating all but the rightmost
@math{32} or @math{64} bits@footnote{Wikipedia contributors, "Linear
congruential generator," Wikipedia, The Free Encyclopedia,
@url{}http://en.wikipedia.org/wiki/Linear_congruential_generator
(accessed May 24, 2009).}.

@acronym{LCG}s should not be used for applications where high-quality
randomness is critical.  For example, they are not suitable for a Monte
Carlo simulation or for cryptographic applications.  A further problem
of @acronym{LCG}s is that the lower--order bits of the generated
sequence have a far shorter period than the sequence as a whole if
@math{M} is set to a power of @math{2}.

@c page
@node random prng mwc
@subsection Multiply with carry


Multiply--with--carry (@acronym{MWC}) is a method invented by George
Marsaglia for generating sequences of pseudo--random integers based on
an initial set of from two to many thousands of randomly chosen seed
values@footnote{Wikipedia contributors, ``Multiply--with--carry,''
Wikipedia, The Free Encyclopedia,
@url{http://en.wikipedia.org/wiki/Multiply-with-carry} (accessed May 8,
2009).}.

The main advantage of the @acronym{MWC} method is that it invokes simple
computer integer arithmetic and leads to very fast generation of
sequences of pseudo--random numbers with immense periods, ranging from
around @math{260} to @math{22e6}.  As with most @acronym{PRNG}s, the
resulting sequences are functions of the randomly chosen seed values,
but @acronym{MWC} generators seem to behave as well as, and often better
than, others in tests of randomness.

A @acronym{MWC} sequence is based on arithmetic modulo @math{M}, usually
@math{2^32}, because arithmetic modulo that @math{M} is automatic in
most computers, but sometimes a modulo such as @math{32^2 - 1} is used,
because arithmetic for modulus @math{2^32 - 1} requires only a simple
adjustment from that for @math{2^32}, and theory for @acronym{MWC}
sequences based on modulus @math{2^32} has some nagging difficulties
that use of @math{2^32 - 1} avoids.

Complementary--multiply--with--carry generators (@acronym{CMWC}) are a
slightly modified form of @acronym{MWC} giving better results.  A basic
formulation of the algorithm uses the recurrence:

@example
N' = (M - 1) - (a * N + C) mod M    0 <= N < M

           a * N + C
C' = floor ---------                     C < a
               M
@end example

@noindent
to generate a new number @math{N'} and a new carry @math{C'} from an
initial state @math{N} and an initial carry @math{C}, @math{a} being the
recursion coefficient and @math{M} being the modulo.

Better formulations adopt a ``lag'' of @math{r} values: Chosen a
positive integer @math{r}, an initial carry @math{C} and a vector
@math{[N(1), N(2), ..., N(r)]} of initial seed values, the new number
@math{N'} and the new carry @math{C'} are computed using the seed
@math{N(r)} as:

@example
N' = (M - 1) - (a * N(r) + C) mod M

           a * N(r) + C
C' = floor ------------
                M
@end example

@noindent
then the seed vector is right--shifted purging @math{N(r)}:

@example
N(r)   = N(r-1)
N(r-1) = N(r-2)
...
N(2)   = N(1)
N(1)   = N'
@end example

@c page
@node random prng csprng
@subsection Cryptographically secure @acronym{PRNG}


A cryptographically secure pseudo--random number generator
(@acronym{CSPRNG}) is a @acronym{PRNG} with properties that make it
suitable for use in cryptography.  The requirements of an ordinary
@acronym{PRNG} are also satisfied by a @acronym{CSPRNG}, but the reverse
is not true.

@acronym{CSPRNG} requirements fall into two groups: that they pass
statistical randomness tests; that they hold up well under serious
attacks, even when part of their initial or running state becomes
available to an attacker@footnote{Wikipedia contributors,
``Cryptographically secure pseudorandom number generator,'' Wikipedia,
The Free Encyclopedia, @url{http://en.wikipedia.org/wiki/@/
Cryptographically@/_secure@/_pseudo-random@/_number_generator} (accessed
June 6, 2009).}.

@c page
@node random prng integers
@subsection Generating integers in a specified range


In applications using a randomness source, it happens to need a
pseudo--random integer @math{X} in a given range @math{0 <= X < U},
while the @acronym{PRNG} generates a pseudo--random integer @math{N} in
the range @math{0 <= N < M}.  In other words: We need a sample from the
range @math{0 <= X < U} having uniform probability distribution, by
means of a sample from the range @math{0 <= N < M} having a uniform
probability distribution.

We distinguish the two cases @math{U <= M} and @math{M < U}, because
when @math{U <= M} there are more integers in the range @math{0 <= N <
M} than in the range @math{0 <= X < U}, while when @math{M < U} it is
the other way around.

@itemize
@item
When @math{U <= M}, we have to understand that doing a simple @math{N
mod U} is incorrect, because it breaks uniform distribution of the
result in the range @math{0 <= X < U}.  We can use the following
formulation which gives uniformly distributed results:

@example
Q  = floor(M / U)
QU = Q * U

loop:
  N = <generate the next integer>
  if (N < QU)
  then X = floor(N / Q)
  else goto loop
@end example

@noindent
notice that @math{QU = Q * U <= M}; also notice that it is statistically
possible that the algorithm loops forever, but we can hope that it finds
a solution in a reasonable short time.  It works like this:

@enumerate
@item
Conceptually partition the range @math{0 <= N < QU} in @math{U}
intervals each of length @math{Q}, indexed by @math{X} in the range
@math{0 <= X < U}.

@item
Generate an integer @math{N} and discard it if @math{QU <= N}.

@item
If @math{N} is in the range @math{0 <= N < QU}, then it is also in a
range @math{X * Q < N < (X+1) * Q}.  @math{X} is the result.
@end enumerate

@item
When @math{M < U}, we have to generate pseudo--random integers @math{N'}
uniformly distributed in a range @math{0 <= N' < M'}, with @math{M < U
<= M'}.  We can do it by computing the following formula, which is a
polynomial in @math{M} and a linear combination with positive
coefficients in @math{N(i)} with @math{0 <= i < k}:

@example
N' = N0 + M * N1 + M^2 * N2 + ... +
   + ... + M^(k-2) * N(k-2) + M^(k-1) * N(k-1)
@end example

@noindent
where @math{N0}, @math{N1}, ..., @math{N(k-1)} are all generated
integers in the range @math{0 <= N(i) < M}.  The maximum value, that is
@math{M' - 1}, is realised when every @math{N(i)} equals @math{M - 1}:

@example
M' - 1 = (M - 1) + M * (M - 1) + M^2 * (M - 1) + ... +
       + ... + M^(k-2) * (M - 1) + M^(k-1) * (M - 1)
       = (M - 1) * [1 + M + M^2 + ... + M^(k-2) + M^(k-1)]
       = (M - 1) * (1 - M^k)/(1 - M)
       = (M - 1) * (M^k - 1)/(M - 1)
       = M^k - 1
@end example

@noindent
which implies @math{M^k = M'}.  So by selecting @math{k} such that
@math{U <= M^k} we are sure that @math{N'} will be in a suitable range.

Computing this polinomial/combination is like expressing the big
pseudo--random integer @math{N'} in base @math{M} where @math{N(i)} are
the digits.  Each possible @math{N'} is uniquely associated to a
@math{k}--tuple of integers @math{N(i)}.  Being the probability of
@math{N(i)} uniformly distributed, each possible @math{k}--tuple has
uniform probability in the set of all the possible @math{k}--tuples.  So
also the probability of @math{N'} is uniformly distributed in the range
@math{0 <= N' < M^k}.

Then we proceed like we did before for @math{U <= M}:

@example
Q  = floor(M' / U)
QU = Q * U

loop:
  N' = <compute the next polynomial>
  if (N' < QU)
  then X = floor(N' / Q)
  else goto loop
@end example
@end itemize

@c page
@node random prng reals
@subsection Generating real numbers


We want a sample @math{X} from the discrete range of representable
flonums in @math{0 <= X < 1} with a distribution that mimics the uniform
distribution of real numbers @math{R} in the continuous range @math{0 <
R < 1}.

Knowing that the integers @math{N} generated by a @acronym{PRNG} are
uniformly distributed in the range @math{0 <= N < M}, a pseudo--random
flonum @math{X} in the range @math{0 < X < 1} can be computed from a
generated @math{N} with the following normalisation formula:

@example
X = (1 + N) / (1 + M)
@end example

@noindent
notice that:

@example
N = 0        =>  X = 1 / (1 + M) > 0
N = (M - 1)  =>  X = M / (1 + M) < 1
@end example

@noindent
sometimes this is enough, but we have to notice that: There may be more
representable flonums in @math{0 < X < 1} than exact fractions like
@math{(1 + N) / (1 + M)}.

The following program prints the generated inexact fractions for the
very simple case @math{M = 5}, it prints also the intervals between two
adjacent fractions:

@example
(import (rnrs)
  (lists))

(define M 5)
(fold-left (lambda (prev-X X)
             (write (list X (- X prev-X)))
             (newline)
             X)
           0.0
           (map (lambda (N)
                  (inexact (/ (+ 1 N) (+ 1 M))))
             (list-tabulate M values)))
@print{} (0.16666666666666666 0.16666666666666666)
@print{} (0.3333333333333333  0.16666666666666666)
@print{} (0.5                 0.16666666666666669)
@print{} (0.6666666666666666  0.16666666666666663)
@print{} (0.8333333333333334  0.16666666666666674)
@end example

@noindent
so the generated flonums are in ``units'' of approximately @math{1/6 =
0.166666666666666}; we can compute this unit with @math{1 / (1 + M)}.

It is useful to be able to generate flonums in smaller units: We can do
it by generating a pseudo--random integer @math{N'} uniformly
distributed in a range larger than @math{0 <= N < M}.  We use the same
method previously outlined for large integers generation.  @ref{random
prng integers, Generating integers in a specified range}

So, we select a value for the desired unit, then we find @math{M'} such
that:

@example
1 / (1 + M') <= unit
=>  1 + M' >= 1 / unit
=>  M' >= (1 / unit) - 1
=>  1  >= (1 / unit) - 1 / M'
@end example

@noindent
then we generate a big pseudo--random integer @math{N'} in the range
@math{0 <= N' < M'} and normalise it with:

@example
X = (1 + N') / (1 + M')
@end example

@c page
@node random numbers
@section Simple random numbers


@defvr {Constant} default-random-source
A randomness source built by @func{make-random-source/mrg32k3a}, making
use of Pierre L'Ecuyer's MRG32k3a generator.  @ref{random mrg32k3a,
L'Ecuyer's MRG32k3a generator}.
@end defvr


@defun random-integer @var{n}
Use @code{default-random-source} to generate the next integer @math{X}
in the range @math{0 <= X < U}, where @var{U} is a positive integer.
Subsequent results of this procedure are independent, uniformly
distributed over the range @math{0 <= X < U}.
@end defun


@defun random-real
Use @code{default-random-source} to generate the next real number
@math{X} in the range @math{0 < X < 1}.  @math{X=0} and @math{X=1} are
excluded in order to allow @math{\log(X)} and @math{\log(1-X)} without
the danger of a numerical exception.  Subsequent results of this
procedure are independent, uniformly distributed in the range @math{0 <
X < 1}.
@end defun

@c page
@node random source
@section Randomness sources


@deffn Parameter random-source-maker
Hold a procedure that can be used to generate a new randomness source.
It is initialised to @func{make-random-source/mrg32k3a}.  For example,
it can be used as:

@example
(define source  ((random-source-maker)))
(define integer (random-source-integer-maker source))
(display (integer))
@print{} <a random integer>
@end example

@noindent
and as:

@example
(parameterise ((random-source-maker
                  make-random-source/device))
  (let* ((source  ((random-source-maker)))
         (integer (random-source-integer-maker source)))
    (display (integer))))
@print{} <a random integer>
@end example
@end deffn


@defun random-source? @var{obj}
Test if @var{obj} is a randomness source.  Objects of type randomness
source are distinct from all other types of objects.
@end defun


@defun random-source-state-ref @var{source}
@defunx random-source-state-set! @var{source} @var{state}
Get and set the current state of @var{source}.  The purpose of these
functions is to allow saving and restoring the state between sessions
(for example, save the state to a file and reload it later).

The state value is always a vector whose first element is a symbol
describing the generator.  The other elements of the vector depend on
the kind of generator: Refer to generator's documentation for their
format.
@end defun


@defun random-source-seed! @var{source} @var{integers-maker}
Reseed @var{source} to a new state.  @var{integers-maker} must be a a
generator of random integer numbers, like the ones returned by
@func{random-source-integers-maker}.  Notice that many random sources
require @var{integer-makers} to return integers representable with
@math{32} bits.
@end defun


@defun random-source-required-seed-values @var{source}
When @func{random-source-seed!} is used to reseed a @var{source}, some
generator will invoke @var{integers-maker} a fixed and known number of
times, other generators will invoke it a configurable number of times,
other generators will invoke it until it first returns @false{}, other
generators will invoke it until the returned numbers have some desired
property.

This function returns the number of times @var{integers-maker} will be
called; if the return value is @false{}: @var{integers-maker} will be
invoked until it first returns @false{}; if the return value is
infinity: @var{integers-maker} will be invoked until it returns numbers
with some desired property.
@end defun


@defun random-source-jumpahead! @var{source} @var{number-of-steps}
Move ahead @var{number-of-steps} randomness @var{source}'s state.  What
this means exactly depends on the type of @var{source}.
@end defun


The following procedures return a closure @var{rand} to generate
pseudo--random integers and real numbers using a randomness
@var{source}.  If an application obtains and uses several @var{rand}
procedures for the same randomness @var{source}, a call to any of these
procedures advances the state of @var{source}.  Hence, the procedures do
not produce the same sequence of random integers each, but rather share
a state.


@defun random-source-integers-maker @var{source}
Return a procedure @var{rand} to generate random integers using
@var{source}.  @var{rand} takes a single argument @var{U}, which must be
a positive integer, and returns the next uniformly distributed random
integer @math{X} in the interval @math{0 <= X < U} by advancing the
state of @var{source}.
@end defun


@defun random-source-reals-maker @var{source}
@defunx random-source-reals-maker @var{source} @var{unit}
Return a procedure @var{rand} which, when invoked with no arguments,
generates random real numbers @math{X} in the range @code{0 < X < 1}
using @var{source}.  @math{X=0} and @math{X=1} are excluded in order to
allow @math{\log(X)} and @math{\log(1-X)} without the danger of a
numerical exception.

The optional parameter @var{unit} determines the quantization of the
output; to have effect, @var{unit} must be a number such that @code{0 <
unit < 1}, if @var{unit} is greater than, or equal to, @math{1} the
generated numbers will have the default unit.  The numbers created by
@var{rand} are spaced by at most @var{unit}.  @ref{random prng reals,
Generating real numbers}, for details.
@end defun

@c page
@node random mrg32k3a
@section L'Ecuyer's MRG32k3a generator


The default randomness source of @library{randomisations} is Pierre
L'Ecuyer's MRG32k3a generator:

@quotation
P. L'Ecuyer.  ``Good Parameter Sets for Combined Multiple Recursive
Random Number Generators'', Shorter version in Operations Research, 47,
1 (1999), 159--164.

P. L'Ecuyer, R. Simard, E. J. Chen, W. D. Kelton. ``An Object--Oriented
Random--Number Package With Many Long Streams and Substreams''.  2001.
To appear in Operations Research.
@end quotation


@defun make-random-source/mrg32k3a
Create and return a new randomness source using MRG32k3a, representing a
deterministic stream of random bits.  Each returned randomness source
generates the same stream of values, unless the state is modified with
@func{random-source-seed!}.

The state returned by @func{random-source-state-ref} is a Scheme vector
of length 7, whose first value is the symbol
@code{random-source-state/mrg32k3a}.  All the other values in the vector
are positive integers.
@end defun

@c ------------------------------------------------------------

@subsubheading The algorithm

The MRG32k3a generator produces values @math{N} in the range @math{0 <=
N < 2^32 - 209}.  A new pseudo--random number @math{N} is generated with
the following computation starting from the state vectors @math{[A1, A2,
A3]} and @math{[B1, B2, B3]}:

@example
M1 = 4294967087 = 2^32 - 209
M2 = 4294944443 = 2^32 - 22853

c2 =  1403580
c3 =  -810728
d1 =   527612
d3 = -1370589

A0 = (          c2 * A2 + c3 * A3) mod M1
B0 = (d1 * B1 +           d3 * B3) mod M2

; right-shift A, purging the old A3
A3 = A2
A2 = A1
A1 = A0

; right-shift B, purging the old B3
B3 = B2
B2 = B1
B1 = B0

N = (A0 - B0) mod M1
@end example

@noindent
notice that @math{M1} and @math{M2} are two prime numbers just below
@math{2^32}; @math{c2}, @math{c3}, @math{d1} and @math{d3} are called
@dfn{recursion coefficients}.  The @library{randomisations} library
defines the initial state vectors as:

@example
A1 = 1062452522
A2 = 2961816100
A3 =  342112271

B1 = 2854655037
B2 = 3321940838
B3 = 3542344109
@end example

@c page
@node random device
@section Device--based random numbers


In Unix--like operating systems, @file{/dev/random} is a special file
that serves as a true random number generator or as a pseudorandom
number generator.  It allows access to environmental noise collected
from device drivers and other sources.  Not all operating systems
implement the same semantics for @file{/dev/random}@footnote{See
@url{http://en.wikipedia.org/wiki/Urandom}, last verified Fri Jun 26,
2009.}.

@defun make-random-source/device
@defunx make-random-source/device @var{device}
Create and return a new randomness source using the specified
@var{device} to generate random integers in the range @math{[0, 2^32)}.
When @var{device} is not specified, it defaults to @file{/dev/urandom}.

We have to remember that reading @file{/dev/random} will @strong{block}
if not enough entropy is available, waiting for more randomness to be
provided by the system.  This is why, by default, this function will use
@file{/dev/urandom}, which never blocks but provides randomness of
lesser quality.

The state returned by @func{random-source-state-ref} is a Scheme vector
of length 7, whose first value is the symbol
@code{random-source-state/device}.  The other values are the device
pathname, a cache vector of values, the index of the next value to be
extracted from the cace vector.
@end defun


@deffn Parameter random-device-cache-length
Device--based randomness sources cache read bytes into a bytevector of
fixed size.  This parameter allows us to select the size at source
construction time.  It is preset to @math{4096}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Low level @api{} for device randomness sources


@defun %random-bytevector @var{device} @var{number-of-bytes}
@defunx random-bytevector @var{number-of-bytes}
@defunx urandom-bytevector @var{number-of-bytes}
Read @var{number-of-bytes} from the specified @var{device} on the file
system and return them in a newly allocated bytevector.
@func{random-bytevector} is a specialised version reading bytes from
@file{/dev/random}.  @func{urandom-bytevector} is a specialised version
reading bytes from @file{/dev/urandom}.
@end defun


@defun %random-bytevector! @var{device} @var{bv}
@defunx random-bytevector! @var{bv}
@defunx urandom-bytevector! @var{bv}
Fill the bytevector @var{bv} with bytes read from the specified
@var{device} on the file system; return @var{bv} itself.
@func{random-bytevector!} is a specialised version reading bytes from
@file{/dev/random}.  @func{urandom-bytevector!} is a specialised version
reading bytes from @file{/dev/urandom}.
@end defun

@c page
@node random utils
@section Utilities


@menu
* random utils misc::           Miscellaneous utility functions.
* random utils lists::          Specialised list functions.
* random utils vectors::        Specialised vector functions.
* random utils strings::        Specialised string functions.
@end menu

@c page
@node random utils misc
@subsection Miscellaneous utility functions


The following bindings are exported by the @library{randomisations}
library.


@defun random-source-integers-maker-from-range @var{source} @var{start} @var{last}
@defunx random-source-integers-maker-from-range @var{source} @var{start} @var{last} @var{step}
Return a closure that, when evaluated with no arguments, returns a
random integer in the range selected by @var{start} and @var{last} both
included, using randomness from @var{source}.  @var{start} and
@var{last} must be exact integers.  The optional @var{step} argument,
which defaults to one, establishes the step of allowed values from the
range.
@end defun


@defun random-source-reals-maker-from-range @var{source} @var{start} @var{last}
@defunx random-source-reals-maker-from-range @var{source} @var{start} @var{last} @var{step}
Return a closure that, when evaluated with no arguments, returns a
random real in the range selected by @var{start} and @var{last}, using
randomness from @var{source}.  @var{start} and @var{last} must be real
numbers.

@itemize
@item
When @var{step} is not used: The result @math{R} is computed by
generating a random real @math{X} in the range @math{0 < X < 1}, then
computing:

@example
R = start + (last - start) * X
@end example

@noindent
so @math{R} is in the range delimited by @var{start} and @var{last} both
excluded.  The random real @math{X} is computed with no specified unit.
@ref{random source, @func{random-source-reals-maker}}, for details.

@item
When @var{step} is used: The result @math{R} is computed by generating a
random integer @var{N} in the range @math{0 <= N < U} with upper limit:

@example
U = floor[(last - start) / step]
@end example

@noindent
then computing:

@example
R = start + step * N
@end example

@noindent
so @math{R} is in the range delimited by @var{start} included and
@var{last} excluded.

@end itemize
@end defun


@defun random-permutations-maker @var{source}
Return a closure which, when applied to an integer number @var{n},
generates random permutations of the set @code{@{0, ..., n-1@}} using
randomness from @var{source}.  Such a permutation is represented by a
vector of length @var{n} for the images of the points.
@end defun

@c page
@node random utils lists
@subsection Specialised list functions


The auxiliary library @library{randomisations lists} exports bindings
specialised to handle lists and randomness sources; it is based on
@library{randomisations} only.


@defun random-list-unfold-numbers @var{number-maker} @var{number-of-numbers}
Given the closure @var{number-maker} returning a random number, build
and return a new list of @var{number-of-numbers} random numbers.
@end defun


@defun random-list-shuffle @var{ell} @var{source}
Build and return a new list shuffling the elements of @var{ell} using
randomness from the given @var{source}.
@end defun


@defun random-list-sample @var{ell} @var{source}
Return a closure that, when evaluated with no arguments, returns a
randomly selected item from @var{ell}, using randomness from
@var{source}.
@end defun


@defun random-list-sample-population @var{ell} @var{len} @var{source}
Return a closure that, when evaluated with no arguments, returns a list
of @var{len} items randomly selected from @var{ell}, using randomness
from @var{source}.
@end defun

@c page
@node random utils vectors
@subsection Specialised vector functions


The auxiliary library @library{randomisations vectors} exports bindings
specialised to handle vectors and randomness sources; it is based on
both @library{randomisations} and @library{vectors}.  Arguments to the
following functions follow the same conventions established for
@library{vectors} and @library{vectors low}.  @ref{vectors convention,
Interface conventions}


@defun random-vector-unfold-numbers @var{number-maker} @var{number-of-numbers}
Given the closure @var{number-maker} returning a random number, build
and return a new list of @var{number-of-numbers} random numbers.
@end defun


@deffn Function %random-vector-shuffle @var{source} @var{vec} @var{start} @var{past}
@deffnx Macro random-vector-shuffle @var{V} @var{source}
Build a new vector copying the selected subvector, then shuffle it using
randomness from the given @var{source}.  Return the new vector.
@end deffn


@deffn Function %random-vector-shuffle! @var{source} @var{vec} @var{start} @var{past}
@deffnx Macro random-vector-shuffle! @var{V} @var{source}
Shuffle the selected subvector using randomness from the given
@var{source}.  Return the shuffled vector itself.
@end deffn


@deffn Function %random-vector-sample @var{source} @var{vec} @var{start} @var{past}
@deffnx Macro random-vector-sample @var{V} @var{source}
Return a closure that, when evaluated with no arguments, returns a
randomly selected item from the selected subvector, using randomness
from @var{source}.
@end deffn


@deffn Function %random-vector-sample-population @var{source} @var{len} @var{vec} @var{start} @var{past}
@deffnx Macro random-vector-sample-population @var{V} @var{len} @var{source}
Return a closure that, when evaluated with no arguments, returns a
vector of @var{len} items randomly selected from the selected subvector
of @var{vec}, using randomness from @var{source}.
@end deffn


@defun random-integers-with-sum @var{requested-sum} @var{number-of-numbers} @var{inclusive-min} @var{inclusive-max} @var{source}
Return a vector of length @var{number-of-numbers}, holding random
integers in the range delimited by @var{inclusive-min} and
@var{inclusive-max}, generated using randomness from @var{source}.  The
integers are such that their sum equals @var{requested-sum}.
@end defun


@defun random-reals-with-sum @var{requested-sum} @var{tolerance} @var{number-of-numbers} @var{exclusive-min} @var{exclusive-max} @var{source}
Return a vector of length @var{number-of-numbers}, holding random reals
in the range delimited by @var{exclusive-min} and @var{exclusive-max},
generated using randomness from @var{source}.  The numbers are such that
their sum equals approximately @var{requested-sum} with @var{tolerance}:

@example
(< (- (abs @var{tolerance}))
   (abs (- @var{requested-sum} actual-sum))
   (abs @var{tolerance}))
@result{} #t
@end example
@end defun

@c page
@node random utils strings
@subsection Specialised string functions


The auxiliary library @library{randomisations strings} exports bindings
specialised to handle strings and randomness sources; it is based on
both @library{randomisations} and @library{strings}.  Arguments to the
following functions follow the same conventions established for
@library{strings} and @library{strings low}.  @ref{strings convention,
Interface conventions}


@defun random-string-unfold-chars @var{integer-maker} @var{number-of-chars}
Given the closure @var{integer-maker} returning a random integer, build
and return a new string of @var{number-of-chars} random characters.

As a usage example, the following program will generate random passwords
with characters in the range of graphics @ascii{} codes (warning: for
real world applications, use a true random source):

@example
(import (rnrs)
  (random)
  (random strings)
  (char-sets))

(random-string-unfold-chars
  (lambda ()
    (do ((ch (random-integer 127) (random-integer 127)))
        ((char-set-contains? char-set:ascii/graphic
                             (integer->char ch))
         ch)))
  10)
@end example
@end defun


@deffn Function %random-string-shuffle @var{source} @var{str} @var{start} @var{past}
@deffnx Macro random-string-shuffle @var{S} @var{source}
Build a new string copying the selected substring, then shuffle it using
randomness from the given @var{source}.  Return the new string.
@end deffn


@deffn Function %random-string-shuffle! @var{source} @var{str} @var{start} @var{past}
@deffnx Macro random-string-shuffle! @var{S} @var{source}
Shuffle the selected substring using randomness from the given
@var{source}.  Return the shuffled string itself.
@end deffn


@deffn Function %random-string-sample @var{source} @var{str} @var{start} @var{past}
@deffnx Macro random-string-sample @var{S} @var{source}
Return a closure that, when evaluated with no arguments, returns a
randomly selected item from the selected substring, using randomness
from @var{source}.
@end deffn

@deffn Function %random-string-sample-population @var{source} @var{len} @var{str} @var{start} @var{past}
@deffnx Macro random-string-sample-population @var{S} @var{len} @var{source}
Return a closure that, when evaluated with no arguments, returns a
string of @var{len} items randomly selected from the selected substring
of @var{str}, using randomness from @var{source}.
@end deffn

@c page
@node random generators
@section Auxiliary generators


@menu
* random generators mersenne::  The Mersenne twister.
* random generators marsaglia:: George Marsaglia's generators.
* random generators bbs::       Blum--Blum--Shub generator.
* random generators borosh::    Borosh generator.
* random generators cmrg::      Combined multiple recursive generator.
@end menu

@c page
@node random generators mersenne
@subsection The Mersenne twister


The Mersenne twister is a pseudorandom number generator developed in
1997 by Makoto Matsumoto and Takuji Nishimura:

@quotation
Matsumoto Makoto and Nishimura Takuji.  ``Mersenne twister: a
623--dimensionally equidistributed uniform pseudo--random number
generator''.  1998.  @acronym{ACM} Transactions on Modeling and Computer
Simulation.
@end quotation

@noindent
it provides for fast generation of very high--quality pseudorandom
numbers, having been designed specifically to rectify many of the flaws
found in older algorithms.  Its name derives from the fact that period
length is chosen to be a Mersenne prime@footnote{Wikipedia contributors,
``Mersenne twister'', Wikipedia, The Free Encyclopedia,
@url{http://en.wikipedia.org/w/index.php?title=Mersenne_twister&oldid=299648661}
(accessed July 1, 2009).}.

The following bindings are exported by the @library{randomisations
mersenne} library.


@defun make-random-source/mersenne
Build and return a new randomness source using the Mersenne generator.

The state returned by @func{random-source-state-ref} is a Scheme vector
of length 626, whose first value is the symbol
@code{random-source-state/mersenne}.  The other values are integers
representable with @math{32} bits.

The @func{random-source-seed!} function for this generator, must be
applied tot a numbers maker returning integers representable with
@math{32} bits.
@end defun


@library{randomisations mersenne} initialises the generator drawing
@math{32} bits integer numbers from a specifically built MRG32k3a
randomness source, which in turn is initialised with the default
@library{randomisations} seeds.  @ref{random mrg32k3a, L'Ecuyer's
MRG32k3a generator}

@c page
@node random generators marsaglia
@subsection George Marsaglia's generators


The generators described here were posted by George Marsaglia in a
thread on @url{sci.stat.math} and @url{sci.crypt} starting on January,
12 1999.  The following bindings are exported by the
@library{randomisations marsaglia} library.

For all the randomness sources, the @func{random-source-seed!} function
must be applied to a number maker returning integers representable with
@math{32} bits.


@defun make-random-source/marsaglia/cong
Build and return a new randomness source using the CONG generator.

The state returned by @func{random-source-state-ref} is a Scheme vector
of length 2, whose first value is the symbol
@code{random-source-state/marsaglia/cong}.  The other value is a single
integer representable with @math{32} bits.
@end defun


@defun make-random-source/marsaglia/fib
Build and return a new randomness source using the FIB generator.

The state returned by @func{random-source-state-ref} is a Scheme vector
of length 3, whose first value is the symbol
@code{random-source-state/marsaglia/fib}.  The other values are integers
representable with @math{32} bits.
@end defun


@defun make-random-source/marsaglia/lfib4
Build and return a new randomness source using the LFIB4 generator.

The state returned by @func{random-source-state-ref} is a Scheme vector
of length 258, whose first value is the symbol
@code{random-source-state/marsaglia/lfib4}.  The other values are
integers representable with @math{32} bits.
@end defun


@defun make-random-source/marsaglia/kiss
Build and return a new randomness source using the KISS generator.

The state returned by @func{random-source-state-ref} is a Scheme vector
of length 5, whose first value is the symbol
@code{random-source-state/marsaglia/kiss}.  The other values are
integers representable with @math{32} bits.
@end defun


@defun make-random-source/marsaglia/mwc
Build and return a new randomness source using the MWC generator.

The state returned by @func{random-source-state-ref} is a Scheme vector
of length 3, whose first value is the symbol
@code{random-source-state/marsaglia/mwc}.  The other values are integers
representable with @math{32} bits.
@end defun


@defun make-random-source/marsaglia/shr3
Build and return a new randomness source using the SHR3 generator.

The state returned by @func{random-source-state-ref} is a Scheme vector
of length 2, whose first value is the symbol
@code{random-source-state/marsaglia/shr3}.  The other value is an
integer representable with @math{32} bits.
@end defun


@defun make-random-source/marsaglia/swb
Build and return a new randomness source using the SWB generator.

The state returned by @func{random-source-state-ref} is a Scheme vector
of length 261, whose first value is the symbol
@code{random-source-state/marsaglia/swb}.  The other values are integers
representable with @math{32} bits.
@end defun

@c ------------------------------------------------------------

@subsubheading Algorithms

Here is the core C language implementation of the generators, as posted
by Marsaglia (line wrapping added here, and small bits changed):

@example
#define znew    (z = 36969 * (z & 65535)        \
                   + (z >> 16))

#define wnew    (w = 18000 * (w & 65535)        \
                   + (w >> 16))

#define MWC     ((znew << 16) + wnew)

#define SHR3    (jsr ^= (jsr << 17),  \
                 jsr ^= (jsr >> 13),  \
                 jsr ^= (jsr << 5))

#define CONG    (jcong = 69069 * jcong + 1234567)

#define FIB     ((b = a + b),    \
                 (a = b - a))

#define KISS    ((MWC^CONG) + SHR3)

#define LFIB4   (c++,                           \
                 t[c] = t[c]                    \
                      + t[(uint8_t)(c +  58)]   \
                      + t[(uint8_t)(c + 119)]   \
                      + t[(uint8_t)(c + 178)])

#define SWB     (c++,                                   \
                 bro  = (x < y),                        \
                 t[c] = (x = t[(uint8_t)(c + 34)])      \
                           - (y = t[(uint8_t)(c + 19)]  \
                                + bro))

#define UNI   (KISS * 2.328306e-10)
#define VNI   (((int32_t) KISS) * 4.656613e-10)

#define UC    (uint8_t)   /* a cast operation */

/* Use random seeds to reset z, w, jsr, jcong, a, b,
   and the table t[256] */
uint32_t  z, w, jsr, jcong, a, b, t[256];

uint32_t  x=0, y=0, bro;
uint8_t   c=0;
@end example

What follows is the comment part of the original post by Marsaglia
himself, with minor editing for formatting purposes and porting to
Scheme (errors in the original text are probably present here, too):

@quotation
Any one of KISS, MWC, FIB, LFIB4, SWB, SHR3, or CONG can be used in an
expression to provide a random @math{32} bits integer.

The KISS generator (Keep It Simple Stupid) is designed to combine the
two multiply--with--carry generators in MWC with the @math{3}--shift
register SHR3 and the congruential generator CONG, using addition and
exclusive--or.  Period about @code{2^123}.  It is one of my favorite
generators.

The MWC generator concatenates two 16 bits multiply--with--carry
generators:

@example
x(n) = 36969 * x(n-1) + carry
y(n) = 18000 * y(n-1) + carry mod 2^16
@end example

@noindent
has period about @math{2^60} and seems to pass all tests of randomness.
A favorite stand--alone generator---faster than KISS, which contains it.

FIB is the classical Fibonacci sequence:

@example
x(n) = x(n-1) + x(n-2)
@end example

@noindent
but taken modulo @math{2^32}.  Its period is @math{3 * 2^31} if one of
its two seeds is odd and not @math{1 mod 8}.  It has little worth as a
@acronym{RNG} by itself, but provides a simple and fast component for
use in combination generators.

SHR3 is a @math{3}--shift--register generator with period @math{2^32 -
1}.  It uses:

@example
y(n) = y(n-1) * (I + L^17) * (I + R^13) * (I+L^5)
@end example

@noindent
with the @math{y} viewed as binary vectors, @math{L} the @math{32 x 32}
binary matrix that shifts a vector left @math{1}, and @math{R} its
transpose.  SHR3 seems to pass all tests except those related to the
binary rank test, since @math{32} successive values, as binary vectors,
must be linearly independent, while @math{32} successive truly random 32
bits integers, viewed as binary vectors, will be linearly independent
only about 29% of the time.

CONG is a congruential generator with the widely used @math{69069}
multiplier:

@example
x(n) = 69069 * x(n-1) + 1234567
@end example

@noindent
it has period @math{2^32}.  The leading half of its @math{32} bits seem
to pass tests, but bits in the last half are too regular.

LFIB4 is an extension of what I have previously defined as a lagged
Fibonacci generator:

@example
x(n) = x(n-r) op x(n-s)
@end example

@noindent
with the @math{x} in a finite set over which there is a binary operation
@math{op}, such as @math{+}, @math{-} on integers modulo @math{2^32},
@math{*} on odd such integers, exclusive-or(xor) on binary vectors.

Except for those using multiplication, lagged Fibonacci generators fail
various tests of randomness, unless the lags are very long.  (See SWB
below).  To see if more than two lags would serve to overcome the
problems of @math{2}-lag generators using @math{+}, @math{-} or
@math{xor}, I have developed the @math{4}--lag generator LFIB4 using
addition:

@example
x(n) = [x(n-256) + x(n-179) + x(n-119) + x(n-55)] mod 2^32
@end example

@noindent
its period is @math{2^31 * (2^256 - 1)}, about @math{2^287}, and it
seems to pass all tests---in particular, those of the kind for which
@math{2}-lag generators using @math{+}, @math{-}, @math{xor} seem to
fail.  For even more confidence in its suitability, LFIB4 can be
combined with KISS, with a resulting period of about @math{2^410}: Just
use:

@example
(let* ((kiss       (make-random-source/marsaglia/kiss))
       (cong       (make-random-source/marsaglia/cong))
       (k-integers (random-source-integers-maker kiss))
       (c-integers (random-source-integers-maker cong))
       (integers   (lambda (U M)
                     (mod (+ (k-integers U)
                             (c-integers U))
                          M))))
  ---)
@end example

@noindent
in any Scheme expression.

SWB is a subtract--with--borrow generator that I developed to give a
simple method for producing extremely long periods:

@example
x(n) = [x(n-222) - x(n-237) - borrow] mod 2^32
@end example

@noindent
the @code{borrow} is @math{0}, or set to @math{1} if computing
@math{x(n-1)} caused overflow in 32 bits integer arithmetic. This
generator has a very long period, @math{2^7098 * (2^480 - 1)}, about
@math{2^7578}.  It seems to pass all tests of randomness, except for the
Birthday Spacings test, which it fails badly, as do all lagged Fibonacci
generators using @math{+}, @math{-} or @math{xor}.

I would suggest combining SWB with KISS, MWC, SHR3, or CONG.  KISS+SWB
has period @math{>2^7700} and is highly recommended.
Subtract--with--borrow has the same local behaviour as lagged Fibonacci
using @math{+}, @math{-}, @math{xor}---the borrow merely provides a much
longer period.  SWB fails the birthday spacings test, as do all lagged
Fibonacci and other generators that merely combine two previous values
by means of @math{+}, @math{-} or @math{xor}.  Those failures are for a
particular case: @math{m = 512} birthdays in a year of @math{n = 2^24}
days.  There are choices of @math{m} and @math{n} for which lags
@math{>1000} will also fail the test.  A reasonable precaution is to
always combine a @math{2}-lag Fibonacci or SWB generator with another
kind of generator, unless the generator uses @math{*}, for which a very
satisfactory sequence of odd @math{32} bits integers results.

The classical Fibonacci sequence @math{mod 2^32} from FIB fails several
tests.  It is not suitable for use by itself, but is quite suitable for
combining with other generators.

The last half of the bits of CONG are too regular, and it fails tests
for which those bits play a significant role.  CONG+FIB will also have
too much regularity in trailing bits, as each does.  But keep in mind
that it is a rare application for which the trailing bits play a
significant role.  CONG is one of the most widely used generators of the
last @math{30} years, as it was the system generator for VAX and was
incorporated in several popular software packages, all seemingly without
complaint.
@end quotation

The generators are seeded as follows:

@table @asis
@item CONG
The seed values are:

@example
jcong = 2524969849
@end example

@noindent
with this seeding it is known that the millionth integer is
@math{1529210297}.

@item FIB
The seed values are:

@example
a =  9983651
b = 95746118
@end example

@noindent
with this seeding it is known that the millionth integer is
@math{3519793928}.

@item KISS
The seed values are:

@example
jcong = 1017008441
jsr   = 3259917390
w     =   99545079
z     = 2247183469
@end example

@noindent
with this seeding it is known that the millionth integer is
@math{1372460312}.

@item LFIB4
The seed values are stored in a vector of length 256, holding @math{32}
bits representable integers; the index into the vector is set to @code{c
= 0}.  The seed values of the vector are precomputed, see the source
code of the library.

With this seeding it is known that the millionth integer is
@math{1064612766}.

@item MWC
The seed values are:

@example
w = 1046675282
z = 2374144069
@end example

@noindent
with this seeding it is known that the millionth integer is
@math{904977562}.

@item SHR3
The seed values are:

@example
jsr = 4176875757
@end example

@noindent
with this seeding it is known that the millionth integer is
@math{2642725982}.

@item SWB
The seed values are stored in a vector of length 256, holding @math{32}
bits representable integers; the index into the vector is set to @code{c
= 64}.  The seed values of the vector are precomputed, see the source
code of the library.

With this seeding it is known that the millionth integer is
@math{627749721}.
@end table

@c page
@node random generators bbs
@subsection Blum--Blum--Shub generator


Blum--Blum--Shub is a @acronym{PRNG} proposed in:

@quotation
Lenore Blum, Manuel Blum, Michael Shub.  ``A Simple Unpredictable
Pseudo--Random Number Generator'', SIAM Journal on Computing, volume 15,
page 364-383, May 1986.
@end quotation

@noindent
when seeded with prime numbers satisfying the specified requirements, it
can be considered a cryptographically secure @acronym{PRNG}.  The search
of such prime numbers is a delicate and complex task; we have to turn to
specialised literature to learn how to do it.

The following bindings are exported by the @library{randomisations
blum-blum-shub} library.  The library makes no attempt to validate the
seed numbers for the cryptographic requirements, it just implements the
@acronym{PRNG} algorithm; attaining cryptographic security is entirely
on our shoulders.


@defun make-random-source/blum-blum-shub
Build and return a new randomness source using the BBS generator.  The
returned randomness source is @strong{not} seeded; this is because
seeding a cryptographically secure generator must be done with care, and
it makes no sense to have a default seed.  The first operation after the
creation of the source should be to seed it.

The state returned by @func{random-source-state-ref} is a Scheme vector
of length 5, whose first value is the symbol
@code{random-source-state/blum-blum-shub}.  The other values are integer
numbers.

The @func{random-source-seed!} function for this generator, must be
applied to a numbers maker returning:

@enumerate
@item
The value of the prime number @math{P}.

@item
The value of the prime number @math{Q}.

@item
Integers numbers until one is found whose GCD with @math{P * Q} is
@math{1}.
@end enumerate

@noindent
see the algorithm details below.
@end defun

@c ------------------------------------------------------------

@subsubheading The algorithm

BBS generates a sequence of bits, not of numbers.  Bits can be
concatenated to yield numbers of any sort in base 2.  Seeding goes like
this:

@enumerate
@item
Select two prime numbers @math{P} and @math{Q} and compute @math{M = P *
Q}, which will be the modulus of the internally generated integers.
These primes are the ``secret'' of the generated sequence of
pseudo--random integers; for cryptographic purposes they have to be kept
hidden.

@item
Generate (using another @acronym{PRNG}) random integers @math{S} until
one is found such that: The greatest commond divisor (GCD) between
@math{S} and @math{M} is @math{1}.  Notice that @rnrs{6} Scheme
implementations already provide a @func{gcd} function.  @nauref{baselib
math ops arithmetic, Arithmetic operations}

@item
Compute the seed @math{X}:

@example
X = (S * S) mod M
@end example
@end enumerate

The generator in @library{randomisations blum-blum-shub} computes a new
integer @math{N} representable with @math{32} bits, from an initial
state @math{X} with the following formulation:

@example
X0 = (X * X) mod M
b0 = parity(X0)

X1 = (X0 * X0) mod M
b1 = parity(X1)

X2 = (X1 * X1) mod M
b2 = parity(X2)

...
@end example

@noindent
where @math{b(k)} are the bits of @math{N}, with @math{0 <= k < 32}, and
@math{X32} is the new state of the generator.  The function
@math{parity(X)} is the number of bits set to @math{1} in @math{X},
modulo @math{2}.

@c page
@node random generators borosh
@subsection Borosh generator


This generator is called @dfn{Borosh--Niederreiter}.  It was taken from:

@quotation
Donald E. Knuth.  ``The Art of Computer Programming''.  Volume 2.  Third
Edition.  Addison-Wesley.  Page 106-108.
@end quotation

@noindent
the following bindings are exported by the @library{randomisations
borosh} library.


@defun make-random-source/borosh
Build and return a new randomness source using the
@dfn{Borosh--Niederreiter} generator.

The state returned by @func{random-source-state-ref} is a Scheme vector
of length 2, whose first value is the symbol
@code{random-source-state/borosh}.  The other value is a single integer
representable with @math{32} bits.

The @func{random-source-seed!} function for this generator, must be
applied to a numbers maker returning integers representable with
@math{32} bits.
@end defun


@subsubheading The algorithm

The generator computes a new integer @math{N'} from an initial state
@math{N} with the following formulation:

@example
M = 2^32
A = 1812433253

N' = (A * N) mod M
@end example

@noindent
@library{randomisations borosh} sets the initial state to @math{N = 1}.

@c page
@node random generators cmrg
@subsection Combined multiple recursive generator


This is a combined multiple recursive generator.  The algorithm was
derived from:@footnote{It is available from L'Ecuyer's home page
(@aurl{} last verified Tue Jul 14, 2009):

@center @url{http://www.iro.umontreal.ca/~lecuyer/myftp/papers/combmrg.ps}
@center @url{ftp://ftp.iro.umontreal.ca/pub/simulation/lecuyer/papers/combmrg.ps}
}

@quotation
P.  L'Ecuyer.  ``Combined Multiple Recursive Random Number Generators''.
Operations Research, 44, 5 (1996), 816--822.
@end quotation

@noindent
the following bindings are exported by the @library{randomisations cmrg}
library.


@defun make-random-source/cmrg
Build and return a new randomness source using a @acronym{CMRG}
generator.

The state returned by @func{random-source-state-ref} is a Scheme vector
of length 7, whose first value is the symbol
@code{random-source-state/cmrg}.  The other values are integers
representable with @math{32} bits.

The @func{random-source-seed!} function for this generator, must be
applied to a numbers maker returning integers representable with
@math{32} bits.
@end defun

@c ------------------------------------------------------------

@subsubheading The algorithm

The sequence is:

@example
N = (X0 - Y0) mod m1
@end example

@noindent
where the two underlying generators @math{X} and @math{Y} are:

@example
X0 = (A1 X1 + A2 X2 + A3 X3) mod M1
Y0 = (B1 Y1 + B2 X2 + B3 Y3) mod M2
@end example

@noindent
with coefficients:

@example
A1 = 0       A2 = 63308   A3 = -183326
B1 = 86098   B2 = 0       B3 = -539608
@end example

@noindent
and moduli:

@example
M1 = 2^31 - 1       = 2147483647
M2 = 2^31 - 2000169 = 2145483479
@end example

According to the paper the initial values for @math{X} must lie in the
range @math{0 <= X < M1} and the initial values for @math{Y} must lie in
the range @math{0 <= Y < M2}, with at least one non--zero value.
@library{randomisations cmrg} initialises the generator with:

@example
X1 = 7   X2 = 17   X3 = 47
Y1 = 3   Y2 = 13   Y3 = 43
@end example

@noindent
and the seeding procedure implemented by the randomness source (through
@func{random-source-seed!}) will extract random numbers from the given
generator until it is @math{0 < X < M1} and @math{0 < Y < M2}.

@c page
@node random dist
@section Random numbers from known distributions


The following functions are exported by the @library{randomisations
distributions} library.


@defun random-exponentials-maker @var{source}
Return a closure which, when applied to a real number argument @var{mu},
generates exponentially @math{exp(mu)} distributed random numbers using
randomness from @var{source}.
@end defun


@defun random-normals-maker @var{source}
Return a closure which, when applied to real number arguments @var{mu}
and @var{sigma}, generates normally distributed @math{N(mu, sigma)}
random numbers using randomness from @var{source}.
@end defun

@c page
@node msgcat
@chapter Messages catalog for internationalisation


The @library{msgcat} allows to translate Scheme strings from the
@code{en_GB} locale to other locales.

@menu
* msgcat intro::                Introduction to messages catalogs.
* msgcat api::                  Messages catalogs @api{}.
@end menu

@c page
@node msgcat intro
@section Introduction to messages catalogs


Messages translation is simply handled by a procedure applied to a
string: the return value is meant to be the translated string.
@library{msgcat} defines a ``standard'' translator procedure accepting
one or two arguments:

@itemize
@item
When applied to one argument: the argument must be the string to
translate; the return value must be the translated string or the input
string itself if no translation was found.

@item
When applied to two arguments: the first argument must be the string to
translate, the second argument must be a default value; the return value
must be the translated string or the default value if no translation was
found.
@end itemize

A translator procedure can do anything, for example it can query a set
of other translation procedures in search of a translation.  The
template for a translation procedure is the following:

@example
(define catalog
  (make-hashtable string-hash string=?))

(define translator
  (case-lambda
    ((message)
     (translator message message))
    ((message default)
     (hashtable-ref catalog message default))))
@end example

@noindent
an implementation querying a set of translator procedures is as follows:

@example
(define translator-1 ---)
(define translator-2 ---)
(define translator-3 ---)

(define translator
  (case-lambda
    ((message)
     (translator message message))
    ((message default)
     (or (find (lambda (T)
                 (T message #f))
               (list translator-1 translator-2 translator-3))
         default))))
@end example

A catalog file is a textual file holding a single S--expression which
can be read with the @func{read} function from @rsixlibrary{io simple};
the S--expression must match the following template:

@example
(msgcat (<version0> <version>...)
  <catalog name>
  <data> ...)
@end example

@noindent
where: the @meta{version} datums are exact integers representing the
format version of the catalog; the @meta{catalog name} datum must be a
symbol representing the catalog name; the @meta{data} datums depend on
the catalog format version.

@c ------------------------------------------------------------

@subsubheading Message catalog version @math{1}

The S--expression of version @math{1} must match the following template:

@example
(msgcat (<version0> <version>...)
  <catalog name>
  (<message> <translated message>)
  ...)
@end example

@noindent
where the @meta{message} datums are the message strings in the
@code{en_GB} locale and the @meta{translated message} datums are the
translated message strings.

@c page
@node msgcat api
@section Messages catalogs @api{}


Here are some examples:

@example
(import (nausicaa)
  (prefix (msgcat) msgcat:))

(define it_IT (msgcat:load-catalog 'it_IT))
(define en_US (msgcat:load-catalog 'en_US))

;; the default is en_GB
(msgcat:mc "January")   @result{} "January"

(parametrise ((msgcat:current-catalog it_IT))
  (msgcat:mc "January") @result{} "Gennaio"
  #f)

(parametrise ((current-catalog en_US))
  (msgcat:mc "Yes")     @result{} "Yes"
  #f)
@end example


@defun load-catalog @var{name}
Load a catalog file and return a standard translator procedure;
@var{name} must be a Scheme string or symbol representing the catalog
name.  @value{PACKAGE} comes at least with the following catalogs
installed as files: @samp{en_US}, @samp{it_IT}.  The @samp{en_GB}
catalog is built into the @library{msgcat} library.

The search path for the catalog file is selected by the environment
variable @env{NAUSICAA_MSGCAT}, whose value must be a colon--separated
list of directories.  The file pathname is built as follows:

@example
@cmeta{directory}/@cmeta{name}.cat
@end example

@noindent
where @samp{.cat} is the file extension.
@end defun


@defun load-catalog-from-file @var{pathname}
Like @func{load-catalog} but accept a file pathname as argument.
@end defun


@deffn Parameter current-catalog
Parameter holding the current translator procedure.  It is initialised
with @func{en_GB}.
@end deffn


@deffn Syntax mc @ameta{string}
Expand to the application of the procedure currently stored in the
@func{current-catalog} parameter to @meta{string}.
@end deffn


@deffn mcmax @var{string} ...
Return the maximum number of characters in the translated strings.
@end deffn


@deffn {Catalog Function} en_GB @var{string}
@deffnx {Catalog Function} en_GB @var{string} @var{default}
An identity function just returning @var{string}.  It is the default
value for the @func{current-catalog} parameter: strings are meant to be
written in the @code{en_GB} locale in Nausicaa's source files.
@end deffn

@c page
@node time
@chapter Time data types and procedures


The @library{times-and-dates} library implements procedures and data
types to manipulate timestamps and dates; the library is built on top of
the facilities of the @library{classes} library.  @nauref{classes,
Classes library}.

This chapter contains chunks of slightly edited text from Wikipedia
pages on time scales and related subjects.  The
@library{times-and-dates} library is built upon such Wikipedia
informations and informations extracted from the
@uref{http://@/www.tondering.dk/@/claus/@/calendar.html, Calendar
@acronym{FAQ}} maintained by Claus Tondering.

@menu
* time intro::                  Introduction to time scales.
* time overview::               Overview of the library.
* time system::                 Interface to the system.
* time secs::                   Seconds and nanoseconds objects.
* time duration::               Time duration objects.
* time point::                  Points in time.
* time date::                   Date object.
* time utils::                  Miscellaneous utilities.
* time const::                  Constants.
* time current::                Current time and clock resolution.
* time timeobj::                Time object and accessors.
* time timeobj compar::         Time object comparison procedures.
* time timeobj arithm::         Time object arithmetic procedures.
* time dateobj::                Date object and accessors.
* time string::                 Date to string/string to date
                                converters.
@end menu

@c page
@node time intro
@section Introduction to time scales


@cindex Terrestrial time


When using the @library{times-and-dates} library we aim at dealing with
@uref{http://@/en.wikipedia.org/@/wiki/@/Terrestrial_Time,
@dfn{Terrestrial Time}} in which: seconds are the ones of the
International System of Units (@acronym{SI}), defined using caesium
atomic clocks; @math{60} seconds make one minute; @math{60} minutes make
one hour; @math{24} hours make one day; @math{365} days make one year.
Terrestrial Time is a theoretical ideal, which real clocks can only
approximate.

@menu
* time intro conventions::      Miscellaneous conventions.
* time intro tai::              International Atomic Time (@tai{}).
* time intro utc::              Coordinated Universal Time (@utc{}).
* time intro gmt::              Greenwich Mean Time (@gmt{}).
* time intro zone::             Time zones and daylight saving time.
* time intro dst::              Daylight Saving Time (@dst{}).
* time intro unix::             Unix Time and Unix Epoch.
* time intro gregorian::        Gregorian calendar.
* time intro week::             Week days.
* time intro julian::           Julian Date (@acronym{JD}) and Julian Day (@acronym{JDN}).
@end menu

@c page
@node time intro conventions
@subsection Miscellaneous conventions


In this section we anticipate some concepts which are explained in
detail in later sections; this anticipation should not hinder the
comprehension.

When expressing a timestamp in this documentation, we preferably use
strings of the following format, which is compliant with @iso{} 8601:

@example
@cmeta{YYYY}-@cmeta{MM}-@cmeta{DD}T@cmeta{hh}:@cmeta{mm}:@cmeta{ss}Z
@end example

@noindent
where @meta{YYYY} is the year number, @meta{MM} is the month index in
the range @math{[1, 12]}, @meta{DD} is the day index in the range
@math{[1, 31]}, @meta{hh} is the count of hours in the range @math{[0,
23]}, @meta{mm} is the count of minutes in the range @math{[0, 59]},
@meta{ss} is the count of seconds in the range @math{[0, 60]} (allowing
leap seconds); the literal @code{T} separates the date from the hour and
the literal @code{Z} specifies the mean time of Greenwich
(@acronym{UK}).

The beginning of the first second in a day is @samp{00:00:00} and we
call it @dfn{midnight}; the beginning of the last second in a day is
@samp{23:59:59} when no leap second is added and @samp{23:59:60} when a
leap second is added (@pxref{time intro utc} for details).

@c page
@node time intro tai
@subsection International Atomic Time (@tai{})


@cindex International Atomic Time, @tai{}
@cindex @tai{}, International Atomic Time


A realisation of Terrestrial Time is the
@uref{http://@/en.wikipedia.org/@/wiki/@/International_Atomic_Time,
@dfn{International Atomic Time}}, which is based on the notional passage
of proper time on Earth's surface.

Time coordinates on the @tai{} scale are conventionally expressed using
traditional means of specifying days, for example: the @acronym{SI}
seconds and the time coordinates defined by the proleptic Gregorian
calendar.  @ref{time intro gregorian, Gregorian calendar}.

The timestamp @samp{2010-08-05T11:22:33Z} is valid on the @tai{} scale
with the usual count of years, month and days on the Gregorian calendar.
The count of seconds is always in the range @math{[0, 59]} because the
@tai{} scale has no leap seconds.

@c page
@node time intro utc
@subsection Coordinated Universal Time (@utc{})


@cindex Coordinated Universal Time, @utc{}
@cindex @utc{}, Coordinated Universal Time
@cindex Leap seconds


Another realisation of Terrestrial Time is the
@uref{http://@/en.wikipedia.org/@/wiki/@/Coordinated_Universal_Time,
@dfn{Coordinated Universal Time}}, a time standard based on @tai{} with
@uref{http://@/en.wikipedia.org/@/wiki/@/Leap_second, leap seconds}
added at irregular intervals to compensate for the Earth's slowing
rotation.  Leap seconds are added at the end of some days to allow
@utc{} to closely track the mean solar time at the Royal Observatory,
Greenwich (UK); when a leap second is added, the last minute of the day
has @math{61} seconds.

As a compromise between the history of time scale definitions and the
need to define a time scale for every point in time, the best assumption
we can do is that @tai{} and @utc{} where synchronised before the first
leap second was added; when the first leap second was added (on June 30
1972), @tai{} and @utc{} went out of synchronisation as follows:

@example
                  TAI midnight
                        |
          June 30 1972  |  July 1 1972
                        v
       23:59:58 23:59:59 00:00:00 00:00:01 00:00:02
TAI --|--------|--------|--------|--------|--------|--

       23:59:58 23:59:59 23:59:60 00:00:00 00:00:01
UTC --|--------|--------|++++++++|--------|--------|--
                          leap   ^
                          second |
                                 |
                   June 30 1972  |  July 1 1972
                                 |
                           UTC midnight
@end example

@noindent
when the second leap second was added (on December 31 1972), @tai{} and
@utc{} went further out of synchronisation as follows:

@example
                  TAI midnight
                        |
      December 31 1972  |  January 1 1973
                        v
       23:59:58 23:59:59 00:00:00 00:00:01 00:00:02
TAI --|--------|--------|--------|--------|--------|--

       23:59:57 23:59:58 23:59:59 23:59:60 00:00:00
UTC --|--------|--------|--------|++++++++|--------|--
                                   leap   ^
                                   second |
                                          |
                        December 31 1972  |  January 1 1973
                                          |
                                    UTC midnight
@end example

@noindent
whenever a leap second is added on the @utc{} scale, the @utc{} date
falls back one second with respect to @tai{}.  On August 3 2010 the
@tai{} scale was 34 seconds forwards of the @utc{} scale.

The timestamp @samp{2010-08-05T11:22:33Z} is valid on the @utc{} scale
with the usual count of years, month and days on the Gregorian calendar.
The count of seconds is usually in the range @math{[0, 59]} but it is in
the range @math{[0, 60]} on the specific days in which a leap second is
added.  The first leap second was added on June 30 1972, so the
timestamp @samp{1972-06-30T23:59:60Z} is valid on the @utc{} scale but
invalid on the @tai{} scale.

All the timestamps with seconds count in the range @math{[0, 59]} are
valid on both the @tai{} scale and the @utc{} scale; the difference
between the two scales shows only on the specific timestamps
representing the leap seconds and when converting a timestamp from the
Gregorian calendar to a count of seconds since some conventional origin.

It is not possible to compute the exact time interval elapsed between
two @utc{} timestamps without consulting a table that describes how many
leap seconds occurred during that interval.

@float
@multitable {leap second timestamp} {@utc{} seconds} {@tai{} - @utc{}}
@headitem leap second timestamp @tab @utc{} seconds @tab @tai{} - @utc{}
@item 1972-01-01T00:00:00Z @tab   63072000 @tab 10
@item 1972-06-30T23:59:60Z @tab   78796800 @tab 11
@item 1972-12-31T23:59:60Z @tab   94694400 @tab 12
@item 1973-12-31T23:59:60Z @tab  126230400 @tab 13
@item 1974-12-31T23:59:60Z @tab  157766400 @tab 14
@item 1975-12-31T23:59:60Z @tab  189302400 @tab 15
@item 1976-12-31T23:59:60Z @tab  220924800 @tab 16
@item 1977-12-31T23:59:60Z @tab  252460800 @tab 17
@item 1978-12-31T23:59:60Z @tab  283996800 @tab 18
@item 1979-12-31T23:59:60Z @tab  315532800 @tab 19
@item 1981-06-30T23:59:60Z @tab  362793600 @tab 20
@item 1982-06-30T23:59:60Z @tab  394329600 @tab 21
@item 1983-06-30T23:59:60Z @tab  425865600 @tab 22
@item 1985-06-30T23:59:60Z @tab  489024000 @tab 23
@item 1987-12-31T23:59:60Z @tab  567993600 @tab 24
@item 1989-12-31T23:59:60Z @tab  631152000 @tab 25
@item 1990-12-31T23:59:60Z @tab  662688000 @tab 26
@item 1992-06-30T23:59:60Z @tab  709948800 @tab 27
@item 1993-06-30T23:59:60Z @tab  741484800 @tab 28
@item 1994-06-30T23:59:60Z @tab  773020800 @tab 29
@item 1995-12-31T23:59:60Z @tab  820454400 @tab 30
@item 1997-06-30T23:59:60Z @tab  867715200 @tab 31
@item 1998-12-31T23:59:60Z @tab  915148800 @tab 32
@item 2005-12-31T23:59:60Z @tab 1136073600 @tab 33
@item 2008-12-31T23:59:60Z @tab 1230768000 @tab 34
@end multitable
@caption{Table: the first column is the timestamp of the leap second;
the second column is the count of seconds, on the @utc{} scale since
@samp{1970-01-01T00:00:00Z}, of the second right after the leap second;
the third column is the difference between the @tai{} and @utc{} scales
at the second right after the leap second.  By definition on
@samp{1972-01-01T00:00:00Z} the difference between @tai{} and @utc{} was
@math{10} seconds.}
@end float

Given the table of @utc{} seconds counts since
@samp{1970-01-01T00:00:00Z}, we can convert a @utc{} seconds count to a
@tai{} seconds count as follows:

@example
if utc-seconds < 63072000
then tai-seconds = utc-seconds

else if 63072000 <= utc-seconds < 78796800
then tai-seconds = utc-seconds + 10

else if 78796800 <= utc-seconds < 94694400
then tai-seconds = utc-seconds + 11

else ...
@end example

A leap seconds table is included in the library @library{times-and-dates
leap-second-table}; it can be automatically generated with the script in
the Nausicaa/Scheme sources
@file{src/script/read-leap-seconds-table.sps} applied to the data file
@file{src/data/tai-utc.dat}; the data file is from:

@center @url{ftp://maia.usno.navy.mil/ser7/tai-utc.dat}

@c page
@node time intro gmt
@subsection Greenwich Mean Time (@gmt{})


@cindex Greenwich Mean Time, @gmt{}
@cindex @gmt{}, Greenwich Mean Time


The @dfn{Greenwich Mean Time} is the mean solar time at the Royal
Observatory, Greenwich (UK); in casual use, when fractions of a second
are not important, @gmt{} can be considered equivalent to @utc{}; saying
@gmt{} is generally avoided in technical contexts, where the unambiguous
@utc{} is preferred.

@c page
@node time intro zone
@subsection Time zones and local time


@cindex Time zone
@cindex Local time


A @uref{http://en.wikipedia.org/wiki/Time_zone, @dfn{time zone}} is a
region on Earth, more or less bounded by lines of longitude, that has a
uniform, legally mandated standard time, usually referred to as the
``local time''; @math{24} time zones around the world can be expressed
as positive or negative offsets from @utc{} (the mean solar time at the
Royal Observatory, Greenwich).  Local time is @utc{} plus the current
time zone offset for the location in question.

Ideally, the increase proceeds eastward from the eastern boundary of the
@utc{} time zone, increasing by one hour (@math{3600} seconds) for each
@math{15} degrees, up to the International Date Line (longitude
@math{180} degrees); a corresponding one hour decrease relative to
@utc{} occurs every @math{15} degrees heading westward from the western
boundary of the @utc{} time zone, up to the International Date Line.  As
examples: London is in time zone zero; moving eastward, Rome (Italy) is
in time zone @math{+1} hour or @math{+3600} seconds; moving westward,
New York (@acronym{USA}) is in time zone @math{-5} hours or
@math{-18000} seconds.

In practice, time zones are established by countries based on local
policies, so the only way to retrieve the time zone of a point on Earth
is to look up an appropriate data table.  As examples: Iceland is in
time zone zero (rather than @math{-1} hour); the Iles Marquises are in
time zone @math{-9:30} hours or @math{-34200} seconds; the Chatham
Islands are in time zone @math{+12:45} hours or @math{+45900} seconds.

The web page (@aurl{} last verified Sat Sep 18, 2010) has some
interesting links on time zones:

@center @url{http://www.twinsun.com/tz/tz-link.htm}

@noindent
a database of time zones information can be retrieved at (@aurl{} last
verified Sat Sep 18, 2010):

@center @url{ftp://elsie.nci.nih.gov/pub/}

@c page
@node time intro dst
@subsection Daylight Saving Time (@dst{})


@cindex Daylight Saving Time, @dst{}
@cindex @dst{}, Daylight Saving Time


The @uref{http://en.wikipedia.org/wiki/Daylight_saving_time,
@dfn{Daylight Saving Time}} is the practice of temporarily advancing
clocks so that afternoons have more daylight and mornings have less;
clocks are adjusted forward one hour near the start of spring and are
adjusted backward in autumn.

The effect of @dst{} is to shift the local time forward by one hour or
@math{3600} seconds, possibly causing a shift or wrap around in the
current day (and month and year) number with respect to the local time.

As example, Rome (Italy) is in time zone @math{+1} hour with respect to
@utc{}; when @dst{} is on, @math{+1} hour must be further added to the
time resulting in an effective @math{+2} hours time shift with respect
to @utc{}.

@c page
@node time intro unix
@subsection Unix Time and Unix Epoch


@cindex Unix Time
@cindex @posix{} Time
@cindex Epoch, Unix time
@cindex Unix Epoch


The @uref{http://@/en.wikipedia.org/@/wiki/@/Unix_time, @dfn{Unix Time}}
or @dfn{@posix{} Time} is a system for describing points in time,
defined as the number of seconds elapsed since 1970 January 1 00:00:00
time zone zero, not counting leap seconds; the time 1970 January 1
00:00:00 time zone zero is called @dfn{Unix Epoch}.  Although it does
not count leap seconds, Unix Time stays synchronised with @utc{} time by
repeating twice the same count when a leap second is inserted:

@example
             midnight
                |
                v
... N-2   N-1   N   N   N+1  N+2 ...
                  ^
                  |
         leap second inserted
@end example

@noindent
Unix Time correctly counts @utc{} @strong{days} since the Epoch as
follows:

@example
(define unix-time:seconds ---)

(define unix-time:number-of-seconds-in-one-day
  (* 24 60 60))

(define utc-time:days-since-epoch
  (div0 unix-time:seconds
        unix-time:number-of-seconds-in-one-day))
@end example

@noindent
Unix Time does @strong{not} correctly counts @utc{} @strong{seconds}
since the Epoch, the following code:

@example
(define utc-time:seconds-since-midnight
  (mod0 unix-time:seconds
        unix-time:number-of-seconds-in-one-day))
@end example

@noindent
gives incorrect results when @code{unix-time:seconds} is the count right
before a leap second.

@c page
@node time intro gregorian
@subsection Gregorian calendar


@cindex Gregorian calendar
@cindex Proleptic Gregorian calendar


The @uref{http://@/en.wikipedia.org/@/wiki/@/Gregorian_calendar,
@dfn{Gregorian Calendar}} is the internationally accepted civil
calendar; it counts days as the basic unit of time, grouping them into
years of @math{365} or @math{366} days.  A Gregorian year is divided
into @math{12} months of irregular length:

@multitable {Month Index} {Month Name} {Days123}
@headitem Month Index @tab Month Name @tab Days
@item 1 @tab January @tab 31
@item 2 @tab February @tab 28 or 29
@item 3 @tab March @tab 31
@item 4 @tab April @tab 30
@item 5 @tab May @tab 31
@item 6 @tab June @tab 30
@item 7 @tab July @tab 31
@item 8 @tab August @tab 31
@item 9 @tab September @tab 30
@item 10 @tab October @tab 31
@item 11 @tab November @tab 30
@item 12 @tab December @tab 31
@end multitable

@noindent
February has @math{28} on non--leap years and @math{29} days on leap
years; from the Calendar @acronym{FAQ}:

@quotation
Every year divisible by @math{4} is a leap year.  However, every year
divisible by @math{100} is not a leap year.  However, every year
divisible by @math{400} is a leap year after all.
@end quotation

The @uref{http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar,
@dfn{proleptic Gregorian calendar}} is produced by extending the
Gregorian calendar backward to dates preceding its official introduction
in 1582.

@c page
@node time intro week
@subsection Week days


A @uref{http://@/en.wikipedia.org/@/wiki/@/Week, @dfn{week}} is a time
unit equal to seven days.

@multitable {Day Index} {Day Name}
@headitem Day Index @tab Day Name
@item 0 @tab Sunday
@item 1 @tab Monday
@item 2 @tab Tuesday
@item 3 @tab Wednesday
@item 4 @tab Thursday
@item 5 @tab Friday
@item 6 @tab Saturday
@end multitable

@c page
@node time intro julian
@subsection Julian Date (@acronym{JD}) and Julian Day (@acronym{JDN})


@cindex Julian Date
@cindex Julian Day Number


The @uref{http://en.wikipedia.org/wiki/Julian_day, @dfn{Julian Date}} is
the interval of time in days and fractions of a day since
-4714-11-24T12:00:00Z (November 24, -4714 at noon, @utc{}).

The @dfn{Julian Day Number} is the integral part of the Julian Date.
The day commencing at the above--mentioned epoch is zero.  Negative
values can be used for preceding dates, though they predate all recorded
history.

@dfn{Modified Julian Day Number} represents a point in time as number of
days since 1858-11-17T00:00:00Z (November 17, 1858 at midnight, @utc{}).

Notice that both the Julian Day Number and the Modified Julian Day
Number time points are for time zone zero; the first has the day
starting at noon (12:00:00), the second has the day starting at midnight
(00:00:00).

The Modified Julian Day Number is @math{4800001/2 = 2400000.5} days less
than the Julian Day Number; this brings the numbers into a more
manageable numeric range and makes the day numbers change at midnight
@utc{} rather than noon.

@acronym{JD} test values can be computed with the calculator at (@aurl{}
last verified Thu Jul 29, 2010):

@center @url{http://www.imcce.fr/en/grandpublic/temps/jour_julien.php}

@noindent
the number computed by that calculator is the @acronym{JDN} at
year/month/day hour:minute:second.

@c page
@node time overview
@section Overview of the library


@menu
* time overview assumptions::   Basic assumptions and policies.
* time overview host::          Retrieving the current time.
* time overview time::          Time points and interval durations.
* time overview date::          Dates and calendar.
* time overview julian::        Julian dates and numbers.
@end menu

@c page
@node time overview assumptions
@subsection Basic assumptions and policies


The @library{times-and-dates} library:

@itemize
@item
Assumes that the host clock is synchronised with current @utc{} time,
taking into account both leap seconds and leap years.

@item
Assumes that the host exposes an @api{} through which it can retrieve
the current time from the clock, expressed as Unix Time; this number of
seconds is @strong{not} the number of @utc{} seconds between the current
time and the Unix Epoch.

@item
It makes use of a @tai{} scale with origin at the Unix Epoch to express
timestamps used to compute time intervals.

@item
It makes use of a @utc{} scale and the proleptic Gregorian calendar to
express timestamps representing points in time.
@end itemize

@c page
@node time overview host
@subsection Retrieving the current time


Unix Time is the count of seconds since the Epoch, ignoring leap
seconds; by definition: when @utc{} was at January 1 1972 00:00:00,
@tai{} was at January 1 1972 00:00:10.  We can express @utc{} and @tai{}
times, too, as count of seconds since the Epoch.  After noticing that
neither 1970 nor 1971 are leap years, we assume that the Unix Time scale
and the @tai{} time scale are equal in those years, so the count of
seconds since the Unix Epoch of January 1 1972 00:00:00 is:

@example
(1972 - 1970) * 365 * 24 * 60 * 60 = 63072000
@end example

@noindent
we establish that:

@example
63072000(Unix) = 63072000(UTC) = 63072010(TAI)
@end example

So, let's say that ``now'' is 2000 January 1 00:00:00 @utc{} and the
host clock is synchronised with this time: we retrieve the current time
from a Unix Time clock which returns @math{946681200}, taking into
account leap years but not leap seconds; we can verify this using the
@gnu{} @command{date} command:

@example
$ date -d '2000/01/01 00:00:00' +%s
@end example

@noindent
the count of seconds since the Epoch on the @tai{} scale is
@math{946681200} itself; the count of seconds since the Epoch :


@c page
@node time overview time
@subsection Time points and interval durations


@library{times-and-dates} represents time points as instances of the
@class{time} class; a @class{time} object holds counts of seconds and
nanoseconds on the @tai{} scale using the Unix Epoch as origin in time
zone zero.  The counts are always both positive or both negative; when
positive they represent a point in time after the Epoch, when negative
they represent a point in time before the Epoch.

@library{times-and-dates} represents time durations as intances of the
@class{duration} class; a @class{duration} object holds counts of
seconds and nanoseconds on the @tai{} scale.  The counts are always both
positive or both negative; when positive they represent a time interval
from a time point forwards, when negative they represent a time interval
from a time point backwards.

Both @class{time} and @class{duration} objects are immutable.

The library allows:

@itemize
@item
Comparison between @class{time} objects to sort a sequence of events on
the @tai{} scale.

@item
Comparison between @class{duration} objects to find the longer and the
shorter.

@item
Arithmetics operations between @class{time} and @class{duration} objects
to compute time durations from time points and vice versa.

@item
Conversion to @class{date} objects.
@end itemize

@c page
@node time overview date
@subsection Dates and calendar


@library{times-and-dates} represents dates on the proleptic Gregorian
calendar as instances of the @class{date} class.  A @class{date} object
represents a point in time with the tuple: year, month, day, hour,
minute, second, nanosecond on the @utc{} scale and time zone zero;
additionally the time zone and daylight saving time are represented as
offsets in seconds.

@class{date} objects are immutable.

The library allows:

@itemize
@item
Comparison between @class{date} objects to sort a sequence of events on
the @utc{} scale.

@item
Conversion to and from strings.

@item
Conversion to @class{time} objects.
@end itemize

@c page
@node time overview julian
@subsection Julian dates and numbers


Julian Dates are represented as exact rational numbers, having the
integral part representing the Julian Day Number.

@c page
@node time system
@section Interface to the system


The following bindings are required from the underlying Scheme
implementation, they should be exported by @library{times-and-dates
compat}.


@defun host:current-time
Must return a single value holding the current seconds and nanoseconds
since the Unix Epoch on the Unix Time scale.

@quotation
On a @posix{} system these values can be retrieved with the platform's
function @cfunc{gettimeofday}; this function returns microseconds, so
the resolution is @math{1000} nanoseconds.

@example
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>

int
main (void)
@{
  struct timeval  current_time;

  gettimeofday(&current_time, NULL);

  printf("secs = %ld, microsecs = %ld\n",
    current_time.tv_sec, current_time.tv_usec);
  exit(EXIT_SUCCESS);
@}
@end example
@end quotation
@end defun


@defun host:time-second @var{unix-time}
Given the return value from @func{host:current-time}, it must return the
number of seconds.
@end defun


@defun host:time-nanosecond @var{unix-time}
Given the return value from @func{host:current-time}, it must return the
number of nanoseconds.
@end defun


@defun host:time-gmt-offset @var{unix-time}
Given the return value from @func{host:current-time}, it must return the
number of seconds representing the time zone offset.  Notice that the
returned value may or may not include the offset introduced by Daylight
Saving Time, depending on how the system clock is set.

@quotation
On a @posix{} platform, the offset can be computed with the following C
code:

@example
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>

int
main (void)
@{
  struct timeval  current_time;
  time_t          clock;
  struct tm *     gmt_broken_time;
  time_t          gmtclock;
  time_t          time_zone_offset;

  gettimeofday(&current_time, NULL);
  clock            = current_time.tv_sec;
  gmt_broken_time  = gmtime(&clock);
  gmtclock         = mktime(gmt_broken_time);
  time_zone_offset = clock - gmtclock;

  printf("offset %ld\n", (long)time_zone_offset);
  exit(EXIT_SUCCESS);
@}
@end example
@end quotation
@end defun


@defvr Constant host:time-resolution
An exact positive integer representing the resolution in nanoseconds of
the return value of @func{host:current-time}.

If the function underlying @func{host:current-time} returns
microseconds: the resolution is @math{1000} nanoseconds.
@end defvr

@c ------------------------------------------------------------

@subsubsection System clock inspection

Here we perform an analysis of system clock settings on a @gnu{}+Linux
host having:

@itemize
@item
The system clock set to @utc{}, time zone zero (that is @gmt{}), using
the @acronym{BIOS} facilities.

@item
Geographical time zone configure to @math{+1} hour.

@item
Daylight Saving Time in effect, resulting in a total time zone offset to
@math{+2} hours.
@end itemize

@quotation
The host is a Slackware Linux installation with the
@code{glibc-zoneinfo} package used to configure the local time zone
throught the @command{/usr/sbin/timeconfig} utility.
@end quotation

We can try to inspect the settings of the system clock using @gnu{}
@command{date}; for example:

@example
## acquire UTC time
$ now=$(date --rfc-2822 --utc)

## print as UTC time
$ echo $now
Wed, 14 Jul 2010 15:28:27 +0000

## print as local time
$ date --rfc-2822 --date="$now"
Wed, 14 Jul 2010 17:28:27 +0200

## print as seconds since Unix Epoch
$ date '+%s' --date="$now"
1279121307
@end example

@c page
@node time secs
@section Seconds and nanoseconds objects


@menu
* time secs class::             Seconds and nanoseconds class
                                type definition.
* time secs utils::             Utility fields and methods.
@end menu

@c page
@node time secs class
@subsection Seconds and nanoseconds class type definition


The @class{seconds-and-nanoseconds} class is meant to represent counts
of seconds with neither fixed interpretation as points in time or
duration, nor fixed time scale.  The following bindings are exported by
the @library{times-and-dates} library.


@deftp Class @aclass{seconds-and-nanoseconds}
Base type representing a count of seconds and anoseconds.  The two
counts are normalised to be both non--negative or both non--positive.
@end deftp


@defcv {Immutable Field} @aclass{seconds-and-nanoseconds} seconds
Exact integer representing seconds count.  It can be positive, zero or
negative.
@end defcv


@defcv {Immutable Field} @aclass{seconds-and-nanoseconds} nanoseconds
Exact integer representing nanoseconds count.  It can be positive, zero
or negative.
@end defcv


@deffn Syntax {make @aclass{seconds-and-nanoseconds}} @ameta{seconds} @ameta{nanoseconds}
Expand to an expression evaluating to a new
@class{seconds-and-nanoseconds} instance.  @meta{seconds} and
@meta{nanoseconds} must expand into expression evaluating to exact
integers representing the counts of seconds and nanoseconds.
@end deffn


@deffn Syntax {make* @aclass{seconds-and-nanoseconds}} @ameta{clause} ...
Expand to an expression evaluating to a new
@class{seconds-and-nanoseconds} instance.  The seconds and nanoseconds
counts are computed from the values given in the following maker
clauses:

@table @code
@item :seconds @cmeta{seconds}
@itemx :milliseconds @cmeta{milliseconds}
@itemx :microseconds @cmeta{microseconds}
@itemx :nanoseconds @cmeta{nanoseconds}
Select the count in the specified seconds and subseconds units.  All the
values are normalised to seconds and nanoseconds counts.
@end table
@end deffn

@c page
@node time secs utils
@subsection Utility fields and methods


The following bindings are exported by the @library{times-and-dates}
library.


@defmethod @aclass{seconds-and-nanoseconds} deep-clone
@defmethodx @aclass{seconds-and-nanoseconds} shallow-clone
Return a copy of the object.
@end defmethod


@defcv {Immutable Field} @aclass{seconds-and-nanoseconds} full-seconds
@defcvx {Immutable Field} @aclass{seconds-and-nanoseconds} full-milliseconds
@defcvx {Immutable Field} @aclass{seconds-and-nanoseconds} full-microseconds
@defcvx {Immutable Field} @aclass{seconds-and-nanoseconds} full-nanoseconds
Exact numbers representing the time in seconds or the specified
subseconds counts.
@end defcv

@c page
@node time duration
@section Time duration objects


@menu
* time duration class::         Time duration class type definition.
* time duration compar::        Comparing time durations.
* time duration arith::         Arithmetic functions.
* time duration utils::         Utility fields and methods.
@end menu

@c page
@node time duration class
@subsection Time duration class type definition


A time duration is the algebric difference between two points in time on
the @tai{} scale; durations can be defined directly, added to points in
time or computed as difference between points in time.  Durations are
represented by a seconds count and a nanoseconds count, which are
normalised to be both non--negative or both non--positive.  The
following bindings are exported by the @library{times-and-dates}
library.


@deftp Class @aclass{duration}
Base type representing a time duration on the @tai{} scale.  It is
derived from @class{seconds-and-nanoseconds}.
@end deftp


@defcv {Immutable Field} @aclass{duration} seconds
Exact integer representing seconds count on the @tai{} scale.
@end defcv


@defcv {Immutable Field} @aclass{duration} nanoseconds
Exact integer representing nanoseconds count.
@end defcv


@deffn Syntax {make @aclass{duration}} @ameta{seconds} @ameta{nanoseconds}
Expand to an expression evaluating to a new @class{duration} instance.
@meta{seconds} and @meta{nanoseconds} must expand into expressions
evaluating to exact integers representing the counts of seconds on the
@tai{} scale and the count of nanoseconds.

Seconds and nanoseconds are normalised to be both non--negative or both
non--positive.
@end deffn


@deffn Syntax {make* @aclass{duration}} @ameta{clause} ...
Expand to an expression evaluating to a new @class{duration} instance.
The seconds and nanoseconds counts are computed from the values given in
the following maker clauses and normalised to be both non--negative or
both non--positive:

@table @code
@item :seconds @cmeta{seconds}
@itemx :milliseconds @cmeta{milliseconds}
@itemx :microseconds @cmeta{microseconds}
@itemx :nanoseconds @cmeta{nanoseconds}
Select the count in the specified seconds and subseconds units.  The
seconds count must be on the @tai{} scale.
@end table
@end deffn

@c page
@node time duration compar
@subsection Comparing time durations


Comparison aims at estabilishing the longer or shorter duration between
a couple of durations; comparison functions do @strong{not} consider the
sign of seconds and nanoseconds counts, they compare the absolute
values.  The following bindings are exported by the
@library{times-and-dates} library.



@defmethod @aclass{duration} = @var{duration}
@defmethodx @aclass{duration} < @var{duration}
@defmethodx @aclass{duration} <= @var{duration}
@defmethodx @aclass{duration} > @var{duration}
@defmethodx @aclass{duration} >= @var{duration}
Compare the instance's duration to the duration of the @class{duration}
object @var{duration} and return a boolean value.
@end defmethod


@defun duration= @var{duration} ...
@defunx duration< @var{duration} ...
@defunx duration<= @var{duration} ...
@defunx duration> @var{duration} ...
@defunx duration>= @var{duration} ...
Compare the @class{duration} arguments and return a boolean value.  When
there are no arguments or only one argument: the return value is true.
@end defun

@c page
@node time duration arith
@subsection Arithmetic functions


The following bindings are exported by the @library{times-and-dates}
library.


@defmethod @aclass{duration} + @var{duration}
Add the @class{duration} object @var{duration} to the instance and
return a new @class{duration} object representing the result.
@end defmethod


@defmethod @aclass{duration} - @var{duration}
Subtract the @class{duration} object @var{duration} from the instance
and return a new @class{duration} object representing the result.
@end defmethod


@defmethod @aclass{duration} + @var{lambda}
Multiply the instance by the real number @var{lambda} and return a new
@class{duration} object representing the result.  The results of the
product are turned into exact numbers.
@end defmethod


@defmethod @aclass{duration} / @var{lambda}
Divide the instance by the real number @var{lambda} and return a new
@class{duration} object representing the result.  The results of the
division are turned into exact numbers.
@end defmethod


@defun duration+ @var{duration} ...
Add all the @class{duration} arguments and return a new @class{duration}
object representing the sum.  When called with no arguments: return a
@class{duration} of zero seconds and zero nanoseconds.
@end defun


@defun duration- @var{duration} ...
Subtract the @class{duration} arguments beyond the first from the first
and return a new @class{duration} object representing the difference.
When called with no arguments: return a @class{duration} of zero seconds
and zero nanoseconds.
@end defun

@c page
@node time duration utils
@subsection Utility fields and methods


@defmethod @aclass{duration} deep-clone
@defmethodx @aclass{duration} shallow-clone
Return a copy of the object.
@end defmethod

@c page
@node time point
@section Points in time


@menu
* time point class::            Point in time class type definition.
* time point compar::           Comparing time points.
* time point arith::            Arithmetic functions.
* time point utils::            Utility functions.
@end menu

@c page
@node time point class
@subsection Point in time class type definition


A point time is described by seconds and nanoseconds counts on the
@tai{} time scale using the Unix Epoch as origin.  The following
bindings are exported by the @library{times-and-dates} library.


@deftp Class @aclass{time}
Base type representing a time point on the @tai{} scale.  It is derived
from @class{seconds-and-nanoseconds}.
@end deftp


@defcv {Immutable Field} @aclass{time} seconds
Exact integer representing seconds count on the @tai{} scale.
@end defcv


@defcv {Immutable Field} @aclass{time} nanoseconds
Exact integer representing nanoseconds count.
@end defcv


@deffn Syntax {make @aclass{time}} @ameta{seconds} @ameta{nanoseconds}
Expand to an expression evaluating to a new @class{time} instance.
@meta{seconds} and @meta{nanoseconds} must expand into expression
evaluating to exact integers representing the counts of seconds on the
@tai{} scale and the count of nanoseconds.

Seconds and nanoseconds are normalised to be both non--negative or both
non--positive.
@end deffn


@deffn Syntax {make* @aclass{time}} @ameta{clause} ...
Expand to an expression evaluating to a new @class{time} instance.  The
seconds and nanoseconds counts are computed from the values given in the
following maker clauses and normalised to be both non--negative or both
non--positive:

@table @code
@item :seconds @cmeta{seconds}
@itemx :milliseconds @cmeta{milliseconds}
@itemx :microseconds @cmeta{microseconds}
@itemx :nanoseconds @cmeta{nanoseconds}
Select the count in the specified seconds and subseconds units.  The
seconds count must be on the @tai{} scale.
@end table
@end deffn

@c page
@node time point compar
@subsection Comparing time points


Comparison aims at estabilishing if a time point comes before or after
another time point; comparison functions do consider the sign of seconds
and nanoseconds counts.  The following bindings are exported by the
@library{times-and-dates} library.


@defmethod @aclass{time} = @var{time}
@defmethodx @aclass{time} < @var{time}
@defmethodx @aclass{time} <= @var{time}
@defmethodx @aclass{time} > @var{time}
@defmethodx @aclass{time} >= @var{time}
Compare the instance's time to the time of the @class{time} object
@var{time} and return a boolean value.
@end defmethod


@defun time= @var{time} ...
@defunx time< @var{time} ...
@defunx time<= @var{time} ...
@defunx time> @var{time} ...
@defunx time>= @var{time} ...
Compare the @class{time} arguments and return a boolean value.  When
there are no arguments or only one argument: the return value is true.
@end defun

@c page
@node time point arith
@subsection Arithmetic functions


The following bindings are exported by the @library{times-and-dates}
library.


@defmethod @aclass{time} + @var{duration}
Add the @class{duration} object @var{duration} to the instance and
return a new @class{time} object representing the result.
@end defmethod


@defmethod @aclass{time} - (@var{duration} @aclass{duration})
Subtract the @class{duration} object @var{duration} from the instance
and return a new @class{time} object representing the result.

@example
(let* (((D <time>)      (make <time> 1 2))
       ((E <duration>)  (make <duration> 3 5))
       ((F <time>)      (D.- E)))
  (list (is-a? F <time>) F.seconds F.nanoseconds))
@result{} (#t -2 -3)
@end example
@end defmethod


@defmethod @aclass{time} - (@var{time} @aclass{time})
Subtract the @class{time} object @var{time} from the instance and return
a new @class{duration} object representing the result.

@example
(let* (((D <time>)      (make <time> 1 2))
       ((E <time>)      (make <time> 3 5))
       ((F <duration>)  (D.- E)))
  (list (is-a? F <duration>) F.seconds F.nanoseconds))
@result{} (#t -2 -3)
@end example
@end defmethod

@c page
@node time point utils
@subsection Utility functions


The following bindings are exported by the @library{times-and-dates}
library.


@defmethod @aclass{time} julian-day
@defmethodx @aclass{time} julian-day @var{tz-offset}
Return an exact number representing the Julian Day number corresponding
to the instance's seconds on the @tai{} scale; @var{tz-offset} is the
time zone offset in seconds, it defaults to the local time zone offset.
Ignores the count of nanoseconds.
@end defmethod


@defmethod @aclass{time} date
@defmethodx @aclass{time} date @var{tz-offset}
Return a @class{date} object representing the same time point of the
instance.  @var{tz-offset} is the time zone offset in seconds, it
defaults to the local time zone offset.
@end defmethod

@c page
@node time date
@section Date object

A @emph{Date} object consists of the following components:

@table @emph
@item Nanosecond
An integer between 0 and 999,999,999, inclusive.

@item Second
An integer 0 and 60, inclusive, (60 represents a leap second).

@item Minute
An integer between 0 and 59, inclusive.

@item Hour
An integer between 0 and 23, inclusive.

@item Day
An integer between 0 and 31, inclusive, the upper limit depending on the
month and year of the point in time.

@item Month
An integer between 1 and 12, inclusive; in which 1 means January, 2
February, and so on.

@item Year
An integer representing the year.

@item Time zone
An integer representing the number of seconds East of @gmt{} for this
timezone.
@end table



@c page
@node time utils
@section Miscellaneous utilities

@menu
* time utils secs::             Seconds and nanoseconds utilities.
* time utils year::             Gregorian years and weeks.
* time utils julian::           Julian calendar utilities.
@end menu

@c page
@node time utils secs
@subsection Seconds and nanoseconds utilities


@menu
* time utils secs constants::   Constant values for seconds and
                                subseconds units.
* time utils secs utils::       Utilities for seconds and subseconds
                                units counts.
@end menu

@c page
@node time utils secs constants
@subsubsection Constant values for seconds and subseconds units


The following bindings are exported by the @library{times-and-dates
seconds} library.


@defvr Constant $number-of-nanoseconds-in-one-microsecond
@defvrx Constant $number-of-nanoseconds-in-one-millisecond
@defvrx Constant $number-of-nanoseconds-in-one-second
@defvrx Constant $number-of-nanoseconds-in-one-minute
@defvrx Constant $number-of-nanoseconds-in-one-hour
@defvrx Constant $number-of-nanoseconds-in-one-day
Conversion coefficients for nanosecond counts.
@end defvr


@defvr Constant $number-of-microseconds-in-one-nanosecond
@defvrx Constant $number-of-microseconds-in-one-millisecond
@defvrx Constant $number-of-microseconds-in-one-second
@defvrx Constant $number-of-microseconds-in-one-minute
@defvrx Constant $number-of-microseconds-in-one-hour
@defvrx Constant $number-of-microseconds-in-one-day
Conversion coefficients for microsecond counts.
@end defvr


@defvr Constant $number-of-milliseconds-in-one-nanosecond
@defvrx Constant $number-of-milliseconds-in-one-microsecond
@defvrx Constant $number-of-milliseconds-in-one-second
@defvrx Constant $number-of-milliseconds-in-one-minute
@defvrx Constant $number-of-milliseconds-in-one-hour
@defvrx Constant $number-of-milliseconds-in-one-day
Conversion coefficients for millisecond counts.
@end defvr


@defvr Constant $number-of-seconds-in-one-nanosecond
@defvrx Constant $number-of-seconds-in-one-microsecond
@defvrx Constant $number-of-seconds-in-one-millisecond
@defvrx Constant $number-of-seconds-in-one-minute
@defvrx Constant $number-of-seconds-in-one-hour
@defvrx Constant $number-of-seconds-in-one-day
Conversion coefficients for second counts.
@end defvr

@c page
@node time utils secs utils
@subsubsection Utilities for seconds and subseconds units counts


The following bindings are exported by the @library{times-and-dates
seconds} library.  The following naming conventions hold:

@itemize
@item
All the bindings starting with @code{sn-} take as arguments a seconds
and nanoseconds counts.

@item
All the bindings starting with @code{su-} take as arguments a seconds
and microseconds counts.

@item
All the bindings starting with @code{sm-} take as arguments a seconds
and milliseconds counts.

@item
All the bindings ending with @code{->sn} return two values: seconds and
nanoseconds counts.

@item
All the bindings ending with @code{->su} return two values: seconds and
microseconds counts.

@item
All the bindings ending with @code{->sm} return two values: seconds and
milliseconds counts.
@end itemize

Some of the bindings are macros: this is to allow a level of inline
expansion for small expressions and save a function call.  When the
documentation refers to @dfn{normalised} values, it means that the
seconds and subseconds counts are both non--negative or both
non--positive and:

@itemize
@item
The milliseconds count @math{M} is in the range @math{-1e-3 < M < 1e3}.

@item
The microseconds count @math{U} is in the range @math{-1e-6 < U < 1e6}.

@item
The nanoseconds count @math{N} is in the range @math{-1e-9 < N < 1e9}.
@end itemize

The counts in seconds and subseconds units must be given as exact
numbers when arguments and are always returned as exact numbers.


@deffn Syntax sn-normalise @var{seconds} @var{nanoseconds}
@deffnx Syntax su-normalise @var{seconds} @var{microseconds}
@deffnx Syntax sm-normalise @var{seconds} @var{milliseconds}
Return two values: a normalised seconds count and a normalised
subseconds count.  The returned values are the arguments normalised to
be in such a way that the time from zero is left unchanged.  Examples:

@example
(sn-normalise +1 +1)    @result{} +1 +1
(sn-normalise -1 -1)    @result{} -1 -1
(sn-normalise +1 -1)    @result{}  0 +999999999
(sn-normalise -1 +1)    @result{}  0 -999999999

(sn-normalise +10 #e+1.001e9)     @result{} +11 +1e6
(sn-normalise -10 #e-1.001e9)     @result{} -11 -1e6
@end example
@end deffn


@deffn Syntax sn->seconds @var{seconds} @var{nanoseconds}
@deffnx Syntax su->seconds @var{seconds} @var{microseconds}
@deffnx Syntax sm->seconds @var{seconds} @var{milliseconds}
Return an exact rational number representing the arguments in seconds
units.
@end deffn


@deffn Syntax sn->milliseconds @var{seconds} @var{nanoseconds}
@deffnx Syntax su->milliseconds @var{seconds} @var{microseconds}
@deffnx Syntax sm->milliseconds @var{seconds} @var{milliseconds}
Return an exact rational number representing the arguments in
milliseconds units.
@end deffn


@deffn Syntax sn->microseconds @var{seconds} @var{nanoseconds}
@deffnx Syntax su->microseconds @var{seconds} @var{microseconds}
@deffnx Syntax sm->microseconds @var{seconds} @var{milliseconds}
Return an exact rational number representing the arguments in
microseconds units.
@end deffn


@deffn Syntax sn->nanoseconds @var{seconds} @var{nanoseconds}
@deffnx Syntax su->nanoseconds @var{seconds} @var{microseconds}
@deffnx Syntax sm->nanoseconds @var{seconds} @var{milliseconds}
Return an exact rational number representing the arguments in
nanoseconds units.
@end deffn


@deffn Syntax seconds->sn @var{seconds}
@deffnx Syntax seconds->su @var{seconds}
@deffnx Syntax seconds->sm @var{seconds}
Return two values: @var{seconds} itself and zero.  The returned values
represents the count of seconds and subseconds corresponding to
@var{seconds}.
@end deffn


@deffn Syntax milliseconds->sn @var{milliseconds}
@deffnx Syntax milliseconds->su @var{milliseconds}
@deffnx Syntax milliseconds->sm @var{milliseconds}
Return two values: the count of seconds and the count of subseconds
corresponding to the count of @var{milliseconds}.  The returned values
are normalised.
@end deffn


@deffn Syntax microseconds->sn @var{microseconds}
@deffnx Syntax microseconds->su @var{microseconds}
@deffnx Syntax microseconds->sm @var{microseconds}
Return two values: the count of seconds and the count of subseconds
corresponding to the count of @var{microseconds}.  The returned values
are normalised.
@end deffn


@deffn Syntax nanoseconds->sn @var{nanoseconds}
@deffnx Syntax nanoseconds->su @var{nanoseconds}
@deffnx Syntax nanoseconds->sm @var{nanoseconds}
Return two values: the count of seconds and the count of subseconds
corresponding to the count of @var{nanoseconds}.  The returned values
are normalised.
@end deffn


@defun smun->sn @var{seconds} @var{millliseconds} @var{microseconds} @var{nanoseconds}
Return two values: the count of seconds and the count of nanoseconds
corresponding to the arguments.  The returned values are normalised.
@end defun


@defun sn->smun @var{seconds} @var{nanoseconds}
Return four values: the counts of seconds, milliseconds, microseconds,
nanoseconds corresponding to the arguments.  The returned values are
normalised.
@end defun


@defun sn-add @vari{seconds} @vari{nanoseconds} @varii{seconds} @varii{nanoseconds}
Sum the two couples of counts and return two values: the resulting
normalised counts of seconds and nanoseconds.
@end defun


@defun sn-sub @vari{seconds} @vari{nanoseconds} @varii{seconds} @varii{nanoseconds}
Subtract the seconds couple of counts from the first and return two
values: the resulting normalised counts of seconds and nanoseconds.
@end defun


@defun sn< @vari{seconds} @vari{nanoseconds} @varii{seconds} @varii{nanoseconds}
@defunx sn> @vari{seconds} @vari{nanoseconds} @varii{seconds} @varii{nanoseconds}
@defunx sn<= @vari{seconds} @vari{nanoseconds} @varii{seconds} @varii{nanoseconds}
@defunx sn>= @vari{seconds} @vari{nanoseconds} @varii{seconds} @varii{nanoseconds}
Return true if the first couple of counts is, respectively: less than,
greater than, less than or equal to, greater than or equal to the second
couple of counts.  The comparison is performed on normalised counts.
@end defun


@defun utc->tai @var{utc-seconds}
@defunx tai->utc @var{tai-seconds}
Convert a count of seconds since the Unix Epoch from @utc{} to @tai{}
and vice versa.
@end defun

@c page
@node time utils year
@subsection Gregorian years and weeks


@menu
* time utils year const::       Constants.
* time utils year year::        Year utility functions.
* time utils year week::        Week utility functions.
@end menu

@c page
@node time utils year const
@subsubsection Constants


The following bindings are exported from the @library{times-and-dates
years-and-weeks} library.


@defvr Constant $number-of-seconds-in-half-day
Number of seconds in a half day.  It is used in the expressions
involving the Julian Day, which starts at noon (rather than at
midnight).
@end defvr


@defvr Constant $tai-epoch-in-jd
Julian day number for the Unix Epoch.
@end defvr


@defvr Constant $number-of-days-per-month/non-leap-year
@defvrx Constant $number-of-days-per-month/leap-year
Scheme vectors holding the numbers of days for each month.  The element
at index zero is unused; the element at index @math{1} is for January,
the element at index @math{2} for February, etc.
@end defvr


@defvr Constant $number-of-days-the-first-day-of-each-month/non-leap-year
@defvrx Constant $number-of-days-the-first-day-of-each-month/leap-year
Number of days from the beginning of the year, at the first day of a
month.
@end defvr

@c page
@node time utils year year
@subsubsection Year utility functions


The following bindings are exported from the @library{times-and-dates
years-and-weeks} library.


@defun gregorian-leap-year? @var{yaer}
Return true if @var{year} is a leap year.
@end defun


@defun gregorian-list-of-leap-years @var{inclusive-start} @var{inclusive-end}
Return a list of leap years in the selected range of years.
@end defun


@defun gregorian-year-number-of-days-since-beginning @var{year} @var{month} @var{day}
Return the number of days from the beginning of the year for the
specified date.  Assume that the given date is correct.
@end defun


@defun gregorian-natural-year @var{xy} @var{current-year}
Given a two digit year number @var{xy}, return the full year within
@math{50} years; @var{current-year} must be a full year number
representing the anchor for the returned value.

@example
(gregorian-natural-year 10 1903) @result{} 1910
(gregorian-natural-year 10 1913) @result{} 1910
(gregorian-natural-year 10 1923) @result{} 1910
(gregorian-natural-year 10 1933) @result{} 1910
(gregorian-natural-year 10 1943) @result{} 1910
(gregorian-natural-year 10 1953) @result{} 1910
(gregorian-natural-year 10 1963) @result{} 2010
(gregorian-natural-year 10 1973) @result{} 2010
(gregorian-natural-year 10 1983) @result{} 2010
(gregorian-natural-year 10 1993) @result{} 2010
(gregorian-natural-year 10 2003) @result{} 2010

(gregorian-natural-year 50 1903) @result{} 1950
(gregorian-natural-year 50 1913) @result{} 1950
(gregorian-natural-year 50 1923) @result{} 1950
(gregorian-natural-year 50 1933) @result{} 1950
(gregorian-natural-year 50 1943) @result{} 1950
(gregorian-natural-year 50 1953) @result{} 1950
(gregorian-natural-year 50 1963) @result{} 1950
(gregorian-natural-year 50 1973) @result{} 1950
(gregorian-natural-year 50 1983) @result{} 1950
(gregorian-natural-year 50 1993) @result{} 1950
(gregorian-natural-year 50 2003) @result{} 2050

(gregorian-natural-year 90 1903) @result{} 1890
(gregorian-natural-year 90 1913) @result{} 1890
(gregorian-natural-year 90 1923) @result{} 1890
(gregorian-natural-year 90 1933) @result{} 1890
(gregorian-natural-year 90 1943) @result{} 1990
(gregorian-natural-year 90 1953) @result{} 1990
(gregorian-natural-year 90 1963) @result{} 1990
(gregorian-natural-year 90 1973) @result{} 1990
(gregorian-natural-year 90 1983) @result{} 1990
(gregorian-natural-year 90 1993) @result{} 1990
(gregorian-natural-year 90 2003) @result{} 1990
@end example
@end defun


@defun gregorian-year--western-easter-month-and-day @var{year}
Given the number of a @var{year}, return two values being: the
@math{1}-based index of the month in which Easter falls, the
@math{1}-based index of the day in which Easter falls.  The computation
is performed for the western christianity proleptic gregorian calendar.

From the Calendar @acronym{FAQ}, section 2.13.7.
@end defun

@c page
@node time utils year week
@subsubsection Week utility functions


The following bindings are exported from the @library{times-and-dates
years-and-weeks} library.


@defun gregorian-index-of-day-in-week @var{year} @var{month} @var{day}
Return the index of the day in its week, zero based: Sun=0, Mon=1,
Tue=2, etc.  Assume the given date is correct.  Perform the computation
for the proleptic gregorian calendar.

From the calendar @acronym{FAQ} section 2.6.
@end defun


@defun gregorian-number-of-days-before-first-week @var{year} @var{day-of-week-starting-week}
Return the number of days before the first day of the first week of the
@var{year}.  @var{day-of-week-starting-week} selects which day starts a
week: 0 for Sunday, 1 for Monday, 2 for Tuesday, etc.

For example, given the month layout:

@example
    January 2010
Su Mo Tu We Th Fr Sa
                1  2
 3  4  5  6  7  8  9
10 11 12 13 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
31
@end example

@noindent
in which the year starts on Friday (index 5) the results are as follows:

@example
(gregorian-number-of-days-before-first-week 2010 5)     @result{} 0
(gregorian-number-of-days-before-first-week 2010 6)     @result{} 1
(gregorian-number-of-days-before-first-week 2010 0)     @result{} 2
(gregorian-number-of-days-before-first-week 2010 1)     @result{} 3
(gregorian-number-of-days-before-first-week 2010 2)     @result{} 4
(gregorian-number-of-days-before-first-week 2010 3)     @result{} 5
(gregorian-number-of-days-before-first-week 2010 4)     @result{} 6
@end example
@end defun

@c page
@node time utils julian
@subsection Julian calendar utilities


The following bindings are exported by the @library{times-and-dates
julian-calendar} library.  The arguments to the functions are supposed
to be in their valid type and range:

@itemize
@item
Nanoseconds as exact integers in @math{[0, 999999999)}.

@item
Seconds as exact integers in @math{[0, 59)} when fractions of a minute,
as exact integers when counts since the Epoch on the @tai{} or @utc{}
scale.

@item
Minutes as exact integers in @math{[0, 59)}.

@item
Hours as exact integers in @math{[0, 23)}.

@item
Days as exact integers in @math{[1, 28]}, @math{[1, 29]}, @math{[1, 30]}
or @math{[1, 31]} according to the month number.

@item
Months as exact integers in @math{[1, 12]}.

@item
Years as exact integers.

@item
Julian Dates as exact integers or exact rationals.

@item
Julian Day Numbers and Modified Julian Day Numbers as exact integers.
@end itemize

@c ------------------------------------------------------------

@subsubheading Conversion to/from seconds and nanoseconds


@defun utc-seconds-and-nanoseconds->julian-day @var{utc-seconds} @var{nanoseconds}
Return the Julian Day Number representing the given counts of @utc{}
seconds (time zone zero) since the Unix Epoch and nanoseconds.
@end defun


@defun tai-seconds-and-nanoseconds->julian-day @var{tai-seconds} @var{nanoseconds}
Return the Julian Day Number representing the given counts of @tai{}
seconds (time zone zero) since the Unix Epoch and nanoseconds.
@end defun


@defun julian-day->utc-seconds-and-nanoseconds @var{jdn}
Return two values: the @utc{} seconds count (time zone zero) since the
Unix Epoch and nanoseconds counts representing @var{jdn}.
@end defun


@defun julian-day->tai-seconds-and-nanoseconds @var{jdn}
Return two values: the @tai{} seconds count (time zone zero) since the
Unix Epoch and nanoseconds counts representing @var{JDN}.
@end defun

@c ------------------------------------------------------------

@subsubheading Conversion to/from Gregorian calendar


@defun julian-day-encode-number @var{year} @var{month} @var{day}
Return an exact integer representing the Julian Day Number at the given
date on the proleptic Gregorian calendar at 12:00:00Z, that is: starting
at noon, @utc{} scale, time zone zero.  This function assumes the given
date is correct.

When converting a full time point to a Julian Day Number: the counts of
hours, minutes, seconds and nanoseconds are discarded.

From the Calendar @acronym{FAQ}, section 2.16.1.
@end defun


@defun julian-day-decode-number @var{jdn}
Return 3 values: year, month, day in the proleptic Gregorian calendar
corresponding to the Julian Day Number @var{jdn}.

When converting a Julian Day Number to a full time point: the count of
hours must be set to @math{12} and the counts of minutes, seconds and
nanoseconds must be set to zero.

From the Calendar @acronym{FAQ}, section 2.16.1.
@end defun


@defun time-point->julian-date @var{year} @var{month} @var{day} @var{hours} @var{minutes} @var{seconds} @var{nanoseconds}
Convert the given time point into a Julian Date value.
@end defun


@defun julian-date->time-point @var{jd}
Convert a Julian Date value to a time point tuple; return @math{7}
values: year, month, day, hours, minutes, seconds, nanoseconds.
@end defun

@c ------------------------------------------------------------

@subsubheading Conversion between @jdn{} and @mjdn{}


@defun julian-day->modified-julian-day @var{jdn}
Return the Modified Julian Day Number corresponding to the Julian Day
Number @var{jdn}.
@end defun


@defun modified-julian-day->julian-day @var{mjdn}
Return the Julian Day Number corresponding to the Modified Julian Day
Number @var{mjdn}.
@end defun

@c page
@node time const
@section Constants


@deffn Variable time-duration
Symbol representing @emph{Time} duration.
@end deffn


@deffn Variable time-monotonic
Symbol representing monotonic time.
@end deffn


@deffn Variable time-process
Symbol representing time spent in current process.
@end deffn


@deffn Variable time-tai
Symbol representing @tai{} time.
@end deffn


@deffn Variable time-thread
Symbol representing time spent in current thread.
@end deffn


@deffn Variable time-utc
Symbol representting @utc{} time.
@end deffn

@c page
@node time current
@section Current time and clock resolution


@defun current-date
@defunx current-date @var{tz-offset}
Return a @emph{Date} corresponding to the current @utc{} time.
@end defun

@defun current-julian-date
Current Julian Day.
@end defun


@defun current-modified-julian-day
Current Modified Julian Day.
@end defun


@defun current-time
@defunx current-time @var{time-type}
Current time, of type @var{time-type} system, which defaults to
@code{time-utc}.
@end defun


@defun time-resolution
@defunx time-resolution @var{time-type}
Return an exact integer representing the clock resolution, in
nanoseconds, of the system clock of type type @var{time-type} system,
which defaults to @code{time-utc}.
@end defun

@c page
@node time timeobj
@section Time object and accessors


@defun make-time @var{time-type} @var{nanosecond} @var{second}
Return a new time object.
@end defun


@defun time? @var{object}
@true{} if @var{object} is a @emph{Time} object, otherwise, @false{}.
@end defun


@defun time-type @var{time}
Return the @var{Time type} symbol of @var{time}.  @ref{time intro}
for details.
@end defun


@defun time-nanosecond @var{time}
Return the @emph{Nanosecond} component of @var{time}.
@end defun


@defun time-second @var{time}
Return the @emph{Second} component of @var{time}.
@end defun


@defun set-time-type! @var{time} @var{time-type}
Set the @emph{Time type} component of @var{time} to @var{time-type},
which must be one of the time type symbols.  @ref{time intro} for
details.

Note: This changes the semantics of the time object.  To convert a time
to another system of representation, use one of the conversion
procedures.
@end defun


@defun set-time-nanosecond! @var{time} @var{integer}
Set the @emph{Nanosecond} component of @var{time} to @var{integer}.
@end defun


@defun set-time-second! time integer
Set the @emph{Second} component of @var{time} to @var{integer}.
@end defun


@defun copy-time @var{time}
Create a new time object, with the same @emph{Time type},
@emph{nanosecond}, and @emph{Second} as @var{time}.
@end defun

@c page
@node time timeobj compar
@section Time object comparison procedures


All of the time comparison procedures require the time objects to be of
the same type.  It is an error to use these procedures on time objects
of different types.  For the point--in--time measurements (e.g.
@code{time-tai} and @code{time-utc}), the semantics are described in
plain text.  For durations (e.g. @code{time-duration}, @code{time-cpu})
the semantics are described in parentheses.


@defun time<=? @var{time1} @var{time2}
@true{} if @var{time1} is before or at (less than or equal to)
@var{time2}, @false{} otherwise.
@end defun


@defun time<? @var{time1} @var{time2}
@true{} if @var{time1} is before (less than) @var{time2}, @false{}
otherwise.
@end defun


@defun time=? @var{time1} @var{time2}
@true{} if @var{time1} at (equal) @var{time2}, @false{} otherwise.
@end defun


@defun time>=? @var{time1} @var{time2}
@true{} if @var{time1} is at or after (greater than or equal to)
@var{time2}, @false{} otherwise.
@end defun


@defun time>? @var{time1} @var{time2}
@true{} if @var{time1} is after (greater than) @var{time2}, @false{}
otherwise.
@end defun

@c page
@node time timeobj arithm
@section Time object arithmetic procedures


@defun time-difference @vari{time} @varii{time}
Return the time duration between @vari{time} and @varii{time}.  It is an
error if @vari{time} and @varii{time} are of different time types.  A new
time object is created.
@end defun


@defun add-duration @var{time} @var{time-duration}
Return the time resulting from adding @var{time-duration} to @var{time},
which is a time object of the same time type as @var{time}.  A new time
object is created.
@end defun


@defun subtract-duration @var{time} @var{time-duration}
Return the time resulting from subtracting @var{time-duration} from
@var{time}, which is a time object of the same time type as @var{time}.
A new time object is created.
@end defun

@c page
@node time dateobj
@section Date object and accessors


Date objects are immutable once created.  Notice that to do operations
with date, like the arithmetic ones, we have to convert the date objects
to time objects.


@defun make-date @var{nanosecond} @var{second} @var{minute} @var{hour} @var{day} @var{month} @var{year} @var{zone-offset}
Creates a date object.
@end defun


@defun date? @var{object}
Return @true{} if @var{object} is a @emph{Date} object; otherwise return
@false{}.
@end defun


@defun date-nanosecond @var{date}
Return the @emph{Nanosecond} component of @var{date}.
@end defun


@defun date-second @var{date}
Return the @emph{Second} component of @var{date}.
@end defun


@defun date-minute @var{date}
Return the @emph{Minute} component of @var{date}.
@end defun


@defun date-hour @var{date}
Return the @emph{Hour} component of @var{date}.
@end defun


@defun date-day @var{date}
Return the @emph{Date} component of @var{date}.
@end defun


@defun date-month @var{date}
Return the @emph{Month} component of @var{date}.
@end defun


@defun date-year @var{date}
Return the @emph{Year} component of @var{date}.
@end defun


@defun date-zone-offset @var{date}
Return the @emph{Time zone} component of @var{date}.
@end defun


@defun date-year-day @var{date}
Return the ordinal day of the year of this date.  January 1 is 1, etc.
@end defun


@defun date-week-day @var{date}
Return the day of the week of this date, where Sunday=0, Monday=1, etc.
@end defun


@defun date-week-number date day-of-week-starting-week
Return the ordinal week of the year which holds this date, ignoring a
first partial week.  @var{day-of-week-starting-week} is the integer
corresponding to the day of the week which is to be considered the first
day of the week (Sunday=0, Monday=1, etc.).
@end defun

@c page
@node time string
@section Date to string/string to date converters


The following procedures provide conversion to and from strings.  They
are required.  The specification below describes a ``locale''; the
specification of locales is beyond this @srfi{}.


@defun date->string @var{date} [@var{format-string}]
Convert a date to a string, using the format string.

The format string is copied as is; except escape characters (indicated
by the tilde) are replaced with specfic conversions.

The following table lists the required conversion specifiers;
implementations are free to extend this list.

@multitable {Escape Char} {scrappy dappy doo, scrappy dappy doo, scappy dappy}
@headitem Escape Char @tab Conversion
@item ~~ @tab a literal ~
@item ~a @tab locale's abbreviated weekday name (Sun...Sat)
@item ~A @tab locale's full weekday name (Sunday...Saturday)
@item ~b @tab locale's abbreviate month name (Jan...Dec)
@item ~B @tab locale's full month day (January...December)
@item ~c @tab locale's date and time (e.g., "Fri Jul 14 20:28:42-0400 2000")
@item ~d @tab day of month, zero padded (01...31)
@item ~D @tab date (mm/dd/yy)
@item ~e @tab day of month, blank padded ( 1...31)
@item ~f @tab seconds+fractional seconds, using locale's decimal separator (e.g. 5.2).
@item ~h @tab same as ~b
@item ~H @tab hour, zero padded, 24-hour clock (00...23)
@item ~I @tab hour, zero padded, 12-hour clock (01...12)
@item ~j @tab day of year, zero padded
@item ~k @tab hour, blank padded, 24-hour clock (00...23)
@item ~l @tab hour, blank padded, 12-hour clock (01...12)
@item ~m @tab month, zero padded (01...12)
@item ~M @tab minute, zero padded (00...59)
@item ~n @tab new line
@item ~N @tab nanosecond, zero padded
@item ~p @tab locale's AM or PM
@item ~r @tab time, 12 hour clock, same as "~I:~M:~S ~p"
@item ~s @tab number of full seconds since "the epoch" (in UTC)
@item ~S @tab second, zero padded (00...60)
@item ~t @tab horizontal tab
@item ~T @tab time, 24 hour clock, same as "~H:~M:~S"
@item ~U @tab week number of year with Sunday as first day of week (00...53)
@item ~V @tab week number of year with Monday as first day of week (01...52)
@item ~w @tab day of week (0...6)
@item ~W @tab week number of year with Monday as first day of week (01...52)
@item ~x @tab locale's date representation, for example: "12/31/99"
@item ~X @tab locale's time representation, for example: "23:13:48"
@item ~y @tab last two digits of year (00...99)
@item ~Y @tab year
@item ~z @tab time zone in RFC-822 style
@item ~Z @tab symbol time zone (not--implemented)
@item ~1 @tab @iso{}--8601 year--month--day format
@item ~2 @tab @iso{}--8601 hour--minute--second-timezone format
@item ~3 @tab @iso{}--8601 hour--minute--second format
@item ~4 @tab @iso{}--8601 year--month--day--hour--minute--second--timezone format
@item ~5 @tab @iso{}--8601 year--month--day--hour--minute--second format
@end multitable

@quotation
@emph{Nausicaa note:} These escape sequences are almost like the ones
specified for the C library function @cfunc{strftime} and the @gnu{}
@command{date} command line program.  The original @srfi{} document
defined @code{~x} to:

@quotation
week number of year with Monday as first day of week (00...53)
@end quotation

@noindent
and @code{~X} to:

@quotation
locale's date representation, for example: "07/31/00"
@end quotation

@noindent
which is probably a document composition error, because the reference
implementation accompanying the document does what is described above.
@end quotation
@end defun


@defun string->date @var{input-string} @var{template-string}
Convert an input string to a date, using the template string.

The input string must match the template string as is; except escape
characters (preceded by a the tilde) indicate special converters which:

@enumerate
@item
move to the next character in the input string fulfilling a criterion;

@item
read a value;

@item
act on this value in some way.
@end enumerate

The table below lists the required converters; implementations are free
to extend this list.

@multitable {Escape} {char-alphabetic?} {Scrappy dappy doo, scrappy} {Scrappy dappy}
@headitem Escape @tab Skip to @tab Read @tab Contract
@item ~~ @tab any @tab read literal ~ @tab nothing
@item ~a @tab char-alphabetic? @tab abbreviated weekday in locale @tab nothing
@item ~A @tab char-alphabetic? @tab full weekday in locale @tab nothing
@item ~b @tab char-alphabetic? @tab abbreviated month name in locale @tab nothing
@item ~B @tab char-alphabetic? @tab full month name in locale @tab nothing
@item ~d @tab char-numeric? @tab day of month  @tab date--day
@item ~e @tab any @tab day of month, blank padded @tab date--day
@item ~h @tab char-alphabetic? @tab same as ~b @tab nothing
@item ~H @tab char-numeric? @tab hour @tab date--hour
@item ~k @tab any @tab hour, blank padded @tab date--hour
@item ~m @tab char-numeric? @tab month @tab date--month
@item ~M @tab char-numeric? @tab minute @tab date--minute
@item ~S @tab char-numeric? @tab second @tab date--second
@item ~y @tab any @tab 2--digit year @tab date--year within 50 years
@item ~Y @tab char-numeric? @tab year @tab date-year
@item ~z @tab any @tab time zone @tab date--zone--offset
@end multitable
@end defun

@c page
@node format
@chapter Formatting strings


The @library{formations} library is a distribution of the @func{format}
function written by Dirk Lutzebaeck (@email{lutzeb@@cs.tu-berlin.de}),
originally by Ken Dickey and Aubrey Jaffer, included in the Guile
distribution and later adapted to @rnrs{6} Scheme by Marco Maggi.

This document is derived from the documentation of Guile, the @gnu{}
Ubiquitous Interface Language for Extensions.

The @func{format} function is a powerful way to print numbers, strings
and other objects together with literal text under the control of a
format string.

@menu
* format output::               Formatted Output.
* format escape values::        Escape sequences for generic values.
* format escape char::          Escape sequences for characters.
* format escape integers::      Escape sequences for integers.
* format escape flonums::       Escape sequences for flonums.
* format escape complex::       Escape sequences for complex numbers.
@end menu

@c page
@node format output
@section Formatted Output


A format string is generally more compact and easier than using just the
standard procedures like @func{display}, @func{write} and
@func{newline}.  Parameters in the output string allow various output
styles, and parameters can be taken from the arguments for runtime
flexibility.

@func{format} is similar to the Common Lisp procedure of the same name,
but it's not identical and doesn't have quite all the features found in
Common Lisp.

C programmers will note the similarity between @func{format} and
@cfunc{printf}, though escape sequences are marked with @code{~} instead
of @code{%}, and are more powerful.


@defun format fmt
@defunx format fmt [args@dots{}]
@defunx format dest fmt
@defunx format dest fmt [args@dots{}]
Write output specified by the @var{fmt} string to @var{dest}.

@var{dest} can be an output port, @true{} for
@func{current-output-port}, a number for @func{current-error-port}, or
@false{} to return the output as a string.  If @var{dest} is not given
(that is: the first argument is a string): the output is returned as if
@false{} is used as @var{dest} argument.

@var{fmt} can contain literal text to be output, and @code{~}
escapes.  Each escape has the form:

@example
~ [param [, param@dots{}] [:] [@@] code
@end example

@code{code} is a character determining the escape sequence; the
@code{code} letters are @strong{not} case--sensitive, upper and lower
case are the same.  The @code{:} and @code{@@} characters are optional
modifiers, one or both of which change the way various codes operate.
Optional parameters are accepted by some codes too.  Parameters have the
following forms,

@table @code
@item [+/-]number
An integer, with optional @code{+} or @code{-}.

@item '
The quote.  The following character in the format string, for instance
@code{'z} for @code{z}.

@item v
The next function argument as the parameter.  @code{v} stands for
``variable'', a parameter can be calculated at runtime and included in
the arguments.  Upper case @code{V} can be used too.

@item #
The number of arguments remaining.
@end table

Parameters are separated by commas (@code{,}).  A parameter can be left
empty to keep its default value when supplying later parameters.
@end defun

@c page
@node format escape values
@section Escape sequences for generic values


@deffn Escape ~a
@deffnx Escape ~s
Object output.  Parameters: @var{minwidth}, @var{padinc},
@var{minpad}, @var{padchar}.

@code{~a} outputs an argument like @code{display}, @code{~s}
outputs an argument like @code{write}.

@example
(format #t "~a" "foo") @print{} foo
(format #t "~s" "foo") @print{} "foo"
@end example

@code{~:a} and @code{~:s} put objects that don't have an external
representation in quotes like a string.

@example
(format #t "~:a" car) @print{} "#<primitive-procedure car>"
@end example

If the output is less than @var{minwidth} characters (default 0), it's
padded on the right with @var{padchar} (default space).  @code{~@@a}
and @code{~@@s} put the padding on the left instead.

@example
(format #f "~5a" 'abc)       @result{} "abc  "
(format #f "~5,,,'-@@a" 'abc) @result{} "--abc"
@end example

The number of padding characters, @var{padchar}, included in the output
is computed with: @math{@var{minpad} + @var{N} * @var{padinc}}, where
@var{n} is the smallest integer making the total object plus padding
greater than or equal to @var{minwidth}.  The default @var{minpad} is 0
and the default @var{padinc} is 1 (imposing no minimum or multiple).

@example
(format #f "~5,1,4a" 'abc) @result{} "abc    "
@end example
@end deffn


More examples:

@example
(check
    (format #f "ciao ~:a" display)
  => (cond-expand
      (ypsilon  "ciao \"#<subr display>\"")
      (larceny  "ciao \"#<PROCEDURE display>\"")
      (ikarus   "ciao \"#<procedure display>\""))

(check
    (list (format "~5a" 123)
          (format "~5s" 123))
  => '("123  "
       "123  "))

(check
    (list (format "~5@@a" 123)
          (format "~5@@s" 123))
  => '("  123"
       "  123"))

(check
    (list (format "~5,,,'.a" 123)
          (format "~5,,,'.s" 123))
  => '("123.."
       "123.."))

(check
    (list (format "~5,,,'.@@a" 123)
          (format "~5,,,'.@@s" 123))
  => '("..123"
       "..123"))

(check
    (list (format "~5,,4,'.@@a" 123)
          (format "~5,,4,'.@@s" 123))
  => '("....123"
       "....123"))
;;;     1234

(check
    (list (format "~10,,,'a@@a" 123)
          (format "~10,,,'a@@s" 123))
  => '("aaaaaaa123"
       "aaaaaaa123"))
;;;     1234567

(check
    (list (format "~10,3,,'u@@a" 123)
          (format "~10,3,,'u@@s" 123))
  => '("uuuuuuuuu123"
       "uuuuuuuuu123"))
;;;     123456789

(check
    (list (format "~11,2,,'u@@a" 123)
          (format "~11,2,,'u@@s" 123))
  => '("uuuuuuuu123"
       "uuuuuuuu123"))
;;;     12345678

(check
    (list (format "~8,2,,'u@@a" 1)
          (format "~8,2,,'u@@s" 1))
  => '("uuuuuuuu1"
       "uuuuuuuu1"))
;;;     12345678

@end example

@c page
@node format escape char
@section Escape sequences for characters


@deffn Escape ~c
Character.  Parameter: @var{charnum}.

Output a character.  The default is to simply output, as per
@func{write-char}.  @code{~@@c} prints in @func{write} style.
@code{~:c} prints control characters (@ascii{} 0 to 31) in @code{^X}
form.

@example
(format #t "~c" #\z)        @print{} z
(format #t "~@@c" #\z)       @print{} #\z
(format #t "~:c" #\newline) @print{} ^J
@end example

If the @var{charnum} parameter is given then an argument is not taken
but instead the character is @code{(integer->char @var{charnum})}.  This
can be used for instance to output characters given by their Unicode
code.

@example
(format #t "~65c")  @print{} A
@end example
@end deffn

@c page
@node format escape integers
@section Escape sequences for integers


@deffn Escape ~d
@deffnx Escape ~x
@deffnx Escape ~o
@deffnx Escape ~b
Integer.  Parameters: @var{minwidth}, @var{padchar}, @var{commachar},
@var{commawidth}.

Output an integer argument as a decimal, hexadecimal, octal or binary
integer (respectively).

@example
(format #t "~d" 123) @print{} 123
@end example

If the output is less than the @var{minwidth} parameter (default no
minimum), it's padded on the left with the @var{padchar} parameter
(default space).

@example
(format #t "~5,'*d" 12)   @print{} ***12
(format #t "~5,'0d" 12)   @print{} 00012
(format #t "~3d"    1234) @print{} 1234
@end example

The @code{@@} modifier causes a @code{+} sign to be prepended to
positive numbers, zero included.

@example
(format #t "~@@b" 12) @print{} +1100
(format #t "~@@d" 0)  @print{} +0
@end example

The @code{:} modifier adds a @var{commachar} (default comma) every
@var{commawidth} digits (default 3).

@example
(format #t "~:d" 1234567)         @print{} 1,234,567
(format #t "~10,'*,'/,2:d" 12345) @print{} ***1/23/45
@end example

Hexadecimal @code{~x} output is in lower case, but the @code{~(} and
@code{~)} case conversion directives described elsewhere can be used to
get upper case.

@example
(format #t "~x"       65261) @print{} feed
(format #t "~:@@(~x~)" 65261) @print{} FEED
@end example
@end deffn


@deffn Escape ~r
Integer in words, roman numerals, or a specified radix.  Parameters:
@var{radix}, @var{minwidth}, @var{padchar}, @var{commachar},
@var{commawidth}.

With no parameters output is in words as a cardinal like ``ten'', or
@code{~:r} prints an ordinal like ``tenth''.

@example
(format #t "~r" 9)  @print{} nine        ;; cardinal
(format #t "~r" -9) @print{} minus nine  ;; cardinal
(format #t "~:r" 9) @print{} ninth       ;; ordinal
@end example

And also with no parameters, @code{~@@r} gives roman numerals and
@code{~:@@r} gives old roman numerals.  In old roman numerals
there's no ``subtraction'', so 9 is @code{VIIII} instead of
@code{IX}.  In both cases only positive numbers can be output.

@example
(format #t "~@@r" 89)  @print{} LXXXIX     ;; roman
(format #t "~:@@r" 89) @print{} LXXXVIIII  ;; old roman
@end example

When a parameter is given it means numeric output in the specified
@var{radix} (which can be any integer, @strong{not} only 2, 8, 10 or
16).  The modifiers and parameters following the radix are the same as
described for @code{~d} above.

@example
(format #f "~3r" 27)   @result{} "1000"    ;; base 3
(format #f "~3,5r" 26) @result{} "  222"   ;; base 3 width 5
@end example
@end deffn

@c page
@node format escape flonums
@section Escape sequences for flonums


@menu
* format escape flonums fixed::        Fixed point format.
* format escape flonums exponent::     Exponential format.
* format escape flonums eng::          Engineering format.
@end menu

@c page
@node format escape flonums fixed
@subsection Fixed point format


@deffn Escape @code{~f}
Real fixed--point float.  Parameters: @var{width}, @var{decimals},
@var{scale}, @var{overflowchar}, @var{padchar}.

Output a number or number string in fixed-point format, ie.@: with a
decimal point.

@example
(format #t "~f" 5)              @print{} 5.0
(format #t "~f" 1e-1)           @print{} 0.1
(format #t "~f" "123")          @print{} 123.0
(format #t "~f" "#d123")        @print{} 123.0
(format #t "~f" "#d-1e-1")      @print{} -0.1
@end example

@code{~@@f} prints a @code{+} sign on positive numbers (including
zero).

@example
(format #t "~@@f" 0) @print{} +0.0
@end example

If the output is less than @var{width} characters (default is no limit
and no padding) it's padded on the left with @var{padchar} (space by
default).  If the output equals or exceeds @var{width} then there's no
padding and the decimals after the comma are truncated if this makes the
number fit the @var{width}.

@example
(format "~6f" -1.5)                     @result{} "  -1.5"
(format "~6,,,,'*f" 23)                 @result{} "**23.0"
(format "~6f" 1234567.0)                @result{} "1234567.0"
(format "~10,,,,'.f" 123.456789123)     @result{} "123.456789"
(format "~5,,,,'.f" 1e9)                @result{} "1000000000.0"
(format "~5,,,,'.f" 1000000000.123456)  @result{} "1000000000.123456"
@end example

@var{decimals} is how many digits to print after the decimal point,
with the value rounded or padded with zeros as necessary.  (The
default is to output as many decimals as required.)

@example
(format #t "~1,2f" 3.125) @print{} 3.13
(format #t "~1,2f" 1.5)   @print{} 1.50
@end example

@noindent
Decimals are rounded only when requested.  If not requested they are not
rounded nor truncated when the output exceeds the requested @var{width}.

@example
(format #t "~1f"   0.123) @print{} "0.123")
(format #t "~1,2f" 0.123) @print{} ".12")
@end example

@var{scale} is a power of 10 applied to the value, moving the decimal
point that many places.  A positive @var{scale} increases the value
shown, a negative decreases it.

@example
(format #t "~,,2f" 1234)  @print{} 123400.0
(format #t "~,,-2f" 1234) @print{} 12.34
@end example

If @var{overflowchar} and @var{width} are both given and if the output
would exceed @var{width}, then that many @var{overflowchar}s are
printed instead of the value.

@example
(format #t "~5,,,'xf" 12345) @print{} 12345
(format #t "~4,,,'xf" 12345) @print{} xxxx
@end example
@end deffn

@c page
@node format escape flonums exponent
@subsection Exponential format


@deffn Escape ~e
Real exponential float.  Parameters: @var{width}, @var{decimals},
@var{expdigits}, @var{intdigits}, @var{overflowchar}, @var{padchar},
@var{expchar}.

Output a number or number string in exponential notation.

@example
(format #t "~e" 5000.25) @print{} 5.00025E+3
(format #t "~e" "123.4") @print{} 1.234E+2
(format #t "~e" "1e4")   @print{} 1.0E+4
@end example

@code{~@@e} prints a @code{+} sign on positive numbers (including
zero).  (This is for the mantissa, a @code{+} or @code{-} sign is
always shown on the exponent.)

@example
(format #t "~@@e" 5000.0) @print{} +5.0E+3
@end example

If the output is less than @var{width} characters it's padded on the
left with @var{padchar} (space by default).  The default for
@var{width} is to output with no padding.

@example
(format #f "~10e" 1234.0)       @result{} "  1.234E+3"
(format #f "~10,,,,,'*e" 0.5)   @result{} "****5.0E-1"
@end example

If the output is more than @var{width} characters: decimals in the
exponential representation are rounded to make the output fit the
@var{width}; if rounding does not make the output fit, the full output
without rounding is printed.  When @var{decimals} is specified: no
rounding is done to remove those decimals, even if the output exceeds
the @var{width}.

@example
;; here rounding succeeds in making the output fit
(format #f "~5e" 123456)        @result{} "1.E+5"

;; here rounding fails in making the output fit
(format #f "~2e" 123456)        @result{} "1.23456E+5"

;; here DECIMALS causes the output to overflow
(format "~6,3e" 123.3456)       @result{} "1.233E+2"
@end example

@var{decimals} is the number of digits shown in the mantissa after the
decimal point.  The value is rounded or trailing zeros are added as
necessary.  The default @var{decimals} is to show as much as needed by
the value.

@example
(format #f "~,3e" 11111.0) @result{} "1.111E+4"
(format #f "~,8e" 123.0)   @result{} "1.23000000E+2"
@end example

@var{expdigits} is the minimum number of digits shown for the
exponent, with leading zeros added if necessary.  The default for
@var{expdigits} is to show only as many digits as required.  At least
1 digit is always shown.

@example
(format #f "~,,1e" 1.0e99) @result{} "1.0E+99"
(format #f "~,,6e" 1.0e99) @result{} "1.0E+000099"
@end example

@var{intdigits} (default 1) is the number of digits to show before the
decimal point in the mantissa.  @var{intdigits} can be zero, in which
case the integer part is a single @code{0}, or it can be negative,
in which case leading zeros are shown after the decimal point.

@example
(format #t "~,,,3e" 12345.0)  @print{} 123.45E+2
(format #t "~,,,0e" 12345.0)  @print{} 0.12345E+5
(format #t "~,,,-3e" 12345.0) @print{} 0.00012345E+8
@end example

If @var{overflowchar} is given then @var{width} is a hard limit.  If the
output would exceed @var{width} then instead that many
@var{overflowchar}s are printed.

@example
(format #f "~6,,,,'xe" 100.0) @result{} "1.0E+2"
(format #f "~3,,,,'xe" 100.0) @result{} "xxx"
@end example

@var{expchar} is the exponent marker character (default @code{E}).

@example
(format #t "~,,,,,,'ee" 100.0) @print{} 1.0e+2
@end example
@end deffn

@c page
@node format escape flonums eng
@subsection Engineering format


@deffn Escape @code{~g}
@strong{FIXME} <to be written>
@end deffn

@c page
@node format escape complex
@section Escape sequences for complex numbers


@deffn Escape ~i
Complex fixed--point float.  Parameters: @var{width}, @var{decimals},
@var{scale}, @var{overflowchar}, @var{padchar}.

Output the argument as a complex number, with both real and imaginary
part shown (even if one or both are zero).

The parameters and modifiers are the same as for fixed--point @code{~f}
described above.  The real and imaginary parts are both output with the
same given parameters and modifiers, except that for the imaginary part
the @code{@@} modifier is always enabled, so as to print a @code{+} sign
between the real and imaginary parts.

@example
(format #t "~i" 1)  @print{} 1.0+0.0i
@end example

Notice that the imaginary unit character @code{i} is excluded from the
counting for width and padding.
@end deffn


@deffn Escape @code{~p}
Plural.  No parameters.

Output nothing if the argument is 1, or @samp{s} for any other
value.

@example
(format #t "enter name~p" 1) @print{} enter name
(format #t "enter name~p" 2) @print{} enter names
@end example

@code{~@@p} prints @samp{y} for 1 or @samp{ies} otherwise.

@example
(format #t "pupp~@@p" 1) @print{} puppy
(format #t "pupp~@@p" 2) @print{} puppies
@end example

@code{~:p} re-uses the preceding argument instead of taking a new
one, which can be convenient when printing some sort of count.

@example
(format #t "~d cat~:p" 9)   @print{} 9 cats
(format #t "~d pupp~:@@p" 5) @print{} 5 puppies
@end example

@code{~p} is designed for English plurals and there's no attempt to
support other languages.  @code{~[} conditionals (below) may be able to
help.  When using @code{gettext} to translate messages @code{ngettext}
is probably best though.
@end deffn


@deffn Escape @code{~y}
Pretty print.  No parameters.

Output an argument with @code{pretty-print}.
@end deffn


@deffn Escape @code{~?}
@deffnx Escape @code{~k}
Sub-format.  No parameters.

Take a format string argument and a second argument which is a list of
arguments for that string, and output the result.

@example
(format #t "~?" "~d ~d" '(1 2))    @print{} 1 2
@end example

@code{~@@?} takes arguments for the sub-format directly rather than
in a list.

@example
(format #t "~@@? ~s" "~d ~d" 1 2 "foo") @print{} 1 2 "foo"
@end example

@code{~?} and @code{~k} are the same, @code{~k} is provided for
T-Scheme compatibility.
@end deffn


@deffn Escape @code{~*}
Argument jumping.  Parameter: @var{N}.

Move forward @var{N} arguments (default 1) in the argument list.
@code{~:*} moves backwards.  (@var{N} cannot be negative.)

@example
(format #f "~d ~2*~d" 1 2 3 4) @result{} "1 4"
(format #f "~d ~:*~d" 6)       @result{} "6 6"
@end example

@code{~@@*} moves to argument number @var{N}.  The first argument is
number 0 (and that's the default for @var{N}).

@example
(format #f "~d~d again ~@@*~d~d" 1 2) @result{} "12 again 12"
(format #f "~d~d~d ~1@@*~d~d" 1 2 3)  @result{} "123 23"
@end example

A @code{#} move to the end followed by a @code{:} modifier move
back can be used for an absolute position relative to the end of the
argument list, a reverse of what the @code{@@} modifier does.

@example
(format #t "~#*~2:*~a" 'a 'b 'c 'd)   @print{} c
@end example

At the end of the format string the current argument postion doesn't
matter, any further arguments are ignored.
@end deffn


@deffn Escape @code{~t}
Advance to a column position.  Parameters: @var{colnum}, @var{colinc},
@var{padchar}.

Output @var{padchar} (space by default) to move to the given
@var{colnum} column.  The start of the line is column 0, the default
for @var{colnum} is 1.

@example
(format #f "~tX")  @result{} " X"
(format #f "~3tX") @result{} "   X"
@end example

If the current column is already past @var{colnum}, then the move is
to there plus a multiple of @var{colinc}, ie.@: column
@math{@var{colnum} + @var{N} * @var{colinc}} for the smallest @var{N}
which makes that value greater than or equal to the current column.
The default @var{colinc} is 1 (which means no further move).

@example
(format #f "abcd~2,5,'.tx") @result{} "abcd...x"
@end example

@code{~@@t} takes @var{colnum} as an offset from the current column.
@var{colnum} many pad characters are output, then further padding to
make the current column a multiple of @var{colinc}, if it isn't
already so.

@example
(format #f "a~3,5'*@@tx") @result{} "a****x"
@end example

@code{~t} is implemented using @code{port-column}, so it works even
there has been other output before @code{format}.
@end deffn


@deffn Escape @code{~~}
Tilde character.  Parameter: @var{n}.

Output a tilde character @code{~}, or @var{n} many if a parameter is
given.  Normally @code{~} introduces an escape sequence, @code{~~}
is the way to output a literal tilde.
@end deffn


@deffn Escape @code{~%}
Newline.  Parameter: @var{n}.

Output a newline character, or @var{n} many if a parameter is given.
A newline (or a few newlines) can of course be output just by
including them in the format string.
@end deffn


@deffn Escape @code{~&}
Start a new line.  Parameter: @var{n}.

Output a newline if not already at the start of a line.  With a
parameter, output that many newlines, but with the first only if not
already at the start of a line.  So for instance 3 would be a newline
if not already at the start of a line, and 2 further newlines.
@end deffn


@deffn Escape @code{~_}
Space character.  Parameter: @var{n}.

@c  For reference, in Common Lisp ~_ is a conditional newline, but
@c  slib fmtdoc.txi described it as a space, so we keep that.

Output a space character, or @var{n} many if a parameter is given.

With a variable parameter this is one way to insert runtime calculated
padding (@code{~t} or the various field widths can do similar
things).

@example
(format #f "~v_foo" 4) @result{} "    foo"
@end example
@end deffn


@deffn Escape @code{~/}
Tab character.  Parameter: @var{n}.

Output a tab character, or @var{n} many if a parameter is given.
@end deffn


@deffn Escape @code{~|}
Formfeed character.  Parameter: @var{n}.

Output a formfeed character, or @var{n} many if a parameter is given.
@end deffn


@deffn Escape @code{~!}
Force output.  No parameters.

At the end of output, call @code{force-output} to flush any buffers on
the destination.  @code{~!} can occur anywhere in the format string, but
the force is done at the end of output.

When output is to a string (destination @code{#f}), @code{~!} does
nothing.
@end deffn


@deffn Escape @code{~newline}
@c (ie.@: newline character)
Continuation line.  No parameters.

Skip this newline and any following whitespace in the format string,
ie.@: don't send it to the output.  This can be used to break up a
long format string for readability, but not print the extra
whitespace.

@example
(format #f "abc~
            ~d def~
            ~d" 1 2) @result{} "abc1 def2"
@end example

@code{~:newline} skips the newline but leaves any further whitespace
to be printed normally.

@code{~@@newline} prints the newline then skips following
whitespace.
@end deffn


@deffn Escape {~( ~)}
Case conversion.  No parameters.

Between @code{~(} and @code{~)} the case of all output is changed.
The modifiers on @code{~(} control the conversion.

@itemize @asis
@item @code{~(}
Lower case.
@c
@c  FIXME: The : and @ modifiers are not yet documented because the
@c  code applies string-capitalize and string-capitalize-first to each
@c  separate format:out-str call, which has various subtly doubtful
@c  effects.  And worse they're applied to individual characters,
@c  including literal characters in the format string, which has the
@c  silly effect of being always an upcase.
@c
@c  The Common Lisp spec is apparently for the capitalization to be
@c  applied in one hit to the whole of the output between ~( and ~).
@c  (This can no doubt be implemented without accumulating all that
@c  text, just by keeping a state or the previous char to tell whether
@c  within a word.)
@c
@c  @deffn Escape
@c  @code{:} --- first letter of each word upper case, the rest lower
@c  case, as per the @code{string-capitalize} function (@pxref{Alphabetic
@c  Case Mapping}).
@c  @deffn Escape
@c  @code{@@} --- first letter of just the first word upper case, the
@c  rest lower case.
@c
@item @code{~:@@(}
Upper case.
@end itemize

For example,

@example
(format #t "~(Hello~)")   @print{} hello
(format #t "~:@@(Hello~)") @print{} HELLO
@end example

In the future it's intended the modifiers @code{:} and @code{@@}
alone will capitalize the first letters of words, as per Common Lisp
@code{format}, but the current implementation of this is flawed and
not recommended for use.

Case conversions do not nest, currently.  This might change in the
future, but if it does then it will be to Common Lisp style where the
outermost conversion has priority, overriding inner ones (making those
fairly pointless).
@end deffn


@deffn Escape ~@{ ~@}
Iteration.  Parameter: @var{maxreps} (for @code{~@{}).

The format between @code{~@{} and @code{~@}} is iterated.  The
modifiers to @code{~@{} determine how arguments are taken.  The
default is a list argument with each iteration successively consuming
elements from it.  This is a convenient way to output a whole list.

@example
(format #t "~@{~d~@}"     '(1 2 3))       @print{} 123
(format #t "~@{~s=~d ~@}" '("x" 1 "y" 2)) @print{} "x"=1 "y"=2
@end example

@code{~:@{} takes a single argument which is a list of lists, each
of those contained lists gives the arguments for the iterated format.

@c  @print{} on a new line here to avoid overflowing page width in DVI
@example
(format #t "~:@{~dx~d ~@}" '((1 2) (3 4) (5 6)))
@print{} 1x2 3x4 5x6
@end example

@code{~@@@{} takes arguments directly, with each iteration
successively consuming arguments.

@example
(format #t "~@@@{~d~@}"     1 2 3)       @print{} 123
(format #t "~@@@{~s=~d ~@}" "x" 1 "y" 2) @print{} "x"=1 "y"=2
@end example

@code{~:@@@{} takes list arguments, one argument for each iteration,
using that list for the format.

@c  @print{} on a new line here to avoid overflowing page width in DVI
@example
(format #t "~:@@@{~dx~d ~@}" '(1 2) '(3 4) '(5 6))
@print{} 1x2 3x4 5x6
@end example

Iterating stops when there are no more arguments or when the
@var{maxreps} parameter to @code{~@{} is reached (default no
maximum).

@example
(format #t "~2@{~d~@}" '(1 2 3 4)) @print{} 12
@end example

If the format between @code{~@{} and @code{~@}} is empty, then a
format string argument is taken (before iteration argument(s)) and
used instead.  This allows a sub-format (like @code{~?} above) to be
iterated.

@example
(format #t "~@{~@}" "~d" '(1 2 3)) @print{} 123
@end example

@c  FIXME: What is the @code{:} modifier to ~} meant to do?  The
@c  Common Lisp spec says it's a minimum of 1 iteration, but the
@c  format.scm code seems to merely make it have MAXREPS default to 1.

Iterations can be nested, an inner iteration operates in the same way
as described, but of course on the arguments the outer iteration
provides it.  This can be used to work into nested list structures.
For example in the following the inner @code{~@{~d~@}x} is applied
to @code{(1 2)} then @code{(3 4 5)} etc.

@example
(format #t "~@{~@{~d~@}x~@}" '((1 2) (3 4 5))) @print{} 12x345x
@end example

See also @code{~^} below for escaping from iteration.
@end deffn


@deffn Escape {~[ ~; ~]}
Conditional.  Parameter: @var{selector}.

A conditional block is delimited by @code{~[} and @code{~]}, and
@code{~;} separates clauses within the block.  @code{~[} takes an
integer argument and that number clause is used.  The first clause is
number 0.

@example
(format #f "~[peach~;banana~;mango~]" 1)  @result{} "banana"
@end example

The @var{selector} parameter can be used for the clause number,
instead of taking an argument.

@example
(format #f "~2[peach~;banana~;mango~]") @result{} "mango"
@end example

If the clause number is out of range then nothing is output.  Or the
last clause can be @code{~:;} to use that for a number out of range.

@example
(format #f "~[banana~;mango~]"         99) @result{} ""
(format #f "~[banana~;mango~:;fruit~]" 99) @result{} "fruit"
@end example

@code{~:[} treats the argument as a flag, and expects two clauses.
The first is used if the argument is @code{#f} or the second
otherwise.

@example
(format #f "~:[false~;not false~]" #f)   @result{} "false"
(format #f "~:[false~;not false~]" 'abc) @result{} "not false"

(let ((n 3))
  (format #t "~d gnu~:[s are~; is~] here" n (= 1 n)))
@print{} 3 gnus are here
@end example

@code{~@@[} also treats the argument as a flag, and expects one
clause.  If the argument is @code{#f} then no output is produced and
the argument is consumed, otherwise the clause is used and the
argument is not consumed, it's left for the clause.  This can be used
for instance to suppress output if @code{#f} means something not
available.

@example
(format #f "~@@[temperature=~d~]" 27) @result{} "temperature=27"
(format #f "~@@[temperature=~d~]" #f) @result{} ""
@end example
@end deffn


@deffn Escape @code{~^}
Escape.  Parameters: @var{val1}, @var{val2}, @var{val3}.

Stop formatting if there are no more arguments.  This can be used for
instance to have a format string adapt to a variable number of
arguments.

@example
(format #t "~d~^ ~d" 1)   @print{} 1
(format #t "~d~^ ~d" 1 2) @print{} 1 2
@end example

Within a @code{~@{} @code{~@}} iteration, @code{~^} stops the
current iteration step if there are no more arguments to that step,
but continuing with possible further steps and the rest of the format.
This can be used for instance to avoid a separator on the last
iteration, or to adapt to variable length argument lists.

@example
(format #f "~@{~d~^/~@} go"    '(1 2 3))     @result{} "1/2/3 go"
(format #f "~:@{ ~d~^~d~@} go" '((1) (2 3))) @result{} " 1 23 go"
@end example

@c  For reference, format.scm doesn't implement that Common Lisp ~:^
@c  modifier which stops the entire iterating of ~:{ or ~@:{.

@c  FIXME: Believe the Common Lisp spec is for ~^ within ~[ ~]
@c  conditional to terminate the whole format (or iteration step if in
@c  an iteration).  But format.scm seems to terminate just the
@c  conditional form.
@c
@c      (format #f "~[abc~^def~;ghi~] blah" 0)
@c      @result{} "abc blah"                    ;; looks wrong

@c  FIXME: Believe the Common Lisp spec is for ~^ within ~( ~) to end
@c  that case conversion and then also terminate the whole format (or
@c  iteration step if in an iteration).  But format.scm doesn't seem
@c  to do that quite right.
@c
@c      (format #f "~d ~^ ~d" 1)      @result{} "1 "
@c      (format #f "~(~d ~^ ~d~)" 1)  @result{} ERROR

Within a @code{~?} sub-format, @code{~^} operates just on that
sub-format.  If it terminates the sub-format then the originating
format will still continue.

@example
(format #t "~? items" "~d~^ ~d" '(1))   @print{} 1 items
(format #t "~? items" "~d~^ ~d" '(1 2)) @print{} 1 2 items
@end example

The parameters to @code{~^} (which are numbers) change the condition
used to terminate.  For a single parameter, termination is when that
value is zero (notice this makes plain @code{~^} equivalent to
@code{~#^}).  For two parameters, termination is when those two are
equal.  For three parameters, termination is when @math{@var{val1} <=
@var{val2}} and @math{@var{val2} <= @var{val3}}.
@end deffn


@c  FIXME: Good examples of these?

It's an error if there are not enough arguments for the escapes in the
format string, but any excess arguments are ignored.

Iterations @code{~@{} @code{~@}} and conditionals @code{~[}
@code{~;} @code{~]} can be nested, but must be properly nested,
meaning the inner form must be entirely within the outer form.  So
it's not possible, for instance, to try to conditionalize the endpoint
of an iteration.

@example
(format #t "~@{ ~[ ... ~] ~@}" ...)       ;; good
(format #t "~@{ ~[ ... ~@} ... ~]" ...)   ;; bad
@end example

The same applies to case conversions @code{~(} @code{~)}, they
must properly nest with respect to iterations and conditionals (though
currently a case conversion cannot nest within another case
conversion).

When a sub-format (@code{~?}) is used, that sub-format string must
be self-contained.  It cannot for instance give a @code{~@{} to
begin an iteration form and have the @code{~@}} up in the
originating format, or similar.

@c page
@node checks
@chapter Lightweight testing


The @library{checks} library provides a simple mechanism for testing
Scheme programs.  This library re--exports all the bindings from the
@library{debugging} library.  As a primitive example, the expression:

@example
(check (+ 1 1) => 3)
@end example

@noindent
evaluates the expression @code{(+ 1 1)} and compares the result with the
expected result @samp{3} provided after the syntactic keyword @samp{=>}.
Then the outcome of this comparison is reported in human--readable form
by printing a message of the form:

@example
(+ 1 1) @result{} 2 ; *** failed ***
; expected result: 3
@end example


@menu
* checks select::               Selecting tests to be run.
* checks eval::                 Evaluating code.
* checks result::               Handling multiple results.
@end menu

@c page
@node checks select
@section Selecting tests to be run


As usage example, let's assume that the system environment variable
@env{CHECK_TEST_NAME} is set to @code{yellow}:

@example
(parameterise ((check-test-name 'yellow))

  ;; this is evaluated
  (check
      (do-something)
    => 123)

  ;; this is evaluated, too
  (check
      (do-some-other-thing)
    => 456))

(parameterise ((check-test-name 'blue))

  ;; this is NOT evaluated
  (check
      (do-something)
    => #t)

  ;; this is NOT evaluated
  (check
      (do-some-other-thing)
    => #f))

;; this is evaluated
(check "yellow-one"
    (do-something)
  => 123)

;; this is NOT evaluated
(check 'red
    (do-something)
  => #t)
@end example


@defvr {Environment Variable} CHECK_TEST_NAME
The system environment variable used to select tests in a test suite
file.  The value of the variable must be the name, or the prefix of the
name, or the suffix of the name, of one or more tests.
@end defvr


@deffn Parameter check-test-name
Holds the name of the current test or tests.  Must be set to @false{}, a
string or a symbol.
@end deffn

@c page
@node checks eval
@section Evaluating code


@deffn Syntax check @var{expr} (=> @var{equal}) @var{expected}
@deffnx Syntax check @var{expr} => @var{expected}
@deffnx Syntax check @var{name} @var{expr} (=> @var{equal}) @var{expected}
@deffnx Syntax check @var{name} @var{expr} => @var{expected}
Evaluate @var{expr} and compare the value to the value of @var{expected}
using the predicate @var{equal}, which is @func{equal?} when omitted.
Then a report is printed according to the current mode setting (see
below) and the outcome is recorded in a global state to be used in
@func{check-report}.

The precise order of evaluation is that first @var{equal} and
@var{expected} are evaluated (in unspecified order) and then @var{expr}
is evaluated.  Example: @code{(check (+ 1 1) => 2)}.

When @var{name} is given: it is the name of this test, @ref{checks
select, Selecting tests to be run}.
@end deffn


@deffn Syntax check-ec @meta{qualifier} ... @var{expr} (=> @var{equal}) @var{expected} (@var{argument*})
@deffnx Syntax check-ec @meta{qualifier} ... @var{expr} => @var{expected} (@var{argument*})
@deffnx Syntax check-ec @meta{qualifier} ... @var{expr} (=> @var{equal}) @var{expected}
@deffnx Syntax check-ec @meta{qualifier} ... @var{expr} => @var{expected}
An eager comprehension for executing a parametric sequence of checks.
To use this syntax we have to import the @library{loops} library.

Enumerate the sequence of bindings specified by the @meta{qualifier}
syntaxes.  For each binding evaluate @var{equal} and @var{expected} in
unspecified order. Then evaluate @var{expr} and compare the value
obtained to the value of @var{expected} using the value of @var{equal}
as predicate, which is @func{equal?} when omitted.

The comprehension stops after the first failed check, if there is any.
Then a report is printed according to the current mode setting (see
below) and the outcome is recorded in a global state to be used in
@func{check-report}.  The entire @func{check-ec} counts as a single
check.

In case the check fails @var{argument*} is used for constructing an
informative message with the argument values.  Use @var{argument*} to
list the relevant free variables of @var{expr} (see examples) that you
want to have printed.

A @meta{qualifier} is any qualifier of an eager comprehension.

Examples:

@example
(check-ec (: e 100)
          (positive? (expt 2 e))
          => #t (e)) ; fails on fixnums

(check-ec (: e 100)
          (:let x (expt 2.0 e))
          (= (+ x 1) x)
          => #f (x)) ; fails

(check-ec (: x 10)
          (: y 10)
          (: z 10)
          (* x (+ y z))
          => (+ (* x y) (* x z))
             (x y z)) ; passes with 10^3 cases checked
@end example
@end deffn


@defun check-report
Print a summary and the first failed check, if there is any, depending
on the current mode settings.
@end defun


@defun check-set-mode! @var{mode}
Set the current mode to @var{mode}, which must be a symbol among:
@code{off}, @code{summary}, @code{report-failed}, @code{report}; the
default is @code{report}.  Note that you can change the mode at any
time, and that @func{check}, @func{check-ec} and @func{check-report} use
the current value.

The mode symbols have the following meaning:

@table @code
@item off
do not execute any of the checks;

@item summary
print only summary in @func{check-report} and nothing else;

@item report-failed
report failed checks when they happen, and in summary;

@item report
report every example executed.
@end table
@end defun


@defun check-reset!
Reset the global state (counters of correct/failed examples) to the
state immediately after loading the module for the first time, i.e. no
checks have been executed.
@end defun


@defun check-passed? @var{expected-total-count}
Return @true{} if there were no failed checks and
@var{expected-total-count} correct checks, @false{} otherwise.

Rationale: This procedure can be used in automatized tests by
terminating a test program with the statement:

@example
(exit (if (check-passed? n) 0 1))
@end example
@end defun


@deffn Syntax false-if-exception @var{form0} @var{form} ...
Evaluate all the @var{form}s as in @func{begin}.  If an exception is
raised: return @false{}.
@end deffn


@deffn Syntax check-for-true @var{expr}
@deffnx Syntax check-for-true @var{name} @var{expr}
@deffnx Syntax check-for-false @var{expr}
@deffnx Syntax check-for-false @var{name} @var{expr}
Evaluate @var{expr} in a @func{check} form, expecting a non--false or
@false{} value as result.

When @var{name} is given: it is the name of this test, @ref{checks
select, Selecting tests to be run}.
@end deffn

@c page
@node checks result
@section Handling multiple results


@deffn Syntax with-result @var{form0} @var{form} ...
Evaluate all the @var{form}s, as in @func{begin}, in a dynamic
environment in which an implicit result variable is defined.  The
implicit variable is handled as a list.

Return a list whose first value is the return value of the last
@var{form} and whose second value is the value of the implicit variable.
@end deffn


@defun add-result @var{obj}
Append @var{obj} to the list in the implicit variable defined by
@func{with-result}.
@end defun


@defun get-result
Return the current value of the implicit variable defined by
@func{with-result}.
@end defun


@c page
@node debugging
@chapter Debugging utilities


The @library{debugging} library provide simple utilities to help
debugging.  All the following bindings are re--exported by the
@library{checks} library.


@deffn Parameter debugging
When set to true @func{debug} will print its message.  It is initialised
to @false{}.
@end deffn


@defun debug @var{string}
@defunx debug @var{format-string} @var{arg} ...
If the @code{debugging} parameter is set to true, print @var{string} to
the current error port, or hand @var{format-string} and the optional
@var{arg} values to @func{format} and print the result to the current
error port.
@end defun


@defun debug-print-condition @var{message} @var{exc}
A wrapper for @func{debug} that prints @var{message} and does its best
to print @var{exc}, which must be a Scheme condition value.
@end defun

@c page
@node queues
@chapter Simple queue


The functions in this section are exported by the @library{queues}
library; the library implements queues holding arbitrary scheme objects
and designed for efficient first--in/first--out operations.  The
@library{queues} library is built on top of the @library{classes}
library.

@menu
* queues types::                Type definitions and constructors.
* queues pred::                 Predicates and inspection.
* queues ops::                  Basic operations.
* queues list::                 List operations.
* queues conv::                 Conversion.
@end menu

@c page
@node queues types
@section Type definitions and constructors


@deftp Class @aclass{queue}
Class type name of queue objects.
@end deftp


@defcv {Mutable Field} @aclass{queue} first-pair
The first pair of the internal list of elements.
@end defcv


@defcv {Mutable Field} @aclass{queue} last-pair
The last pair of the internal list of elements.
@end defcv


@defcv {Immutable Field} @aclass{queue} empty?
True if the queue is empty.
@end defcv


@defcv {Immutable Field} @aclass{queue} length
It holds the number of elements in the queue.
@end defcv


@defun make-<queue> @var{arg} ...
Build and return a new @class{queue} record.  When called with no
arguments, return an empty queue; when applied to arguments, return a
queue holding those arguments in the given order.
@end defun


@defun <queue>? @var{obj}
Return @true{} if @var{obj} is an object of type @class{queue}.
@end defun


@defun <queue>-first-pair @var{queue}
@defunx <queue>-first-pair-set! @var{queue} @var{obj}
@defunx <queue>-last-pair @var{queue}
@defunx <queue>-last-pair-set! @var{queue} @var{obj}
Accessors and mutators for the fields of @class{queue} records.
@end defun

@c page
@node queues pred
@section Predicates and inspection


@defun queue-empty? @var{que}
Return @true{} if the queue is empty.
@end defun


@defun queue-length @var{que}
Return the number of elements in the queue.
@end defun


@defun queue-front @var{que}
Return the first element in the queue, that is the value returned by a
dequeue operation.  The queue is left unchanged.  Raise an exception if
the queue is empty.
@end defun


@defmethod @aclass{queue} front
Return first element in the queue: the next element returned by a
dequeue operation.  The queue is left unchanged.  Raise an exception if
the queue is empty.
@end defmethod


@defun queue-rear @var{que}
Return the last element in the queue, that is the last enqueued valued.
The queue is left unchanged.  Raise an exception if the queue is empty.
@end defun


@defmethod @aclass{queue} rear
The last element in the queue.  The queue is left unchanged.  Raise an
exception if the queue is empty.
@end defmethod

@c page
@node queues ops
@section Basic operations


@defun queue-enqueue! @var{que} @var{obj}
Enqueue @var{obj} in the rear of the queue.
@end defun


@defmethod @aclass{queue} enqueue! @var{obj}
Enqueue @var{obj} in the rear of the queue.
@end defmethod


@defun queue-push! @var{obj} @var{que}
Push @var{obj} in the front of the queue.
@end defun


@defmethod @aclass{queue} push! @var{obj}
Push @var{obj} in the front of the queue.
@end defmethod


@defun queue-dequeue! @var{que}
@defunx queue-pop! @var{que}
Pop and return a value from the front of the queue.
@end defun


@defmethod @aclass{queue} dequeue!
@defmethodx @aclass{queue} pop!
Pop and return a value from the front of the queue.
@end defmethod


@defun queue-purge! @var{que}
Discard all the elements from the queue.
@end defun


@defmethod @aclass{queue} purge!
Discard all the elements from the queue.
@end defmethod

@c page
@node queues list
@section List operations


@defun queue-find @var{proc} @var{que}
@defunx queue-for-all @var{proc} @var{que}
@defunx queue-exists @var{proc} @var{que}
Apply @func{find} or @func{for-all} or @func{exists} to the internal
list of the queue, return the result.
@end defun


@defmethod @aclass{queue} find @var{proc}
@defmethodx @aclass{queue} for-all @var{proc}
@defmethodx @aclass{queue} exists @var{proc} @var{que}
Apply @func{find} or @func{for-all} or @func{exists} to the internal
list of the queue, return the result.
@end defmethod


@defun queue-remp! @var{proc} @var{que}
@defunx queue-remove! @var{obj} @var{que}
Apply @func{remp} or @func{remove} or @func{remv} or @func{remq} to the
internal list of the queue, removing objects from the queue.
@end defun


@defmethod @aclass{queue} remv! @var{obj}
@defmethodx @aclass{queue} remq! @var{obj}
Apply @func{remp} or @func{remove} or @func{remv} or @func{remq} to the
internal list of the queue, removing objects from the queue.
@end defmethod


@defun queue-memp @var{proc} @var{que}
@defunx queue-member @var{obj} @var{que}
Apply @func{memp} or @func{member} or @func{memv} or @func{memq} to the
internal list of the queue, return the result.
@end defun


@defmethod @aclass{queue} memv @var{obj}
@defmethodx @aclass{queue} memq @var{obj}
Apply @func{memp} or @func{member} or @func{memv} or @func{memq} to the
internal list of the queue, return the result.
@end defmethod

@c page
@node queues conv
@section Conversion


@defun queue->list @var{que}
@defunx queue->vector @var{que}
Return a list or vector holding the elements in the queue.  In the list
case, return a copy of the spine of the list in the queue.
@end defun


@defmethod @aclass{queue} list
@defmethodx @aclass{queue} vector
Return a list or vector holding the elements in the queue.  In the list
case, return a copy of the spine of the list in the queue.
@end defmethod


@defun list->queue @var{ell}
@defunx vector->queue @var{vec}
Build and return a new queue holding the elements from the list or
vector.  In the list case, the queue holds a copy of the spine of the
list argument.
@end defun

@c page
@node stacks
@chapter Simple stacks


The functions in this section are exported by the @library{stacks}
library; the library implements stacks holding arbitrary scheme objects
and designed for efficient last--in/first--out operations.  The
@library{queues} library is built on top of the @library{classes}
library.

@menu
* stacks types::                Type definitions and constructors.
* stacks pred::                 Predicates and inspection.
* stacks ops::                  Basic operations.
* stacks list::                 List operations.
* stacks conv::                 Conversion.
@end menu

@c page
@node stacks types
@section Type definitions and constructors


@deftp Class @aclass{stack}
Class name of stack objects.
@end deftp


@defcv {Mutable Field} @aclass{stack} first-pair
The first pair of the internal list of elements.
@end defcv


@defcv {Immutable Field} @aclass{stack} empty?
True if the stack is empty.
@end defcv


@defcv {Immutable Field} @aclass{stack} length
The number of elements on the stack.
@end defcv


@defun make-<stack> @var{arg} ...
Build and return a new @class{stack} record.  When called with no
arguments, return an empty stack; when applied to arguments, return a
stack holding those arguments in the given order.
@end defun


@defun <stack>? @var{obj}
Return @true{} if @var{obj} is a record of type @class{stack}.
@end defun


@defun <stack>-first-pair @var{stack}
@defunx <stack>-first-pair-set! @var{stack} @var{obj}
Accessor and mutator for the concrete field of @class{stack} records.
@end defun

@c page
@node stacks pred
@section Predicates and inspection


@defun stack-empty? @var{stk}
Return @true{} if the stack is empty.
@end defun


@defun stack-length @var{stk}
Return the number of elements in the stack.
@end defun


@defun stack-top @var{stk}
Return the first element in the stack: the value returned by a pop
operation.  The stack is left unchanged.  Raise an exception if the
stack is empty.
@end defun


@defmethod @aclass{stack} top
The first element in the stack: the next element returned by a pop
operation.  The stack is left unchanged.  Raise an exception if the
stack is empty.
@end defmethod

@c page
@node stacks ops
@section Basic operations


@defun stack-push! @var{obj} @var{stk}
Push @var{obj} in the top of the stack.
@end defun


@defmethod @aclass{stack} push! @var{obj}
Push @var{obj} in the top of the stack.
@end defmethod


@defun stack-pop! @var{stk}
Pop and return a value from the top of the stack.
@end defun


@defmethod @aclass{stack} pop!
Pop and return a value from the top of the stack.
@end defmethod


@defun stack-purge! @var{stk}
Remove all the elements from the stack.
@end defun


@defmethod @aclass{stack} purge!
Remove all the elements from the stack.
@end defmethod

@c page
@node stacks list
@section List operations


@defun stack-find @var{proc} @var{stk}
@defunx stack-for-all @var{proc} @var{stk}
@defunx stack-exists @var{proc} @var{stk}
Apply @func{find} or @func{for-all} or @func{exists} to the internal
list of elements, return the result.
@end defun


@defmethod @aclass{stack} find @var{proc}
@defmethodx @aclass{stack} for-all @var{proc}
@defmethodx @aclass{stack} exists @var{proc}
Apply @func{find} or @func{for-all} or @func{exists} to the internal
list of elements, return the result.
@end defmethod


@defun stack-remp! @var{proc} @var{stk}
@defunx stack-remove! @var{obj} @var{stk}
@defunx stack-remv! @var{obj} @var{stk}
@defunx stack-remq! @var{obj} @var{stk}
Apply @func{remp} or @func{remove} or @func{remv} or @func{remq} to the
internal list of elements, removing objects from the stack.
@end defun


@defmethod @aclass{stack} remp! @var{proc}
@defmethodx @aclass{stack} remove! @var{obj}
@defmethodx @aclass{stack} remv! @var{obj}
@defmethodx @aclass{stack} remq! @var{obj}
Apply @func{remp} or @func{remove} or @func{remv} or @func{remq} to the
internal list of elements, removing objects from the stack.
@end defmethod


@defun stack-memp @var{proc} @var{stk}
@defunx stack-member @var{obj} @var{stk}
@defunx stack-memv @var{obj} @var{stk}
@defunx stack-memq @var{obj} @var{stk}
Apply @func{memp} or @func{member} or @func{memv} or @func{memq} to the
internal list of elements, return the result.
@end defun


@defmethod @aclass{stack} memp @var{proc}
@defmethodx @aclass{stack} member @var{obj}
@defmethodx @aclass{stack} memv @var{obj}
@defmethodx @aclass{stack} memq @var{obj}
Apply @func{memp} or @func{member} or @func{memv} or @func{memq} to the
internal list of elements, return the result.
@end defmethod

@c page
@node stacks conv
@section Conversion


@defun stack->list @var{stk}
@defunx stack->vector @var{stk}
Return a list or vector holding the elements in the stack.  In the list
case, return a copy of the spine of the list in the stack.
@end defun


@defmethod @aclass{stack} list
@defmethodx @aclass{stack} vector
Return a list or vector holding the elements in the stack.  In the list
case, return a copy of the spine of the list in the stack.
@end defmethod


@defun list->stack @var{ell}
@defunx vector->stack @var{vec}
Build and return a new stack holding the elements from the list or
vector.  In the list case, the stack holds a copy of the spine of the
list argument.
@end defun

@c page
@node object-properties
@chapter Object properties


An @dfn{object property} is a convenient interface to an @func{eq?}
hashtable.  It is a function that can be called with one or two
arguments.  When called with two arguments: the first is an object and
the second is its property value; they are stored in the hashtable.
When called with one argument: the hashtable is queried using the
argument as key, and the value is returned.  Object properties are
implemented by the library @library{object-properties}.

@quotation
The idea of  object properties implemented in this library comes from
Guile, the @gnu{} Ubiquitous Interface Language for Extensions.
@end quotation


@defun make-object-property
Build and return a new object property.
@end defun


@deffn Syntax with-true-property (@var{prop} @var{object}) @var{form0} @var{form} ...
Temporarily save the value of @var{object} in @var{prop} and set it to
@true{}, then evaluate the @var{form}s and restore the original value.
@end deffn


@deffn Parameter object-property-initial-capacity
An integer representing the initial size of the hashtable.  The default
value is 100.
@end deffn


@deffn Parameter object-property-default-value
The value to return if the property is queried for an object that was
not registered before.  The default value is @false{}.
@end deffn


@c ------------------------------------------------------------

@subsubheading Examples

The following will evaluate successfully:

@example
(import (scheme)
  (uriel object-property)
  (checks)
  (srfi parameters))

(check-set-mode! 'report-failed)

(check
    (let ((prop (make-object-property))
          (a (vector 1 2 3))
          (b (vector 4 5 6))
          (c (vector 7 8 9)))
      (prop a 1)
      (prop b 2)
      (list (prop a) (prop b) (prop c)))
  => '(1 2 #f))

(check
    (let ((prop (parameterize ((object-property-initial-capacity 10)
                               (object-property-default-value 'quack))
                  (make-object-property)))
          (a (vector 1 2 3))
          (b (vector 4 5 6))
          (c (vector 7 8 9)))
      (prop a 1)
      (prop b 2)
      (list (prop a) (prop b) (prop c)))
  => '(1 2 quack))

(check-report)
@end example

@c page
@node cleanup-handlers
@chapter Cleaning up


On Scheme implementations that provide guardians (like Ikarus) there is
the need to invoke the guardian function, every now and then, to release
guarded resources that were garbage collected.  For example: if the
program makes use of an event loop, we can enqueue a periodic, batch,
event that invokes a cleanup function.

We may have code like this:

@example
(define block-guardian (make-guardian))

(define (block-cleanup)
  (do ((p (block-guardian) (block-guardian)))
      ((not p))
    (primitive-free p)))
@end example

@noindent
and allocate memory with:

@example
(define (malloc/guarded size)
  (let ((p (malloc size)))
    (block-guardian p)
    p))
@end example

@noindent
whenever the values returned by @func{malloc/guarded} are garbage
collected: they will be made available as return values from the
guardian function, so we can invoke @func{block-cleanup} to free them.

Of course, with code like this, we need a guardian for each type of
resource, or, to be more precise, a guardian for each destructor
(@func{primitive-free} in the example).

To make it simpler to invoke all the cleanup functions, the library
@library{cleanup-handlers} provides an interface to register them and
invoke them in sequence.


@defun register-cleanup-function @var{thunk}
Register @var{thunk} in the internal list of cleanup functions.
@end defun


@defun forget-cleanup-function @var{thunk}
Remove @var{thunk} from the internal list of cleanup functions.
@end defun


@defun cleanup
Invoke all the functions registered in the internal list of cleanup
functions.  Every function is invoked with no arguments.
@end defun


@quotation
@strong{NOTE} This library implements no event loop.  The only way to
invoke a cleanup thunk only once is to register it, invoke
@func{cleanup}, then remove it.  This is usually not what we want to do
to handle such a simple case: we should use a proper event loop,
instead.
@end quotation

@c page
@node combinators
@chapter Combinators


The following combinators are exported by @library{combinators}.


@deffn Syntax K @var{form} . @var{forms}
Evaluate all the forms like the standard @func{begin}, but return the
value of the first form.

@example
(define-syntax K
  (syntax-rules ()
    ((_ ?expr0 ?expr ...)
     (call-with-values
         (lambda () ?expr0)
       (lambda x
         ?expr ...
         (apply values x))))))
@end example

This is the same as the @func{begin0} syntax.
@end deffn


@deffn Syntax Y @var{func}
Build a recursive function with no name.

@example
(define-syntax Y
  (syntax-rules ()
    ((_ ?func)
     (let ((F ?func))
       ((lambda (f)
          (F (lambda (. args)
               (apply (f f) args))))
        (lambda (f)
          (F (lambda (. args)
               (apply (f f) args)))))))))
@end example

The combinator has to called like this:

@example
((Y (lambda (f)
      (lambda (. args)
        (do-something-with-args args)
        (if (condition) (f args))))
    arg1 arg2 ...))
@end example
@end deffn


@deffn Syntax S @var{x} @var{y} @var{z}
The S combinator:

@example
(define-syntax S
  (syntax-rules ()
    ((_ ?x ?y ?z)
     (let ((Z ?z))
       (?x Z (?y Z))))))
@end example
@end deffn

@c page
@node keywords
@chapter Keyword values


The @library{keywords} library implements a type of value,
@dfn{keywords}, disjoint from all the other types.  Keywords can be
treated much like symbols, but they must be compared with
@func{keyword=?} not @func{eq?}.


@deffn Syntax keyword @ameta{symbol}
@deffnx Function %keyword @var{symbol}
Both the macro and the function return a new keyword value associated to
the Scheme @var{symbol}.  The macro is a wrapper for the function, so
the following two forms are equivalent (notice the quoting):

@example
(keyword   alpha)
(%keyword 'alpha)
@end example

When this function is applied to the same symbol multiple times, it
returns the same keyword value; so those keywords are @func{eq?} to each
other.
@end deffn


@deffn Syntax define-keywords @ameta{symbol} ...
Build new keyword values using @func{keyword} upon @meta{symbol}
arguments, then bind them to @meta{symbol}.  Keyword values defined by
@func{define-keywords} can be, and are meant to be, exported by a
library if there is the need.
@end deffn


@defun keyword? @var{obj}
Return true if @var{obj} is a keyword value.
@end defun


@defun keyword=? @vari{obj} @varii{obj}
Return true if the arguments are equal keywords; two keywords are equal
if @func{keyword->symbol} applied to them returns the same symbol
according to @func{eq?}.
@end defun


@defun keyword->symbol @var{key}
@defunx symbol->keyword @var{str}
Convert a keyword to and from a symbol.
@end defun


@defun keyword->string @var{key}
@defunx string->keyword @var{str}
Convert a keyword to and from a string.
@end defun


@deffn Syntax with-keywords @var{keywords} @var{form0} @var{form} ...
Define a set of keywords while the forms are evaluated.  The following:

@example
(with-keywords (:a :b :c :d)
  ---)
@end example

@noindent
expands to:

@example
(let ((:a (keyword :a))
      (:b (keyword :b))
      (:c (keyword :c))
      (:d (keyword :d)))
  ---)
@end example
@end deffn


@deffn Syntax let-keywords @ameta{options} @ameta{allow-unknown} ((@ameta{name} @ameta{key} @ameta{default}) ...) @ameta{form0} @ameta{form} ...
@deffnx Syntax let-keywords* @ameta{options} @ameta{allow-unknown} ((@ameta{name} @ameta{key} @ameta{default}) ...) @ameta{form0} @ameta{form} ...
These are @func{let} and @func{let*} like macros that allow parsing a
list of keyword/value couples in @meta{options}.  All the @meta{key}
arguments must be keywords identifier; they are created by this form to
be available in the context of the @meta{form}.

@enumerate
@item
First all the @meta{default} expressions are evaluated and their results
bound to the @meta{name} identifiers, like with @func{let} or
@func{let*}.

@item
Then @meta{options} is parsed and the values associated to the @meta{key}
keywords are assigned to the @meta{name} variables.

@item
Finally the @meta{form} arguments are evaluated like in a @func{begin}
form.  The @meta{form} arguments are the region of the @meta{name}
bindings.
@end enumerate

If @meta{allow-unknown} is true: @meta{options} can contain keywords not
included in the @meta{key} list; else an error is raised.  Each keyword
in @meta{options} must be followed by a value, else an error is raised.

Example:

@example
(define (doit . options)
  (let-keywords options #f
       ((a :a #\a)
        (b :b #\b)
        (c :c #\c)
        (d :d #\d))
    (list a b c d)))

(with-keywords (:a :b :c :d)
  (doit :a 1 :b 2 :d 4))
@result{} (1 2 #\c 4)
@end example
@end deffn

@c page
@node variables
@chapter Defining storage locations


The @library{variables} library provides a way to define simple storage
locations similar to the variables used in many languages.  The
@dfn{variable} type of value is disjoint from the other types.


@defun make-variable
@defunx make-variable @var{obj}
Build and return a new variable value.  The variable is initialised to
@var{obj}, which defaults to the sentinel.  @nauref{sentinel, The
sentinel value}
@end defun


@defun variable? @var{obj}
Return @true{} if @var{obj} is a variable value.
@end defun


@defun variable-set! @var{variable} @var{obj}
@defunx variable-ref @var{variable}
Setter and getter for variables.
@end defun


It is possible to access variables' slots using identifier syntaxes:

@example
(define-syntax define-variable
  (syntax-rules ()
    ((_ ?name)
     (define-variable/test ?name sentinel))
    ((_ ?name ?value)
     (define ?name (make-variable ?value)))))

(define-syntax v
  (identifier-syntax
     (_
      (variable-ref  the-var))
     ((set! _ ?e)
      (variable-set! the-var ?e))))

(define-variable the-var 123)

v @result{} 123
(set! v 456)
v @result{} 456
@end example

@noindent
a more sophisticated of this is the @func{define-variable} syntax
exported by @library{variables}.


@deffn Syntax define-variable @var{name}
@deffnx Syntax define-variable @var{name} @var{obj}
@deffnx Syntax define-variable (@var{name} . @meta{formals}) @meta{body}
Like @func{define}, but stores the value in a newly built variable which
is then bound to @var{name}.  Example:

@example
(define-variable the-var 123)

v @result{} 123
(set! v 456)
v @result{} 456
@end example

The difference between @func{define-syntax} and @func{define}, is that
@func{define} only defines a binding which cannot be modified, while
@func{define-syntax} allocates a storage location, so the value bound to
@var{name} can be modified at will.
@end deffn

@c page
@node scmobj
@chapter A simple object system


The @library{scmobj} library defines an object system for Scheme that
provides: simple and multiple inheritance, generic functions,
multimethods.  It resembles @clos{} (the Common Lisp Object System), but
it does not implement a meta object protocol (@acronym{MOP}).

The library is a reorganisation and repackaging of ScmObj, an object
system for Scheme implemented by Dorai Sitaram.  The original code is
available from@footnote{@aurl{} last checked Thu Nov 13, 2008.}:

@center @url{http://www.ccs.neu.edu/home/dorai/scmobj/scmobj.html}

This library has the main purpose of keeping the source code simple and
understandable, so that it can be taken as starting point for more
sophisticated object systems.

@menu
* scmobj overview::             Overview of the library.
* scmobj example::              Objects layout examples.
* scmobj class::                Classes.
* scmobj instance::             Instances.
* scmobj inspect::              Inspecting classes and instances.
* scmobj slot::                 Accessing slots.
* scmobj generic::              Generic functions and methods.
@end menu

@c page
@node scmobj overview
@section Overview of the library


@library{scmobj} objects, that is classes and instances, are association
lists: Proper lists of pairs whose cars are symbols and whose cdrs can
be any value.

In this document: each pair is called @dfn{slot}; the symbol is called
@dfn{slot name}; the value is called @dfn{slot value}.  By convention
the slot name symbols must have name starting with a colon @code{:}.

A @dfn{class} object is an alist whose first slot's name is
@code{:class}, and the other slot names are:

@example
:class-definition-name
:class-precedence-list
:slots
@end example

An instance object is an alist whose first slot's name is @code{:class},
and the other slot names are configured by the user.


@deffn Slot :class
It must be the first slot for both class and instance objects.

For an instance object: The value must be the class of the instance.

For a class object: The value must be the predefined @class{class}
object.  So a class object is a special case of instance object.
@end deffn


@deffn Slot :class-definition-name
A class object's slot whose value is the ``public name'' of the class.
By convention it must be a symbol whose name is enclosed in angular
parentheses.  It is useful to print debug messages.
@end deffn


@deffn Slot :class-precedence-list
A class object's slot whose value is a list representing the hierarchy
of superclasses for the instance objects of the class, or @false{} if
the class has no precedence list.  It is used for dispatching of
multimethods.

Notice that the value of this slot does @strong{not} hold the class
object itself.
@end deffn


@deffn Slot :slots
A class object's slot whose value is the list of slot names for the
instances of the class, or @false{} if instances have no slots.  For the
predefined @class{class} object, the list is:

@example
(:class-definition-name :class-precedence-list :slots)
@end example

Notice that the symbol @code{:class} is @strong{not} included.
@end deffn

@c page
@node scmobj example
@section Objects layout examples


In the following it is not always convenient to show the full layout; to
highlight informations of interest, it is better to omit the layout of
class objects nested into class objects.  When this is done the string
@code{#<apple>} is included in place of the layout of the class
@class{apple}.

Let's start with the layout of @class{class} itself:

@example
((:class . #<class>)
 (:class-definition-name . <class>)
 (:class-precedence-list . #f)
 (:slots . (:class-definition-name
            :class-precedence-list
            :slots)))
@end example

@noindent
we see that the class of @class{class} is @class{class} itself.

As an example of class hierarchy, let's define a class with no
superclass and no slots:

@example
(define-class <biologic>)
@end example

@noindent
its layout is this:

@example
((:class . #<class>)
 (:class-definition-name . <biologic>)
 (:class-precedence-list . #f)
 (:slots . #f))
@end example

@noindent
now we derive a class from it, still without slots:

@example
(define-class <fruit> (<biologic>))
@end example

@noindent
@class{fruit} is a @dfn{subclass} of @class{biologic}, @class{biologic}
is a @dfn{superclass} of @class{fruit}; the layout of the subclass is:

@example
((:class . #<class>)
 (:class-definition-name . <fruit>)
 (:class-precedence-list . (#<biologic>))
 (:slots . #f))
@end example

@noindent
finally we subclass again adding slots:

@example
(define-class <apple> (<fruit>)
  :variety :colour :quality)
@end example

@noindent
and the layout is:

@example
((:class . #<class>)
 (:class-definition-name . <apple>)
 (:class-precedence-list . (#<fruit> #<biologic>))
 (:slots . (:variety :colour :quality)))
@end example

We have a usable class, so we instantiate it:

@example
(define o (make <apple>
            :variety 'renetta
            :colour  'green
            :quality 'high))
@end example

@noindent
and the layout of the instance is:

@example
((:class   . #<apple>)
 (:variety . renetta)
 (:colour  . green)
 (:quality . high))
@end example

We may want to add a price:

@example
(define-class <price> () :tag)

(define-class <priced-apple> (<apple> <price>))
@end example

@noindent
and the layout of the class with multiple inheritance is:

@example
((:class . #<class>)
 (:class-definition-name . <priced-apple>)
 (:class-precedence-list . (#<apple>
                            #<fruit>
                            #<biologic>
                            #<price>))
 (:slots . (:variety :colour :quality :tag)))
@end example

The instance of a priced apple:

@example
(define p (make <priced-apple>
            :variety 'renetta
            :colour  'green
            :quality 'high
            :tag 100))
@end example

@noindent
has layout:

@example
((:class   . #<priced-apple>)
 (:variety . renetta)
 (:colour  . green)
 (:quality . high)
 (:tag     . 100))
@end example

@c page
@node scmobj class
@section Classes


@menu
* scmobj class make::           Making classes
* scmobj class chart::          A chart for predefined classes
* scmobj class core::           Core class types.
* scmobj class list::           List types.
* scmobj class compound::       Non-list compound data types.
* scmobj class numeric::        Numeric data types.
* scmobj class port::           Port types.
* scmobj class misc::           Miscellaneous types.
@end menu

@c page
@node scmobj class make
@subsection Making classes


@deffn Syntax make-class @var{list-of-superclasses} . @var{class-slots}
Build and return a new class value.

@var{list-of-superclasses} is the list of superclasses of the new
class; acceptable values are:

@itemize
@item
The empty list, in which case @class{class} is added by default.

@item
A list containing only the @class{class} value.

@item
A list of previously defined base classes.
@end itemize

@var{class-slots} must be a list of symbols representing the slot names.
By convention their names should start with a colon character, @code{:}.
It is possible for a class to add no new slots, that is
@var{class-slots} can be the empty string: This allows subclassing for
the only purpose of method dispatching.

Notice that classes instantiated with @func{make-class} will have no
class definition name.  The @func{class-definition-name} function
applied to them will return the symbol @code{:uninitialised}.
@end deffn


@deffn Syntax define-class @var{name} @var{list-of-superclasses} . @var{class-slots}
A wrapper for @func{make-class} that defines a new variable named
@var{name} and assigns the new class to it.  The class definition name
of the class is initialised to @var{name}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Examples

Definition of a class with no superclasses and 3 slots named: @code{:a},
@code{:b} and @code{:c}:

@example
(define <one>
  (make-class () :a :b :c)
@end example

@noindent
the same with explicit selection of the base @class{class}:

@example
(define <one>
  (make-class (<class>) :a :b :c)
@end example

Simple inheritance:

@example
(let* ((<one>   (make-class ()      :a :b :c))
       (<two>   (make-class (<one>) :d :e :f))
       (<three> (make-class (<two>) :g :h :i)))
  ---)
@end example

@noindent
and multiple inheritance:

@example
(let* ((<one>   (make-class ()            :a :b :c))
       (<two>   (make-class (<one>)       :d :e :f))
       (<three> (make-class (<two> <one>) :g :h :i)))
  ---)
@end example

Defining classes using @func{define-class}:

@example
(define-class <one> ()
  :a :b :c)

(define-class <two> (<one>)
  :d :e :f)

(define-class <three> (<two>)
  :g :h :i)
@end example

@c page
@node scmobj class chart
@subsection A chart for predefined classes


@example
<class>
   |
   |                             -> <input-port>
   |                            |
   |                            +-> <output-port>
   |                            |
   |                            +-> <binary-port>
   |                            |
   |               --> <port> --+-> <textual-port>
   |              |
   |              +--> <record> --> <condition>
   |              |
   |              +--> <string>
   |              |
   |              +--> <char>
   v              |
<builtin-class> --+-------+-------+-----------+
   |              |       |       |           |
   v              v       v       v           v
<number>        <pair> <vector> <bytevector> <hashtable>
   |              |
   v              |
<complex>         +--------------+------------
   |              |              |            |
   v              v              v            v
<real-valued>   <list>    <dotted-list> <circular-list>
   |
   v
<real> ------> <flonum>
   |
   v
<rational-valued>
   |         |
   v         v
<rational> <integer-valued>
   |
   v
<integer>
   |
   v
<fixnum>
@end example

@c page
@node scmobj class core
@subsection Core class types


@deftp {Class} <class>
The base class of all the @library{scmobj} classes.
@end deftp


@deftp {Class} <builtin-class>
The base class builtin Scheme values.
@end deftp

@c page
@node scmobj class list
@subsection List types


@deftp Class @aclass{pair}
Class for values that satisfy @func{pair?}.
@end deftp


@deftp Class @aclass{list}
Class for values that satisfy @func{list?}.
@end deftp


@deftp Class @aclass{circular-list}
Class for values that satisfy @func{circular-list?}.  Notice that a pair
and a proper list are not circular lists.
@end deftp


@deftp Class @aclass{dotted-list}
Class for values that satisfy @func{dotted-list?}.  Notice that a pair
is always a dotted list, but a proper list is not a dotted list.
@end deftp

@c page
@node scmobj class compound
@subsection Non--list compound data types


@deftp Class @aclass{vector}
Class for values that satisfy @func{vector?}.
@end deftp


@deftp Class @aclass{bytevector}
Class for values that satisfy @func{bytevector?}.
@end deftp


@deftp Class @aclass{hashtable}
Class for values that satisfy @func{hashtable?}.
@end deftp


@deftp Class @aclass{record}
Class for values that satisfy @func{record?}.
@end deftp

@c page
@node scmobj class numeric
@subsection Numeric data types


@deftp Class @aclass{number}
Class for values that satisfy @func{number?}.
@end deftp


@deftp Class @aclass{complex}
Class for values that satisfy @func{complex?}.
@end deftp


@deftp Class @aclass{real-valued}
Class for values that satisfy @func{real-valued?}.
@end deftp


@deftp Class @aclass{real}
Class for values that satisfy @func{real?}.
@end deftp


@deftp Class @aclass{rational}
Class for values that satisfy @func{integer?}.
@end deftp


@deftp Class @aclass{rational-valued}
Class for values that satisfy @func{integer?}.
@end deftp


@deftp Class @aclass{integer-valued}
Class for values that satisfy @func{integer?}.
@end deftp


@deftp Class @aclass{integer}
Class for values that satisfy @func{integer?}.
@end deftp


@deftp Class @aclass{fixnum}
Class for values that satisfy @func{fixnum?}.
@end deftp


@deftp Class @aclass{flonum}
Class for values that satisfy @func{flonum?}.
@end deftp

@c page
@node scmobj class port
@subsection Port types


The following classes for input/output ports are predefined.


@deftp Class @aclass{port}
Class for values that satisfy @func{port?}.
@end deftp


@deftp Class @aclass{input-port}
Class for values that satisfy @func{input-port?}.
@end deftp


@deftp Class @aclass{output-port}
Class for values that satisfy @func{output-port?}.
@end deftp


@deftp Class @aclass{textual-port}
Class for values that satisfy @func{textual-port?}.
@end deftp


@deftp Class @aclass{binary-port}
Class for values that satisfy @func{binary-port?}.
@end deftp


The binary/textual attributes are not mututally exclusive with the
input/output attributes, so if we need it, we can use multiple
inheritance:

@example
(define-class <binary-input-port> (<binary-port> <input-port>))
@end example

@c page
@node scmobj class misc
@subsection Miscellaneous types


@deftp {Class} <condition>
Class for values that satisfy @func{condition?}.
@end deftp


@deftp {Class} <string>
Class for values that satisfy @func{string?}.
@end deftp


@deftp {Class} <char>
Class for values that satisfy @func{char?}.
@end deftp

@c page
@node scmobj instance
@section Instances


@deffn Macro make @var{class-object} . @var{init-slots}
Build and return a new instance object of class @var{class-object}.  The
optional arguments are symbol/value couples used to initialise the
slots: The symbol must be the name of a slot, the value its value.

It is @strong{not} mandatory to initialise all the slots in a class
instance.  Uninitialised slots will be initialised to the symbol
@code{:uninitialised}.
@end deffn


@subsubheading Examples

Instantiate a class with 3 slots:

@example
(let* ((<one> (make-class () :a :b :c))
       (o     (make <one>
                 :a 1 :b 2 :c 3)))
  ---)
@end example

Instantiate a class with superclasses, initialising all the slots:

@example
(let* ((<one>   (make-class () :a :b :c))
       (<two>   (make-class (<one>) :d :e :f))
       (<three> (make-class (<two>) :g :h :i))
       (o       (make <three>
                   :a 1 :b 2 :c 3
                   :d 4 :e 5 :f 6
                   :g 7 :h 8 :i 9)))
  ---)
@end example

@c page
@node scmobj inspect
@section Inspecting classes and instances


@defun class? @var{obj}
Does its best to determine if @var{obj} is a valid class object.
@end defun


@defun instance? @var{obj}
Does its best to determine if @var{obj} is a valid instance object.
@end defun


@defun class-of @var{class/instance}
Return the class of the argument.  This function can be applied to both
class objects and instance objects.  If this function is not able to
determine a class, it returns @false{}; this should never happen,
though.
@end defun


@defun is-a? @var{class/instance} @var{class}
Return true if @var{class/instance} is an object of class @var{class}.
This function can be applied to both class objects and instance objects.
@end defun


@defun subclass? @var{class-1} @var{class-2}
Return true if @var{class-1} is a subclass of @var{class-2}, false
otherwise.
@end defun


@defun class-definition-name @var{class}
Return the class definition name for @var{class}.  Note that the
definition name is set only for classes instantiated with
@func{define-class}, for classes instantiated with @func{make-class} the
return value is the symbol @code{:uninitialised}.
@end defun


@defun class-precedence-list @var{class}
Return a list of classes representing the class precendence list, used
for method dispatching.  Note that @var{class} itself is @strong{not}
part of the class precedence list.
@end defun


@defun class-slots @var{class}
Return a list of symbols representing the slot names of @var{class}.
The symbol @code{:class} is excluded.
@end defun


@defun class-direct-slots @var{class}
Return a list of symbols representing the slot names of @var{class},
excluding the slots of its superclasses.
@end defun

@c page
@node scmobj slot
@section Accessing slots


@defun slot-ref @var{object} @var{slot-name}
Return the value of @var{slot-name} in @var{object}.  @var{slot-name}
must be a symbol.  It is an error if @var{object} has no slot named
@var{slot-name}.
@end defun


@defun {slot-set!} @var{object} @var{slot-name} @var{new-value}
Overwrite the value of @var{slot-name} in @var{object} with
@var{new-value}.  @var{slot-name} must be a symbol.  It is an error if
@var{object} has no slot named @var{slot-name}.
@end defun

@c ------------------------------------------------------------

@subsubheading Examples

Basic slot access:

@example
(let* ((<one>  (make-class () :a :b :c))
       (o      (make <one>
                 :a 1 :b 2 :c 3)))

  (slot-set! o ':b 123)

  (list (slot-ref o ':b)
        (slot-ref o ':a)
        (slot-ref o ':c))) @result{} '(123 1 3)
@end example

It is possible to define simple accessors for slots like this:

@example
(define-class <one> ()
  :alpha :beta)

(define alpha
  (case-lambda
    ((o)
     (slot-ref  o ':alpha))
    ((o v)
     (slot-set! o ':alpha v))))

(define o (make <one> :alpha 123))

(alpha o)       @result{} 123
(alpha o 456)
(alpha o)       @result{} 456
@end example

@noindent
or better:

@example
(define-class <one> ()
  :alpha :beta)

(define (make-accessor slot-name)
  (case-lambda
    ((o)
     (slot-ref  o slot-name))
    ((o v)
     (slot-set! o slot-name v))))

(define o (make <one> :alpha 123))
(define alpha
  (make-accessor ':alpha))

(alpha o)       @result{} 123
(alpha o 456)
(alpha o)       @result{} 456
@end example

@noindent
and closure accessors are also possible:

@example
(define-class <one> ()
  :alpha :beta)

(define (make-accessor o slot-name)
  (case-lambda
    (()
     (slot-ref  o slot-name))
    ((v)
     (slot-set! o slot-name v))))

(define o (make <one> :alpha 123))
(define alpha
  (make-accessor o ':alpha))

(alpha)         @result{} 123
(alpha 456)
(alpha)         @result{} 456
@end example

@c page
@node scmobj generic
@section Generic functions and methods


@dfn{Generic functions} are procedures that can be specialized to the
classes of their arguments.  Each specialisation of a generic function
is called @dfn{method}.  When applying a generic function to a set of
arguments, the most specific method with respect to the arguments'
classes is chosen.

@menu
* scmobj generic application::  How generic functions and methods
                                are invoked.
* scmobj generic dispatching::  How methods are dispatched.
* scmobj generic define::       Defining generic functions and methods.
* scmobj generic next::         Invoking the next method.
* scmobj generic examples::     Examples of method dispatching.
@end menu

@c page
@node scmobj generic application
@subsection How generic functions and methods are invoked


@library{scmobj} allows the definition of four kinds of methods:
@code{:primary}, @code{:around}, @code{:before} and @code{:after}.  The
short description is that @code{:around} methods are applied first, then
@code{:before}, @code{:primary} and @code{:after} methods are applied in
this order.

When a generic function is applied to a tuple of arguments, the
following happens:

@enumerate
@item
For each argument in the tuple a class is determined.  The tuple of
classes is called @dfn{signature}.
@end enumerate

For each kind of method, the generic function maintains an internal
collection in which every method's closure is associated to a signature.

@enumerate 2
@item
For each kind of method: The internal collection is queried for all the
methods applicable to the tuple of arguments, using the signature as
search key.

@item
For each kind of method: The list of applicable methods is sorted from
the more specific to the least specific for the signature.  The list of
@code{:after} methods is reversed.
@end enumerate

From now on the lists of sorted, applicable methods are handled as
stacks; the stacks of @code{:primary}, @code{:around} and @code{:before}
methods have most specific method on the top; the stack of @code{:after}
methods has the least specific method on the top.

From now on the application of the generic function enters an implicit
loop in which more methods' closures can be applied to the same tuple of
arguments.  The loop can terminate if a method's closure throws an
exception or, for @code{:around} and @code{:primary} methods, if it does
not take the special action of calling @func{call-next-method}.

The loop is a bit articulated, so we may have to read the following
descriptions multiple times.  We split the description in two branches:
First a simplified invocation for generic functions having at least one
applicable @code{:primary} method, no @code{:around} methods, and
performing no calls to @func{call-next-method}; then the full
application algorithm.

Here is the simplified branch with no @code{:around} methods and no
calls to @func{call-next-method}:

@enumerate 4
@item
Pop all the @code{:before} methods from the stack and apply their
closures to the tuple of arguments.  The return values of these
applications are discarded.

@item
Pop the next @code{:primary} method from the stack and apply its closure
to the tuple of arguments.  The return value of this application is
saved in a temporary location.

@item
Pop all the @code{:after} methods from the stack and apply their
closures to the tuple of arguments.  The return values of these
applications are discarded.

@item
Return the saved return value of the @code{:primary} method.
@end enumerate

Here is the full application algorithm:

@enumerate 4
@item
Test if this function application originated from a call to
@func{call-next-method} from a @code{:before} or @code{:after} method.
If it has: Raise an assertion violation.

@item
Test if this function application originated from a call to
@func{call-next-method} from a @code{:primary} method.  If it has:

@enumerate a
@item
If the stack of @code{:primary} methods is empty raise an assertion
violation.

@item
Pop the next @code{:primary} method from the stack and apply its closure
to the tuple of arguments.

@item
Break out returning the return value of this application: It becomes the
return value of @func{call-next-method}.
@end enumerate

@item
If the stack of @code{:primary} methods is empty: Raise an assertion
violation.  This condition means that the generic function has no
applicable methods for the tuple of arguments.

@item
If the stack of @code{:around} methods is not empty: Pop the next
@code{:around} method and apply its closure to the tuple of arguments.
Break out returning the return value of this application.

@item
Pop all the @code{:before} methods from the stack and apply their
closures to the tuple of arguments.  The return values of these
applications are discarded.

@item
Pop the next @code{:primary} method from the stack and apply its closure
to the tuple of arguments.  The return value of this application is
saved in a temporary location.

@item
Pop all the @code{:after} methods from the stack and apply their
closures to the tuple of arguments.  The return values of these
applications are discarded.

@item
Return the saved return value of the @code{:primary} method.
@end enumerate

The @code{:primary} methods are meant to do the real work of the
function.  Only the most specific is applied to the arguments, however
it can use @func{call-next-method} to invoke a least specialised version
and use its return value.

@code{:before} and @code{:after} methods are meant to execute additional
work before and after the primary methods.  While @code{:before} methods
are applied from the most specific to the least specific, @code{:after}
methods are applied from the least specific to the most specific.
Notice that the @code{:after} methods have no access to the return value
of the @code{:primary} methods.

@code{:around} methods are yet another level for performing tasks before
and after the primary methods; only the most specific is applied to the
arguments.  It is expected, but not mandatory, that an @code{:around}
method invokes @func{call-next-method}; such invocations will consume
all the applicable @code{:around} methods, from the least to the most
specific, and then will start the application of @code{:before},
@code{:primary} and @code{:after} methods.

@c page
@node scmobj generic dispatching
@subsection How methods are dispatched


Here we attempt the formulation of the rules by which methods are
dispatched.  A method is identified by a triplet of values: a list of
classes, called signature, representing the classes or expected
arguments; a boolean value telling if the closure accepts rest
arguments; the closure.

@c ------------------------------------------------------------

@subsubheading Applicability

First we need to understand when a method is applicable to a tuple of
arguments.  Given a tuple of arguments, a method supporting no rest
arguments is applicable to it if:

@enumerate
@item
The length of the signature is equal to the length of the arguments'
tuple.

@item
Position by position, the class in the signature is @func{eq?} to the
class of the value in the tuple, or it is in the class precedence list
of the class of the value in the tuple.
@end enumerate

@noindent
a method supporting rest arguments is applicable to it if:

@enumerate
@item
The length of the signature is less than or equal to the length of the
arguments' tuple.

@item
Position by position, up to the last element in the signature, the class
in the signature is @func{eq?} to the class of the value in the tuple,
or it is in the class precedence list of the class of the value in the
tuple.
@end enumerate

@c ------------------------------------------------------------

@subsubheading Specificity

Now we can understand how to determine which one, among two applicable
methods, is more specific for a tuple of arguments.  Let's call the
methods @var{A} and @var{B}.  Notice that it is impossible for two
distinct methods, in the same generic function, to have the same
signature and the same support for rest arguments.

@enumerate
@item
If both @var{A} and @var{B} support rest arguments: The one with the
longest signature is more specific.

@item
The classes in the signatures are compared in couples, position by
position from the beginning to the end.

@enumerate a
@item
If the classes are @func{eq?}, the next couple is inspected.

@item
If the class from @var{A} is a subclass of the one from @var{B}: Then
@var{A} is more specific than @var{B}.  If no subclass relation exists
between the two, the next couple is inspected.

@item
For the current position, the class of the value in the tuple of
arguments is determined, its class precedence acquired.  The positions
of the classes from the signatures in the class precedence list is
computed: If the class from @var{A} comes first, then @var{A} is more
specific than @var{B}.
@end enumerate

@item
If the methods' signatures have the same length, and, position by
position, the classes of @var{A} are @func{eq?} to the classes of
@var{B}, but @var{A} supports rest arguments while @var{B} does not:
Then @var{B} is more specific than @var{A}.
@end enumerate

@c page
@node scmobj generic define
@subsection Defining generic functions and methods


The number of arguments (arity) of a generic function is undefined:
Every method can have a different number of arguments.


@deffn Macro define-generic @var{name}
Define a new generic function and bind it to @var{name}.
@end deffn


@defun make-generic-function
Build and return a new generic function.
@end defun


@deffn Macro declare-method @var{generic} (@var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method (@var{generic} @var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method @var{generic} :primary (@var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method @var{generic} :before (@var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method @var{generic} :after (@var{arg-spec} ...) . @var{body}
@deffnx Macro declare-method @var{generic} :around (@var{arg-spec} ...) . @var{body}
Add a new method to an already existent generic function, @var{generic}.
A declaration is @strong{not} a definition.  @nauref{baselib definitions,
Definitions}

The qualifier specifies the kind of method; when the qualifier is not
present, it defaults to @code{:primary}.

The list of @var{arg-spec} specifies the classes of the values for which
the method specialises the function.  Notice that rest arguments are
supported and specified with the usual syntax.  A @var{arg-spec} can be:

@table @code
@item (@var{arg} @var{class})
Where @var{arg} is the formal name of the argument and @var{class} the
class of expected values.

@item @var{arg}
Where @var{arg} is the formal name of the argument.  In this case the
class defaults to @true{}, which is interpreted as superclass of every
other class.
@end table

If a method is defined with the same signature, and support for rest
arguments, of an already registered method: The old method is
overwritten by the new one.  Two methods having, position by position,
arguments of the same class, but such that one supports rest arguments
and the other does not, are different.
@end deffn


@deffn Macro add-method @var{generic} @var{signature} @var{has-rest} @var{closure}
@deffnx Macro add-method @var{generic} :primary @var{signature} @var{has-rest} @var{closure}
@deffnx Macro add-method @var{generic} :before @var{signature} @var{has-rest} @var{closure}
@deffnx Macro add-method @var{generic} :after @var{signature} @var{has-rest} @var{closure}
@deffnx Macro add-method @var{generic} :around @var{signature} @var{has-rest} @var{closure}
Add a new method to an already existent generic function, @var{generic}.
@var{signature} must be a list of classes for which the method
specialises the function.  @var{closure} must be the method's closure.
When the method qualifier is not present, it defaults to
@code{:primary}.  @var{has-rest} must be @true{} or @false{}, when
@true{} it means that the closure supports rest arguments.
@end deffn

@c page
@node scmobj generic next
@subsection Invoking the next method


@defun call-next-method
To be invoked from a @code{:primary} or @code{:around} method.  Call the
next most specific method.
@end defun


@defun next-method?
Return true if a next method is available.  Available next methods are
@code{:primary} and @code{:around} methods.  After the first
@code{:primary} method has been called, only @code{:primary} methods are
considered.

It can be invoked by any kind of method.
@end defun

@c page
@node scmobj generic examples
@subsection Examples of method dispatching.


Here we show with some examples what we have to expect from the
multimethod dispatching of @library{scmobj}.  In the following examples
the string @code{%apple} is written in place of the value bound to the
symbol @class{apple}.


@subsubheading Simple inheritance

Let's examine this example:

@example
(define-class <top> ())
(define-class <one> (<top>))
(define-class <two> (<one>))
(define-class <c>   (<two>))
@end example

@noindent
the class hierarchy is:

@example
<top> -> <one> -> <two> -> <c>
@end example

@noindent
and the full class precedence list for @class{c} is:

@example
(cons <c> (class-precedence-list <c>))
@result{} (%c %two %one %top)
@end example

@noindent
so for the generic function:

@example
(define-generic doit)
(declare-method doit ((o <one>)) 'one)
(declare-method doit ((o <two>)) 'two)
@end example

@noindent
applied to a value of class @class{c}: the method with @class{two} in
the signature is @emph{more specific} than the method with @class{one}
in the signature:

@example
(doit (make <c>)) @result{} two
@end example

@c ------------------------------------------------------------

@subsubheading Multiple inheritance


Let's examine this example:

@example
(define-class <top> ())
(define-class <one> (<top>))
(define-class <two> (<top>))
(define-class <c> (<two> <one>))
@end example

@noindent
the class hierarchy is:

@example
<top> -+-> <one> -+-> <c>
       |          |
        -> <two> -
@end example

@noindent
and given the order in which the classes where handed to
@func{define-class}, the class precedence list for @class{c} is:

@example
(cons <c> (class-precedence-list <c>))
@result{} (%c %two %one %top)
@end example

@noindent
so for the generic function:

@example
(define-generic doit)
(declare-method doit ((o <one>)) 'one)
(declare-method doit ((o <two>)) 'two)
@end example

@noindent
applied to a value of class @class{c}: The method with @class{two} in
the signature is @emph{more specific} than the method with @class{one}
in the signature:

@example
(doit (make <c>)) @result{} two
@end example

Another multiple inheritance example:

@example
(define-class <top> ())
(define-class <one> (<top>))
(define-class <two> (<top>))
(define-class <three> (<two>))
(define-class <c> (<three> <one>))
@end example

@noindent
the class hierarchy is:

@example
<top> -+-------> <one> ------+-> <c>
       |                     |
        -> <two> -> <three> -
@end example

@noindent
and given the order in which the classes where handed to
@func{define-class}, the class precedence list for @class{c} is:

@example
(cons <c> (class-precedence-list <c>))
@result{} (%c %three %two %one %top)
@end example

@noindent
so for the generic function:

@example
(define-generic doit)
(declare-method doit ((o <one>)) 'one)
(declare-method doit ((o <two>)) 'two)
@end example

@noindent
applied to a value of class @class{c}: The method with @class{two} in
the signature is @emph{more specific} than the method with @class{one}
in the signature:

@example
(doit (make <c>)) @result{} two
@end example

@c ------------------------------------------------------------

@subsubheading Other examples

Let's look at this:

@example
(define-class <top> ())
(define-class <c>   (<top>))
(define-class <one> (<c>))

(define-generic doit)
(declare-method doit ((o <one>)) 'one)

(doit (make <c>))
@end example

@noindent
this will result in a ``no method defined for these argument classes'
error because a value of class @class{c} is @strong{not} a value of
class @class{one}.  For a method to be applicable: the class from the
signature of the method has to be in in the class list of the argument,
not vice versa.  That is:

@example
(subclass? <c> <one>)
@end example

@noindent
must evaluate to true.

@c ------------------------------------------------------------

@subsubheading Kinds of methods

In the examples for the application of different kinds of methods, we
will make use of the following hierarchy of classes:

@example
(define-class <a> () :a)
(define-class <b> () :b)
(define-class <c> () :c)
(define-class <d> () :d)
(define-class <e> () :e)

(define-class <pp> (<a> <b>))
(define-class <qq> (<c> <d>))
(define-class <rr> (<pp> <e> <qq>))

(define pp (make <pp> :a 1 :b 2))
(define qq (make <qq> :c 3 :d 4))
(define rr (make <rr> :a 10 :b 20 :c 30 :d 40))
@end example

First some error case.  The following will raise an error because
@code{:before} methods are forbidden to @func{call-next-method}:

@example
(define-generic alpha)

(declare-method alpha ((o <a>))
  1)

(declare-method alpha :before ((o <a>))
  (call-next-method))

(alpha pp)
@end example

The following will raise an error because we @func{call-next-method}
when no next method is available:

@example
(define-generic alpha)

(declare-method alpha ((o <a>))
  (call-next-method))

(alpha pp)
@end example

The following will raise an error because we apply a generic function
when no @code{:primary} method has been defined:

@example
(define-generic alpha)

(declare-method alpha :around ((o <a>))
  (call-next-method))

(alpha pp)
@end example

Here is a full example showing the order of applications for all the
kinds of methods; it makes use of the @func{with-result} and
@func{add-result} forms from the @library{checks} library:

@example
(define-generic alpha)

(declare-method alpha :before ((o <rr>)) (add-result 1))
(declare-method alpha :before ((o <pp>)) (add-result 2))
(declare-method alpha :before ((o <a>))  (add-result 3))
(declare-method alpha :before ((o <b>))  (add-result 4))
(declare-method alpha :before ((o <e>))  (add-result 5))

(declare-method alpha :after  ((o <rr>)) (add-result 10))
(declare-method alpha :after  ((o <pp>)) (add-result 9))
(declare-method alpha :after  ((o <a>))  (add-result 8))
(declare-method alpha :after  ((o <b>))  (add-result 7))
(declare-method alpha :after  ((o <e>))  (add-result 6))

(declare-method alpha :around  ((o <rr>)) (cons 1 (call-next-method)))
(declare-method alpha :around  ((o <pp>)) (cons 2 (call-next-method)))
(declare-method alpha :around  ((o <a>))  (cons 3 (call-next-method)))
(declare-method alpha :around  ((o <b>))  (cons 4 (call-next-method)))
(declare-method alpha :around  ((o <e>))  (cons 5 (call-next-method)))

(declare-method alpha :primary ((o <rr>)) (cons 6 (call-next-method)))
(declare-method alpha :primary ((o <pp>)) (cons 7 (call-next-method)))
(declare-method alpha :primary ((o <a>))  (cons 8 (call-next-method)))
(declare-method alpha :primary ((o <b>))  (cons 9 (call-next-method)))
(declare-method alpha :primary ((o <e>))  10)

(with-result (alpha rr))
@result{} ((1 2 3 4 5 6 7 8 9 . 10)
    (1 2 3 4 5 6 7 8 9 10))
@end example

@noindent
notice, in particular, how multiple inheritance is handled: Methods for
the @class{b} and @class{e} classes, coming as seconds in the class
inheritance lists, are applied after the methods of the @class{a} and
@class{pp} classes.

Now let's consider a the following class hierarchy with diamond
inheritance:

@example
(define-class <t> ()    :t)   ;  <t>---+
(define-class <x> (<t>) :x)   ;        v
(define-class <y> (<x>) :y)   ;   --- <x> ---
(define-class <w> (<x>) :w)   ;  |           |
(define-class <z> (<y> <w>))  ;  v           v
                              ; <y>         <w>
                              ;  |           |
                              ;   --> <z> <--

(define z (make <z> :t 0 :x 1 :y 2 :w 3))
@end example

@noindent
and let's define and apply all the kinds of methods:

@example
(define-generic alpha)

(declare-method alpha :around ((o <z>))  (cons 1 (call-next-method)))
(declare-method alpha :around ((o <y>))  (cons 2 (call-next-method)))
(declare-method alpha :around ((o <w>))  (cons 3 (call-next-method)))
(declare-method alpha :around ((o <x>))  (cons 4 (call-next-method)))
(declare-method alpha :around ((o <t>))  (cons 5 (call-next-method)))

(declare-method alpha :primary ((o <z>)) (cons 6 (call-next-method)))
(declare-method alpha :primary ((o <y>)) (cons 7 (call-next-method)))
(declare-method alpha :primary ((o <w>)) (cons 8 (call-next-method)))
(declare-method alpha :primary ((o <x>)) (cons 9 (call-next-method)))
(declare-method alpha :primary ((o <t>)) 10)

(declare-method alpha :before ((o <z>))  (add-result 1))
(declare-method alpha :before ((o <y>))  (add-result 2))
(declare-method alpha :before ((o <w>))  (add-result 3))
(declare-method alpha :before ((o <x>))  (add-result 4))
(declare-method alpha :before ((o <t>))  (add-result 5))

(declare-method alpha :after ((o <z>))   (add-result 10))
(declare-method alpha :after ((o <y>))   (add-result 9))
(declare-method alpha :after ((o <w>))   (add-result 8))
(declare-method alpha :after ((o <x>))   (add-result 7))
(declare-method alpha :after ((o <t>))   (add-result 6))

(with-result (alpha z))
@result{} ((1 2 3 4 5 6 7 8 9 . 10)
    (1 2 3 4 5 6 7 8 9 10))
@end example

Here is yet another example with diamond inheritance:

@example
(define-class <0> () :0)        ;    <0>--+
(define-class <1> (<0>) :1)     ;         v
(define-class <2> (<1>) :2)     ;   ---- <1> ----
(define-class <3> (<1>) :3)     ;  |             |
(define-class <4> (<3>) :4)     ;  v             |
(define-class <5> (<4> <2>))    ; <3>            |
                                ;  |             |
                                ;  v             v
                                ; <4>           <2>
                                ;  |             |
                                ;   ---> <5> <---

(define n (make <5> :0 0 :1 1 :2 2 :3 3 :4 4))
@end example

@noindent
and let's define and apply all the kinds of methods:

@example
(define-generic alpha)

(declare-method alpha :around ((o <5>))  (cons 1 (call-next-method)))
(declare-method alpha :around ((o <4>))  (cons 2 (call-next-method)))
(declare-method alpha :around ((o <3>))  (cons 3 (call-next-method)))
(declare-method alpha :around ((o <2>))  (cons 4 (call-next-method)))
(declare-method alpha :around ((o <1>))  (cons 5 (call-next-method)))
(declare-method alpha :around ((o <0>))  (cons 6 (call-next-method)))

(declare-method alpha :primary ((o <5>)) (cons 7 (call-next-method)))
(declare-method alpha :primary ((o <4>)) (cons 8 (call-next-method)))
(declare-method alpha :primary ((o <3>)) (cons 9 (call-next-method)))
(declare-method alpha :primary ((o <2>)) (cons 10 (call-next-method)))
(declare-method alpha :primary ((o <1>)) (cons 11 (call-next-method)))
(declare-method alpha :primary ((o <0>)) 12)

(declare-method alpha :before ((o <5>))  (add-result 1))
(declare-method alpha :before ((o <4>))  (add-result 2))
(declare-method alpha :before ((o <3>))  (add-result 3))
(declare-method alpha :before ((o <2>))  (add-result 4))
(declare-method alpha :before ((o <1>))  (add-result 5))
(declare-method alpha :before ((o <0>))  (add-result 6))

(declare-method alpha :after ((o <5>))   (add-result 12))
(declare-method alpha :after ((o <4>))   (add-result 11))
(declare-method alpha :after ((o <3>))   (add-result 10))
(declare-method alpha :after ((o <2>))   (add-result 9))
(declare-method alpha :after ((o <1>))   (add-result 8))
(declare-method alpha :after ((o <0>))   (add-result 7))

(with-result (alpha n))
@result{} ((1 2 3 4 5 6 7 8 9 10 11 . 12)
    (1 2 3 4 5 6 7 8 9 10 11 12)))
@end example

We can conclude that, when it comes to method application:

@itemize
@item
If diamond inheritance is not present: The graph of inheritance is a
tree, which is flattened to a list representing the visit of a preorder
iterator.

@item
When diamond inheritance is present: Diamond groups are flattened to a
list with classes in the middle at the center:

@example
  -- <x> --
 |         |
 v         v
<y>       <w>       @result{}   (<z> <y> <w> <x>)
 |         |
  -> <z> <-

  ---- <1> ----
 |             |
 v             |
<3>            |
 |             |    @result{}  (<5> <4> <3> <2> <1>)
 v             v
<4>           <2>
 |             |
  ---> <5> <---
@end example

@noindent
then the graph is flattened and visited in preorder.
@end itemize

@c page
@node sexps
@chapter Handling symbolic expressions


The @library{sexps} and @library{sexps syntax} libraries implement
matching procedures and macros for symbolic expressions (S--expressions
or @dfn{sexp}).  The libraries are built on top of @library{classes}.

@menu
* sexps match::                 Plain matching.
* sexps operators::             Matching operators.
* sexps transform::             Transforming S--expressions.
@end menu

@c page
@node sexps match
@section Plain matching


Let's start with some example of sexp matching:

@example
(let ((pattern '(a 1 #t))
      (form    '(a 1 #t))
  (sexp-match pattern form))
@result{} ()

(sexp-match '(a b) '(a c))
@error{} mismatch between B and C

(sexp-match `(a ,(sexp-pred integer?))
            '(a 1))
@result{} ()

(sexp-match `(a ,(sexp-pred integer?))
            '(a b))
@error{} mismatch between INTEGER? and B
@end example

@noindent
the @library{sexps} library defines several @dfn{matching operators},
and custom ones can be easily coded.  @ref{sexps operators, Matching
operators}


@defun sexp-match @var{pattern} @var{form}
Recursively match elements in the sexp template @var{pattern} with
elements in the sexp @var{form}.  Return an alist whose entries
represent the bindings between variables from @var{pattern} and values
from @var{form}, or null if no bindings where defined.

If a mismatch between @var{pattern} and @var{form} is detected, an error
is raised with condition of type @condition{sexp-mismatch}.

@var{pattern} must be a sexp template with the following constraints and
semantics meaning:

@itemize
@item
@var{pattern} must be null or a proper list.  If it is null, it can
match only a null @var{form}.

@item
If an element of @var{pattern} is a pair, it must be the first pair in a
proper list; the list is interpreted as a nested sexp pattern.

@item
If an element of @var{pattern} is a procedure, it must be a matching
operator.  @ref{sexps operators, Matching operators}

@item
Every other element is compared to the elements of @var{form} using
@func{equal?}.
@end itemize

@var{form} must be a sexp whose elements have the following constraints
and semantics meaning:

@itemize
@item
@var{form} must be null or a proper list.  If it is null, it can be
matched both by a null @var{pattern} and by a @var{pattern} holding an
appropriate matching operator.

@item
If an element of @var{form} is a pair, it is @strong{not} mandatory for
it to be the first pair in a proper list.  A proper list in @var{form}
can be matched by a proper list in @var{pattern}.  In general, whether a
pair in @var{form} will be matched or not depends on the operators in
@var{pattern}.

@item
Every other element is compared to the elements of @var{pattern} using
@func{equal?}.  Notice that the behaviour of @func{equal?} with respect
to procedures is undefined in @rnrs{6}; it appears there is no safe way
to match a procedure in @var{form}.
@end itemize
@end defun


@defun sexp-match? @var{pattern} @var{form}
Like @func{sexp-match} but return @true{} when successfully matches and
@false{} otherwise.
@end defun


@deffn Syntax sexp-mismatch-error @var{who} @var{pattern} @var{form}
Raise a non--continuable exception with conditions of type
@condition{sexp-mismatch}, @condition{message}, @condition{who}.  All the arguments
are evaluated only once.
@end deffn


@deftp {Condition Type} &sexp-mismatch
Type of condition used to signal a sexp mismatch.  It is derived from
@condition{mismatch}.
@end deftp


@defun make-sexp-mismatch-condition @var{pattern-token} @var{form-token}
Return a new condition object of type @condition{sexp-mismatch}.
@var{pattern-token} must be a value representing the portion of sexp
pattern which failed to match.  @var{form-token} must be a value
representing the portion of sexp form which failed to match.
@end defun

@defun sexp-mismatch-condition? @var{obj}
Return @true{} if @var{obj} is a condition object of type
@condition{sexp-mismatch}.
@end defun


@defun condition-sexp-mismatch/pattern @var{obj}
@defunx condition-sexp-mismatch/form @var{obj}
Accessors for the fields of a @condition{sexp-mismatch} condition object.
@end defun

@c page
@node sexps operators
@section Matching operators


A @dfn{matching operator} is a function (usually a closure) which is
applied to a sexp form with the purpose of matching zero, one or more
elements in it.  An operator can consume any number of tokens from its
form argument.

@itemize
@item
If successful, it must return two values:

@enumerate
@item
The alist of bindings defined by the matching (see variables matching
below), which can be null.

@item
The tail of the form still to match.
@end enumerate

@item
If a mismatch is detected, it must raise a @condition{sexp-mismatch}
condition.
@end itemize

@menu
* sexps operators examples::    Operator examples.
* sexps operators variable::    Variable matching.
* sexps operators predicate::   Predicate matching.
* sexps operators logic::       Logic matching.
@end menu

@c page
@node sexps operators examples
@subsection Operator examples


An operator which matches nothing and returns the whole form looks like
this:

@example
(define (match-nothing form)
  (values '() form))
@end example

@noindent
and it can be used as follows:

@example
(sexp-match `(a b ,match-nothing) '(a b))
@result{} ()

(sexp-match `(,match-nothing) '())
@result{} ()
@end example

An operator which matches the symbol @samp{alpha} looks like this:

@example
(define (alpha-op form)
  (cond ((null? form)
         (sexp-mismatch-error #f 'alpha form))
        ((eq? 'alpha (car form))
         (values '() (cdr form)))
        (else
         (sexp-mismatch-error #f 'alpha form))))
@end example

@noindent
it can be parametrised with a symbol argument like:

@example
(define (sexp-symbol symbol)
  (lambda (form)
    (cond ((null? form)
           (sexp-mismatch-error #f symbol form))
          ((eq? symbol (car form))
           (values '() (cdr form)))
          (else
           (sexp-mismatch-error #f symbol form)))))
@end example

@noindent
and it can be used as follows:

@example
(sexp-match `(a b ,(sexp-symbol 'alpha))
            '(a b alpha))
@result{} ()

(sexp-match `(,(sexp-symbol 'alpha) ,(sexp-symbol 'beta))
            '(alpha beta))
@result{} ()
@end example

@noindent
in the last example, the first operator's closure is invoked with:

@example
form @equiv{} (alpha beta)
@end example

@noindent
and the second operator's closure is invoked with:

@example
form @equiv{} (beta)
@end example

@c page
@node sexps operators variable
@subsection Variable matching


To extract a value from a sexp form we use @dfn{variables matching}
operators.  It works like this:

@example
(define ?alpha (make-sexp-variable '?alpha 1))
(define ?beta  (make-sexp-variable '?beta  2))

(sexp-match `(,(sexp-var ?alpha) ,(sexp-var ?beta))
            '(91 92))
@result{} ((#<record sexp-variable ?alpha> . 91)
    (#<record sexp-variable ?beta>  . 92))
@end example

@noindent
the resulting alist of bindings can be inspected with @func{assq} using
the @samp{sexp-variable} records as keys.  A variable matching operator
matches any value but null.


@defun sexp-var @var{variable}
Used to extract a value from a form, return a matching operator.
@var{variable} must be a record of type @samp{sexp-variable}.
@end defun


@defun sexp-var-rest @var{variable}
Used to extract a list of values from a form, return a matching
operator.  @var{variable} must be a record of type @samp{sexp-variable}.
This operator matches all its input form and binds it to the variable;
the input form can be null.
@end defun


@deftp Class sexp-variable
Record type used to assign a name to values from sexp forms.
@end deftp


@defcv {Immutable Field} @aclass{sexp-variable} name
The public name of the variable, to be used for debugging purposes.
@end defcv


@defcv {Immutable Field} @aclass{sexp-variable} default
A default value for the variable in case the sexp form does no bind it.
When using a transformer the sentinel value has a special meaning.
@nauref{sentinel, The sentinel value}
@end defcv


@defun make-sexp-variable @var{name} @var{default}
Build and return a new @samp{sexp-variable} record.
@end defun


@defun sexp-variable? @var{obj}
Return @true{} if @var{obj} is a record of type @samp{sexp-variable}.
@end defun


@defun sexp-variable-name @var{obj}
@defunx sexp-variable-default @var{obj}
Accessors for the fields of a @samp{sexp-variable} record.
@end defun


@deffn Syntax let-sexp-variables ((@ameta{var} @ameta{default}) ...) @ameta{body}
Similar to @func{let}, build a set of @samp{sexp-variable} records and
bind them to @meta{var} identifiers.  The body is evaluated in the
current environment extended with the variables bindings.

@example
(let-sexp-variables ((?alpha 1)
                     (?beta  2))
  (sexp-match `(,(sexp-var ?alpha) ,(sexp-var ?beta))
              '(91 92)))
@result{} ((#<record sexp-variable ?alpha> . 91)
    (#<record sexp-variable ?beta>  . 92))
@end example
@end deffn

@c page
@node sexps operators predicate
@subsection Predicate matching


A @dfn{predicate matching} operator can be used to match any value from
a sexp form:

@example
(sexp-match `(,(sexp-pred integer?)) '(123))
@result{} ()

(sexp-match `(,(sexp-pred null?)) '())
@result{} ()

(sexp-match `(((,(sexp-pred positive?)))) '(((123))))
@result{} ()
@end example

@noindent
a predicate matching operator matches any value for which the predicate
returns true.

@defun sexp-pred @var{pred}
Used to match a value using a Scheme predicate procedure.  @var{pred}
must be a procedure returning true or @false{}.
@end defun

@c page
@node sexps operators logic
@subsection Logic matching


@deffn Function sexp-or @var{pattern-token} ...
@deffnx Syntax sexp-or* @ameta{pattern-token} ...
Return an operator which attempts to match the car of the form with each
@var{pattern-token}, halting at the first positive match.  The match of
the operator is positive if at least one of the alternatives does match.

@func{sexp-or*} behaves like @func{sexp-or}, but quotes each of its
arguments.

@example
(sexp-match `(,(sexp-or 'a 'b 'c)) '(a)) @result{} '()
(sexp-match `(,(sexp-or 'a 'b 'c)) '(b)) @result{} '()
(sexp-match `(,(sexp-or 'a 'b 'c)) '(c)) @result{} '()

(sexp-match `(,(sexp-or* a b c)) '(a)) @result{} '()
(sexp-match `(,(sexp-or* a b c)) '(b)) @result{} '()
(sexp-match `(,(sexp-or* a b c)) '(c)) @result{} '()
@end example

Notice that the arguments of @func{sexp-or*} must be pattern tokens, not
pattern sexps:

@example
(sexp-match `(,(sexp-or* (a) (b) (c))) '((a))) @result{} '()
(sexp-match `(,(sexp-or* (a) (b) (c))) '((b))) @result{} '()
(sexp-match `(,(sexp-or* (a) (b) (c))) '((c))) @result{} '()
@end example

If @func{sexp-or} invoked with no arguments, it returns an operator
which matches nothing and always raises a sexp mismatch error; this is
consistent with @code{(or)} returning @false{} in @rnrs{6}.
@end deffn


@deffn Function sexp-and @var{pattern-token} ...
@deffnx Syntax sexp-and* @ameta{pattern-token} ...
Return an operator which attempts to match the car of the form with each
@var{pattern-token}, halting at the first mismatch.  The match of the
operator is positive if all the alternatives do match.

@func{sexp-and*} behaves like @func{sexp-and}, but quotes each of its
arguments.

If @func{sexp-and} is invoked with no arguments, it returns an operator
which always matches a single token; this is consistent with
@code{(and)} returning @true{} in @rnrs{6}.

@example
(sexp-match `(,(sexp-and* a)) '(a))      @result{} '()
(sexp-match `(,(sexp-and) b)  '(a b))    @result{} '())

(let-sexp-variables ((?v 0))
  (sexp-match `(,(sexp-and (sexp-pred integer?)
                           (sexp-var ?v)))
              '(123)))
@result{} ((#<record sexp-variable ?v> . 123))
@end example
@end deffn


@deffn Function sexp-any @var{pattern-token}
@deffnx Syntax sexp-any* @ameta{pattern-token}
Return an operator which attempts to match every sexp in the form with
@var{pattern-token}, halting at the first mismatch.  It is fine if
@var{pattern-token} does not match the car of the form.

@func{sexp-any*} behaves like @func{sexp-any}, but quotes its argument.

@example
(sexp-match `(,(sexp-any* a)) '())      @result{} '()
(sexp-match `(,(sexp-any* a)) '(a))     @result{} '()
(sexp-match `(,(sexp-any* a)) '(a a))   @result{} '()
(sexp-match `(,(sexp-any* a)) '(a a a)) @result{} '()

(sexp-match `(,(sexp-any* a) b) '(b))       @result{} '()
(sexp-match `(,(sexp-any* a) b) '(a b))     @result{} '()
(sexp-match `(,(sexp-any* a) b) '(a a b))   @result{} '()
(sexp-match `(,(sexp-any* a) b) '(a a a b)) @result{} '()
@end example
@end deffn


@deffn Function sexp-one @var{pattern-token}
@deffnx Syntax sexp-one* @ameta{pattern-token}
Like @func{sexp-any}, but @var{pattern-token} must match at least the
car of the form.
@end deffn

@c page
@node sexps transform
@section Transforming S--expressions


A sexp transformer is used to match a sexp with a pattern, extracting
variable values from it.  The position of the ``variables'' in the sexp
form is marked by objects of type @samp{sexp-variable}.  Example:

@example
(import (nausicaa)
  (sexps)
  (sentinel))

(define trans
  (let-sexp-variables ((?a sentinel)
                       (?b sentinel))
    (make-sexp-transformer `(doit (alpha ,(sexp-var ?a))
                                  (beta  ,(sexp-var ?b)))
                           `(doit ,?a ,?b))))

(trans '(doit (alpha 1) (beta 2)))
@result{} (doit 1 2)
@end example

@noindent
the following example makes use of the default values for unbound
variables:

@example
(import (nausicaa)
  (sexps)
  (sentinel))

(define trans
  (let-sexp-variables ((?a 10)
                       (?b 20))
    (make-sexp-transformer
      `(doit ,(sexp-any (sexp-or `(alpha ,(sexp-var ?a))
                                 `(beta  ,(sexp-var ?b)))))
      `(doit ,?a ,?b))))

(trans '(doit (alpha 1) (beta 2)))
@result{} (doit 1 2)

(trans '(doit (alpha 1)))
@result{} (doit 1 20)

(trans '(doit (beta 2)))
@result{} (doit 10 2)

(trans '(doit))
@result{} (doit 10 20)
@end example


@defun make-sexp-transformer @var{pattern} @var{output}
Return a function that takes a sexp, matches it to the @var{pattern}
sexp, extracts bindings for the variables, and returns a copy of the
sexp @var{output} with the variables substituted by their values.

If a variable referenced by @var{output} is left undefined by the
bindings:

@itemize
@item
If the variable has default value set to the @code{sentinel} value from
@library{sentinel}: an error is raised.

@item
If the variable has default value different from the @code{sentinel}
value from @library{sentinel}: the default value is substituted.
@end itemize

See @func{sexp-match} for the syntax of @var{pattern}.
@end defun


@defun sexp-substitute-bindings @var{output} @var{bindings-alist}
Build and return a copy of the sexp @var{output} in which the
occurrences of the keywords in @var{bindings-alist} are substituted with
their values.  The keywords are meant to be records of type
@samp{sexp-variable}.
@end defun

@c page
@node matches
@chapter Pattern matching


The @library{matches} library implements @dfn{pattern matching}, also
known as @dfn{destructuring bind}.  The library creates simple
generative pattern matchers; each pattern is expanded into the required
tests, calling a failure continuation if the tests fail.

This makes the logic easy to follow and extend, but produces sub-optimal
code in cases where we have many similar clauses due to repeating the
same tests.  Nonetheless a smart compiler should be able to remove the
redundant tests.  For ``match let'' and ``destructuring bind'' type uses
there is no performance hit.  Also, the library is great for batch
processing of S-expressions.

The library does everything through syntaxes, no functions are defined
nor exported.

@menu
* matches match::               Basic pattern matching.
* matches condition::           Mismatch error condition.
* matches syntax::              The pattern syntax.
* matches macros::              Syntaxes for pattern matching.
@end menu

@c page
@node matches match
@section Basic pattern matching


@deffn Syntax match @ameta{sexp} @ameta{clause} ...
@deffnx {Auxiliary Syntax} =>
Match the S--expression @meta{sexp} against the @meta{clause} arguments;
each clause is one of:

@example
(@cmeta{pattern} . @cmeta{body})
(@cmeta{pattern} (=> next) . @cmeta{body})
@end example

@meta{expr} is evaluated and the result is matched against each
@meta{pattern} in turn; the first to succeed causes the corresponding
@meta{body} forms to be evaluated as in @func{begin}, and the remaining
patterns are ignored.  However, if the @samp{next} identifier is
labeled, it may be used as a continuation to continue matching, allowing
for additional runtime tests on the pattern.

The syntax for the patterns is:

@table @samp
@item _
The literal underscore is the wildcard: it matches anything, it does not
bind any variable.

@item #t
Matches if non-false.

@item #f
Matches if false.

@item @cmeta{literal}
Matches with @func{equal?}.

@item (quote @cmeta{sexp})
A literal S--expression; matches with @func{equal?}.

@item @cmeta{variable}
When the pattern is an unquoted symbol: it matches anything and binds
@meta{variable} to it as in:

@example
(let ((@meta{variable} @meta{matched subexpression}))
  ---)
@end example

@item (@cmeta{pattern1} --- @cmeta{patternN})
Proper list of @math{N} elements.

@item (@cmeta{pattern1} --- @cmeta{patternN} . @cmeta{patternN+1})
Improper list of @math{N} or more elements.

@item (@cmeta{pattern1} --- @cmeta{patternN} @cmeta{patternN+1} ...)
List of @math{N} or more elements with terminating ellipsis; each
element of remainder must match @meta{patternN+1}.

@item #(@cmeta{pattern1} --- @cmeta{patternN})
Vector of @math{N} elements.

@item #(@cmeta{pattern1} --- @cmeta{patternN} @cmeta{patternN+1} ...)
Vector of @math{N} or more elements with terminating ellipsis; each
element of remainder must match @meta{patternN+1}.

@item (:and @cmeta{pattern} ---)
If all of @meta{pattern} match.

@item (:or @cmeta{pattern} ---)
If any of @meta{pattern} match.

@item (:not @cmeta{pattern} ---)
If all @meta{pattern} do not match at all.

@item (:predicate @cmeta{pred} @cmeta{pattern} ---)
If the predicate function @meta{pred} applied to the subexpression is
true and all the @meta{pattern} match.

@item (:accessor @cmeta{proc} @cmeta{pattern})
If @meta{pattern} matches the result of applying @meta{proc} to the
subexpression.

@item (:getter @cmeta{symbol})
Match anything and bind to @meta{symbol} a thunk which, when evaluated,
returns the matched element itself.

@item (:setter @cmeta{symbol})
Match anything and bind to @meta{symbol} a function which, when applied
to a value, replaces the expression with that value.  This involves the
use of @func{set-car!}, @func{set-cdr!} and other mutators.
@end table
@end deffn

@c page
@node matches condition
@section Mismatch error condition


When the expansion of @func{match}, or one of its derivatives, detects a
mismatch between the expression and the patterns in @strong{all} the
clauses, an error is raised with condition type
@condition{match-mismatch}.


@deftp {Condition Type} &match-mismatch
Raised to signal an expression/pattern mismatch while evaluating the
expansion of @func{match}; it is derived from @condition{mismatch} from
the @library{conditions} library.  There is only one field,
@samp{expression}, which holds the mismatched expression.
@end deftp


@defun make-match-mismatch-condition @var{expression}
Build and return a condition of type @condition{match-mismatch}.
@end defun


@defun match-mismatch-condition? @var{obj}
Return @true{} if @var{obj} is a condition of type
@condition{match-mismatch}.
@end defun


@defun condition-match-mismatch-expression @var{obj}
Accessor for the @samp{expression} field of a @condition{match-mismatch}
condition object.
@end defun


@deffn Syntax match-mismatch-error @ameta{who} @ameta{expression}
Raise a non--continuable exception with condition types:
@condition{match-mismatch}, @condition{message}, @condition{who}.  All
the arguments are evaluated only once.
@end deffn

@c page
@node matches syntax
@section The pattern syntax


This section describes the syntax of the patterns and gives examples of
expansion for the @func{match} macro.  The full expansion can be quite
big, with several nested @func{let} forms; for this reason, when
convenient, only a smaller but conceptually equivalent expansion is
shown.

While expanding, the @func{match} macro introduces unique identifiers
bound to expressions; there is no way to directly reference these
identifiers in the body of a clause.  They are indicated here with
@samp{expr}, @samp{expr1}, @samp{expr2}, @dots{}

@menu
* matches syntax wildcard::     Matching anything with blind semantic
                                action.
* matches syntax literal::      Matching literal values.
* matches syntax clauses::      Multiple clauses.
* matches syntax quoted::       Matching quoted S--expressions.
* matches syntax lists::        Matching pairs and lists.
* matches syntax vectors::      Matching vectors.
* matches syntax variables::    Pattern variables.
* matches syntax pred::         Matching with predicates.
* matches syntax accessor::     Matching with accessor procedures.
* matches syntax logic::        Logic alternatives and negation.
* matches syntax quasiquote::   Matching quasiquotation.
* matches syntax getter::       Getting values out of the expression.
* matches syntax setter::       Mutating the expression's value.
* matches syntax continuation:: Continuing after mismatch.
* matches syntax ellipsis::     Matching an arbitrary number of
                                subexpressions.
* matches syntax macros::       Impossibility of using macros as
                                patterns.
@end menu

@c page
@node matches syntax wildcard
@subsection Mathing anything with blind semantic action


The wildcard pattern @samp{_} matches any expression and, when used
alone, it only allows the evaluation of code independent from the
expression itself.  A wildcard pattern usage looks like this:

@example
(match '(1 2 3)
  (_ 'ok))
@result{} ok
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr '(1 2 3)))
  'ok)
@end example

@noindent
where @samp{expr} is a unique identifier symbol introduced by the
expansion of @func{match}; there is no way to reference such an
identifier in the body of a clause.

We understand that it does not matter what the expression is, because
the body of the wildcard pattern will always ignore it.

Notice that it is possible to match the cdr of a list with:

@example
(match '(1 2 3 4)
  ((1 2 . _)
   'ok))
@result{} ok
@end example

@noindent
with patterns of the form @samp{(@cmeta{pattern} ... . _)} the tail of
the list can be a subexpression but also null.

@c page
@node matches syntax literal
@subsection Matching literal values


Literal values can be matched by putting them in the pattern.  The usage
of a literal matcher for the number @samp{123} looks like this:

@example
(match 123
  (123 'ok))
@result{} ok
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr 123))
  (if (equal? expr 123)
      'ok
    (match-mismatch-error 'match expr)))
@end example

@noindent
if there is a mismatch an error will be raised:

@example
(match 9
  (123 'ok))
@error{} "no matching pattern"
@end example

Literal matching is performed with @func{equal?} (rather than
@func{eqv?} or @func{eq?}) because, when matching strings and
bytevectors, it makes use of the appropriate predicates @func{string=?}
and @func{bytevector=?} as mandated by @rnrs{6}.

A more specialised comparison function (like @func{=}) cannot be used
because literal matching has to fail gracefully when comparing, say, a
number with a string: @func{equal?} returns @false{}, while @func{=} and
@func{string=?} would raise an error.

@c page
@node matches syntax clauses
@subsection Multiple clauses


When a pattern fails to match an expression, @func{match} will try with
the next clause.  A multiple clause matcher usage looks like this:

@example
(match 2
  (1 'one)
  (2 'two)
  (_ 'any))
@result{} two
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr 2))
  (if (equal? expr 1)
      'one
    (if (equal? expr 2)
        'two
      'any)))
@end example

@noindent
we see that it detects the fact that the pattern in the last clause
matches everything; without the wildcard pattern:

@example
(match 2
  (1 'one)
  (2 'two))
@end example

@noindent
the expansion is equivalent to:

@example
(let ((expr 2))
  (if (equal? expr 1)
      'one
    (if (equal? expr 2)
        'two
      (match-mismatch-error 'match expr))))
@end example

We can use a specialised form to raise a mismatch error with:

@example
(match @cmeta{expr}
  (1 'one)
  (2 'two)
  (_
   (raise-specialised-error)))
@end example

@c page
@node matches syntax quoted
@subsection Matching quoted S--expressions


Matching quoted S--expressions is similar to matching literals.  The
usage of a quoted sexp matcher for a symbol looks like this:

@example
(match 'alpha
  ('alpha 'ok))
@result{} ok

(match 'beta
  ('alpha 'ok))
@error{} no matching pattern
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr 'alpha))
  (if (eq? expr 'alpha)
      'ok
    (match-matching-error 'match expr)))
@end example

The @func{match} macro can detect at expansion time whether the quoted
pattern is a symbol or a generic S--expression, so it can optimise the
expansion to use @func{eq?} or @func{equal?}.  The following usage
matches a generic S--expression:

@example
(match '(alpha (beta (delta 123)))
  ('(alpha (beta (delta 123))) 'ok))
@result{} ok

(match '(alpha (gamma (delta 123)))
  ('(alpha (beta (delta 123))) 'ok))
@error{} no matching pattern
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr '(alpha (beta (delta 123)))))
  (if (equal? expr '(alpha (beta (delta 123))))
      'ok
    (match-matching-error 'match expr)))
@end example

@c page
@node matches syntax lists
@subsection Matching pairs and lists


Pairs and lists in expressions can be matched by pairs and lists in the
pattern.  The usage of a pair matcher looks like this:

@example
(match '(1 . 2)
  ((1 . 2)
   'ok))
@result{} ok
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr '(1 . 2)))
  (if (pair? expr)
      (let ((expr1 (car expr))
            (expr2 (cdr expr)))
        (if (equal? expr1 1)
            (if (equal? expr2 2)
                'ok
              (match-mismatch-error 'match expr2))
          (match-mismatch-error 'match expr1)))
    (match-mismatch-error 'match expr)))
@end example

@noindent
we see that the expression pair is destructured in its car and cdr, then
both are matched against the car and cdr of the pattern, which happen to
be literals in this example; if we isolate the parts related to matching
the pair we obtain:

@example
(let ((expr '(1 . 2)))
  (if (pair? expr)
      (let ((expr1 (car expr))
            (expr2 (cdr expr)))
        ---)
    (match-mismatch-error 'match expr)))
@end example

@noindent
we can understand how multiple patterns are matched by nesting forms one
into the other.

If we just want to verify that the expression is a pair, we can use the
wildcards:

@example
(match '(1 . 2)
  ((_ . _)
   'ok))
@result{} ok
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr '(1 . 2)))
  (if (pair? expr)
      (let ((expr1 (car expr))
            (expr2 (cdr expr)))
        ok)
    (match-mismatch-error 'match expr)))
@end example

We can match a list of literals with the following code:

@example
(match '(1 2 3)
  ((1 2 3)
   'ok))
@result{} ok
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr '(1 2)))
  (if (pair? expr)
      (let ((expr1 (car expr))
            (expr2 (cdr expr)))
        (if (equal? expr1 1)
            (if (pair? expr2)
                (let ((expr3 (car expr2))
                      (expr4 (cdr expr2)))
                  (if (equal? expr3 2)
                      (if (null? expr4)
                          'ok
                        (match-mismatch-error 'match expr4))
                    (match-mismatch-error 'match expr3)))
              (match-mismatch-error 'match expr2))
          (match-mismatch-error 'match expr1)))
    (match-mismatch-error 'match expr)))
@end example

@c page
@node matches syntax vectors
@subsection Matching vectors


Vectors in expressions can be matched by vectors in the pattern.  The
usage of a vector matcher looks like this:

@example
(match '#(1 2)
  (#(1 2) 'ok))
@result{} ok
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr '#(ok)))
  (if (vector? expr)
      (let ((len (vector-length expr)))
        (if (= len 2)
            (let ((expr1 (vector-ref expr 0)))
              (if (equal? expr1 1)
                  (let ((expr2 (vector-ref expr 1)))
                    (if (equal? expr2 2)
                        'ok
                      (check-mismatch-error 'match expr2)))
                (check-mismatch-error 'match expr1)))
          (check-mismatch-error 'match expr)))
    (match-mismatch-error 'match expr)))
@end example

An empty vector pattern matches an empty expression pattern:

@example
(match '#()
  (#() 'ok))
@result{} ok
@end example

@c page
@node matches syntax variables
@subsection Pattern variables


Pattern variables match any expression and bind them to a known
identifier symbol.  A pattern variable usage looks like this:

@example
(match '(1 2 3)
  (alpha    alpha))
@result{} (1 2 3)
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr '(1 2 3)))
  (let ((alpha expr))
    alpha))
@end example

We understand that it does not matter what the expression is, because
@func{match} just binds it to the selected identifier.  We can reference
the identifier any number of times:

@example
(match '(1 2 3)
;; pattern  body
  (alpha    (list alpha alpha alpha)))
@result{} ((1 2 3) (1 2 3) (1 2 3))
@end example

@noindent
which expands to:

@example
(let ((expr '(1 2 3)))
  (let ((alpha expr))
    (list alpha alpha alpha)))
@end example

We can use the same variable multiple times in a single pattern; the
first time it will be bound to the expression, while the subsequent
times the new expression will be compared to the bound value using
@func{equal?}:

@example
(match '(1 1)
  ((X X) 'ok))
@result{} ok

(match '(1 2)
  ((X X) 'ok))
@error{} no matching pattern
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr '(1 1)))
  (let ((expr1 (car  expr))
        (expr2 (cadr expr)))
    (let ((X expr1))            ;1st time, bind expression
      (if (equal? expr2 X)      ;2nd time, compare previous
          'ok
        (match-mismatch-error 'match expr2)))))
@end example

@c page
@node matches syntax pred
@subsection Matching with predicates


An expression can be matched agains a predicate: the match is successful
if the predicate applied to it evaluates to true.  A predicate pattern
usage looks like this:

@example
(match 123
  ((:predicate integer?)
   'ok))
@result{} ok

(match 'alpha
  ((:predicate integer?)
   'ok))
@error{} no matching pattern
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr 123))
  (if (integer? expr)
      'ok
    (match-mismatch-error 'match expr)))
@end example

We can add more predicates in the @code{:predicate} form and all of them
are tried if the predicate evaluates to true:

@example
(match 28
  ((:predicate number? x)
   x))
@result{} 28
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr 123))
  (if (integer? expr)
      (let ((x expr))
        'ok)
    (match-mismatch-error 'match expr)))
@end example

More examples:

@example
(match 28
  ((:predicate number? x y z)
   (list x y z)))
@result{} (28 28 28)

(match 28
  ((:predicate number? (:predicate integer? x))
   (+ 1 x)))
@result{} 29
@end example

@c page
@node matches syntax accessor
@subsection Matching with accessor procedures


Matching a sexp with an accessor means that instead of matching the sexp
itself, we first apply a procedure to it and then try to match the
pattern against the result.  An accessor pattern usage looks like this:

@example
(match '(1 2)
  ((:accessor car x)
   x))
@result{} 1
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr '(1 2)))
  (let ((expr1 (car expr)))
    (let ((x expr1))
      x)))
@end example

@noindent
we see that the pattern @samp{x} is matched against the result of
applying the accessor @func{car} to the expression.  It is mandatory to
specify a single pattern after the accessor in the @code{:accessor} form.

A notable use of this pattern is to access record fields:

@example
(define-record-type color
  (fields (immutable red)
          (immutable green)
          (immutable blue)))

(match (make-color 1 2 3)
  ((:predicate color?
      (:accessor color-red   x)
      (:accessor color-green y)
      (:accessor color-blue  z))
   (list x y z)))
@result{} (1 2 3)

(match (make-color 1 2 3)
  ((:predicate color?
      (:accessor color-red
         (:predicate zero?))) 'ok)
  (_ 'fail))
@result{} fail  ;because red is not zero
@end example

@c page
@node matches syntax logic
@subsection Logic alternatives and negation


We can compose patterns using a logical AND or a logical OR; we can also
negate the matching of a pattern.

@menu
* matches syntax logic and::    Logical conjunction.
* matches syntax logic or::     Logical disjunction.
* matches syntax logic not::    Logical negation.
@end menu

@c page
@node matches syntax logic and
@subsubsection Logical conjunction


A logical AND pattern usage looks like this:

@example
(match 123
  ((:and (:predicate number?)
         (:predicate positive?)
         x)
   x))
@result{} 123
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr 123))
  (if (number? expr)
      (if (positive? expr)
          (let ((x expr))
            x)
        (match-mismatch-error 'match expr))
    (match-mismatch-error 'match expr)))
@end example

@noindent
the code performing the matching is simply nested referencing the same
expression.  An empty @code{:and} pattern will match everything, it is
equivalent to the wildcard @samp{_}:

@example
(match 123
  ((:and) 'ok))
@result{} ok
@end example

@c page
@node matches syntax logic or
@subsubsection Logical disjunction


A logical OR pattern usage looks like this:

@example
(match 123
  ((:or (:predicate number? x)
        (:predicate symbol? x))
   x))
@result{} 123

(match 'alpha
  ((:or (:predicate number? x)
        (:predicate symbol? x))
   x))
@result{} alpha
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr 123))
  (let ((success (lambda (x) x)))
    (if (number? expr)
        (let ((x expr))
          (success x))
      (if (symbol? expr)
          (let ((x expr))
            (success x))
        (match-mismatch-error 'match expr)))))
@end example

@noindent
the @samp{success} procedure is the ``success continuation''; it takes
as arguments one value for each of the pattern variables in each of the
@code{:or} alternative patterns.  All the pattern variables defined in
an @code{:or} alternative must be defined in all the other, else an
error will occur.  (The @samp{success} identifier is introduced by
@func{match} while expanding, so it cannot be referenced directly in the
body of a clause.)

The above example is correct because @samp{x} is defined in both the
alternative patterns, the following example is wrong:

@example
(match 123
  ((:or (:predicate integer? x)
        (:predicate symbol?  y))
   y))
@error{} unbound identifier
@end example

@noindent
because it expands to:

@example
(let ((expr 123))
  (let ((success (lambda (x y) y)))
    (if (integer? expr)
        (let ((x expr))
          (success x y))        ;undefined y
      (if (symbol? expr)
          (let ((y expr))
            (success x y))      ;undefined x
        (match-mismatch-error 'match expr)))))
@end example

An empty @code{:or} pattern matches nothing, it always fails:

@example
(match 123
  ((:or) 'fail))
@error{} no matching pattern
@end example

@c page
@node matches syntax logic not
@subsubsection Logical negation


A logical NOT pattern usage looks like this:

@example
(match 123
  ((:not (:predicate symbol?))
   'ok))
@result{} ok
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr 123))
  (if (symbol? expr)
      (match-mismatch-error 'match expr)
    'ok))
@end example

Notice that the following will raise an error:

@example
(match 123
  ((:not (:predicate symbol? x))
   x))
@error{} unbound identifier x
@end example

@noindent
because the @code{:predicate} pattern fails to match, so @samp{x} is not
bound when the body evaluates; we can think of it as expanding to:

@example
(let ((expr 123))
  (if (symbol? expr)
      (let ((x expr))
        (match-mismatch-error 'match expr))
    x))
@end example

@c page
@node matches syntax quasiquote
@subsection Matching quasiquotation


The patterns in the clauses are like quoted S--expressions:

@example
(let ((x 9))
  (match 1
    (x x)))
@result{} 1
@end example

@noindent
the @samp{x} in the pattern is a pattern variable which shadows the
outer @samp{x} binding.

Despite this, we can insert a runtime value in the pattern matching
forms using @samp{quasiquote} forms; only single values can be inserted
like this (rather than chunks of patterns), the pattern specification
remains unchanged.  A @samp{quasiquote} pattern usage looks like this:

@example
(let ((x 1))
  (match 1
    (`,x 'ok)
    (_   'fail)))
@result{} ok
@end example

@noindent
we can think of it as expanding to:

@example
(let ((x 1))
  (let ((expr 1))
    (let ((pattern `,x))
      (if (equal? pattern expr)
          'ok
        'fail))))
@end example

Let's see other examples:

@example
(let ((x 2))
  (match '(1 2 3)
    ((_ `,x y) y)
    (_         'fail)))
@result{} 3

(let ((x 10))
  (match '(1 2 3)
    ((_ `,(- x 8) y)
     y)))
@result{} 3

(let ((x '(2 3)))
  (match '(1 2 3 4)
    (`(1 ,@@x 4)   'ok)))
@result{} ok
@end example

The @samp{quasiquote} mechanism can be used to select predicates and
accessors, too:

@example
(let ((pred number?))
  (match 28
    ((:predicate `,pred) 'ok)))
@result{} ok

(let ((f (lambda (x) (+ 1 x))))
  (match 2
    ((:accessor `,f x) x)))
@result{} 3
@end example

@c page
@node matches syntax getter
@subsection Getting values out of the expression


A getter expression matcher looks like this:

@example
(match 2
  ((:getter two)
   (two)))
@result{} 2
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr 2))
  (let ((two (lambda () expr)))
    (two)))
@end example

@noindent
so the @samp{(:getter two)} pattern instructs @func{match} to define a
thunk that can be used to retrieve the expression itself.  We understand
that the single argument @meta{getter} in the abstract pattern
@samp{(:getter @cmeta{getter})} must be an indentifier.  We can evaluate
the thunk any number of times.

Let's look at another example:

@example
(match '(1 2 3)
  ((_ (:getter two) _)
   (two)))
@result{} 2
@end example

@noindent
we can think of this as expanding to:

@example
(let ((expr '(1 2 3)))
  (let ((expr1 (cadr expr)))
    (let ((two (lambda () expr1)))
      (two))))
@end example

@c page
@node matches syntax setter
@subsection Mutating the expression's value


A setter expression matcher looks like this:

@example
(let ((x 1))
  (match x
    ((:setter doit)
     (doit 3)))
  x)
@result{} 3
@end example

@noindent
we can think of it as expanding to:

@example
(let ((x 1))
  (let ((expr x))
    (let ((doit (lambda (y) (set! x y))))
      (doit 3)))
  x)
@end example

@noindent
so the @samp{(:setter doit)} pattern instructs @func{match} to define a
procedure that can be used to store a new value in the expression
itself.  We understand that the single argument @meta{setter} in the
abstract pattern @samp{(:setter @cmeta{setter})} must be an indentifier.
We can evaluate the procedure any number of times.

For a composite expression, @func{match} tries to select the correct
mutator:

@example
(let ((x '(1 . 2)))
  (match x
    (((:setter doit) . _)
     (doit 3)))
  x)
@result{} (3 . 2)
@end example

@noindent
we can think of it as expanding to:

@example
(let ((x '(1 . 2)))
  (let ((expr x))
    (if (pair? expr)
        (let ((expr1 (car expr))
              (expr2 (cdr expr)))
          (let ((doit (lambda (y) (set-car! x y))))
            (doit 3)))
      (match-mismatch-error 'match expr)))
  x)
@end example

@noindent
and for a cadr setter:

@example
(let ((x '(1 2 3)))
  (match x
    ((_ (:setter doit) _)
     (doit 9)))
  x)
@result{} (1 9 3)
@end example

@noindent
we can think of it as expanding to:

@example
(let ((x '(1 2 3)))
  (let ((expr x))
    (if (pair? expr)
        (let ((expr1 (car expr))
              (expr2 (cdr expr)))
          (if (pair? expr2)
              (let ((doit (lambda (y) (set-car! (cdr x) y))))
                (doit 3))
            (match-mismatch-error 'match expr2)))
      (match-mismatch-error 'match expr)))
  x)
@end example

The setter works only when the expression is an identifier or a
composite object like a list or vector, the following will fail:

@example
(match 1
  ((and (:setter doit)
        x)
   (doit 3)
   x))
@error{} invalid expression (:setter 1 3)
@end example

@c page
@node matches syntax continuation
@subsection Continuing after mismatch


A ``matcher continuation'' is a thunk we can invoke to jump to the next
matcher clause; we can use it to step to the next matching clause after
we have determined, in the body of a clause, that the expression does
not fit some criteria.  A matcher continuation use looks like this:

@example
(match 3

  ((:predicate positive? x)
   (=> next)
   (if (even? x)
       x
     (next)))

  (_ 0))
@result{} 0
@end example

@noindent
we can think of it as expanding to:

@example
(let ((expr 3))
  (let ((next (lambda ()
                0)))
    (if (positive? expr)
        x
      (next))))
@end example

@c page
@node matches syntax ellipsis
@subsection Matching an arbitrary number of subexpressions


The special ellipsis pattern @code{...} can be used to match an
arbitrary number of subexpressions against the same pattern.  A usage of
ellipsis in a list looks like:

@example
(match '(a b c d)
  ((x ...)
   x))
@result{} (a b c d)

(match '(a b c d)
  ((x y ...)
   (list x y)))
@result{} (a (b c d))
@end example

@noindent
all the elements of the list expression are matched against the pattern
variable @samp{x}, which is bound to the list of matched expressions.
The same happens with vector patterns:

@example
(match '#(a b c d)
  (#(x ...)
   x))
@result{} (a b c d)

(match '#(a b c d)
  (#(x y ...)
   (list x y)))
@result{} (a (b c d))
@end example

@noindent
currently (Mon Apr 12, 2010) the ellipsis can appear only as last
element of a pattern vector; instead, other patterns can appear after an
ellipsis in a list pattern, but only one ellipsis is allowed in a list
pattern.

@example
(match '(a b c d)
  ((x ... y z)
   (list x y z)))
@result{} ((a b) c d)

(match '(a b c d)
  ((x ... y z w v)
   (list x y z w v)))
@result{} (() a b c d)

(match '(a b (c d))
  ((x ... (y ...))
   (list x y)))
@result{} ((a b) (c d))

(match '(a b #(c d))
  ((x ... #(y ...))
   (list x y)))
@result{} ((a b) (c d))

(match '(1 2 3)
  (((:predicate odd? n) ...)     ;no match, not all odd
   n)
  (((:predicate even? n) ...)    ;no match, not all even
   n)
  (((:predicate number? n) ...)  ;match, all numbers
   n))
@result{} (1 2 3)
@end example

@c page
@node matches syntax macros
@subsection Impossibility of using macros as patterns


We may be tempted to use a macro to define a pattern, that is to try the
following:

@example
(define-syntax it
  (syntax-rules ()
    ((_ ?var)
     (_ ?var _))))

(match '(1 2 3)
  ((it x) x)
  (_      'fail))
@result{} fail
@end example

@noindent
the reason the result is @samp{fail} rather than @samp{2} is that, when
expanding macros in an @rnrs{6} system, ``outer'' ones are expanded
first.  So @func{match} is expanded before @func{it}, and this results
in destructuring the form @samp{(it x)}, which disappears in the
expansion; the macro @func{it} is never used.

We can see the same mechanism in the following example:

@example
(let-syntax ((one (syntax-rules ()
                    ((_)
                     1)))
             (two (syntax-rules ()
                    ((_ ?v)
                     (quote ?v)))))
  (two (one)))
@result{} (one)
@end example

@c page
@node matches macros
@section Syntaxes for pattern matching


@deffn Syntax match-let ((@meta{pattern} @meta{expression}) ...) . @meta{body}
@deffnx Syntax match-let @meta{variable} ((@meta{pattern} @meta{expression}) ...) . @meta{body}
@deffnx Syntax match-let* ((@meta{pattern} @meta{expression}) ...) . @meta{body}
@deffnx Syntax match-letrec ((@meta{pattern} @meta{expression}) ...) . @meta{body}
Match each @cmeta{expression} against each @meta{pattern} and, if all
the matches are successful, evaluate @cmeta{body} in the resulting
environment.  If a pattern does not match, a mismatch error is raised.
These syntaxes are meant to provide destructuring; they are not meant to
test if an S--expression matches a pattern.

When the second form is used: a named @func{match-let} is defined,
working like the named @func{let}.

@example
(match-let ((x 1))
  x)
@result{} 1

(match-let (((x . y) '(1 . 2))
            (z       3))
  (list x y z))
@result{} (1 2 3)
@end example

These syntaxes are matching extensions of the corresponding @rnrs{6}
@func{let} syntaxes.  Notice that:

@example
(match-let ((_ 1))
  _)
@result{} 1

(match-let (((_) '(1)))
  'ok)
@result{} ok
@end example

@noindent
normal binding of variables takes precedence over pattern matching.
@end deffn


@deffn Syntax match-lambda @meta{clause} ...
@deffnx Syntax match-lambda* @meta{clause} ...
Define a @func{lambda} which matches its arguments against a set of
patterns.

@example
(match-lambda @cmeta{clause} ...) @equiv{}
  (lambda (expr) (match expr @meta{clause} ...))

(match-lambda* @cmeta{clause} ...) @equiv{}
  (lambda expr (match expr @meta{clause} ...))
@end example
@end deffn


@deffn Syntax match-define @ameta{name} @meta{clause} ...
@deffnx Syntax match-define* @ameta{name} @meta{clause} ...
Define, and bind to @meta{name}, a @func{lambda} which matches its
arguments against a set of patterns.

@example
(match-define @cmeta{name} @cmeta{clause} ...) @equiv{}
  (define @cmeta{name} (match-lambda @cmeta{clause} ...))

(match-define* @cmeta{name} @cmeta{clause} ...) @equiv{}
  (define @cmeta{name} (match-lambda* @cmeta{clause} ...))
@end example

Examples:

@example
(match-define one
  ((x y) (+ x y)))

(one '(1 2))
@result{} 3

(match-define* two
  ((x y) (+ x y)))

(two 1 2)
@result{} 3
@end example
@end deffn

@c page
@node irregex
@chapter IrRegular expressions


The @library{irregex} library is an implementation of regular
expressions; it supports both @posix{} syntax with various (irregular)
Perl--Compatible Regular Expressions (@acronym{PCRE}) extensions, as
well as SCSH's Scheme Regular Expressions (@acronym{SRE}) syntax, with
various aliases for commonly used patterns.

Deterministic Finite Automata (@acronym{DFA}) matching is used when
possible, otherwise a closure--compiled Nondeterministic Finite Automata
(@acronym{NFA}) approach is
used.@footnote{See @url{http://en.wikipedia.org/wiki/Automata_theory}.}

The library is derived from IrRegex, an implementation of regular
expressions by Alex Shinn; only small changes were needed for
integration into Nausicaa.  The original package is distributed under a
@acronym{BSD} style license (@nauref{credits, Credits}) and can be
downloaded from:

@center @url{http://synthcode.com/}

@menu
* irregex conventions::         Conventions.
* irregex pred::                Predicates.
* irregex compile::             Compiling regular expressions.
* irregex match::               Match objects.
* irregex replace::             Replacing substrings.
* irregex chunk::               Chunked string matching.
* irregex misc::                Miscellaneous functions.
* irregex pcre::                Supported @acronym{PCRE} syntax.
* irregex sre::                 Extended @acronym{SRE} syntax.
@end menu

@c page
@node irregex conventions
@section Conventions


In the documentation of the @library{irregex} functions, the following
conventions for arguments names are used:

@table @var
@item pcre
A string representing a regular expression in @posix{} syntax, with
@acronym{PCRE} extensions.

@item sre
A symbolic expression (a list) representing an @acronym{SRE} regular
expression in SCSH syntax.

@item irx
A regular expression in one of the following forms: string in
@posix{}/@acronym{PCRE} syntax; symbolic expression in @acronym{SRE}
syntax; a precompiled regular expression value.

@item str
A string.

@item start
@itemx past
Non--negative, exact integers representing indexes usually into a
string.  @var{start} is the index of the first code point in a selected
substring; @var{past} is the index of the code point past the last code
point included in the selected substring.

@item obj
Can be any value.
@end table

@c page
@node irregex pred
@section Predicates


@defun {irregex?} @var{obj}
Return @true{} if @var{obj} is a compiled regular expression.  Compiled
regular expression values are disjoint from all the other Scheme types.
@end defun


@defun {irregex-match-data?} @var{obj}
Return @true{} if @var{obj} is a successful match result from
@func{irregex-search} or @func{irregex-match}.  Match data values are
disjoint from all the other Scheme types.
@end defun

@c page
@node irregex compile
@section Compiling regular expressions


@defun irregex @var{pcre/sre} @var{options} ...
@defunx {string->irregex} @var{pcre} @var{options} ...
@defunx {sre->irregex} @var{sre} @var{options} ...
Compile a regular expression from either a @posix{}--style regular
expression string (with most @acronym{PCRE} extensions) or an
SCSH--style @acronym{SRE}.  Return an object representing the compiled
regular expression.

There is no @code{(rx ...)} syntax to specify the regular expression, we
just use normal Scheme lists.  Technically a string by itself could be
considered a valid @acronym{SRE}, so if we want to just match a literal
string we should use something like:

@example
(irregex `(: ,str))
@end example

@noindent
or use the explicit:

@example
(string->irregex str)
@end example

The optional @var{options} are a list of any of the following symbols,
which must be quoted:

@table @code
@item i
@itemx case-insensitive
match case--insensitively;

@item m
@itemx multi-line
treat string as multiple lines (effects @code{^} and @code{$});

@item s
@item single-line
treat string as a single line (@code{.} can match newline);

@item utf8
@utf{}-8 mode, assumes strings are byte--strings;

@item fast
try to optimize the regular expression;

@item small
try to compile a smaller regular expression.
@end table

@quotation
@strong{NOTE} The @code{fast} and @code{small} options may not actually
make the compiled expression any faster or smaller at the moment.
@end quotation
@end defun

@c page
@node irregex match
@section Match objects


@defun irregex-search @var{irx} @var{str}
@defunx irregex-search @var{irx} @var{str} @var{start}
@defunx irregex-search @var{irx} @var{str} @var{start} @var{past}
Search for any instance of the pattern @var{irx} in @var{str},
optionally between the given range.  If a match is found, return a match
object, otherwise @false{}.  Match objects can be used to query the
selected substring or its submatches using the @func{irregex-match-*}
procedures below.  Examples:

@example
(irregex-search "[a-z]+" "123abc456")
@result{} ... ; match object

(irregex-search "[a-z]+" "123456")
@result{} #f

(irregex-search "foobar" "abcFOOBARdef")
@result{} #f

(irregex-search (string->irregex "foobar"
                                 'case-insensitive)
                "abcFOOBARdef")
@result{} ... ; match object
@end example

Matching follows the @posix{} leftmost, longest semantics, when
searching.  That is, of all possible matches in the string,
@func{irregex-search} will return the match at the first position
(leftmost).  If multiple matches are possible from that same first
position, the longest match is returned.
@end defun


@defun irregex-match @var{irx} @var{str}
Like @func{irregex-search}, but performs an anchored match against the
beginning and end of the string, without searching.

Examples:

@example
(irregex-match '(w/nocase "foobar") "abcFOOBARdef")
@result{} #f

(irregex-match '(w/nocase "foobar") "FOOBAR")
@result{} ... ; match object
@end example
@end defun


@defun irregex-match-substring @var{match-obj}
@defunx irregex-match-substring @var{match-obj} @var{index-or-name}
@defunx irregex-match-start-index @var{match-obj} @var{index-or-name}
@defunx irregex-match-end-index @var{match-obj} @var{index-or-name}
Fetch the matched substring (or its start or end offset) at the given
submatch index, or named submatch.  The entire match is index 0, the
first 1, etc.  The default is index 0.  Examples:

@example
(irregex-match-substring
   (irregex-search "ciao" "hello ciao salut")
   0)
@result{} "ciao"

(let ((match (irregex-search "c(i(a(o)))"
                             "hello ciao salut")))
;;;                           01234567890123456

  (irregex-match-substring match)       @result{} "ciao"
  (irregex-match-substring match 0)     @result{} "ciao"
  (irregex-match-substring match 1)     @result{} "iao"
  (irregex-match-substring match 2)     @result{} "ao"
  (irregex-match-substring match 3)     @result{} "o"

  (irregex-match-start-index match 0)   @result{} 6
  (irregex-match-past-index match 0))   @result{} 10
@end example
@end defun

@c page
@node irregex replace
@section Replacing substrings


@defun irregex-replace @var{irx} @var{str} [@var{replacements} ...]
@defunx {irregex-replace/all} @var{irx} @var{str} [@var{replacements} ...]
Match a pattern in a string, and replaces it with a (possibly empty)
list of substitutions.  Each @var{replacement} can be either a string
literal, a numeric index, a symbol (as a named submatch), or a procedure
which takes one argument (the match object) and returns a string.

@func{irregex-replace} will replace only the first match, while
@func{irregex-replace/all} will replace all of them.

Examples:

@example
(irregex-replace "[aeiou]" "hello world" "*")
@result{} "h*llo world"

(irregex-replace/all "[aeiou]" "hello world" "*")
@result{} "h*ll* w*rld"
@end example
@end defun

@c page
@node irregex chunk
@section Chunked string matching


It's often desirable to perform regular expression matching over
sequences of characters not represented as a single string.  The most
obvious example is a text--buffer data structure, but we may also want
to match over lists or trees of strings (i.e. ropes), over only certain
ranges within a string, over an input port, etc.

With existing regular expression libraries, the only way to accomplish
this is by converting the abstract sequence into a freshly allocated
string.  This can be expensive, or even impossible if the object is a
text--buffer opened onto a 500MB file.

@library{irregex} provides a chunked string @api{} specifically for this
purpose.


@defun make-irregex-chunker @var{get-next} @var{get-string}
@defunx make-irregex-chunker @var{get-next} @var{get-string} @var{get-start}
@defunx make-irregex-chunker @var{get-next} @var{get-string} @var{get-start} @var{get-end}
@defunx make-irregex-chunker @var{get-next} @var{get-string} @var{get-start} @var{get-end}
@defunx make-irregex-chunker @var{get-next} @var{get-string} @var{get-start} @var{get-end} @var{get-substring}
@defunx make-irregex-chunker @var{get-next} @var{get-string} @var{get-start} @var{get-end} @var{get-substring} @var{get-subchunk}
Define a chunking @api{}.

@table @code
@item (@var{get-next} chunk)
Return the next chunk, or @false{} if there are no more chunks.

@item (@var{get-string} chunk)
A string source for the chunk.

@item (@var{get-start} chunk)
The start index of the result of @var{get-string} (defaults to always 0).

@item (@var{get-end} chunk)
The end (exclusive) of the string (defaults to @func{string-length} of
the source string).

@item (@var{get-substring} @var{cnk1} @var{i} @var{cnk2} @var{j})
A substring for the range between the chunk @var{cnk1} starting at index
@var{i} and ending at @var{cnk2} at index @var{j}.

@item (@var{get-subchunk} @var{cnk1} @var{i} @var{cnk2} @var{j})
As above but returns a new chunked data type instead of a string
(optional).
@end table

There are two important constraints on the @var{get-next} procedure.  It
must return an @func{eq?} identical object when called multiple times on
the same chunk, and it must not return a chunk with an empty string
(start == past).  This second constraint is for performance reasons, we
push the work of possibly filtering empty chunks to the chunker since
there are many chunk types for which empty strings aren't possible, and
this work is thus not needed.  Note that the initial chunk passed to
match on is allowed to be empty.

@var{get-substring} is provided for possible performance improvements,
without it a default is used.

@var{get-subchunk} is optional, but without it we cannot use
@func{irregex-match-subchunk}.
@end defun


@defun irregex-match-subchunk @var{match-obj}
@defunx irregex-match-subchunk @var{match-obj} @var{index-or-name}
Generate a chunked data--type for the given match item, of the same type
as the underlying chunk type.  This is only available if the chunk type
specifies the @func{get-subchunk} @api{}, otherwise an error is raised.
@end defun


@defun {irregex-search/chunked} @var{irx} @var{chunker} @var{chunk}
@defunx {irregex-search/chunked} @var{irx} @var{chunker} @var{chunk} @var{start}
@defunx {irregex-match/chunked} @var{irx} @var{chunker} @var{chunk}
@defunx {irregex-match/chunked} @var{irx} @var{chunker} @var{chunk} @var{start}
These return normal match--data objects.

Example: To match against a simple, flat list of strings use:

@example
(define (rope->string rope1 start rope2 end)
  (if (eq? rope1 rope2)
      (substring (car rope1) start end)
      (let loop ((rope (cdr rope1))
                 (res (list (substring (car rope1) start))))
         (if (eq? rope rope2)
             (string-concatenate-reverse      ; from SRFI-13
              (cons (substring (car rope) 0 end) res))
             (loop (cdr rope) (cons (car rope) res))))))

(define rope-chunker
  (make-irregex-chunker (lambda (x)
                          (and (pair? (cdr x)) (cdr x)))
                        car
                        (lambda (x)
                          0)
                        (lambda (x)
                          (string-length (car x)))
                        rope->string))

(irregex-search/chunked <pat> rope-chunker <list-of-strings>)
@end example

Here we are just using the default start, end and substring behaviors,
so the above chunker could simply be defined as:

@example
(define rope-chunker
  (make-irregex-chunker (lambda (x)
                          (and (pair? (cdr x)) (cdr x)))
                        car))
@end example
@end defun


@defun irregex-fold/chunked @var{irx} @var{kons} @var{knil} @var{chunker} @var{chunk}
@defunx irregex-fold/chunked @var{irx} @var{kons} @var{knil} @var{chunker} @var{chunk} @var{finish}
@defunx irregex-fold/chunked @var{irx} @var{kons} @var{knil} @var{chunker} @var{chunk} @var{finish} @var{start-index}
Chunked version of @func{irregex-fold}.
@end defun


@c page
@node irregex misc
@section Miscellaneous functions


@defun irregex-split @var{irx} @var{str}
@defunx irregex-split @var{irx} @var{str} @var{start} @var{end}
@defunx irregex-extract @var{irx} @var{str}
@defunx irregex-extract @var{irx} @var{str} @var{start} @var{end}
@func{irregex-split} splits the string @var{str} into substrings divided
by the pattern in @var{irx}.  @func{irregex-extract} does the opposite,
returning a list of each instance of the pattern matched disregarding
the substrings in between.
@end defun


@defun irregex-fold @var{irx} @var{kons} @var{knil} @var{str} [@var{finish} @var{start} @var{past}]
This follows the @api{} for @func{regexp-fold} from SCSH.  The
@var{kons} procedure takes the following signature:

@example
(@var{kons} <from-index> <match> <seed>)
@end example

@noindent
where @code{@meta{from-index}} is the index from where we started
searching (initially @var{start} and thereafter the past index of the
last match); @code{@meta{match}} is the resulting match data object;
@code{@meta{seed}} is the accumulated fold result starting with
@var{knil}.

The rationale for providing the @code{@meta{from-index}} is because this
information is useful (e.g. for extracting the unmatched portion of the
string before the current match, as needed in @func{irregex-replace}),
and not otherwise directly accessible.

The optional @var{finish} takes two arguments:

@example
(@var{finish} <from-index> <seed>)
@end example

@noindent
which simiarly allows us to pick up the unmatched tail of the string,
and defaults to just returning the @code{@meta{seed}}.

@var{start} and @var{past} select a substring of @var{str}.

To extract all instances of a match out of a string, we can use:

@example
(map irregex-match-substring
  (irregex-fold <irx>
                (lambda (i m s)
                  (cons m s))
                '()
                <str>
                (lambda (i s)
                  (reverse s))))
@end example
@end defun


@defun irregex-quote @var{str}
Return a new string with any special regular expression characters
escaped, to match the original string literally in @posix{} regular
expressions.
@end defun


@defun irregex-opt @var{list-of-strings}
Return an optimized @acronym{SRE} matching any of the literal strings in
the list, like Emacs' @func{regexp-opt}.  Note this optimization does
not help when @func{irregex} is able to build a @acronym{DFA}.
@end defun


@defun {sre->string} @var{sre}
Convert an @acronym{SRE} to a @posix{}--style regular expression string, if
possible.
@end defun

@c page
@node irregex pcre
@section Supported @acronym{PCRE} syntax


Since the @acronym{PCRE} syntax is so overwhelming complex, it's easier
to just list what @library{irregex} does @strong{not} support for now.
Refer to the @acronym{PCRE} documentation for details.@footnote{See
@url{http://pcre.org/pcre.txt}.  @aurl{} last verified Sun Jul 12,
2009.}

@itemize
@item
Unicode character classes (@code{\P}) are not supported, but will be in
an upcoming release.  @code{\C} named characters are not supported.

@item
Callbacks, subroutine patterns and recursive patterns are not supported.
@code{(*FOO)} patterns are not supported and may never be.

@item
@code{\G} and @code{\K} are not supported.

@item
Octal character escapes are not supported because they are ambiguous
with back--references; just use hex character escapes.
@end itemize

Other than that, everything should work, including named submatches,
zero--width assertions, conditional patterns, etc.

In addition, @code{\<} and @code{\>} act as beginning--of--word and
end--of--word marks, respectively, as in Emacs regular expressions.

Also, two escapes are provided to embed @acronym{SRE} patterns inside
@acronym{PCRE} strings, @code{"\'<sre>"} and @code{"(*'<sre>)"}.  For
example, to match a comma--delimited list of integers we could use:

@example
"\\'integer(,\\'integer)*"
@end example

@noindent
and to match a @aurl{} in angle brackets we could use:

@example
"<('*http-url)>"
@end example

@noindent
note in the second example the enclosing @code{"('*...)"} syntax is
needed because the Scheme reader would consider the closing @samp{>} as
part of the @acronym{SRE} symbol.

The following chart gives a quick reference from @acronym{PCRE} form to
the @acronym{SRE} equivalent:

@example
;; basic syntax
"^"                     ;; bos (or eos inside (?m: ...))
"$"                     ;; eos (or eos inside (?m: ...))
"."                     ;; nonl
"a?"                    ;; (? a)
"a*"                    ;; (* a)
"a+"                    ;; (+ a)
"a??"                   ;; (?? a)
"a*?"                   ;; (*? a)
"a+?"                   ;; (+? a)
"a@{n,m@}"                ;; (** n m a)

;; grouping
"(...)"                 ;; (submatch ...)
"(?:...)"               ;; (: ...)
"(?i:...)"              ;; (w/nocase ...)
"(?-i:...)"             ;; (w/case ...)
"(?<name>...)"          ;; (=> <name>...)

;; character classes
"[aeiou]"               ;; ("aeiou")
"[^aeiou]"              ;; (~ "aeiou")
"[a-z]"                 ;; (/ "az") or (/ "a" "z")
"[[:alpha:]]"           ;; alpha

;; assertions
"(?=...)"               ;; (look-ahead ...)
"(?!...)"               ;; (neg-look-ahead ...)
"(?<=...)"              ;; (look-behind ...)
"(?<!...)"              ;; (neg-look-behind ...)
"(?(test)pass|fail)"    ;; (if test pass fail)
"(*COMMIT)"             ;; commit
@end example

@c page
@node irregex sre
@section Extended @acronym{SRE} Syntax


Scheme Regular Expressions were proposed by Olin Shivers.  The original
request for coments is available at:

@center @url{http://www.scsh.net/docu/post/sre.html}

@menu
* irregex sre syntax::          Syntax tables.
* irregex sre basic::           Basic patterns.
* irregex sre repetition::      Repetition patterns.
* irregex sre char-sets::       Character sets.
* irregex sre assertion::       Assertion patterns.
* irregex sre utility::         Utility patterns.
@end menu

@c page
@node irregex sre syntax
@subsection Syntax tables


The following tables summarizes the @acronym{SRE} syntax, with detailed
explanations following.

@example
;; basic patterns
<string>                          ; literal string
(seq <sre> ...)                   ; sequence
(: <sre> ...)
(or <sre> ...)                    ; alternation

;; optional/multiple patterns
(? <sre> ...)                     ; 0 or 1 matches
(* <sre> ...)                     ; 0 or more matches
(+ <sre> ...)                     ; 1 or more matches
(= <n> <sre> ...)                 ; exactly <n> matches
(>= <n> <sre> ...)                ; <n> or more matches
(** <from> <to> <sre> ...)        ; <n> to <m> matches
(?? <sre> ...)                    ; non-greedy (non-greedy) pattern: (0 or 1)
(*? <sre> ...)                    ; non-greedy kleene star
(**? <from> <to> <sre> ...)       ; non-greedy range

;; submatch patterns
(submatch <sre> ...)              ; numbered submatch
($ <sre> ...)
(submatch-named <name> <sre> ...) ; named submatch
(=> <name> <sre> ...)
(backref <n-or-name>)             ; match a previous submatch

;; toggling case-sensitivity
(w/case <sre> ...)                ; enclosed <sre>s are case-sensitive
(w/nocase <sre> ...)              ; enclosed <sre>s are case-insensitive

;; character sets
<char>                            ; singleton char set
(<string>)                        ; set of chars
(or <cset-sre> ...)               ; set union
(~ <cset-sre> ...)                ; set complement (i.e. [^...])
(- <cset-sre> ...)                ; set difference
(& <cset-sre> ...)                ; set intersection
(/ <range-spec> ...)              ; pairs of chars as ranges

;; named character sets
any
nonl
ascii
lower-case     lower
upper-case     upper
alphabetic     alpha
numeric        num
alphanumeric   alphanum  alnum
punctuation    punct
graphic        graph
whitespace     white     space
printing       print
control        cntrl
hex-digit      xdigit

;; assertions and conditionals
bos eos                           ; beginning/end of string
bol eol                           ; beginning/end of line
bow eow                           ; beginning/end of word
nwb                               ; non-word-boundary
(look-ahead <sre> ...)            ; zero-width look-ahead assertion
(look-behind <sre> ...)           ; zero-width look-behind assertion
(neg-look-ahead <sre> ...)        ; zero-width negative look-ahead assertion
(neg-look-behind <sre> ...)       ; zero-width negative look-behind assertion
(atomic <sre> ...)                ; for (?>...) independent patterns
(if <test> <pass> [<fail>])       ; conditional patterns
commit                            ; don't backtrack beyond this (i.e. cut)

;; backwards compatibility
(posix-string <string>)           ; embed a POSIX string literal
@end example

@c page
@node irregex sre basic
@subsection Basic patterns


The simplest @acronym{SRE} is a literal string, which matches that
string exactly.

@example
(irregex-search "needle" "hayneedlehay")
@result{} #<match>
@end example

By default the match is case--sensitive, though we can control this
either with the compiler flags or local overrides:

@example
(irregex-search "needle" "haynEEdlehay")
@result{} #f

(irregex-search (irregex "needle" 'i) "haynEEdlehay")
@result{} #<match>

(irregex-search '(w/nocase "needle") "haynEEdlehay")
@result{} #<match>
@end example

We can use @code{w/case} to switch back to case--sensitivity inside a
@code{w/nocase} or when the @acronym{SRE} was compiled with
@code{case-insensitive}:

@example
(irregex-search '(w/nocase "SMALL" (w/case "BIG")) "smallBIGsmall")
@result{} #<match>

(irregex-search '(w/nocase "small" (w/case "big")) "smallBIGsmall")
@result{} #f
@end example

Of course, literal strings by themselves aren't very interesting regular
expressions, so we want to be able to compose them.  The most basic way
to do this is with the @code{seq} operator (or its abbreviation
@code{:}), which matches one or more patterns consecutively:

@example
(irregex-search '(: "one" space "two" space "three") "one two three")
@result{} #<match>
@end example

The @code{w/case} and @code{w/nocase} operators allowed multiple
@acronym{SRE}s in a sequence; other operators that take any number of
arguments (e.g. the repetition operators below) allow such implicit
sequences.

To match any one of a set of patterns we use the @code{or} alternation
operator:

@example
(irregex-search '(or "eeney" "meeney" "miney") "meeney")
@result{} #<match>

(irregex-search '(or "eeney" "meeney" "miney") "moe")
@result{} #f
@end example

@c page
@node irregex sre repetition
@subsection Repetition patterns


There are several ways to control the number of times a pattern is
matched.  The simplest of these is @code{?} which just optionally
matches the pattern:

@example
(irregex-search '(: "match" (? "es") "!") "matches!")
@result{} #<match>

(irregex-search '(: "match" (? "es") "!") "match!")
@result{} #<match>

(irregex-search '(: "match" (? "es") "!") "matche!")
@result{} #f
@end example

To optionally match any number of times we use @code{*}, the Kleene
star:

@example
(irregex-search '(: "<" (* (~ #\>)) ">") "<html>")
@result{} #<match>

(irregex-search '(: "<" (* (~ #\>)) ">") "<>")
@result{} #<match>

(irregex-search '(: "<" (* (~ #\>)) ">") "<html")
@result{} #f
@end example

Often we want to match any number of times, but at least one time is
required, and for that we use @code{+}:

@example
(irregex-search '(: "<" (+ (~ #\>)) ">") "<html>")
@result{} #<match>

(irregex-search '(: "<" (+ (~ #\>)) ">") "<a>")
@result{} #<match>

(irregex-search '(: "<" (+ (~ #\>)) ">") "<>")
@result{} #f
@end example

More generally, to match at least a given number of times, we use
@code{>=}:

@example
(irregex-search '(: "<" (>= 3 (~ #\>)) ">") "<table>")
@result{} #<match>

(irregex-search '(: "<" (>= 3 (~ #\>)) ">") "<pre>")
@result{} #<match>

(irregex-search '(: "<" (>= 3 (~ #\>)) ">") "<tr>")
@result{} #f
@end example

To match a specific number of times exactly we use @code{=}:

@example
(irregex-search '(: "<" (= 4 (~ #\>)) ">") "<html>")
@result{} #<match>

(irregex-search '(: "<" (= 4 (~ #\>)) ">") "<table>")
@result{} #f
@end example

And finally, the most general form is @code{**} which specifies a range
of times to match.  All of the earlier forms are special cases of this.

@example
(irregex-search '(: (= 3 (** 1 3 numeric) ".")
                    (** 1 3 numeric))
                "192.168.1.10")
@result{} #<match>

(irregex-search '(: (= 3 (** 1 3 numeric) ".")
                    (** 1 3 numeric))
                "192.0168.1.10")
@result{} #f
@end example

There are also so--called ``non-greedy'' variants of these repetition
operators, by convention suffixed with an additional @code{?}.  Since
the normal repetition patterns can match any of the allotted repetition
range, these operators will match a string if and only if the normal
versions matched.  However, when the endpoints of which submatch matched
are taken into account (specifically, all matches when using
@func{irregex-search} since the endpoints of the match itself matter),
the use of a non--greedy repetition can change the result.

So, whereas @code{?} can be thought to mean ``match or don't match'',
@code{??} means ``don't match or match''.  @code{*} typically consumes
as much as possible, but @code{*?}  tries first to match zero times, and
only consumes one at a time if that fails.  If we have a greedy operator
followed by a non--greedy operator in the same pattern, they can produce
surprising results as they compete to make the match longer or shorter.
If this seems confusing, that's because it is.  Non--greedy repetitions
are defined only in terms of the specific backtracking algorithm used to
implement them, which for compatibility purposes always means the Perl
algorithm.  Thus, when using these patterns we force @library{irregex}
to use a backtracking engine, and can't rely on efficient execution.

@c page
@node irregex sre char-sets
@subsection Character sets


Perhaps more common than matching specific strings is matching any of a
set of characters.  We can use the @code{or} alternation pattern on a
list of single--character strings to simulate a character set, but this
is too clumsy for everyday use so @acronym{SRE} syntax allows a number
of shortcuts.

A single character matches that character literally, a trivial character
class.  More conveniently, a list holding a single element which is a
string, refers to the character set composed of every character in the
string.

@example
(irregex-match '(* #\-) "---")
@result{} #<match>

(irregex-match '(* #\-) "-_-")
@result{} #f

(irregex-match '(* ("aeiou")) "oui")
@result{} #<match>

(irregex-match '(* ("aeiou")) "ouais")
@result{} #f
@end example

Ranges are introduced with the @code{/} operator.  Strings or characters
in the @code{/} are flattened and then taken in pairs to represent the
start and end points, inclusive, of character ranges.

@example
(irregex-match '(* (/ "AZ09")) "R2D2")
@result{} #<match>

(irregex-match '(* (/ "AZ09")) "C-3PO")
@result{} #f
@end example

In addition, a number of set algebra operations is provided.  @code{or},
of course, has the same meaning, but when all the options are character
sets it can be thought of as the set union operator.  This is further
extended by the @condition{} set intersection, @code{-} set difference, and
@code{~} set complement operators.

@example
(irregex-match '(* (& (/ "az") (~ ("aeiou")))) "xyzzy")
@result{} #<match>

(irregex-match '(* (& (/ "az") (~ ("aeiou")))) "vowels")
@result{} #f

(irregex-match '(* (- (/ "az") ("aeiou"))) "xyzzy")
@result{} #<match>

(irregex-match '(* (- (/ "az") ("aeiou"))) "vowels")
@result{} #f
@end example

@c page
@node irregex sre assertion
@subsection Assertion patterns


It can be useful to assert something about the area around a pattern,
without explicitly making it part of the pattern.  The most common cases
are specifically anchoring some pattern to the beginning or end of a
word or line or even the whole string.  For example, to match on the end
of a word:

@example
(irregex-match '(: "foo" eow) "foo")
@result{} #<match>

(irregex-match '(: "foo" eow) "foo!")
@result{} #<match>

(irregex-match '(: "foo" eow) "foof")
@result{} #f
@end example

The @code{bow}, @code{bol}, @code{eol}, @code{bos} and @code{eos} work
similarly.  @code{nwb} asserts that you are not in a word--boundary; if
replaced with @code{eow} in the above examples it would reverse all the
results.

There is no @code{wb}, since we probably know from context whether it
would be the beginning or end of a word, but if we need it we can always
use @code{(or bow eow)}.

Somewhat more generally, Perl introduced positive and negative
@code{look-ahead} and @code{look-behind} patterns.  Perl's
@code{look-behind} patterns are limited to a fixed length, however the
@library{irregex} versions have no such limit.

@example
(irregex-match '(: "regular" (look-ahead " expression"))
               "regular expression")
@result{} #<match>
@end example

The most general case, of course, would be an @code{and} pattern to
complement the @code{or} pattern; all the patterns must match or the
whole pattern fails.  This may be provided in a future release, although
it (and @code{look-ahead} and @code{look-behind} assertions) are
unlikely to be compiled efficiently.

@c page
@node irregex sre utility
@subsection Utility patterns


The following utility regular expressions are also provided for common
patterns that people are eternally reinventing.  They are not
necessarily the official patterns matching the @rfc{} definitions
of the given data, because of the way that such patterns tend to be
used.  There are three general usages for regexps:

@table @emph
@item Searching
Search for a pattern matching a desired object in a larger text.

@item Validation
Determine whether an entire string matches a pattern.

@item Extraction
Given a string already known to be valid, extract certain fields from it
as submatches.
@end table

In some cases, but not always, these will overlap.  When they are
different, @func{irregex-search} will naturally always want the
searching version, so @library{irregex} provides that version.

As an example where these might be different, consider an @aurl{}.  If
we want to match all the @aurl{}s in some arbitrary text, we probably
want to exclude a period or comma at the tail end of an @aurl{}, since
it's more likely being used as punctuation rather than part of the
@aurl{}, despite the fact that it would be valid @aurl{} syntax.

Another problem with the @rfc{} definitions is the standard itself may
have become irrelevant.  For example, the pattern @library{irregex}
provides for email addresses doesn't match quoted local parts
(e.g. @code{"first last"@@domain.com}) because these are increasingly
rare, and unsupported by enough software that it's better to discourage
their use.  Conversely, technically consecutive periods
(e.g. @code{first..last@@domain.com}) are not allowed in email
addresses, but most email software does allow this, and in fact such
addresses are quite common in Japan.

The current patterns provided are:

@table @code
@item newline
General newline pattern (@code{crlf}, @code{cr}, @code{lf}).

@item integer
An integer.

@item real
A real number (including scientific).

@item string
A ``quoted'' string.

@item symbol
An @rnrs{6} Scheme symbol.

@item ipv4-address
A numeric decimal IPv4 address.

@item ipv6-address
A numeric hexadecimal IPv6 address.

@item domain
A domain name.

@item email
An email address.

@item http-url
A @aurl{} beginning with @code{https?://}.
@end table

Because of these issues the exact definitions of these patterns are
subject to change, but will be documented clearly when they are
finalized.  More common patterns are also planned, but as what we want
increases in complexity it's probably better to use a real parser.

@c page
@node pregexp
@chapter Portable regular expressions for Scheme


The @library{pregexp} library implements regular expressions parsing
modeled on Perl's, and includes such powerful directives as numeric and
non--greedy quantifiers, capturing and non--capturing clustering,
@posix{} character classes, selective case- and space--insensitivity,
backreferences, alternation, backtrack pruning, positive and negative
lookahead and lookbehind, in addition to the more basic directives
familiar to all regexp users.

The library is based upon the Pregexp package by Dorai Sitaram.  It was
modified to work with @rnrs{6} Scheme implementations and to fit into
the Nausicaa distribution.

@menu
* pregexp intro::               Introduction.
* pregexp api::                 Interface procedures.
* pregexp syntax::              The regexp pattern language.
* pregexp example::             An extended example.
@end menu

@c page
@node pregexp intro
@section Introduction


A @dfn{regexp} is a string that describes a pattern.  A regexp matcher
tries to match this pattern against (a portion of) another string, which
we will call the text string.  The text string is treated as raw text
and not as a pattern.

Most of the characters in a regexp pattern are meant to match
occurrences of themselves in the text string.  Thus, the pattern
@code{abc} matches a string that contains the characters @code{a},
@code{b}, @code{c} in succession.

In the regexp pattern, some characters act as metacharacters, and some
character sequences act as metasequences.  That is, they specify
something other than their literal selves.  For example, in the pattern
@code{a.c}, the characters @code{a} and @code{c} do stand for themselves
but the metacharacter @code{.} can match any character (other than
newline).  Therefore, the pattern @code{a.c} matches an @code{a},
followed by any character, followed by a @code{c}.

If we needed to match the character @code{.} itself, we escape it, ie,
precede it with a backslash (@code{\}).  The character sequence
@code{\.} is thus a metasequence, since it doesn't match itself but
rather just @code{.}.  So, to match @code{a} followed by a literal
@code{.}  followed by @code{c}, we use the regexp pattern
@code{a\\.c}.@footnote{The double backslash is an artifact of Scheme
strings, not the regexp pattern itself.  When we want a literal
backslash inside a Scheme string, we must escape it so that it shows up
in the string at all.  Scheme strings use backslash as the escape
character, so we end up with two backslashes; one Scheme--string
backslash to escape the regexp backslash, which then escapes the dot.
Another character that would need escaping inside a Scheme string is
@code{"}.}  Another example of a metasequence is @code{\t}, which is a
readable way to represent the tab character.

We will call the string representation of a regexp the U-regexp, where U
can be taken to mean Unix-style or universal, because this notation for
regexps is universally familiar.  Our implementation uses an
intermediate tree--like representation called the S-regexp, where S can
stand for Scheme, symbolic, or s-expression.  S-regexps are more verbose
and less readable than U-regexps, but they are much easier for Scheme's
recursive procedures to navigate.

@c page
@node pregexp api
@section Interface procedures


@defun pregexp @var{urex}
Takes a U-regexp, which is a string, and returns an S-regexp, which is a
tree.

@example
(pregexp "c.r")
@result{} (:sub (:or (:seq #\c :any #\r)))
@end example

There is rarely any need to look at the S-regexps returned by pregexp.
@end defun


@defun pregexp-match-positions @var{rex} @var{str}
@defunx pregexp-match-positions @var{rex} @var{str} @var{start}
@defunx pregexp-match-positions @var{rex} @var{str} @var{start} @var{past}
Take a regexp pattern, either a U- or an S-regexp, and a text string,
and return a match if the regexp matches (some part of) the text string.

Return @false{} if the regexp did not match the string; and a list of
index pairs if it did match.

@example
(pregexp-match-positions "brain" "bird")
@result{} #f

(pregexp-match-positions "needle" "hay needle stack")
@result{} ((4 . 10))
@end example

In the second example, the integers @math{4} and @math{10} identify the
substring that was matched.  @math{4} is the starting (inclusive) index
and @math{10} the ending (exclusive) index of the matching substring.

@example
(substring "hay needle stack" 4 10)
@result{} "needle"
@end example

Here, @func{pregexp-match-positions}'s return list contains only one
index pair, and that pair represents the entire substring matched by the
regexp.  When we discuss subpatterns later, we will see how a single
match operation can yield a list of submatches.

@func{pregexp-match-positions} takes optional third and fourth arguments
that specify the indices of the text string within which the matching
should take place.

@example
(pregexp-match-positions "needle"
  "his hay needle stack -- my hay needle stack -- her hay needle stack"
  24 43)
@result{} ((31 . 37))
@end example

Note that the returned indices are still reckoned relative to the full
text string.
@end defun


@defun pregexp-match @var{rex} @var{str}
@defunx pregexp-match @var{rex} @var{str} @var{start}
@defunx pregexp-match @var{rex} @var{str} @var{start} @var{past}
Like @func{pregexp-match-positions} but instead of returning index pairs
it returns the matching substrings:

@example
(pregexp-match "brain" "bird")
@result{} #f

(pregexp-match "needle" "hay needle stack")
@result{} ("needle")
@end example
@end defun


@defun pregexp-split @var{rex} @var{str}
Takes a regexp pattern and a text string, and return a list of
substrings of the text string, where the pattern identifies the
delimiter separating the substrings.

@example
(pregexp-split ":"
   "/bin:/usr/bin:/usr/bin/X11:/usr/local/bin")
@result{} ("/bin" "/usr/bin" "/usr/bin/X11" "/usr/local/bin")

(pregexp-split " " "pea soup")
@result{} ("pea" "soup")
@end example

If the first argument can match an empty string, then the list of all
the single--character substrings is returned.

@example
(pregexp-split "" "smithereens")
@result{} ("s" "m" "i" "t" "h" "e" "r" "e" "e" "n" "s")
@end example

To identify one--or--more spaces as the delimiter, take care to use the
regexp @code{" +"}, not @code{" *"}.

@example
(pregexp-split " +" "split pea     soup")
@result{} ("split" "pea" "soup")

(pregexp-split " *" "split pea     soup")
@result{} ("s" "p" "l" "i" "t" "p" "e" "a" "s" "o" "u" "p")
@end example
@end defun


@defun pregexp-replace @var{rex} @var{str} @var{replacement}
Replace the matched portion of the text string by another string.  The
first argument is the pattern, the second the text string, and the third
is the insert string (string to be inserted).

@example
(pregexp-replace "te" "liberte" "ty")
@result{} "liberty"
@end example

If the pattern doesn't occur in the text string, the returned string is
identical (@func{eq?}) to the text string.
@end defun


@defun pregexp-replace* @var{rex} @var{str} @var{replacement}
Replace all matches in the text string by the insert string:

@example
(pregexp-replace* "te" "liberte egalite fraternite" "ty")
@result{} "liberty egality fratyrnity"
@end example

If the pattern doesn't occur in the text string, the returned string is
identical (@func{eq?}) to the text string.
@end defun


@defun pregexp-quote
Take an arbitrary string and returns a U-regexp (string) that precisely
represents it.  In particular, characters in the input string that could
serve as regexp metacharacters are escaped with a backslash, so that
they safely match only themselves.

@example
(pregexp-quote "cons")
@result{} "cons"

(pregexp-quote "list?")
@result{} "list\\?"

(pregexp-quote "([a-z]+) +([0-9]+,)? *([0-9]+)")
@result{} "\\(\\[a-z\\]\\+\\) \\+\\(\\[0-9\\]\\+,\\)\\? \\*\\(\\[0-9\\]\\+\\)"
@end example

@func{pregexp-quote} is useful when building a composite regexp from a
mix of regexp strings and verbatim strings.
@end defun

@c page
@node pregexp syntax
@section The regexp pattern language


Here is a complete description of the regexp pattern language recognized
by the pregexp procedures.

@menu
* pregexp syntax basic::        Basic assertions.
* pregexp syntax chars::        Characters and character classes.
* pregexp syntax quantifiers::  Quantifiers.
* pregexp syntax clusters::     Clusters.
* pregexp syntax alternation::  Alternation.
* pregexp syntax backtrack::    Backtracking.
* pregexp syntax look::         Looking ahead and behind.
@end menu

@c page
@node pregexp syntax basic
@subsection Basic assertions


The assertions @code{^} and @code{$} identify the beginning and the end
of the text string respectively.  They ensure that their adjoining
regexps match at one or other end of the text string.  Examples:

@example
(pregexp-match-positions "^contact" "first contact")
@result{} #f
@end example

The regexp fails to match because @code{contact} does not occur at the
beginning of the text string.

@example
(pregexp-match-positions "laugh$" "laugh laugh laugh laugh")
@result{} ((18 . 23))
@end example

The regexp matches the last laugh.

The metasequence @code{\b} asserts that a word boundary exists.

@example
(pregexp-match-positions "yack\\b" "yackety yack")
@result{} ((8 . 12))
@end example

The @code{yack} in @code{yackety} doesn't end at a word boundary so it
isn't matched.  The second @code{yack} does and is.

The metasequence @code{\B} has the opposite effect to @code{\b}: It
asserts that a word boundary does not exist.

@example
(pregexp-match-positions "an\\B" "an analysis")
@result{} ((3 . 5))
@end example

The @code{an} that doesn't end in a word boundary is matched.

@c page
@node pregexp syntax chars
@subsection Characters and character classes


Typically a character in the regexp matches the same character in the
text string.  Sometimes it is necessary or convenient to use a regexp
metasequence to refer to a single character.  Thus, metasequences
@code{\n}, @code{\r}, @code{\t}, and @code{\.} match the newline,
return, tab and period characters respectively.

The metacharacter period (@code{.}) matches any character other than
newline.

@example
(pregexp-match "p.t" "pet")
@result{} ("pet")
@end example

It also matches @code{pat}, @code{pit}, @code{pot}, @code{put}, and
@code{p8t} but not @code{peat} or @code{pfffft}.

A character class matches any one character from a set of characters. A
typical format for this is the bracketed character class @code{[...]},
which matches any one character from the non--empty sequence of
characters enclosed within the brackets.@footnote{Requiring a bracketed
character class to be non-empty is not a limitation, since an empty
character class can be more easily represented by an empty string.}
Thus @code{p[aeiou]t} matches pat, pet, pit, pot, put and nothing else.

Inside the brackets, a hyphen (@code{-}) between two characters
specifies the @ascii{} range between the characters.  Eg,
@code{ta[b-dgn-p]} matches tab, tac, tad, and tag, and tan, tao, tap.

An initial caret (@code{^}) after the left bracket inverts the set
specified by the rest of the contents, ie, it specifies the set of
characters other than those identified in the brackets.  Eg,
@code{do[^g]} matches all three--character sequences starting with do
except dog.

Note that the metacharacter @code{^} inside brackets means something
quite different from what it means outside.  Most other metacharacters
(@code{.}, @code{*}, @code{+}, @code{?}, etc.) cease to be
metacharacters when inside brackets, although we may still escape them
for peace of mind.  @code{-} is a metacharacter only when it's inside
brackets, and neither the first nor the last character.

Bracketed character classes cannot contain other bracketed character
classes (although they contain certain other types of character classes;
see below).  Thus a left bracket (@code{[}) inside a bracketed character
class doesn't have to be a metacharacter; it can stand for itself.  Eg,
@code{[a[b]} matches @code{a}, @code{[}, and @code{b}.

Furthermore, since empty bracketed character classes are disallowed, a
right bracket (@code{]}) immediately occurring after the opening left
bracket also doesn't need to be a metacharacter.  Eg, @code{[]ab]}
matches @code{]}, @code{a}, and @code{b}.

@c ------------------------------------------------------------

@subsubheading Some frequently used character classes

Some standard character classes can be conveniently represented as
metasequences instead of as explicit bracketed expressions.  @code{\d}
matches a digit (@code{[0-9]}); @code{\s} matches a whitespace
character; @code{\w} matches a character that could be part of a
``word''.@footnote{Following regexp custom, we identify ``word''
characters as @code{[A-Za-z0-9_]}, although these are too restrictive
for what a Schemer might consider a ``word''.}

The upper--case versions of these metasequences stand for the inversions
of the corresponding character classes.  Thus @code{\D} matches a
non--digit, @code{\S} a non--whitespace character, and @code{\W} a
non--``word'' character.

Remember to include a double backslash when putting these metasequences
in a Scheme string:

@example
(pregexp-match "\\d\\d"
               "0 dear, 1 have 2 read catch 22 before 9")
@result{} ("22")
@end example

These character classes can be used inside a bracketed expression.  Eg,
@code{[a-z\\d]} matches a lower--case letter or a digit.

@c ------------------------------------------------------------

@subsubheading @posix{} character classes

A @posix{} character class is a special metasequence of the form
@code{[:...:]} that can be used only inside a bracketed expression.  The
@posix{} classes supported are:

@table @code
@item [:alnum:]
Letters and digits.

@item [:alpha:]
Letters.

@item [:algor:]
The letters c, h, a and d.

@item [:ascii:]
7-bit ascii characters.

@item [:blank:]
Widthful whitespace, ie, space and tab.

@item [:cntrl:]
``Control'' characters, viz, those with code @math{< 32}.

@item [:digit:]
Digits, same as @code{\d}.

@item [:graph:]
Characters that use ink.

@item [:lower:]
Lower-case letters.

@item [:print:]
Ink-users plus widthful whitespace.

@item [:space:]
Whitespace, same as @code{\s}.

@item [:upper:]
Upper--case letters.

@item [:word:]
Letters, digits, and underscore, same as @code{\w}.

@item [:xdigit:]
Hex digits.
@end table

For example, the regexp @code{[[:alpha:]_]} matches a letter or
underscore.

@example
(pregexp-match "[[:alpha:]_]" "--x--")
@result{} ("x")

(pregexp-match "[[:alpha:]_]" "--_--")
@result{} ("_")

(pregexp-match "[[:alpha:]_]" "--:--")
@result{} #f
@end example

The @posix{} class notation is valid only inside a bracketed expression.
For instance, @code{[:alpha:]}, when not inside a bracketed expression,
will not be read as the letter class.  Rather it is (from previous
principles) the character class containing the characters :, a, l, p, h.

@example
(pregexp-match "[:alpha:]" "--a--")
@result{} ("a")

(pregexp-match "[:alpha:]" "--_--")
@result{} #f
@end example

By placing a caret (@code{^}) immediately after @code{[:}, we get the
inversion of that @posix{} character class.  Thus, @code{[:^alpha]} is
the class containing all characters except the letters.

@c page
@node pregexp syntax quantifiers
@subsection Quantifiers


The quantifiers @code{*}, @code{+}, and @code{?} match respectively:
zero or more, one or more, and zero or one instances of the preceding
subpattern.

@example
(pregexp-match-positions "c[ad]*r" "cadaddadddr")
@result{} ((0 . 11))
(pregexp-match-positions "c[ad]*r" "cr")
@result{} ((0 . 2))

(pregexp-match-positions "c[ad]+r" "cadaddadddr")
@result{} ((0 . 11))
(pregexp-match-positions "c[ad]+r" "cr")
@result{} #f

(pregexp-match-positions "c[ad]?r" "cadaddadddr")
@result{} #f
(pregexp-match-positions "c[ad]?r" "cr")
@result{} ((0 . 2))
(pregexp-match-positions "c[ad]?r" "car")
@result{} ((0 . 3))
@end example

@c ------------------------------------------------------------

@subsubheading  Numeric quantifiers

We can use braces to specify much finer--tuned quantification than is
possible with @code{*}, @code{+}, @code{?}.

The quantifier @code{@{m@}} matches exactly @math{m} instances of the
preceding subpattern.  @math{m} must be a nonnegative integer.

The quantifier @code{@{m,n@}} matches at least @math{m} and at most
@math{n} instances.  @math{m} and @math{n} are nonnegative integers with
@math{m <= n}.  We may omit either or both numbers, in which case
@math{m} defaults to @math{0} and @math{n} to infinity.

It is evident that @code{+} and @code{?} are abbreviations for
@code{@{1,@}} and @code{@{0,1@}} respectively.  @code{*} abbreviates
@code{@{,@}}, which is the same as @code{@{0,@}}.

@example
(pregexp-match "[aeiou]@{3@}" "vacuous")
@result{} ("uou")

(pregexp-match "[aeiou]@{3@}" "evolve")
@result{} #f

(pregexp-match "[aeiou]@{2,3@}" "evolve")
@result{} #f

(pregexp-match "[aeiou]@{2,3@}" "zeugma")
@result{} ("eu")
@end example

@c ------------------------------------------------------------

@subsubheading Non--greedy quantifiers

The quantifiers described above are greedy, i.e., they match the maximal
number of instances that would still lead to an overall match for the
full pattern.

@example
(pregexp-match "<.*>" "<tag1> <tag2> <tag3>")
@result{} ("<tag1> <tag2> <tag3>")
@end example

To make these quantifiers non--greedy, append a @code{?} to them.
Non--greedy quantifiers match the minimal number of instances needed to
ensure an overall match.

@example
(pregexp-match "<.*?>" "<tag1> <tag2> <tag3>")
@result{} ("<tag1>")
@end example

The non--greedy quantifiers are respectively: @code{*?}, @code{+?},
@code{??}, @code{@{m@}?}, @code{@{m,n@}?}.  Note the two uses of the
metacharacter @code{?}.

@c page
@node pregexp syntax clusters
@subsection Clusters


Clustering, i.e., enclosure within parens @code{(...)}, identifies the
enclosed subpattern as a single entity.  It causes the matcher to
capture the submatch, or the portion of the string matching the
subpattern, in addition to the overall match.

@example
(pregexp-match "([a-z]+) ([0-9]+), ([0-9]+)" "jan 1, 1970")
@result{} ("jan 1, 1970" "jan" "1" "1970")
@end example

Clustering also causes a following quantifier to treat the entire
enclosed subpattern as an entity.

@example
(pregexp-match "(poo )*" "poo poo platter")
@result{} ("poo poo " "poo ")
@end example

The number of submatches returned is always equal to the number of
subpatterns specified in the regexp, even if a particular subpattern
happens to match more than one substring or no substring at all.

@example
(pregexp-match "([a-z ]+;)*" "lather; rinse; repeat;")
@result{} ("lather; rinse; repeat;" " repeat;")
@end example

Here the @code{*}--quantified subpattern matches three times, but it is
the last submatch that is returned.

It is also possible for a quantified subpattern to fail to match, even
if the overall pattern matches.  In such cases, the failing submatch is
represented by @false{}.

@example
(define date-re
  ;match `month year' or `month day, year'.
  ;subpattern matches day, if present
  (pregexp "([a-z]+) +([0-9]+,)? *([0-9]+)"))

(pregexp-match date-re "jan 1, 1970")
@result{} ("jan 1, 1970" "jan" "1," "1970")

(pregexp-match date-re "jan 1970")
@result{} ("jan 1970" "jan" #f "1970")
@end example

@c ------------------------------------------------------------

@subsubheading Backreferences

Submatches can be used in the insert string argument of the procedures
@func{pregexp-replace} and @func{pregexp-replace*}.  The insert string
can use @code{\n} as a backreference to refer back to the @math{n}-th
submatch, i.e., the substring that matched the @math{n}-th subpattern.
@code{\0} refers to the entire match, and it can also be specified as
@code{\&}.

@example
(pregexp-replace "_(.+?)_"
  "the _nina_, the _pinta_, and the _santa maria_"
  "*\\1*")
@result{} "the *nina*, the _pinta_, and the _santa maria_"

(pregexp-replace* "_(.+?)_"
  "the _nina_, the _pinta_, and the _santa maria_"
  "*\\1*")
@result{} "the *nina*, the *pinta*, and the *santa maria*"
@end example

@noindent
recall: @code{\S} stands for non--whitespace character:

@example
(pregexp-replace "(\\S+) (\\S+) (\\S+)"
  "eat to live"
  "\\3 \\2 \\1")
@result{} "live to eat"
@end example

Use @code{\\} in the insert string to specify a literal backslash.
Also, @code{\$} stands for an empty string, and is useful for separating
a backreference @code{\n} from an immediately following number.

Backreferences can also be used within the regexp pattern to refer back
to an already matched subpattern in the pattern.  @code{\n} stands for
an exact repeat of the @math{n}-th submatch.@footnote{@code{0}, which is
useful in an insert string, makes no sense within the regexp pattern,
because the entire regexp has not matched yet that you could refer back
to it.}

@example
(pregexp-match "([a-z]+) and \\1"
  "billions and billions")
@result{} ("billions and billions" "billions")
@end example

Note that the backreference is not simply a repeat of the previous
subpattern.  Rather it is a repeat of the particular substring already
matched by the subpattern.

In the above example, the backreference can only match billions.  It
will not match millions, even though the subpattern it harks back to
@code{([a-z]+)} would have had no problem doing so:

@example
(pregexp-match "([a-z]+) and \\1"
  "billions and millions")
@result{} #f
@end example

The following corrects doubled words:

@example
(pregexp-replace* "(\\S+) \\1"
  "now is the the time for all good men to to come to the aid of of the party"
  "\\1")
@result{} "now is the time for all good men to come to the aid of the party"
@end example

The following marks all immediately repeating patterns in a number
string:

@example
(pregexp-replace* "(\\d+)\\1"
  "123340983242432420980980234"
  "@{\\1,\\1@}")
@result{} "12@{3,3@}40983@{24,24@}3242@{098,098@}0234"
@end example

@c ------------------------------------------------------------

@subsubheading Non--capturing clusters

It is often required to specify a cluster (typically for quantification)
but without triggering the capture of submatch information.  Such
clusters are called non--capturing.  In such cases, use @code{(?:}
instead of @code{(} as the cluster opener.  In the following example,
the non--capturing cluster eliminates the ``directory'' portion of a
given pathname, and the capturing cluster identifies the basename.

@example
(pregexp-match "^(?:[a-z]*/)*([a-z]+)$"
  "/usr/local/bin/mzscheme")
@result{} ("/usr/local/bin/mzscheme" "mzscheme")
@end example

@c ------------------------------------------------------------

@subsubheading Cloisters

@cindex pregexp-comment-char

The location between the @code{?} and the @code{:} of a non--capturing
cluster is called a cloister.@footnote{A useful, if terminally cute,
coinage from the abbots of Perl.}  We can put modifiers there that will
cause the enclustered subpattern to be treated specially.  The modifier
@code{i} causes the subpattern to match case--insensitively:

@example
(pregexp-match "(?i:hearth)" "HeartH")
@result{} ("HeartH")
@end example

The modifier @code{x} causes the subpattern to match
space--insensitively, i.e., spaces and comments within the subpattern
are ignored.  Comments are introduced as usual with a semicolon
(@code{;}) and extend till the end of the line.  If we need to include a
literal space or semicolon in a space--insensitized subpattern, escape
it with a backslash.

@example
(pregexp-match "(?x: a   lot)" "alot")
@result{} ("alot")

(pregexp-match "(?x: a  \\  lot)" "a lot")
@result{} ("a lot")

(pregexp-match "(?x:
   a \\ man  \\; \\   ; ignore
   a \\ plan \\; \\   ; me
   a \\ canal         ; completely
   )"
 "a man; a plan; a canal")
@result{} ("a man; a plan; a canal")
@end example

The parameter @func{pregexp-comment-char} contains the comment character
(#\;).  For Perl--like comments,

@example
(parameterise ((pregexp-comment-char #\#))
   ---)
@end example

We can put more than one modifier in the cloister.

@example
(pregexp-match "(?ix:
   a \\ man  \\; \\   ; ignore
   a \\ plan \\; \\   ; me
   a \\ canal         ; completely
   )"
 "A Man; a Plan; a Canal")
@result{} ("A Man; a Plan; a Canal")
@end example

A minus sign before a modifier inverts its meaning.  Thus, we can use
@code{-i} and @code{-x} in a subcluster to overturn the insensitivities
caused by an enclosing cluster.

@example
(pregexp-match "(?i:the (?-i:TeX)book)"
  "The TeXbook")
@result{} ("The TeXbook")
@end example

This regexp will allow any casing for the and book but insists that TeX
not be differently cased.

@c page
@node pregexp syntax alternation
@subsection Alternation


You can specify a list of alternate subpatterns by separating them by
@code{|}.  The @code{|} separates subpatterns in the nearest enclosing
cluster (or in the entire pattern string if there are no enclosing
parens).

@example
(pregexp-match "f(ee|i|o|um)" "a small, final fee")
@result{} ("fi" "i")

(pregexp-replace* "([yi])s(e[sdr]?|ing|ation)"
   "it is energising to analyse an organisation
   pulsing with noisy organisms"
   "\\1z\\2")
@result{} "it is energizing to analyze an organization
   pulsing with noisy organisms"
@end example

Note again that if we wish to use clustering merely to specify a list of
alternate subpatterns but do not want the submatch, use @code{(?:}
instead of @code{(}.

@example
(pregexp-match "f(?:ee|i|o|um)" "fun for all")
@result{} ("fo")
@end example

An important thing to note about alternation is that the leftmost
matching alternate is picked regardless of its length.  Thus, if one of
the alternates is a prefix of a later alternate, the latter may not have
a chance to match.

@example
(pregexp-match "call|call-with-current-continuation"
  "call-with-current-continuation")
@result{} ("call")
@end example

To allow the longer alternate to have a shot at matching, place it
before the shorter one:

@example
(pregexp-match "call-with-current-continuation|call"
  "call-with-current-continuation")
@result{} ("call-with-current-continuation")
@end example

In any case, an overall match for the entire regexp is always preferred
to an overall nonmatch.  In the following, the longer alternate still
wins, because its preferred shorter prefix fails to yield an overall
match.

@example
(pregexp-match "(?:call|call-with-current-continuation) constrained"
  "call-with-current-continuation constrained")
@result{} ("call-with-current-continuation constrained")
@end example

@c page
@node pregexp syntax backtrack
@subsection Backtracking


We've already seen that greedy quantifiers match the maximal number of
times, but the overriding priority is that the overall match
succeed.  Consider:

@example
(pregexp-match "a*a" "aaaa")
@end example

The regexp consists of two subregexps, @code{a*} followed by @code{a}.
The subregexp @code{a*} cannot be allowed to match all four @code{a}'s
in the text string @code{aaaa}, even though @code{*} is a greedy
quantifier.  It may match only the first three, leaving the last one for
the second subregexp.  This ensures that the full regexp matches
successfully.

The regexp matcher accomplishes this via a process called backtracking.
The matcher tentatively allows the greedy quantifier to match all four
@code{a}'s, but then when it becomes clear that the overall match is in
jeopardy, it backtracks to a less greedy match of three @code{a}'s.  If
even this fails, as in the call:

@example
(pregexp-match "a*aa" "aaaa")
@end example

@noindent
the matcher backtracks even further.  Overall failure is conceded only
when all possible backtracking has been tried with no success.

Backtracking is not restricted to greedy quantifiers.  Nongreedy
quantifiers match as few instances as possible, and progressively
backtrack to more and more instances in order to attain an overall
match.  There is backtracking in alternation too, as the more rightward
alternates are tried when locally successful leftward ones fail to yield
an overall match.

@c ------------------------------------------------------------

@subsubheading Disabling backtracking

Sometimes it is efficient to disable backtracking.  For example, we may
wish to commit to a choice, or we know that trying alternatives is
fruitless.  A nonbacktracking regexp is enclosed in @code{(?>...)}.

@example
(pregexp-match "(?>a+)." "aaaa")
@result{} #f
@end example

In this call, the subregexp @code{?>a+} greedily matches all four
@code{a}'s, and is denied the opportunity to backpedal.  So the overall
match is denied.  The effect of the regexp is therefore to match one or
more @code{a}'s followed by something that is definitely non--@code{a}.

@c page
@node pregexp syntax look
@subsection Looking ahead and behind


We can have assertions in our pattern that look ahead or behind to
ensure that a subpattern does or does not occur.  These ``look around''
assertions are specified by putting the subpattern checked for in a
cluster whose leading characters are:

@table @code
@item ?=
Positive lookahead.

@item ?!
Negative lookahead.

@item ?<=
Positive lookbehind.

@item ?<!
Negative lookbehind.
@end table

Note that the subpattern in the assertion does not generate a match in
the final result.  It merely allows or disallows the rest of the match.

@c ------------------------------------------------------------

@subsubheading Lookahead

Positive lookahead (@code{?=}) peeks ahead to ensure that its subpattern
could match.

@example
(pregexp-match-positions "grey(?=hound)"
  "i left my grey socks at the greyhound")
@result{} ((28 . 32))
@end example

The regexp @code{grey(?=hound)} matches grey, but only if it is followed
by hound.  Thus, the first grey in the text string is not matched.

Negative lookahead (@code{?!}) peeks ahead to ensure that its subpattern
could not possibly match.

@example
(pregexp-match-positions "grey(?!hound)"
  "the gray greyhound ate the grey socks")
@result{} ((27 . 31))
@end example

The regexp @code{grey(?!hound)} matches @code{grey}, but only if it is
not followed by @code{hound}.  Thus the @code{grey} just before
@code{socks} is matched.

@c ------------------------------------------------------------

@subsubheading Lookbehind

Positive lookbehind (@code{?<=}) checks that its subpattern could match
immediately to the left of the current position in the text string.

@example
(pregexp-match-positions "(?<=grey)hound"
  "the hound in the picture is not a greyhound")
@result{} ((38 . 43))
@end example

The regexp @code{(?<=grey)hound} matches hound, but only if it is
preceded by grey.

Negative lookbehind (@code{?<!}) checks that its subpattern could not
possibly match immediately to the left.

@example
(pregexp-match-positions "(?<!grey)hound"
  "the greyhound in the picture is not a hound")
@result{} ((38 . 43))
@end example

The regexp @code{(?<!grey)hound} matches @code{hound}, but only if it is
not preceded by @code{grey}.

Lookaheads and lookbehinds can be convenient when they are not
confusing.

@c page
@node pregexp example
@section An extended example


Here's an extended example@footnote{From: Jeffrey E. F. Friedl,
Mastering Regular Expressions, 2/e, O'Reilly, 2002.}  that covers many
of the features in @library{pregexp}.  The problem is to fashion a
regexp that will match any and only @ip{} addresses or dotted quads,
i.e., four numbers separated by three dots, with each number between
@math{0} and @math{255}.  We will use the commenting mechanism to build
the final regexp with clarity.  First, a subregexp @code{n0-255} that
matches @code{0} through @code{255}.

@example
(define n0-255
  "(?x:
  \\d          ;  0 through   9
  | \\d\\d     ; 00 through  99
  | [01]\\d\\d ;000 through 199
  | 2[0-4]\\d  ;200 through 249
  | 25[0-5]    ;250 through 255
  )")
@end example

The first two alternates simply get all single- and double--digit
numbers.  Since zero--padding is allowed, we need to match both @code{1}
and @code{01}.  We need to be careful when getting @math{3}--digit
numbers, since numbers above @math{255} must be excluded.  So we fashion
alternates to get @code{000} through @code{199}, then @code{200} through
@code{249}, and finally @code{250} through @code{255}.@footnote{Note
that @code{n0-255} lists prefixes as preferred alternates, something we
cautioned against.  However, since we intend to anchor this subregexp
explicitly to force an overall match, the order of the alternates does
not matter.}

An @ip{}--address is a string that consists of four @code{n0-255}s with
three dots separating them.

@example
(define ip-re1
  (string-append
    "^"        ;nothing before
    n0-255     ;the first n0-255,
    "(?x:"     ;then the subpattern of
    "\\."      ;a dot followed by
    n0-255     ;an n0-255,
    ")"        ;which is
    "@{3@}"      ;repeated exactly 3 times
    "$"        ;with nothing following
    ))
@end example

Let's try it out.

@example
(pregexp-match ip-re1
  "1.2.3.4")
@result{} ("1.2.3.4")

(pregexp-match ip-re1
  "55.155.255.265")
@result{} #f
@end example

@noindent
which is fine, except that we also have:

@example
(pregexp-match ip-re1
  "0.00.000.00")
@result{} ("0.00.000.00")
@end example

All--zero sequences are not valid @ip{} addresses!  Lookahead to the
rescue.  Before starting to match @code{ip-re1}, we look ahead to ensure
we don't have all zeros.  We could use positive lookahead to ensure
there is a digit other than zero.

@example
(define ip-re
  (string-append
    "(?=.*[1-9])" ;ensure there's a non-0 digit
    ip-re1))
@end example

Or we could use negative lookahead to ensure that what's ahead isn't
composed of only zeros and dots.

@example
(define ip-re
  (string-append
    "(?![0.]*$)" ;not just zeros and dots
                 ;(note: dot is not metachar inside [])
    ip-re1))
@end example

The regexp @code{ip-re} will match all and only valid @ip{} addresses.

@example
(pregexp-match ip-re
  "1.2.3.4")
@result{} ("1.2.3.4")

(pregexp-match ip-re
  "0.0.0.0")
@result{} #f
@end example

@c page
@node parser-tools
@chapter Lexer and parser utilities


A set of libraries provides basic tools to implement lexers, parsers and
the interface between them.  These tools are meant to be used by all the
lexers and parsers distributed with @value{PACKAGE};  at present they
are used by @library{silex} and @library{lalr}.

@menu
* parser-tools location::       Source location records.
* parser-tools token::          Lexical token records.
@end menu

@c page
@node parser-tools location
@section Source location records


Location records are meant to store informations about the position of a
token in the input stream; they should be produced by the lexer and
either discarded or consumed by the parser's error handler.  All the
bindings are exported by the @library{parser-tools source-location}
library; this library is built on top of @library{classes} and
@library{generics}.

It is cleaner to implement the parser in such a way that location
records are used only by client--supplied error handlers, not by the
parser itself.  The parser should handle the location as an opaque
value, possibly @false{} when there is no consistent way to track the
source location.

@menu
* parser-tools location type::          The record type.
* parser-tools location makers::        Building records.
* parser-tools location pred::          Predicates.
* parser-tools location cmp::           Comparison functions.
* parser-tools location update::        Updating the location.
* parser-tools location misc::          Miscellaneous functions.
@end menu

@c page
@node parser-tools location type
@subsection Type, makers, accessors


@deftp Class @aclass{source-location}
References the position of the next character to parse in the input
stream, which is the position of the first char in the next token
produced by the lexer.
@end deftp


@defcv {Immutable Field} @aclass{source-location} input
Describes the source of the input.  It can be any Scheme value, for
example a string representing the pathname of an input file.  Set to
@false{} if the source is unknown.
@end defcv


@defcv {Immutable Field} @aclass{source-location} line
@defcvx {Immutable Field} @aclass{source-location} column
@defcvx {Immutable Field} @aclass{source-location} offset
Counters for the line number, column number and character offset from
the start of the input.  By convention: Line and column numbers start
from @math{1}, the offset starts from @math{0}.

When the value of these counters is not known, by convention, they
should be set to @false{}, so that they are no more numbers.

Notice that these values match the local bindings @samp{yyline},
@samp{yycolumn} and @samp{yyoffset} available to the lexer actions of
the @library{silex} library.  @ref{silex semantics action, Evaluation of
the actions}
@end defcv


@defcv {Immutable Virtual Field} @aclass{source-location} line-string
@defcvx {Immutable Virtual Field} @aclass{source-location} column-string
@defcvx {Immutable Virtual Field} @aclass{source-location} offset-string
Strings representing the counters for the line number, column number and
character offset from the start of the input.
@end defcv


@defun <source-location>-input @var{loc}
@defunx <source-location>-line @var{loc}
@defunx <source-location>-column @var{loc}
@defunx <source-location>-offset @var{loc}
Accessors for the fields of a @class{source-location} record.
@end defun

@c page
@node parser-tools location makers
@subsection Building records


@defun make-<source-location> @var{input} @var{line} @var{colum} @var{offset}
Build and return a record of type @class{source-location}.
@end defun


@defun make-<source-location>/start @var{input}
Build and return a @class{source-location} record representing the very
beginning of an input stream.  The line and column counters are set to
@math{1}, the offset counter is set to @math{0}; @var{input} is stored
in the @samp{input} field.
@end defun

@c page
@node parser-tools location pred
@subsection Predicates


@defun <source-location>? @var{obj}
@defunx <source-location>?/or-false @var{obj}
Return true if @var{obj} is a record of type @class{source-location}.
The second variant accepts @false{}, too.
@end defun


@defun <source-location>?/start @var{obj}
@defunx <source-location>?/start/or-false @var{obj}
Return true if @var{obj} is a record of type @class{source-location} and
it represents the first possible location: Column and line counters set
to @math{1}.  The offset counter is ignored.  The second variant accepts
@false{}, too.
@end defun

@c page
@node parser-tools location cmp
@subsection Comparison functions


@defun source-location=? @vari{loc} @varii{loc}
Compare @vari{loc} and @varii{loc} which must be @false{} or records of
type @class{source-location}.  Return true if @vari{loc} and @varii{loc}
are true and the line, column and offset counters have the same values.
@end defun


The following comparison functions establish an ordering in the space of
the @class{source-location} records and @false{} by comparing the line
and column counters.  By convention:

@itemize
@item
A @class{source-location} record is more advanced than @false{} in the
input stream.

@item
When the arguments of a comparision function application are both
@false{}, the result is @false{}.
@end itemize


@defun source-location-point=? @vari{loc} @varii{loc}
Return @true{} if the line and column counters of @vari{loc} and
@varii{loc} have the same values.
@end defun


@defun source-location-point>? @vari{loc} @varii{loc}
Return @true{} if @vari{loc} is more advanced in the input stream than
@varii{loc}.
@end defun


@defun source-location-point>=? @vari{loc} @varii{loc}
Return @true{} if @vari{loc} is more advanced or at the same point, in
the input stream than @varii{loc}.
@end defun


@defun source-location-point<? @vari{loc} @varii{loc}
Return @true{} if @vari{loc} is less advanced in the input stream than
@varii{loc}.
@end defun


@defun source-location-point<=? @vari{loc} @varii{loc}
Return @true{} if @vari{loc} is less advanced or at the same point, in
the input stream than @varii{loc}.
@end defun

@c page
@node parser-tools location update
@subsection Updating the location


@defun source-location-update @var{location} @var{char/token-length}
If @var{location} is @false{}, the return value is @false{}.  If
@var{location} is a @class{source-location} record, build and return a
new @class{source-location} record representing the position of the next
char to be parsed in the input stream, starting from @var{location} and
updated with @var{char/token-length}.

@itemize
@item
If @var{char/token-length} is an exact integer, it is interpreted as
token length.  The column and offset counters from @var{location} are
incremented by that amount.

@item
If @var{char/token-length} is the @samp{#\return} character the action
depends upon the value of the @samp{source-location-honor-return}
parameter: if it is true, the column counter is set to @math{1} and the
offset counter is incremented by @math{1}; if it is @false{}, the column
and offset counters are incremented by @math{1}.

@item
If @var{char/token-length} is the @samp{#\newline} character: The line
counter is incremented by @math{1}, the column counter is set to
@math{1} and the offset counter is incremented by @math{1}.

@item
If @var{char/token-length} is the @samp{#\tab} character: The offset
counter is incremented by @math{1} and the column counter is set to the
result of:

@example
((source-location-tab-function)
    (<source-location>-column @var{location}))
@end example

@noindent
that is, the current procedure in the
@samp{source-location-tab-function} parameter is applied to the column
counter to produce the next column counter's value.
@end itemize
@end defun


@deffn Parameter source-location-tab-function
Hold a function used to produce the next column counter's value given
the current column counter.  By default it is set to
@func{source-location-tab-function/8chars}.
@end deffn


@defun source-location-tab-function/8chars @var{column}
Return the smallest multiple of @math{8} which is greater than
@var{column}.
@end defun


@defun source-location-tab-function/tab-table @var{column}
Produce the next column counter's value drawing it from the list of
horizontal tabulation offsets in the @samp{source-location-tab-table}
parameter.  The returned value is the smallest offset which is greater
than @var{column}.  If the list is null or all the offsets are smaller
than @var{column}, @func{source-location-tab-function/8chars} is used to
compute the return value.
@end defun


@deffn Parameter source-location-tab-table
Hold a list of horizontal tabulation offsets, sorted in increasing
order.  The default value is null.
@end deffn


@deffn Parameter source-location-honor-return
Hold a boolean value which causes @func{source-location-update} to honor
a @samp{#\return} character or not.
@end deffn

@c page
@node parser-tools location misc
@subsection Miscellaneous functions


The procedures described here make use of the @library{generics}
library; @ref{generics, Multimethod dispatching}.


@defun source-location->string @var{loc}
Return a string representation of @var{loc}, which must be a record of
type @class{source-location} or @false{}.  If @var{loc} is @false{}, the
return value is the string @samp{<??>}; else the result is of the form:

@example
<input>:line:column
@end example

@noindent
for example @samp{main.c:33:7}.  @meta{input} is a string produced by
applying @func{object->string} to the value of the @samp{input} field of
@var{loc}.

Notice that the use of this function is not mandatory at all.
@end defun


@deffn Method object->string (@var{o} <source-location>)
Return a string representation of @var{o}.  It is a wrapper for
@func{source-location->string}.
@end deffn

@c page
@node parser-tools token
@section Lexical token records


Lexical token records are meant to store informations about a token from
the input stream; they should be produced by the lexer and consumed by
the parser.  The following bindings are exported by the
@library{parser-tools lexical-token} library; this library is built on
top of @library{classes}.

@menu
* parser-tools token type::     The record type.
* parser-tools token maker::    Record makers.
* parser-tools token pred::     Predicates.
@end menu

@c page
@node parser-tools token type
@subsection The record type


@deftp Class @aclass{lexical-token}
Hold the informations about a token from the input stream.
@end deftp


@defcv {Immutable Field} @aclass{lexical-token} category
Represents the grammar's terminal symbol to which this token belongs.
Every parser @api{} must provide an interface to specify the list of
allowed terminal symbols.
@end defcv


@defcv {Immutable Field} @aclass{lexical-token} location
Represents the location in the input from which the token was built; it
must be @false{} or an instance of @class{source-location} record.
@end defcv


@defcv {Immutable Field} @aclass{lexical-token} value
Represents the semantic value associated with the token.  It can be any
Scheme value.
@end defcv


@defcv {Immutable Field} @aclass{lexical-token} length
It is meant to be the length of the string which generated the token.
When the token represents the end--of--input, this field can be set to
zero.
@end defcv


@defun <lexical-token>-category @var{tok}
@defunx <lexical-token>-location @var{tok}
@defunx <lexical-token>-value @var{tok}
@defunx <lexical-token>-length @var{tok}
Accessors for the fields of @class{lexical-token} records.
@end defun

@c page
@node parser-tools token maker
@subsection Record makers


For example, when the lexer tokenises the number @math{123} from the
string @samp{123}, it can build a record with:

@example
(let ((position ---))
  (make-<lexical-token> 'NUMBER position 123 3))
@end example

@noindent
while when tokenising a string it can do:

@example
(let ((position ---))
  (make-<lexical-token> 'STRING position "some text" 9))
@end example

When the lexer has to signal the end--of--input, it must return a token
with category @samp{*eoi*}, and continue to return it if it is called
again and again; it can do:

@example
(let ((position ---))
  (make-lexical-token '*eoi* position (eof-object)))
@end example

When the lexer closure has to signal a lexer error (an invalid character
from the input stream), it must return a token with category
@samp{*lexer-error*}.


@defun make-<lexical-token> @var{category} @var{location} @var{value} @var{length}
Build and return a new record of type @class{lexical-token}.
@end defun


@defun make-<lexical-token>/end-of-input @var{location}
Build and return a new record of type @class{lexical-token} meant to
represent the end--of--input.  The field @samp{category} is set to the
symbol @samp{*eoi*}, the field @samp{value} is set to
@samp{(eof-object)}, the field @samp{length} is set to zero.  The field
@samp{location} is set to @var{location}, which must be a
@class{source-location} record or @false{}.
@end defun


@defun make-<lexical-token>/lexer-error @var{location} @var{value} @var{length}
Build and return a new record of type @class{lexical-token} meant to
represent a lexer error.  The field @samp{category} is set to
@samp{*lexer-error*}, all the other fields are initialised with the
arguments.
@end defun

@c page
@node parser-tools token pred
@subsection Predicates


@defun <lexical-token>? @var{obj}
Return true if @var{obj} is an instance of @class{lexical-token}.
@end defun


@defun <lexical-token>?/end-of-input @var{obj}
Return true if @var{obj} is an instance of @class{lexical-token} having
category @func{eq?} to the symbol @samp{*eoi*}.
@end defun


@defun <lexical-token>?/lexer-error @var{obj}
Return true if @var{obj} is an instance of @class{lexical-token} having
category @func{eq?} to the symbol @samp{*lexer-error*}.
@end defun


@defun <lexical-token>?/special @var{obj}
Return true if @var{obj} is an instance of @class{lexical-token} having
category @func{eq?} to the symbol @samp{*eoi*} or @samp{*lexer-error*}.
@end defun

@c page
@node silex
@chapter A lexical analyser generator


The @library{silex} library generates a lexical analyser table from a
Lex--like specification file.  The @library{silex lexer} library
generates a Scheme lexical analyser using a supplied table.

``SILex'' stands for ``Scheme Implementation of Lex''.  The library is a
port to @rnrs{6} Scheme of SILex version 1.0 by Danny Dube'.  The
original code is available at@footnote{@aurl{} last verified Mon Aug 3,
2009}:

@center @url{http://www.iro.umontreal.ca/~dube/}

@menu
* silex example::               A lexer example for a calculator.
* silex tables::                Creating lexer tables.
* silex input::                 Input systems.
* silex lexer::                 Building and using lexical analysers.
* silex syntax::                Syntax of the specification.
* silex semantics::             Semantics of the specification file.
* silex format::                Tables output format.
* silex utilities::             Utility functions.
@end menu

@c page
@node silex example
@section A lexer example for a calculator


The following is a lexer specification file that can be used to tokenise
a mathematical expression.

@smallexample
blanks          [ \9\10\13]+

decint          [0-9]+
binint          #[bB][01]+
octint          #[oO][0-7]+
hexint          #[xX][0-9A-Fa-f]+
integer         @{decint@}|@{binint@}|@{octint@}|@{hexint@}

exponent        ([eE][+\-]?[0-9]+)
truereal        [0-9]+\.|[0-9]*\.[0-9]+@{exponent@}?|[0-9]+@{exponent@}
real            @{truereal@}|@{integer@}

imag            (@{decint@}|@{real@})i

nan             \-nan\.0|\+nan\.0|nan\.0
pinf            \+inf\.0|inf\.0
minf            \-inf\.0

initial         [a-zA-Z_]
subsequent      @{initial@}|[0-9\.@!$&:<=>?~\-]
symbol          @{initial@}@{subsequent@}*

operator        <=|>=|//|[\+\-*/%\^<>=]

comma           ,

oparen          \(
cparen          \)

%%
@{blanks@}        ;; skip blanks, tabs and newlines
@{imag@}          (string->number (string-append "+" yytext))
@{real@}          (string->number yytext)
@{nan@}           +nan.0
@{pinf@}          +inf.0
@{minf@}          -inf.0
@{operator@}      (case (string->symbol yytext)
                    ((+) '+)
                    ((-) '-)
                    ((*) '*)
                    ((/) '/)
                    ((%) 'mod)
                    ((^) 'expt)
                    ((//) 'div)
                    ((=) '=)
                    ((<) '<)
                    ((>) '>)
                    ((<=) '<=)
                    ((>=) '>=))
@{symbol@}        (string->symbol yytext)
@{comma@}         'cons

@{oparen@}        #\(
@{cparen@}        #\)

<<EOF>>         (eof-object)
<<ERROR>>       (assertion-violation #f
                  "invalid lexer token")
@end smallexample

Let's say the file is called @file{calc.l}, then the table for this
lexer can be created with one of the following forms (and other forms
not described here):

@example
;; Generate a proper Scheme library called "(calc)" and
;; save it in the file "calc-lib.sls".
;;
;; Use the default table format.
;;
;; The library exports the table bound to "calc-table".

(lex (:input-file "calc.l") (:output-file "calc-lib.sls")
     (:library-spec "(calc)")
     (:table-name 'calc-table))


;; Generate a DEFINE form in that binds the lexer table
;; to the symbol "calc-table" and save it in the file
;; "calc-def.sls".
;;
;; Use the Scheme code table format.

(lex (:input-file "calc.l") (:output-file "calc-def.sls")
     (:lexer-format 'code)
     (:table-name 'calc-table))

;; Generate the lexer table, evaluate it and return it
;; as value immediately usable.
;;
;; Use the Scheme code table format.

(define calc-table
  (lex (:input-file "calc.l") (:output-value #t)
       (:lexer-format 'code)))
@end example

Once we have created the lexer table, let's say bound to
@samp{calc-table}, we can use it as follows.  We take advantage of the
fact that: When the input reaches the end, the lexer closure returns the
@samp{(eof-object)} value.

@example
(define (tokenize table string)
  (let* ((IS    (lexer-make-IS (:string string)))
         (lexer (lexer-make-lexer table IS))
    (do ((token (lexer) (lexer))
         (out   '()))
        ((eof-object? token)
         (reverse out))
      (set! out (cons token out))))))

(tokenize calc-table "1*(2/3)")
@result{} (1 * #\( 2 / 3 #\))

(tokenize calc-table "fun(1+a, sin(2), 3, 4)")
@result{} (fun #\( 1 + a cons sin #\( 2 #\) cons 3 cons 4 #\))
@end example

@c page
@node silex tables
@section Creating lexer tables


The following bindings are exported by the @library{silex} library.


@deffn Syntax lex @ameta{clause} ...
Build a new lexer table from a lexer specification.  @ref{silex syntax,
Syntax of the specification}

The behaviour of this function is configured with the given
@meta{clause} arguments; See below for the list of supported options.

The specification can be loaded from a file, or read from a textual
input port, or acquired from a Scheme string.

The output is the lexer's @dfn{table}, a Scheme vector representing the
lexer automaton.  It can be saved to a file, or written to a port, or
evaluated using the @library{rnrs eval} library and returned as value.
@end deffn


@deffn Clause :input-string @var{spec-str}
Instruct @func{lex} to build the lexer tables from the specification in
the given Scheme string.  When used together, this option supersedes
@samp{:input-file} and @samp{:input-port}.
@end deffn


@deffn Clause :input-port @var{port}
Instruct @func{lex} to build the lexer tables from the specification
read from the given textual input port.  When used together, this option
supersedes @samp{:input-file}.
@end deffn


@deffn Clause :input-file @var{pathname}
Instruct @func{lex} to build the lexer tables from the specification in
the selected file.  @var{pathname} must be a string representing an
existent file pathname.
@end deffn


@deffn Clause :library-spec @var{library-name}
Instruct @func{lex} to build the output as a proper Scheme library.
This means a Scheme string is built, representing a @func{library} form.
The string may contain Scheme comments.  When this option is not used
the output is the raw table vector or a @func{define} form.

The argument @var{library-name} must represent a valid library name; the
following formats are accepted:

@itemize
@item
A string, including the parentheses.  Example:

@example
:library-spec "(calc-lexer)"
; -> (library (calc-lexer) ---)
@end example

@item
A symbol, which will be converted to string and to which parentheses
will be added.  Example:

@example
:library-spec 'calc-lexer
; -> (library (calc-lexer) ---)
@end example

@item
A list of values, which will be simply converted to string.  Example:

@example
:library-spec '(calc-lexer)
; -> (library (calc-lexer) ---)
@end example
@end itemize

It is mandatory to use the option @samp{:table-name} along with
@samp{:library-spec}.
@end deffn


@deffn Clause :library-imports @var{import-list}
Select a list of libraries which must be imported when using the
generated lexer.  @var{import-list} must be a list of library
specifications; for example, if we want to include the
@library{sentinel} and @library{parameters} libraries we do:

@example
:library-imports '((sentinel) (parameters))
@end example

If the lexer table is written to a proper Scheme library:
@var{import-list} is added to the import specification of the generated
library.  If the lexer table is directly evaluated: @var{import-list} is
added to the environment which is handed to @func{eval}.

This option is ignored when the selected output is neither a library,
nor an evaluated library.
@end deffn


@deffn Clause :table-name @var{name}
Instruct @func{lex} to output a @func{define} form defining a binding
between @var{name} and the table vector.  @var{name} can be a string or
symbol, and it must represent a valid identifier.

When this option is used along with @samp{:library-spec}, the
@func{library} form will export the identifier @var{name}.
@end deffn


@deffn Clause :output-value #t|#f
When the argument is @true{}, instruct @func{lex} to evaluate the vector
table using the @library{rnrs eval} library and to return the result,
which is then directly usable.

The list of libraries selected by @samp{:library-imports} is added to
the environment used for the evaluation.  By default, the environment
always includes @library{rnrs}, and also @library{silex lexer} when the
selected lexer format is @samp{code}.

It is an error to use this option along with @samp{:table-name}.  When
used together, this option supersedes @samp{:output-file} and
@samp{:output-port}.
@end deffn


@deffn Clause :output-port @var{port}
Instruct @func{lex} to write the output as string in the given textual
output port.

When used together, this option supersedes @samp{:output-file}.
@end deffn


@deffn Clause :output-file @var{pathname}
Instruct @func{lex} to save the output in a file with given pathname.
This is especially useful when the output is a proper @func{library} or
@func{define} form.
@end deffn


@deffn Clause :lexer-format @var{format}
Instruct @func{lex} about the format of the lexer table.  @var{format}
can be one among the following symbols: @samp{decision-tree},
@samp{code}, @samp{portable}; the default is @samp{decision-tree}.
@ref{silex format, Tables output format}
@end deffn


@deffn Clause :pretty-print #t|#f
Instruct @func{lex} to pretty--print the contents of the table.
Normally, the table is displayed as a compact mass of characters fitting
in about @math{75} columns.  The option is useful only for a developer
of @library{silex}.  The Scheme code generated with the @samp{code}
option is always pretty--printed, the others are not by default.
@end deffn


@deffn Clause :counters @var{which-ones}
Instruct @func{lex} about which counters will be available to the lexer.

Counters are managed by the input system, and can be used by the lexer.
The following values for @var{which-ones} are available: @samp{all},
@samp{line}, @samp{none}; @samp{line} is the default.  The more counters
the input system maintains, the more it is slowed down.

Notice that the same @samp{:counters} option must be given to @func{lex}
and to @func{lexer-make-IS}, a mismatch will result in undefined
behaviour.  This is because an input system is independent from a lexer
table, and it is more efficient to build tables for a specific set of
counters rather than to configure them at run time.
@end deffn

@c page
@node silex input
@section Input systems


An input system provides the buffering, the line counting and similar
low level services.  The following bindings are exported by the
@library{silex lexer} library.


@deffn Syntax lexer-make-IS @ameta{clauses} ...
Build and return a new input system.  The behaviour of this function is
configured with the given @meta{clauses}; see below for the list of
supported options.

Input characters can come from a string, a port or the return value of a
procedure.  When an input port is used by an input system, the program
should avoid reading characters directly from the port.  This is because
the input system may have needed a look--ahead to do the analysis of the
preceding token.  The program would not find what it expects on the
port.  The input system provides safe functions to get characters from
the input.
@end deffn


@deffn Clause :string @var{string}
Instruct @func{lexer-make-IS} to build an input system that will take
characters from the supplied string.  When the input system is
initialized with a string, it takes a copy of it.  This way, eventual
mutations of the string do not affect the analysis.

When used together, this option supersedes @samp{:port} and
@samp{:procedure}.
@end deffn


@deffn Clause :port @var{port}
Instruct @func{lexer-make-IS} to build an input system that will read
characters from the supplied textual input port.  The input system never
closes itself the port it has received, this task is left to the
program.

When used together, this option supersedes @samp{:procedure}.
@end deffn


@deffn Clause :procedure @var{proc}
Instruct @func{lexer-make-IS} to build an input system that will read
characters invoking the supplied procedure.

The use of a function as character source allows the input system to
parse any character stream, no matter how it is obtained.  For example,
the characters may come from the decompression or decryption of a huge
file, the task being done lazily in order to save space.

The function must take no argument and return a character each time it
is called.  When the end of file (or its logical equivalent) is reached,
the function must return an object that is not a character (for example,
the symbol @samp{eof}).  After the function has returned an end of file
indicator, it is not called again.
@end deffn


@deffn Clause :counters @var{which-ones}
Instruct @func{lexer-make-IS} about which counters to make available to
the lexer.

Counters are managed by the input system, and can be used by the lexer.
The following values for @var{which-ones} are available: @samp{all},
@samp{line}, @samp{none}; @samp{line} is the default.  The more counters
the input system maintains, the more it is slowed down.

Notice that the same @samp{:counters} option must be given to @func{lex}
and to @func{lexer-make-IS}, a mismatch will result in undefined
behaviour.  This is because an input system is independent from a lexer
table, and it is more efficient to build tables for a specific set of
counters rather than to configure them at run time.
@end deffn


@defun lexer-get-func-line @var{input-system}
Return a closure which, when invoked with no arguments, will return the
current line number in @var{input-system}.
@end defun


@defun lexer-get-func-column @var{input-system}
Return a closure which, when invoked with no arguments, will return the
current column number in @var{input-system}.
@end defun


@defun lexer-get-func-offset @var{input-system}
Return a closure which, when invoked with no arguments, will return the
current offset in @var{input-system}.
@end defun


@defun lexer-get-func-getc @var{input-system}
Return a closure which, when invoked with no arguments, will return the
next character from @var{input-system}.  The closure allows client code
to perform a lookahead.

The returned character is not forgotten by the lexer, this function just
increments by @math{1} a pointer into the internal buffer.  Multiple
invocations of this function will return the sequence of characters
about to be analysed by the lexer.  When there are no more characters,
the return value is the @samp{(eof-object)} value.

The returned characters are @strong{skipped} by the lexer, unless we put
them back with the closure returned by @func{lexer-get-func-ungetc}.
@end defun


@defun lexer-get-func-ungetc @var{input-system}
Return a closure which, when invoked with no arguments, will decrement a
pointer into the buffer of @var{input-system}.  This function puts back
a character previously read by a closure returned by
@func{lexer-get-func-getc}.

It is not possible to replace characters in the input system.
@end defun

@c page
@node silex lexer
@section Building and using lexical analysers


Each lexer is associated to a lexer table and an input system.  Any
number of lexers, using any table, can be created using the same input
system.  Multiple lexers sharing the same input system can be invoked in
turn to parse complex inputs.  The following bindings are exported from
the @library{silex lexer} library.


@defun lexer-make-lexer @var{lexer-table} @var{input-system}
Build and return a new lexical analyser: an analysis function which,
when invoked with no arguments, returns the next token.
@var{lexer-table} must be a table generated by @func{lex}.
@var{input-system} is the input system from which the analyser will take
its input.
@end defun

@c page
@node silex syntax
@section Syntax of the specification


A specification for a lexical analyser contains two parts: the
@dfn{macro definitions part} and the @dfn{rules part}.  The two parts
are separated by the mark @code{%%}.  Example:

@example
blanks          [ \9\10\13]+
decint          [0-9]+

%%

@{blanks@}        ;; skip blanks, tabs and newlines
@{decint@}        (string->number yytext)
@end example

The first part is used to define @dfn{macros}; that is, to give names to
some regular expressions.  The second part is used to indicate the
regular expressions with which the input will have to match, and the
@dfn{actions} associated with each expression.

Comments can be inserted any place where white space is allowed and is
considered as white space itself.  Comments begin with a semicolon
@samp{;} and extend up to the end of a line.  The semicolon is a valid
token in many languages, so we should take care not to comment out an
entire line when writing a regular expression matching a semicolon.

@menu
* silex syntax macros::         Syntax of the macro definitions.
* silex syntax rules::          Syntax of the rule--action pairs.
* silex syntax regexp atomic::  Atomic regular expressions.
* silex syntax regexp compose:: Composing regular expressions.
* silex syntax regexp marker::  Markers.
* silex syntax regexp space::   White spaces in regular expressions.
* silex syntax sample::         Show some frequent mistakes.
@end menu

@c page
@node silex syntax macros
@subsection Macro definitions part


The first part of a specification contains zero or more macro
definitions.  A definition consists of a name and a regular expression,
separated by white space.  It looks better when each definition is
written on a separate line.

The syntax for a macro name is that of a Scheme symbol.  The case of the
letters is not significant.  For example, @code{abcd}, @code{+},
@code{...}, @code{Digit} and @code{digit} are all valid macro names; the
last two being the same.  We cannot write two macro definitions with the
same name.

The defined macro can be referenced in regular expressions using the
syntax @code{@{@var{name}@}}.  The scope of a macro definition includes
the remaining definitions and the rules part.  It is analogous to the
@code{let*} is Scheme, where the macro definitions correspond to the
bindings and the rules part correspond to the body.

We end the macro definitions part with @code{%%}.

@c page
@node silex syntax rules
@subsection Rules part


The rules part contains the rules up to the end of the specification.
Each rule is a @dfn{pattern} optionally followed by an @dfn{action}.
The pattern is a regular expression.  The action, if there is one, is
formed of one or more Scheme expressions.

The actions can span over several lines.  To distinguish between the
remaining of the current action and the start of a new rule, SILex
checks the indentation.  A new rule must start at the beginning of the
line.  That is, the action starts right after the pattern and contains
all the following lines that start with white space.

SILex does not parse the actions.  It simply captures the text
up to the start of the next rule.  So a syntax error in an action is not
detected by SILex.

Nevertheless, SILex is able to detect that an action has been omitted.
In that case, a default action is supplied.

@c page
@node silex syntax regexp atomic
@subsection Atomic regular expressions


The following constructs are regular expressions:

@table @code
@item c
@dfn{Ordinary character}.  It is a regular expression that matches the
character @var{c} itself.  @var{c} must @strong{not} be one of the
following characters:

@example
. \ @{ " [ | ? + * ( ) ^ $ ;
@end example

@noindent
or any white space.

@item .
@dfn{Wild card}.  It matches any character except the newline character.

@item \n
@itemx \@var{integer}
@itemx \@var{c}
@dfn{Backslash}.  The backslash is used for two things: protect a
character from special meaning; generating non-printable characters.

The expression @code{\n} matches the newline character.

The expression @code{\@var{integer}} matches the character that has
number @var{integer} (in the sense of @func{char->integer}).
@var{integer} must be a valid character number on the underlying Scheme
implementation.  Notice that @samp{\9} represents the horizontal
tabulation @samp{#\tab}, @samp{\10} the newline character
@samp{#\newline}, and @samp{\13} the carriage return character
@samp{#\return}.

The expression @code{\@var{c}} matches the character @var{c} if @var{c}
is not @samp{n}, @samp{-} nor a digit.

@item @{@var{name}@}
@dfn{Macro reference}.  This expression matches the same lexemes as
those matched by the regular expression named @var{name}.  We can
imagine that the reference is replaced by the text of the named
expression.  However, it works as if parentheses had been added to
protect the substituting expression.

@item "@var{some text}"
@dfn{String}.  A string matches a lexeme identical to its contents.  In
a string, the only special characters are @samp{"}, which closes the
string, and @samp{\} which keeps the effect mentioned above.

@item [@var{list of characters}]
@itemx []@var{list of characters}]
@itemx [-@var{list of characters}]
@itemx [^@var{list of characters}]
@dfn{Character class}.  The expression matches one of the enumerated
characters.  For example, the expression @samp{[abc]} matches one of
@samp{a}, @samp{b} and @samp{c}.

We can list a range of characters by writing the first character, the
@samp{-} and the last character.  For example, @samp{[A-Za-z]} matches
one letter.

The special characters in a class are @samp{]}, which closes the class,
@samp{-}, which denotes a range of characters, and @samp{\}, which keeps
its usual meaning.

There is an exception with the first character in a class.  If the first
character is @samp{]} or @samp{-}, it loses its special meaning.  If the
first character is @samp{^}, the expression matches one character if it
is @strong{not} enumerated in @var{list of characters}.
@end table

@c page
@node silex syntax regexp compose
@subsection Composing regular expressions


Suppose @var{r} and @var{s} are regular expressions.  Then the following
expressions can be built:

@table @code
@item @var{r}|@var{s}
@dfn{Union}.  This regular expression matches a lexeme if the lexeme is
matched by @var{r} or by @var{s}.

@item @var{r}@var{s}
@dfn{Concatenation}.  This expression matches a lexeme if the lexeme can
be written as the concatenation of a lexeme matched by @var{r} and a
lexeme matched by @var{s}.

@item @var{r}?
@dfn{Optional expression}.  A lexeme matches this expression if it is
the empty lexeme or if it matches @var{r}.

@item @var{r}+
@dfn{Positive closure}.  This expression matches a lexeme that can be
written as the concatenation of one or more lexemes, where each of those
matches @var{r}.

@item @var{r}*
@dfn{Kleene closure}.  A lexeme is matched by this expression if it can
be written as the concatenation of zero or more lexemes, where each of
those matches @var{r}.

@item @var{r}@{@var{i}@}
@itemx @var{r}@{@var{i},@}
@itemx @var{r}@{@var{i},@var{j}@}
@dfn{Power or repetition of an expression}.  These expressions allow the
``repetition'' of a regular expression a certain number of times.
@var{i} and @var{j} must be positive integers and @var{j} must be
greater than, or equal to, @var{i}.

The first form repeats the expression @var{r} exactly @var{i} times.
The second form repeats @var{r} at least @var{i} times.  The last form
repeats @var{r} at least @var{i} times and at most @var{j} times.

We should avoid using large numbers (more than @math{10}), because the
finite automaton for @var{r} is copied once for each repetition.  The
tables of the analyser may quickly become very large.  We should note
that the syntax of these expressions does not conflict with the syntax
of the macro reference.

@item (@var{r})
@dfn{Parentheses}.  This expression matches the same lexemes as @var{r}.
It is used to override the precedence of the operators.
@end table

The building operators are listed in order of increasing precedence.
The @code{?}, @code{+}, @code{*} and repetition operators have the same
precedence.

@c page
@node silex syntax regexp marker
@subsection Markers


The remaining ``expressions'' would better be called @dfn{markers}.
They all match the empty lexeme but require certain conditions to be
respected in the input.  They cannot be used in all regular expressions.
Suppose that @var{r} is a regular expression without markers.

@table @code
@item ^@var{r}
@itemx @var{r}$
@dfn{Beginning and end of line}.  These markers require that the lexeme
is found at the beginning or at the end of the line, respectively.  The
markers lose their special meaning if they are not placed at the
beginning or end of the regular expression, or if they are used in the
first part of the specification.  In those cases, they are treated as
regular characters.

@item <<EOF>>
@dfn{End of file}.  This marker is matched only when the input system is
at the end of input.  The marker must be used alone in its pattern, and
only in the second part of the specification.  There can be at most one
rule with this particular pattern.

@item <<ERROR>>
@dfn{Error}.  This marker is matched only when there is a parsing error.
It can be used under the same conditions as @code{<<EOF>>}.
@end table

@c page
@node silex syntax regexp space
@subsection White spaces in regular expressions


White space ends the regular expressions.  In order to include white
space in a regular expression, it must be protected by a backslash or
placed in a string.

@c page
@node silex syntax sample
@subsection An example of a specification file


Here is an example of a SILex specification file.  The file is
syntactically correct from the SILex point of view.  However, many
common mistakes are shown.  The file is not a useful one.

@example
; This is a syntactically correct but silly file.

partial     hel
complete    @{partial@}lo            ; @r{Backward macro ref. only}
digit       [0-9]
letter      [a-zA-Z]

%%

-?@{digit@}+    (cons 'integer yytext)   ; @r{@code{yytext} contains}
                                       ; @r{the lexeme}
-?@{digit@}+\.@{digit@}+[eE][-+]?@{digit@}+
              (cons                ; @r{An action}
               'float              ; @r{spanning multiple}
               yytext)             ; @r{lines}

;             (list 'semicolon)    ; @r{Probably a mistake}

begin         )list 'begin(        ; @r{No error detected here}
end                                ; @r{The action is optional}

\73           (list 'bell-3)       ; @r{It does not match the}
                                   ; @r{char. # 7 followed by @samp{3}}
\0073         (list 'bell-3)       ; @r{Neither does it}
(\7)3         (list 'bell-3)       ; @r{This does it}

"*()+|@{@}[].? are ordinary but \" and \\ are special"

[^\n]         (list 'char)         ; @r{Same thing as @samp{.}}
(@{letter@}|_)(@{letter@}|_|@{digit@})*  ; @r{A C identifier}
[][]                               ; @r{One of the square brackets}

Repe(ti)@{2@}on   (list 'repetition)

^@{letter@}+:   (cons 'label yytext) ; @r{A label placed at the}
                                   ; @r{beginning of the line}
$^                                 ; @r{No special meaning}
<<EOF>>       (list 'eof)          ; @r{Detection of the end of file}
<<ERROR>>     (my-error)           ; @r{Error handling}
@end example

@c page
@node silex semantics
@section Semantics of the specification


An important part of the semantics of a specification is described with
the syntax of the regular expressions.  The remainder is presented here.
We begin with the role of the actions.  Information on the matching
method follows.

@menu
* silex semantics action::      What does an action do.
* silex semantics rules::       When does a regular expression
                                matches the input.
@end menu

@c page
@node silex semantics action
@subsection Evaluation of the actions


@vindex yycontinue
@vindex yygetc
@vindex yyungetc
@vindex yytext
@vindex yyline
@vindex yycolumn
@vindex yyoffset


The action of a rule is evaluated when the corresponding pattern is
matched.  The result of its evaluation is the result that the lexical
analyser returns to its caller.

We can think of an action like this: It is a form which is placed in the
body of a @func{lambda} function, which in turn is invoked when a token
matching the regular expression is found.  So the following
specification:

@example
decint          [0-9]+

%%

@{decint@}        (string->number yytext)
@end example

@noindent
will cause the following code to be put in the generated lexer tables:

@example
(lambda (yytext)
  (string->number yytext))
@end example

@noindent
arguments in the formals of the @func{lambda} are local bindings we can
use in our actions.  There are a few local bindings that are accessible
by the action when it is evaluated: @code{yycontinue}, @code{yygetc},
@code{yyungetc}, @code{yytext}, @code{yyline}, @code{yycolumn} and
@code{yyoffset}.


@deffn Binding yycontinue
Contains the lexical analysis function itself.  Use @code{(yycontinue)}
to ask for the next token.  Typically, the action associated with a
pattern that matches white space is a call to @code{yycontinue}; it has
the effect of skipping the white space.
@end deffn


@deffn Binding yygetc
@deffnx Binding yyungetc
Contain functions to get and unget characters from the input of the
analyser.  They take no argument.  @code{yygetc} returns a character, or
the @samp{(eof-object)} value if the end of input is reached.

They should be used to read characters instead of accessing directly the
input port because the analyser may have read more characters in order
to have a look--ahead.

It is incorrect to try to unget more characters than has been gotten
since @emph{the parsing of the last token}.  If such an attempt is made,
@code{yyungetc} silently refuses.
@end deffn


@deffn Binding yytext
Bound to a string containing the lexeme.  This string is guaranteed not
to be mutated.  The string is created only if the action @emph{seems} to
need it.  The action is considered to need the lexeme when @samp{yytext}
appears somewhere in the text of the action.
@end deffn


@deffn Binding yyline
@deffnx Binding yycolumn
@deffnx Binding yyoffset
Indicate the position in the input at the beginning of the lexeme.
@code{yyline} is the number of the line; the first line is numbered
@math{1}.  @code{yycolumn} is the number of the column; the first column
numbered @math{1}.

It is important to mention that characters such as the tabulation
generate a variable length output when they are printed.  So it would be
more accurate to say that @code{yycolumn} is the index of the first
character of the lexeme, starting at the beginning of the line.

@code{yyoffset} indicates the distance from the beginning of the input;
the first lexeme has offset @math{0}.

The three bindings may not all be existent depending on options given to
the function @func{lex} when generating the tables.
@end deffn


There is a default action that is provided for a rule when its action is
omitted.

@itemize
@item
If the pattern is @samp{<<EOF>>}, the default action returns the
end--of--file object, @samp{(eof-object)}.

@item
If the pattern is @samp{<<ERROR>>}, the default action raises an
assertion violation.  Notice that the error message of this assertion
cannot hold the line and column numbers, because this default action
must be usable by lexers that do not use such counters, too.

@item
The default action for the other patterns is to call the analyser again.
@end itemize

It is clearer (and normally more useful) to specify explicitly the
action associated with each rule.

@c page
@node silex semantics rules
@subsection Matching the rules


Each time the analyser is asked to return a token, it tries to match a
prefix of the input with a pattern.  There may be more than one possible
match; when it is the case, we say there is a conflict.  For example,
suppose we have those regular expressions:

@example
begin
[a-z]*
@end example

@noindent
and the input is @samp{beginning1 @r{@dots{}}}.  We have a match with
the first expression and we have many different matches with the second.
To resolve such a conflict, the longest match is chosen.  So the chosen
match is the one between the lexeme @samp{beginning} and the second
pattern.

Suppose we have the same regular expressions but the input is
@samp{begin+ @r{@dots{}}}.  We have @emph{two} longest match.  This
conflict is resolved by choosing the first pattern that allows a longest
match.  So the chosen match is between the lexeme @samp{begin} and the
first pattern.

The analyser generated by @library{silex} allows the empty lexeme to be
matched if there is no longer match.  However, we should take care not
to call the analyser again without consuming at least one character of
the input: It would cause an infinite loop.

The pattern @samp{<<EOF>>} is matched when the analyser is called and
the input system is at end of input.  In this situation, the marker is
matched even if there is a pattern that matches the empty lexeme.  The
analyser can be called again and again and the @samp{<<EOF>>} pattern
will be matched each time, causing its corresponding action to be
evaluated each time, too.

The pattern @samp{<<ERROR>>} is matched when the input system is not at
end of input and no other match is possible.  Depending on the action
associated with this pattern, our program may choose to stop or choose
to try to recover from the error.  To recover from the error, our
program has to read some characters from the input before it can call
the analyser again.

All lexical analysers generated by @library{silex} are interactive.
That is, they read as few characters as possible to get the longest
match.  This is a useful property when the input is coming from a
terminal.  A lexical analyser is normally based on a finite automaton;
it is the case for the analysers generated by @library{silex}.  A
non--interactive analyser always needs an extra character to provoke an
invalid transition in the automaton.  The longest match is detected this
way.  With an interactive analyser, an extra character is not required
when it is impossible to obtain a longer match.

A lexical analyser generated by @library{silex} does not impose any @i{a
priori} limit on the size of the lexemes.  The internal buffer is
extended each time it is necessary.

@c page
@node silex format
@section Tables output format


The @library{silex} library provides three different encodings of the
tables: the @dfn{decision tree} encoding, the @dfn{portable} encoding
and the ``compilation'' to Scheme code.  The decision tree is the
default.

With the decision tree encoding, the finite automaton of the analyser is
represented with data structures holding integers representation of the
characters (in the sense of @func{char->integer}).  This representation
is the most compact, but it relies on the character integer
representations in @rnrs{6} Schemes.

With the portable encoding, the data structures describing the automaton
contain characters directly.  If the automaton, as generated, contains a
transition from state @var{s} to state @var{t} on character @var{c},
then somewhere in the table there is the Scheme character
@samp{#\@var{c}}.  When the file containing the analyser is loaded in
any implementation, the character is read as is, and not as the number
@samp{(char->integer #\@var{c})}.

This encoding should be portable to non--@rnrs{6} Schemes.  However, it
is less compact.  This is because something like @samp{(65 90)} is more
compact than something like @samp{(#\A #\B @r{@dots{}} #\Y #\Z)} to
represent @samp{[A-Z]}.  The construction of an analyser from a portable
table takes more time than the construction from a default table.  But,
once built, the performance of the analyser is the same in both cases.

It is important to note that in some character sets, the letters or the
digits are not contiguous.  So, in those cases, the regular expression
@samp{[A-Z]} does not necessarily accept only the uppercase letters.

The last encoding is the compilation to Scheme code.  This produces a
fast lexical analyser.  Instead of containing data structures
representing the behavior of the automaton, the table contains Scheme
code that ``hard--codes'' the automaton.  This encoding often generates
big tables.  Such an analyser is not portable to non--@rnrs{6} Schemes.

@c page
@node silex utilities
@section Utility functions


The following bindings are exported by the @library{silex utilities}
library.


@defun make-max-count-lexer @var{lexer} @var{max-number-of-tokens} @var{error-handler}
Return a lexer function wrapping @var{lexer}; if the number of returned
tokens reaches @var{max-number-of-tokens}: the thunk @var{error-handler}
is invoked.
@end defun

@c page
@node lalr
@chapter A LALR(1) parser generator


The @library{lalr} library is a LALR(1) parser tables generator.  The
@library{lalr lr-driver} and @library{lalr glr-driver} libraries
generate instances of a parser using a supplied table.  The two drivers
are not compatible, each of them requires a specifically built table.

The algorithm is the same used in @gnu{} Bison and it is described in:

@quotation
F. DeRemer and T. Pennello.  ``Efficient Computation of LALR(1)
Look--Ahead Set''.  TOPLAS, vol. 4, no. 4, october 1982.
@end quotation

@noindent
as a consequence, it is not written in a fully functional style.  In
fact, much of the code is a direct translation from C to Scheme of the
Bison sources.

The library is a port to @rnrs{6} Scheme of Lalr-scm by Dominique
Boucher.  The original source is available at@footnote{@aurl{} last
verified Tue Jul 21, 2009.}:

@center @url{http://code.google.com/p/lalr-scm/}

@menu
* lalr intro::                  Introduction to the LR parser.
* lalr tables::                 Creating parser tables.
* lalr lexer::                  Describing tokens.
* lalr parser::                 Running the parser.
* lalr grammar::                Defining the grammar.
* lalr glr::                    Generalised LR parsing.
@end menu

@c page
@node lalr intro
@section Introduction to the LR parser


This section introduces the behaviour of the LR driver; it is meant to
be a tutorial for users who know nothing about parsing, and it has no
commitment to being rigorous and exhaustive.  This tutorial is meant to
be read in sequence, each section after the other as they appear.

We describe the basic mechanism of the parser, in a way that is easy to
understand.  Let's say we want to compute simple arithmetic expressions
involving numbers, the operators @math{+-*/}, and parentheses to
establish precedence.  We want to compute one--line expressions like:

@example
10
-20
1 + 2
3 * 4 - 5
(6 - (7 - 8)) * 2
@end example

@menu
* lalr intro tokens::           Splitting expressions in
                                semantic tokens.
* lalr intro want::             What we want.
* lalr intro simple::           Simplified parser behaviour.
* lalr intro look::             Why the lookahead.
* lalr intro states::           From symbol sequences to states.
* lalr intro error::            Error recovering.
* lalr intro nonterm::          Non--terminal categories.
@end menu

@c page
@node lalr intro tokens
@subsection Splitting expressions in semantic tokens


The first step is to split the expression in @dfn{tokens}, that is basic
elements having a semantic meaning.  In @samp{3 * 4 - 5} there are five
of them:

@example
3       -> number
*       -> operator
4       -> number
-       -> operator
5       -> number
@end example

Splitting the input into tokens is the job of the lexer.  We cannot
decide what the lexer has to do if we do not define the parser grammar
first.

We can be sure that we want to deal with every number @math{3} in the
same way, the same goes for every operator @math{*}.  But there is more
of this.

Scheme implements the functions @func{+}, @func{-}, @func{*}, @func{/}
which can be applied to every Scheme's number object; so it is
reasonable to state that: We are not interested in the concrete value of
each number, but only in the abstract fact that they are numbers.  We
can say that all the number tokens are in the same @dfn{category}; let's
use the Scheme symbol @samp{N} to indicate it.  @samp{N} is an
abstraction for each number.

The Scheme functions @func{+}, @func{-}, @func{*}, @func{/} are all
applied in the same way, but the arithmetic operators @math{+-*/} are
not: @math{+} and @math{-} can be both unary and binary, @math{*} and
@math{/} take precedence over @math{+} and @math{-}.  We may come up
with the following alternative categorisations:

@itemize
@item
All the operator tokens are in the same category.

@item
The operators @math{+} and @math{-} are in a category; the operators
@math{*} and @math{/} are in another category.

@item
Each operator has its own category.
@end itemize

Putting all the tokens equal to each other in the same category is
always safe, but it leads to an explosion of the number of categories;
this complicates the definition of the grammar.  Experience shows that
``it works'' to put @math{+} and @math{-} in a category, let's call it
@samp{A} like addition, and @math{*} and @math{/} in another category,
let's call it @samp{M} like multiplication.

With these abstractions, we can see the expression @samp{3 * 4 - 5} as
the following ordered sequence of categorised tokens:

@example
[N, 3]  [M, *]  [N, 4]  [A, -]  [N, 5]
@end example

@noindent
the parser will not be interested in the concrete values, only in the
categories; so it will see the sequence as just:

@example
N M N A N
@end example

We want to support parentheses, too.  The semantic meaning of the open
parenthesis is different from the semantic meaning of the closed one;
@math{(1 + 2)} makes sense, but @math{(1 + 2(} is wrong; giving
different semantic meaning to the parentheses is mandatory to recognise
nested expressions like @math{(1 * (2 + 3))}.  So we assign the open
parenthesis to the category @samp{O} and the closed one to the category
@samp{C}; with these abstractions, the expression:

@example
(6 - (7 - 8)) * 2
@end example

@noindent
is tokenised by the following ordered sequence (from left to right, then
top to bottom):

@example
[O, (]  [N, 6]  [A, -]  [O, (]  [N, 7]  [A, -]
[N, 8]  [C, )]  [C, )]  [M, *]  [N, 2]
@end example

@noindent
but the parser is interested only in the categories:

@example
O N A O N A N C C M N
@end example

The categories defined so far are not the only ones with which an LR
parser is concerned; we call them @dfn{terminal categories} or
@dfn{terminal symbols} or just @dfn{terminals}, because they are direct
abstractions of concrete values.  In contrast, the other categories are
called @dfn{non--terminal categories} or @dfn{non--terminal symbols} or
just @dfn{non--terminals}, because they are higher level abstractions
for sequences of terminals and nested non--terminals.

When modeling a terminal with a Scheme object, we need at least two
fields:

@enumerate
@item
The Scheme symbol representing the category.

@item
The Scheme object representing the concrete value.  We can represent:

@itemize
@item
Number tokens with Scheme number objects.

@item
Operator tokens with the Scheme functions implementing them.

@item
Parenthesis tokens with the Scheme characters @samp{#\(} and @samp{#\)}.
@end itemize
@end enumerate

Experience shows that it is useful to define yet another token: The
end--of-input; it is used by the lexer to signal the no more tokens are
available.  We need to define a new terminal category for this, let's
call it @samp{*eoi*}.  The concrete value of this terminal is not
important, we can just select @samp{(eof-object)}; in what follows we
will display it as @samp{#<eof>}.

Putting all together, given the input expression:

@example
(6 - (7 - 8)) * 2
@end example

@noindent
the lexer transforms it into the ordered sequence of tokens:

@example
[O, (]  [N, 6]  [A, -]  [O, (]  [N, 7]  [A, -]
[N, 8]  [C, )]  [C, )]  [M, *]  [N, 2]  [*eoi*, #<eof>]
@end example

@noindent
and the parser will operate on the terminal categories:

@example
O N A O N A N C C M N *eoi*
@end example

@c page
@node lalr intro want
@subsection What we want


Let's take the simple expression @samp{1 + 2 * 3}; its tokenisation is:

@example
[N, 1] [A, +] [N, 2] [M, *] [N, 3] [*eoi*, #<eof>]
@end example

@noindent
and we can imagine values and category symbols to be available in Scheme
vectors:

@example
#(1  +  2  *  3  #<eof>)
#(N  A  N  M  N   *eoi*)
@end example

@noindent
experience shows that it is useful to consider a fake first element in
both vectors; we assign this element to an additional terminal category
whose symbol is @samp{S} as in start, its value is not important so we
select @false{}:

@example
#(#f  1  +  2  *  3  #<eof>)
#( S  N  A  N  M  N   *eoi*)
@end example

Basically, we want the following:

@enumerate
@item
The parser has to recognise the subvectors @samp{N A N} and @samp{N M N}
as representing expressions it can compute.

@item
The parser must recognise that @samp{N M N} has precedence above @samp{N
A N}.  @samp{N M N} has to be computed first.

@item
The values @samp{2 * 3} have to be fed to a @dfn{semantic clause} of our
choice to compute a result; the semantic clause is just a Scheme form in
which we do whatever we want with the three operands @samp{2}, @samp{*}
and @samp{3}.  For example, we can compute the result @math{2 * 3 = 6}.

The parser generator should create code equivalent to:

@example
(let (($3   2)   ;
      ($2   *)   ; Automatically generated preamble
      ($1   3))  ;

  ($2 $3 $1))    ; Client-supplied semantic clause
@end example

So we want the parser to mutate the vectors as follows:

@example
#(#f  1  +  6  #<eof>  #f #f)
#( S  N  A  N   *eoi*  #f #f)
@end example

@item
The parser has to recognise the subvector @samp{N A N} has representing
a sequence it can compute; the values have to be fed to a semantic
action; let's say it computes the result @math{1 + 6 = 7}.

So we want the parser to mutate the vectors as follows:

@example
#(#f  7  #<eof>  #f #f #f #f)
#( S  N   *eoi*  #f #f #f #f)
@end example

@item
Finally we want the parser to recognise @samp{*eoi*} as the
end--of--input terminal, and to finish the parsing operation returning
the value @samp{7} it left in the vector before.
@end enumerate

@c page
@node lalr intro simple
@subsection Simplified parser behaviour


We can describe the desired behaviour of the LR driver in terms of three
basic actions: lookahead, shift, reduce; with the addition of two
special actions: accept, error.  We assume that the parser can consult a
data structure called @dfn{grammar} and decide what to do, we can think
of it as an associative container.

We scan the vectors using a variable @samp{p} (as in ``pointer'')
holding the index of the current element; at first @samp{p} is set to
zero, so it references the terminal @samp{S}:

@example
#(#f  1  +  2  #<eof>)
#( S  N  A  N   *eoi*)
   |
   p
@end example

The first action is always a @dfn{lookahead}, that is: To look at the
element at index @samp{1 + p} and acquire its category; such element is
always a terminal, in this case with symbol @samp{N}.

The parser searches the grammar for the sequence @samp{S N}: It finds
that the action associated to it is a @dfn{shift}, that is: Increment
@samp{p} by @math{1}.  The parser obeys:

@example
#(#f  1  +  2  #<eof>)
#( S  N  A  N   *eoi*)
      |
      p
@end example

A shift action is similar to pushing a value on a stack; for this
reason, we name the Scheme vectors @dfn{stacks} and the variable
@samp{p} @dfn{stack pointer}.

After a shift, the parser always performs a lookahead, it acquires the
symbol @samp{A}.  Parser searches the grammar for the sequences @samp{S
N A} and @samp{N A}, in this order, stopping at the first with an action
associated to it; if finds that @samp{S N A} has no action, but @samp{N
A} is associated to a shift.  Parser obeys:

@example
#(#f  1  +  2  #<eof>)
#( S  N  A  N   *eoi*)
         |
         p
@end example

Again after a shift, the parser performs a lookahead; it acquires the
symbol @samp{N}.  Parser searches the grammar for each of the sequences:

@example
S N A N
N A N
A N
@end example

@noindent
stopping at the first with an action associated to it; the action
associated to @samp{N A N} is a shift.  Parser obeys:

@example
#(#f  1  +  2  #<eof>)
#( S  N  A  N   *eoi*)
            |
            p
@end example

After the shift, parser performs a lookahead; it acquires the symbol
@samp{*eoi*}.  Parser searches the grammar for each of the sequences:

@example
S N A N *eoi*
N A N *eoi*
A N *eoi*
N *eoi*
@end example

@noindent
stopping at the first with an action associated to it; the action
associated to @samp{N A N *eoi*} is a @dfn{reduce}: Take the values
associated to @samp{N A N}, that is @samp{1 + 2}, and use them as
arguments for the semantic clause the grammar associates to @samp{N A N
*eoi*}.

We have established that we want the semantic clauses to compute the
given expression, so the result of the evaluation is @samp{3}; parser
searches the grammar, finding that the result associated to @samp{N A N
*eoi*} has to be of category @samp{N}; so it mutates the stacks and the
stack pointer as follows:

@example
#(#f  3 #<eof>  #f  #f)
#( S  N  *eoi*  #f  #f)
      |
      p
@end example

After a reduce, parser performs a lookahead; it acquires the symbol
@samp{*eoi*}, again.  Parser searches the grammar for the sequences
@samp{S N *eoi*} and @samp{N *eoi*}; it finds the action associated to
@samp{S N *eoi*} is @dfn{accept}, that is: Stop parsing and return the
value referenced by the stack pointer, which is @samp{3}.

Let's see, more briefly, what happens when parsing:

@example
#(#f  1  +  2  *  3  #<eof>)
#( S  N  A  N  M  N   *eoi*)
   |
   p
@end example

@noindent
everything is the same as before until:

@example
#(#f  1  +  2  *  3  #<eof>)
#( S  N  A  N  M  N   *eoi*)
            |
            p
@end example

@noindent
in the previous example the lookahead returned @samp{*eoi*} and the
grammar said ``reduce'' for @samp{N A N *eoi*}; here the lookahead
returns @samp{M} and the grammar says ``shift'' for @samp{N A N M}:

@example
#(#f  1  +  2  *  3  #<eof>)
#( S  N  A  N  M  N   *eoi*)
               |
               p
@end example

@noindent
the lookahead returns @samp{N} and the grammar says ``shift'' for
@samp{N M N}:

@example
#(#f  1  +  2  *  3  #<eof>)
#( S  N  A  N  M  N   *eoi*)
                  |
                  p
@end example

@noindent
the lookahead returns @samp{*eoi*} and the grammar says ``reduce'' for
@samp{N M N *eoi*}:

@example
#(#f  1  +  6  #<eof>  #f #f)
#( S  N  A  N   *eoi*  #f #f)
            |
            p
@end example

@noindent
the lookahead returns @samp{*eoi*} and the grammar says ``reduce'' for
@samp{N A N *eoi*}:

@example
#(#f  7  #<eof>  #f #f #f #f)
#( S  N   *eoi*  #f #f #f #f)
      |
      p
@end example

@noindent
the lookahead returns @samp{*eoi*} and the grammar says ``accept'' for
@samp{S N *eoi*}.

@c page
@node lalr intro look
@subsection Why the lookahead


Why do we need to look ahead at the next token's category?  When the
stacks are:

@example
#(#f  1  +  2  #<eof>)
#( S  N  A  N   *eoi*)
            |
            p
@end example

@noindent
we can recognise the subvector @samp{N A N} to be a reducible one
without looking a the next token's category; the same goes with:

@example
#(#f  1  +  2  -  3  #<eof>)
#( S  N  A  N  A  N   *eoi*)
            |
            p
@end example

But let's look at:

@example
#(#f  1  +  2  *  3  #<eof>)
#( S  N  A  N  M  N   *eoi*)
            |
            p
@end example

@noindent
it is an error to reduce @samp{N A N}, because the following
multiplication takes precedence over addition; we can detect the need to
give precedence to what follows only by looking at the next token's
category.

This is not always the case.  Let's make a change to our parser, let's
say we want to parse scripts in which every line is an arithmetic
expression.  We add a new token with category @samp{T}, as in
terminator, and value @samp{#\newline}.

Let's look at this example:

@example
#(#f  1  +  2  *  3  #\newline  4  /  5  #\newline  #<eof>)
#( S  N  A  N  M  N  T          N  M  N  T           *eoi*)
                  |
                  p
@end example

@noindent
once the parser has performed the lookahead and detected the @samp{T}
category, the grammar can tell it to reduce twice the stack, without
doing another lookahead:

@example
#(#f  1  +  6  #\newline  4  /  5  #\newline  #<eof>  #f #f)
#( S  N  A  N  T          N  M  N  T           *eoi*  #f #f)
            |
            p

#(#f  7  #\newline  4  /  5  #\newline  #<eof>  #f #f #f #f)
#( S  N  T          N  M  N  T           *eoi*  #f #f #f #f)
      |
      p
@end example

Notice that, with a well written grammar, the parser generator can
understand that the result of the first line is no more needed and
remove it with a reduce action.  Starting from the above stacks, the
lookahead returns @samp{T} and the action is shift:

@example
#(#f  7  #\newline  4  /  5  #\newline  #<eof>  #f #f #f #f)
#( S  N  T          N  M  N  T           *eoi*  #f #f #f #f)
         |
         p
@end example

@noindent
now the lookahead returns @samp{N} and the action can be a reduction
which puts the stacks in the following state:

@example
#(#f  4  /  5  #\newline  #<eof>  #f #f #f #f #f #f)
#( S  N  M  N  T           *eoi*  #f #f #f #f #f #f)
   |
   p
@end example

@noindent
parser is ready to start a new line.

@c page
@node lalr intro states
@subsection From symbol sequences to states


We have seen that parser searches the grammar for an action associated
to a sequence of categories; this is inefficient.  We can represent the
grammar with a directed graph, having a single source and a single sink,
in which:

@itemize
@item
Each sequence of categories having an action is represented by a
state--node.

@item
Every shift and every reduce causes a transaction from one node to the
other.

@item
The lookahead determines which outgoing transaction link to take from a
given node.
@end itemize

There are many possible expressions and many possible paths in the
graph; for example, the following expressions:

@example
1
1 + 2
1 + (2 * 3)
3 * 4
@end example

@noindent
and much more can be represented by the following sequences of
terminals:

@example
N *eoi*
N A N *eoi*
N A O N M N C *eoi*
N M N *eoi*
@end example

@noindent
which in turn are represented by the following graph, in which every
node has a numeric index (from @math{0} to @math{11}) and every terminal
category (@samp{N}, @samp{A}, @samp{M}, @samp{C}, @samp{O}) has the
associated action between parenthesis (@samp{s} for shift, @samp{r} for
reduce, @samp{a} for accept):

@example
         (11) finish
          ^
          |
          |*eoi*(a)
     N(s) |
 (0)---->(1)<------------+------------------------------
start     |              |                              |
          |              |*eoi*(r)                      |
          | A(s)    N(s) |           *eoi*(r)           |
          +----->(2)--->(3)<-------------------------   |
          |       |                                  |  |
          |       |                                  |  |
          |       | O(s)   N(s)   M(s)   N(s)   C(s) |  |
          |        ---->(4)--->(5)--->(6)--->(7)--->(8) |
          |                                             |
          |                                             |
          | M(s)    N(s)      *eoi*(r)                  |
           ----->(9)--->(10)----------------------------
@end example

Starting from node @math{0}, with each shift and reduce we move our
position in the graph to some node.  What matters to select the next
action to perform, is just the node we are in and the category of the
lookahead token.

Let's try it with the expression @samp{1 + 2}; we add a stack for the
current node number:

@example
#(#f   1   +   2  #<eof>)
#( S   N   A   N   *eoi*)
#( 0  #f  #f  #f      #f)
   |
   p
@end example

@noindent
the lookahead returns @samp{N} and the grammar associates @samp{[0, N]}
with @samp{[1, shift]}:

@example
#(#f   1   +   2  #<eof>)
#( S   N   A   N   *eoi*)
#( 0   1  #f  #f      #f)
       |
       p
@end example

@noindent
the lookahead returns @samp{A} and the grammar associates @samp{[1, A]}
with @samp{[2, shift]}:

@example
#(#f   1   +   2  #<eof>)
#( S   N   A   N   *eoi*)
#( 0   1   2  #f      #f)
           |
           p
@end example

@noindent
the lookahead returns @samp{N} and the grammar associates @samp{[2, N]}
with @samp{[3, shift]}:

@example
#(#f   1   +   2  #<eof>)
#( S   N   A   N   *eoi*)
#( 0   1   2   3      #f)
               |
               p
@end example

@noindent
the lookahead returns @samp{*eoi*} and the grammar associates @samp{[3,
*eoi*]} with @samp{[1, reduce]}:

@example
#(#f   3  #<eof>  #f  #f)
#( S   N   *eoi*  #f  #f)
#( 0   1      #f  #f  #f)
       |
       p
@end example

@noindent
the lookahead returns @samp{*eoi*} and the grammar associates @samp{[1,
*eoi*]} with @samp{[11, accept]}.

@c page
@node lalr intro error
@subsection Error recovering


Until now we have seen only examples for which, given a sequence of
symbols @samp{S A B C} and a lookahead @samp{D}, at least one of the
sequences:

@example
S A B C D
A B C D
B C D
C D
@end example

@noindent
has an action associated to it in the grammar; in other words, using the
graph model:

@itemize
@item
The state associated to the sequence @samp{S A B C} has an
outgoing link associated to the lookahead @samp{D}, or

@item
The state associated to the sequence @samp{A B C} has an outgoing link
associated to the lookahead @samp{D}, or

@item
The state associated to the sequence @samp{B C} has an outgoing link
associated to the lookahead @samp{D}, or

@item
The state associated to the sequence @samp{C} has an outgoing link
associated to the lookahead @samp{D}.
@end itemize

What happens if the lookahead is not associated to an outgoing link?  It
means that the sequence of tokens does not comply with the defined
grammar.  There are two possible reactions to this: Stop parsing and
signal an error, or try to recover.

Recovering makes sense only when the grammar is such that: It is
possible to discard a subsequence of symbols as invalid, and go on
parsing the following symbols.

In the example of the single expressions parser: If the lookahead
returns an invalid category symbol, the only possible reaction is to
stop parsing and signal an error.  The whole expression is wrong.

In the example of the script expression parser: We can discard an
invalid line and try to parse the following ones.  Let's examine how
this is done by the LR driver.

The valid terminal categories are:

@example
N A M O C T *eoi*
@end example

@noindent
where @samp{T} is the line terminator; examples of valid lines are:

@example
N T
A N T
N A N T
N M N T
N A N M N T
@end example

If we use a grammar describing a sequence of lines, the grammar
``knows'' that after each line it has to reduce the stacks to the
starting symbol; it knows that @samp{S} is the first symbol of each
line.  For example:

@example
#(#f  1  +  2  #\newline  3  *  4  #\newline  #<eof>)
#(S   N  A  N  T          N  M  N  T          *eoi*)
@end example

@noindent
after parsing the first line is reduced to:

@example
#(#f  3  *  4  #\newline  #<eof>  #f #f #f)
#(S   N  M  N  T          *eoi*   #f #f #f)
@end example

When writing the grammar specification: We associate an error action to
the beginning of a line, and it ends up being associated to @samp{S}.

Let's consider the following couple of lines, with the first being a
wrong expression:

@example
#(#f  1  +  #\newline  3  *  4  #\newline  #<eof>)
#(S   N  A  T          N  M  N  T          *eoi*)
@end example

@noindent
when the stack pointer references the symbol @samp{A}, the lookahead
returns @samp{T} and the grammar signals an error.  The parser
decrements the pointer, ``rewinding'' the stack, in search of a symbol
which has an error action associated to it.  It finds that @samp{S} has
such an action, and it is associated to the symbol @samp{T}; so it
removes all the symbols between @samp{S}, excluded, and the first
@samp{T}, excluded:

@example
#(#f  #\newline  3  *  4  #\newline  #<eof>  #f #f)
#(S   T          N  M  N  T           *eoi*  #f #f)
  |
  p
@end example

@noindent
and it restarts parsing doing a lookahead that returns @samp{T}; the
action is a shift:

@example
#(#f  #\newline  3  *  4  #\newline  #<eof>  #f #f)
#(S   T          N  M  N  T           *eoi*  #f #f)
      |
      p
@end example

@noindent
the lookahead returns @samp{N} and the action is a reduce:

@example
#(#f  3  *  4  #\newline  #<eof>  #f #f #f)
#(S   N  M  N  T          *eoi*   #f #f #f)
  |
  p
@end example

@noindent
we have recovered from the error.

@c page
@node lalr intro nonterm
@subsection Non--terminal categories


We have seen the graph representation of the grammar with tokens
belonging to terminal categories.  But how many nodes are there in such
a graph?  There are an infinite number of expressions, and consequently
an infinite number of sequences of terminals is required to represent
them.  This would make it impossible to code a parser, unless we take a
different approach.

We start by noticing that, if the following sequences of terminals
represent expressions:

@example
N
A N
N A N
N M N
@end example

@noindent
then the following sequences of terminals represent expressions with
subexpression:

@example
N A  N
N A  A N
N A  N A N
N A  N M N

N M  N
N M  A N
N M  N A N
N M  N M N
@end example

Let's define a new category, indicated by the Scheme symbol @samp{E},
which represents the basic expressions:

@example
E @equiv{} N
  @equiv{} A N
  @equiv{} N A N
  @equiv{} N M N
@end example

@noindent
then we can represent the composite sequences written above with:

@example
N A E
N M E
@end example

@noindent
and more generally:

@example
E A E
E M E
@end example

Let's suppose in defining the category @samp{E} we can use @samp{E}
itself, recursively; then we can write:

@example
E @equiv{} N
  @equiv{} A E
  @equiv{} E A E
  @equiv{} E M E
  @equiv{} O E C
@end example

@noindent
in which we have included a rule for the parentheses; with this
definition involving a few symbols we can represent the whole set of
possible expressions.  @library{lalr} allows us to do exactly this,
using the following S--expression:

@example
(E (N)
   (A E)
   (E A E)
   (E M E)
   (O E C))
@end example

Categories defined this way, as sequences of the same and other
categories, are called non--terminals for reasons we can imagine.  The
definition of non--terminals changes nothing in the way the parser
itself works, but it is the fundamental tool to describe the grammar.
We can use any number of non--terminals to describe a grammar.

@c page
@node lalr tables
@section Creating parser tables


The following bindings are exported by the @library{lalr} library.


@deffn Syntax lalr-parser @ameta{clause} ...
@deffnx Syntax make-lalr-parser @ameta{clause} ...
Generate a parser table to be used by the LR or GLR drivers.  The
behaviour of this function is configured with the @meta{clause}
arguments; see below for the list of supported options.  For example,
this is a simple expression grammar:

@example
(lalr-parser

  (:terminals '(ID
                (left: + -)
                (left: * /)
                (nonassoc: uminus)))

  (:rules '((e (e + e)              : (+ $1 $3)
               (e - e)              : (- $1 $3)
               (e * e)              : (* $1 $3)
               (e / e)              : (/ $1 $3)
               (- e (prec: uminus)) : (- $2)
               (ID)                 : $1)))

  ---) ;other options
@end example

@ref{lalr grammar, Defining the parser}, for the definition of the
grammar and the meaning of the @samp{:terminals} and @samp{:rules}
options.

The core of the output is a set of parser ``tables'': Scheme vectors
representing the automaton.  There are three of them: action, goto,
reduction.  The tables are used as arguments for a call to
@func{lr-driver} or @func{glr-driver}: Their return value is a closure
implementing an instance of the parser.
@end deffn


@deffn Clause :terminals @var{sexpr}
Specifies a list representing the terminal symbols, their precedence and
their associativity.
@end deffn


@deffn Clause :rules @var{sexpr}
Specifies a list representing the grammar production rules.
@end deffn


@deffn Clause :expect @var{number-of-conflicts}
Specifies the number of rule conflicts we expect in the parser
definition.  The default is zero.

When more than @var{number-of-conflicts} are detected, warning messages
are printed to the current error port.  If @var{number-of-conflicts} is
@false{}, rather than an exact non-negative integer, no message is ever
displayed on the error port.
@end deffn


@deffn Clause :parser-type @var{driver}
Select the type of tables to generate.  Available drivers are selected
with a symbol among: @samp{lr}, @samp{glr}.  The default is @samp{lr}.
@end deffn


@deffn Clause :output-value #t|#f
If the value is true, instruct @func{lalr-parser} to evaluate the output
with @func{eval} and return a proper Scheme function implementing a
parser maker.  @nauref{stdlib eval, Evaluation}

With this option, in the case of the @samp{lr} driver, the generated
code has the form:

@example
(lambda ()
  (lr-driver <action-table> <goto-table> <reduction-table>))
@end example

@noindent
so the value returned by @func{lalr-parser} is a closure which, when
evaluated with no arguments, returns a new parser closure.  See
@samp{:library-imports} to add libraries to the evaluation environment.

When used together, this option supersedes @samp{:output-port} and
@samp{:output-file}.
@end deffn


@deffn Clause :output-port @var{port}
Instruct @func{lalr-parser} to print the generated code to the specified
port.  When used together, this option supersedes @samp{:output-file}.

When neither @samp{:library-spec} nor @samp{:parser-name} are used, the
output is the same as the one generated by @samp{:output-value}: A
lambda function returning new parser closures.  See @samp{:library-spec}
and @samp{:parser-name} for details on the other output types.
@end deffn


@deffn Clause :output-file @var{pathname}
Instruct @func{lalr-parser} to save the generated code to the specified
file; the file will be overwritten if it already exists.  @var{pathname}
must be a Scheme string representing a file pathname.

When neither @samp{:library-spec} nor @samp{:parser-name} are used, the
output is the same as the one generated by @samp{:output-value}: A
lambda function returning new parser closures.  See @samp{:library-spec}
and @samp{:parser-name} for details on the other output types.
@end deffn


@deffn Clause :dump-table @var{pathname}
Instruct @func{lalr-parser} to save a human readable dump of the
generated parser in the specified file.  The file will be overwritten if
it already exists.  This is useful for debugging purposes (if we know
how the parser works).
@end deffn


@deffn Clause :parser-name @var{name}
Instruct @func{lalr-parser} to use the symbol @var{name} as identifier
to which bind the parser maker function.  It is mandatory to use this
option when generating a library.

If this option is used, but @samp{:library-spec} is not: The output is a
@func{define} form which, when evaluated, binds the parser maker to
@var{name}.  Example output for the @samp{lr} driver:

@example
(define (@var{name})
  (lr-driver <action-table> <goto-table> <reduction-table>))
@end example
@end deffn


@deffn Clause :library-spec @var{spec}
Instruct @func{lalr-parser} to generate a proper Scheme library, holding
the parser definition and exporting a binding to the parser maker
function.  @var{spec} must be a proper @meta{library name} as defined by
@rnrs{6}.  @nauref{scheme library form, Libary form}

This option is especially useful in conjunction with @samp{output-file}.
It is mandatory to use the option @samp{:parser-name} along with
@samp{:library-spec}.

Example output for the @samp{lr} driver assuming @var{name} is the value
used for the @samp{:parser-name} option:

@example
(library @var{spec}
  (export @var{name})
  (import (rnrs)
          (lalr lr-driver)
          (parser-tools source-location)
          (parser-tools lexical-token)
          (sentinel))
  (define (@var{name})
    (lr-driver <action-table> <goto-table>
               <reduction-table>)))
@end example
@end deffn


@deffn Clause :library-imports @var{imports}
Instruct @func{lalr-parser} to add @var{imports} to the list of Scheme
libraries required by the parser definition.  @var{imports} must be a
list of library specifications; for example, if the parser definition
(meaning the semantic actions) requires the @library{alpha} and
@library{beta} libraries, we must use:

@example
(:library-imports '((alpha) (beta)))
@end example

The selected imports will be added to the import list of the generated
library (if @samp{:library-spec} is used), or to the @func{eval}
environment argument (if @samp{:output-value} is used).  The imports are
ignored when the output is a @func{define} form.

By default, the import list always includes @samp{(rnrs)}, the selected
driver's library @library{lalr lr-driver} or @library{lalr glr-driver}
and the following libraries:

@example
(parser-tools source-location)
(parser-tools lexical-token)
(sentinel)
@end example
@end deffn

@c page
@node lalr lexer
@section Describing tokens


The parser closure accepts as argument a lexer closure which, invoked
with no arguments, must return the next token from the input.  Tokens
are described using records of type @class{lexical-token}.  The current
position in the input stream is described using records of type
@class{source-location}.  @ref{parser-tools} for the definition of these
record types.

Once the lexer closure finds the end of input, it must return a token
with category @samp{*eoi*}; it must continue to return such a token if
invoked multiple times.

If the lexer closure finds a lexer error in the input, it must return a
token with category @samp{*lexer-error*}; lexer errors are
unrecoverable.

@c page
@node lalr parser
@section Running the parser


Here we suppose to have used @func{lalr-parser} to generate a proper
Scheme library exporting a binding to the parser maker.  Let
@library{calc-parser} be the library specification and
@func{make-calc-parser} the name of the binding to the parser maker.

The parser maker is invoked with no arguments and returns a new parser
closure, which represents an instance of the parser.  To create a parser
closure we do:

@example
(import (rnrs)
  (calc-parser))

(define parser (make-calc-parser))
@end example

The @func{parser} function accepts two or three arguments: the lexer
closure, an error handler procedure, a custom value.  When invoked, it
consumes tokens from the lexer until the end of input is found or an
unrecoverable error occurs.

To invoke @func{parser} with a lexer generated by the @library{silex}
library, using a table in @samp{calc-lexer-table} to parse
@var{input-string}, we do:

@example
(let* ((IS        (lexer-make-IS :string @var{input-string}
                                 :counters 'all))
       (lexer     (lexer-make-lexer calc-lexer-table IS))
       (error-hnd (lambda (message token) ---))
       (yycustom  #f))
  (parser lexer error-hnd yycustom))
@end example

The parser closure will return the value computed by the semantic clause
of the outer non--terminal, the @dfn{start symbol}.

@c ------------------------------------------------------------

@subsubheading The lexical analyser

The lexer closure must be a thunk invoked each time the parser needs to
lookahead in the token stream.  Its return value must be a record of
type @class{lexical-token}.  @ref{parser-tools token, Lexical token
records}

Once the lexer closure finds the end of input, it must return a token
with category @samp{*eoi*}; it must continue to return such a token if
invoked multiple times.

If the lexer closure finds a lexer error in the input, it must return a
token with category @samp{*lexer-error*}; lexer errors are
unrecoverable.

If the lexer raises an exception, it will go through the parser closure
with no obstacles.

@c ------------------------------------------------------------

@subsubheading The error procedure

It must be a function accepting two arguments: an error message as
Scheme string, the lexical token that caused the error.  Its return
value does not matter for the parser itself.

If the error procedure returns, the parser closure attempts to recover
from the error and to resume parsing.  If it raises an exception parsing
may stop, depending on how the program deals with it.

A simple error procedure raising an exception looks like this:

@example
(define (error-handler message token)
  (error #f
    (if (or (not (<lexical-token>? token))
            (not (<lexical-token>-location token)))
        message
      (let* ((position  (<lexical-token>-source   token))
             (line      (<source-location>-line   position))
             (column    (<source-location>-column position)))
        (string-append message
          " line "
          (if line   (number->string line)   "unknown")
          " column "
          (if column (number->string column) "unknown"))))
    token))
@end example

@noindent
notice how the handler detects if the @samp{location} field of the
@class{lexical-token} record is @false{} or a @class{source-location}
record.

The error procedure is invoked:

@itemize
@item
When an invalid value is returned by the lexer.  If the value is not a
@class{lexical-token} record, the error procedure is invoked with the
offending value as second argument.

Parsing stops and the return value of the parser closure is the return
value of the error procedure, if any.

@item
When the stream of tokens returned by the lexer violates parser's
grammar.

@itemize -
@item
If the error is an unexpected end--of--input, the second argument is a
@class{lexical-token} record with @samp{*eoi*} in the category field.

Parsing stops and the return value of the parser closure is the return
value of the error procedure, if any.

@item
If the error is another grammar violation, the error procedure is
invoked with the offending value as second argument; its return value,
if any, is discarded.

If the error procedure returns, the parser will try to recover from the
error and resume parsing; if error recovery fails, the parser behaves as
if the end--of--input is found.
@end itemize
@end itemize

@c page
@node lalr grammar
@section Defining the parser


@menu
* lalr grammar intro::          Introduction to grammar definition.
* lalr grammar precedence::     Operator precedence and associativity.
* lalr grammar clauses::        Writing semantic clauses.
* lalr grammar error::          Error recovery.
* lalr grammar conflict::       Conflicts resolution.
* lalr grammar examples::       Dummy examples of grammar definitions.
@end menu

@c page
@node lalr grammar intro
@subsection Introduction to grammar definition


The grammar is defined by the list of terminal token categories and the
list of non--terminal definitions.  Each non--terminal definition is a
list where the first element is the non--terminal and the other elements
are the right--hand sides (lists of grammar symbols).  In addition to
this, each right--hand side can be followed by a semantic clause.

For example, consider the following (Yacc) grammar for a very simple
expression language:

@example
e : e '+' t
  | e '-' t
  | t
  ;

t : t '*' f
  : t '/' f
  | f
  ;

f : ID
  ;
@end example

@noindent
the same grammar, written with @library{lalr}, would look like this:

@example
(lalr-parser

  (:terminals '(ID + - * /))

  (:rules '((e (e + t)    : (+ $1 $3)
               (e - t)    : (- $1 $3)
               (t)        : $1)

            (t (t * f)    : (* $1 $3)
               (t / f)    : (/ $1 $3)
               (f)        : $1)

            (f (ID)       : $1)))

  ---) ;other options
@end example

Here the symbols @samp{ID}, @samp{+}, @samp{-}, @samp{*}, @samp{/}
represent the terminal token categories; each token returned by the
lexer closure must belong to one of these.  The non--terminal
definitions are the symbols @samp{e}, @samp{t} and @samp{f}; the
right--hand sides of @samp{e} are the rules:

@example
(e + t)
(e - t)
(t)
@end example

@noindent
which are used to match sequences of terminals and non--terminals.  The
rule @samp{(e + t)} has the semantic clause @samp{(+ $1 $3)}.

In the semantic clauses, the symbol @samp{$n} refers to the value of the
@math{n}-th symbol in the right--hand side rule.  For example, when the
sequence of tokens @samp{1 + 2} is matched by the rule:

@example
(e + t)    : (+ $1 $3)
@end example

@noindent
the semantic clause is evaluated with @samp{$1} bound to @samp{1}, and
@samp{$2} bound to @samp{2}; the result of the evaluation of the
semantic clause becomes the value of the non--terminal @samp{e}.

A rule with no semantic clause can be written by omitting the @samp{: ---}
part, example:

@example
(e (e + t)    : (+ $1 $3)
   (e - t)    : (- $1 $3)
   (p)                       ;no semantic clause
   (t)        : $1)
@end example

@noindent
when such a rule matches a sequence of symbols, it generates the
sentinel value.  @nauref{sentinel, The sentinel value}

@c page
@node lalr grammar precedence
@subsection Operator precedence and associativity


The grammar defined in the introduction (@ref{lalr grammar intro})
implicitly handles operator precedences.  It is also possible to
explicitly assign precedences and associativity to terminal symbols and
productions a la Yacc.  Here is a modified (and augmented) version of
the grammar:

@example
(lalr-parser

  (:terminals '(ID
                (left: + -)
                (left: * /)
                (nonassoc: uminus)))

  (:rules '((e (e + e)              : (+ $1 $3)
               (e - e)              : (- $1 $3)
               (e * e)              : (* $1 $3)
               (e / e)              : (/ $1 $3)
               (- e (prec: uminus)) : (- $2)
               (ID)                 : $1)))

  ---) ;other options
@end example

The @samp{left:} clause is used to specify a set of left--associative
operators of the same precedence level.  The @samp{right:} clause
specifies right--associative operators at the same precedence level.
The @samp{nonassoc:} clause specifies operators that are
non--associative.

Note the use of the (apparently) useless terminal @samp{uminus}.  It is
only defined in order to assign to the penultimate rule a precedence
level higher than that of @samp{*} and @samp{/}.  The @samp{prec:}
directive can only appear as the last element of a rule.

Finally, note that precedence levels are incremented from left to right,
i.e. the precedence level of @samp{+} and @samp{-} is less than the
precedence level of @samp{*} and @samp{/} since the formers appear first
in the list of terminal symbols.

@c page
@node lalr grammar clauses
@subsection Writing semantic clauses


Semantic clauses are Scheme forms that can do anything Scheme allows us
to do.  They are allowed to access the local bindings @samp{$1},
@samp{$2}, @dots{} bound to values in the same number of the symbols of
the production rule.

An important limit is the environment in which the semantic clauses are
evaluated:

@itemize
@item
If we have instructed @func{lalr-parser} to generate a @func{define}
form, we can take the form and place it in our code; in this case the
environment is the one active at that position.

@item
If we have instructed @func{lalr-parser} to generate a proper Scheme
library, we can add libraries specifications to the import list of the
generated library using the @samp{:library-imports} option of
@func{lalr-parser}.

@item
If we have instructed @func{lalr-parser} to evaluate the generated
parser maker using the @library{rnrs eval} library, we can add libraries
specifications to the evaluation environment using the
@samp{:library-imports} option of @func{lalr-parser}.
@end itemize


The following local bindings are accessible in the semantic clauses.


@defun yypushback
If evaluated, tell the parser closure to reuse the last token (as
lookahead) rather than to retrieve a new one from the lexer.  This may
be useful to handle some corner cases in the grammar definition.
@end defun


@defvar yycustom
This is the custom value we give as @var{yycustom} argument to the
parser function.  It can be any value, from a closure to a constant, to
a continuation.
@end defvar

@c page
@node lalr grammar error
@subsection Error recovery


@menu
* lalr grammar error intro::    Introduction to error recovery.
* lalr grammar error single::   Dummy example: Single token parser.
@end menu

@c page
@node lalr grammar error intro
@subsubsection Introduction to error recovery


@library{lalr} implements a very simple error recovery strategy.  A
production can be of the form:

@example
(NON-TERMINAL
   ---                  ;right-hand side rules
   (error TERMINAL) : semantic-clause)
@end example

If, while parsing the right--hand side rules for @samp{NON-TERMINAL},
the lookahead returns an invalid category: The parser resets the state
associated with the parsing of the rule and skips all the tokens
returned by the lexer until one with category @samp{TERMINAL} is found.
The @samp{TERMINAL} token is also discarded and parsing continues with a
new lookahead.

The symbol @samp{error} is reserved as error recovery directive, it
cannot be used as terminal or non--terminal.

There can be several such right--hand side rules for a single
non--terminal: For a C--like language, we could ``synchronise'' on
semicolons and closing curly brackets by writing error rules like these:

@example
(statement
   (expression SEMICOLON)        : ---
   (LBRACKET statement RBRACKET) : ---
   (error SEMICOLON)    ;empty semantic claus
   (error RBRACKET))    ;empty semantic claus
@end example

@noindent
if an error occurs, the parser will discard its internal state up to,
and including, the first token that started the @samp{statement}
non--terminal (@samp{LBRACKET} or the first of @samp{expression}).

@c page
@node lalr grammar error single
@subsubsection Dummy example: Single token parser


Let's consider the following parser which accepts as input only the
sequence: @samp{A}, @samp{*eoi*}; it is a corner case which is useful to
understand.  The correct way to handle this case is to have an error
handler that does not return; in the following the error handler
returns, leaving the parser to handle everything.

@example
(define (example . tokens)
  (let* ((lexer        (make-lexer tokens))
         (make-parser  (lalr-parser
                         (:output-value #t)
                         (:terminals '(A))
                         (:rules '((e (A) : $1)))))
         (parser       (make-parser)))
    (parser lexer error-handler)))
@end example

We have already examined the correct usage of this grammar (@ref{lalr
grammar examples single}); we can now understand what happens in the
following test:

@example
(example (make-lexical-token 'A #f 1)
         (make-lexical-token 'A #f 2)
         (make-lexical-token 'A #f 3)))
@result{} ("unexpected end of input" . (eof-object))
@end example

@noindent
following the reasoning exposed in the introduction (@pxref{lalr
intro}), we can imagine the input tokens on the following stacks:

@example
#(#f  1  2  3  #<eof>)
#(S   A  A  A   *eoi*)
  |
  p
@end example

@enumerate
@item
The first lookahead returns @samp{A} and the action is a shift:

@example
#(#f  1  2  3  #<eof>)
#(S   A  A  A   *eoi*)
      |
      p
@end example

@item
The second lookahead returns @samp{A} and the action is a reduce, which
changes nothing because there is only one token and the semantic action
is @samp{$1}:

@example
#(#f  1  2  3  #<eof>)
#(S   A  A  A   *eoi*)
      |
      p
@end example

@item
The third lookahead returns @samp{A} and the action is error because
only @samp{*eoi*} is acceptable now.  The error handler is invoked and
its return value discarded.

The parser attempts to recover from the error; we already know that the
recovery will fail, because we have not included any @samp{error}
right--hand side rule in the grammar.

@item
The first operation of recovery is to reset the current parser state
removing everything related to this right--hand side rule:

@example
#(#f  2  3  #<eof>  #f)
#(S   A  A   *eoi*  #f)
  |
  p

@end example

@item
The parser detects the fact that the stack has been fully rewind without
finding a non--terminal with an @samp{error} directive, so it just stops
reading tokens from the lexer and imposes a @samp{*eoi*} token as
lookahead.

@item
The end--of--input token is invalid as lookahead from the initial state,
so an ``unexpected end--of--input error'' is generated; the error
handler is invoked and its return value becomes the return value of the
parser closure.
@end enumerate

@c page
@node lalr grammar conflict
@subsection Conflicts resolution


Conflicts in the grammar are handled in a conventional way.  In the
absence of precedence directives, Shift/Reduce conflicts are resolved by
shifting, and Reduce/Reduce conflicts are resolved by choosing the rule
listed first in the grammar definition.

@c page
@node lalr grammar examples
@subsection Dummy examples of grammar definitions


In this section we examine some dummy parser definitions to understand
some basic mechanism.

@menu
* lalr grammar examples helpers:: Helper definitions.
* lalr grammar examples single::  Single token parser.
@end menu

@c page
@node lalr grammar examples helpers
@subsubsection Helper definitions


In all the examples of this section we will use these helpers:

@example
(define eoi-token
  (make-lexical-token '*eoi* #f (eof-object) 0))

(define (make-lexer list-of-tokens)
  ;;Return a lexer closure  drawing tokens
  ;;from LIST-OF-TOKENS.  When the list is
  ;;empty, return the EOI-TOKEN.
  ;;
  (lambda ()
    (if (null? list-of-tokens)
        eoi-token
      (begin0
          (car list-of-tokens)
        (set! list-of-tokens (cdr list-of-tokens))))))

(define (make-token category semantic-value)
  (make-<lexical-token> category #f semantic-value 0))

(define (error-handler message token)
  (cons message (<lexical-token>-value token)))
@end example

@noindent
we see that the error handler does not raise an exception, so the parser
is allowed to attempt a recovery after an error.

@c page
@node lalr grammar examples single
@subsubsection Single token parser


The following example defines a parser accepting only a single token of
category @samp{A}, which must be followed by the end--of--input
@samp{*eoi*}.  Every other input sequence causes an error; this includes
an @samp{*eoi*} token alone.

@example
(define (example . tokens)
  (let* ((lexer        (make-lexer tokens))
         (make-parser  (lalr-parser
                         (:output-value #t)
                         (:terminals '(A))
                         (:rules '((e (A) : $1)))))
         (parser       (make-parser)))
    (parser lexer error-handler)))

;;Parse the sequence: A *eoi*
(example (make-token 'A 1))
@result{} 1

;;Parse the sequence: *eoi*
(example)
@result{} ("unexpected end of input" . (eof-object))
@end example

@noindent
the following test raises an error:

@example
(example (make-token 'A 1)
         (make-token 'A 2)
         (make-token 'A 3)))
@result{} ("unexpected end of input" . (eof-object))
@end example

@noindent
we will come back to this test when describing the error recovery
mechanism.  @ref{lalr grammar error, Error recovery}

@c ------------------------------------------------------------

@subsubheading Accepting @samp{*eoi*} alone

The following parser defines a grammar which accepts the sequence
@samp{A *eoi*}, but also accepts @samp{*eoi*} alone.

@example
(define (example . tokens)
  (let* ((lexer        (make-lexer tokens))
         (make-parser  (lalr-parser
                         (:output-value #t)
                         (:terminals '(A))
                         (:rules '((e (A) : $1)
                                      ()  : 0))))
         (parser       (make-parser)))
    (parser lexer error-handler)))

;;Parse the sequence: A *eoi*
(example (make-token 'A 1))
@result{} 1

;;Parse the sequence: *eoi*
(example)
@result{} 0
@end example

When the input is a single @samp{*eoi*} token: The parser returns the
value of the semantic action in @samp{() : 0}.  When the input is the
sequence @samp{A *eoi*}: The parser returns the value of the semantic
action in @samp{(A) : $1}.  Let's understand why.

Using the reasoning of the introduction (@pxref{lalr intro}), we can
imagine the tokens of the sequence @samp{A *eoi*} on the following
stacks:

@example
#(#f  1  #<eof>)
#(S   A   *eoi*)
  |
  p
@end example

@noindent
the first lookahead returns @samp{A} and the action is shift, we
``enter'' the right--hand side rule @samp{(A)}:

@example
#(#f  1  #<eof>)
#(S   A   *eoi*)
      |
      p
@end example

@noindent
the second lookahead returns @samp{*eoi*} and the action is reduce, we
``leave'' the right--hand side rule @samp{(A)}; one couple is popped
from the stack and one couple is pushed:

@example
#(#f  1  #<eof>)
#(S   e   *eoi*)
      |
      p
@end example

@noindent
the value has not changed because the semantic clause is just @samp{$1}
which is @samp{1} itself; the third lookahead returns @samp{*eoi*} and
the action is accept (the value @samp{1}).

We can imagine the tokens of the sequence @samp{*eoi*} on the following
stacks:

@example
#(#f  #<eof>)
#(S   *eoi*)
  |
  p
@end example

@noindent
the first lookahead returns @samp{*eoi*} and the action is reduce, we
enter and leave the right--hand side rule @samp{()} in a single step; no
couples are popped from the stacks, but a couple is pushed:

@example
#(#f  0  #<eof>)
#(S   e   *eoi*)
      |
      p
@end example

@noindent
we see the result of the semantic clause; the second lookahead returns
@samp{*eoi*} and the action is accept (the value @samp{0}).

@c ------------------------------------------------------------

@subsubheading Accepting fixed sequences

The following parser defines a grammar which accepts the following fixed
sequences:

@example
*eoi*
A *eoi*
A A *eoi*
A A A *eoi*
@end example

@noindent
the return value of the parser is the list of values from the tokens.

@example
(define (example . tokens)
  (let* ((lexer        (make-lexer tokens))
         (make-parser  (lalr-parser
                         (:output-value #t)
                         (:terminals '(A))
                         (:rules '((e (A)     : (list $1)
                                      (A A)   : (list $1 $2)
                                      (A A A) : (list $1 $2 $3)
                                      ()      : 0)))))
         (parser       (make-parser)))
    (parser lexer error-handler)))

;;Parse the sequence: A *eoi*
(example (make-token 'A 1))
@result{} (1)

;;Parse the sequence: A A *eoi*
(example (make-token 'A 1)
         (make-token 'A 2))
@result{} (1 2)

;;Parse the sequence: A A A *eoi*
(example (make-token 'A 1)
         (make-token 'A 2)
         (make-token 'A 3))
@result{} (1 2 3)

;;Parse the sequence: *eoi*
(example)
@result{} 0
@end example

@c ------------------------------------------------------------

@subsubheading Accepting a sequence of arbitrary length

The following parser defines a grammar which accepts a sequence of
@samp{A} tokens of any length; it also accepts @samp{*eoi*} alone.

@example
(define (example . tokens)
  (let* ((lexer        (make-lexer tokens))
         (make-parser  (lalr-parser
                         (:output-value #t)
                         (:terminals '(A))
                         (:rules '((e (e A) : $2
                                      (A)   : $1
                                      ()    : 0)))))
         (parser       (make-parser)))
    (parser lexer error-handler)))

;;Parse the sequence: *eoi*
(example)
@result{} 0

;;Parse the sequence: A *eoi*
(example (make-token 'A 1))
@result{} 1

;;Parse the sequence: A A A *eoi*
(example (make-token 'A 1)
         (make-token 'A 2)
         (make-token 'A 3))
@result{} 3
@end example

@noindent
in the last test example, notice that the parser's return value is the
value of the last parsed token (@samp{3}), while the other values are
discarded.  This is because the whole sequence matches the right--hand
side rule @samp{(e A)} and its semantic clause is @samp{$2}, which is
the value of the token matching the last terminal @samp{A}.

@c ------------------------------------------------------------

@subsubheading Returning all the values from an arbitrary sequence

If we want all the values in the sequence we can use the following
parser:

@example
(define (example . tokens)
  (let* ((lexer        (make-lexer tokens))
         (make-parser  (lalr-parser
                         (:output-value #t)
                         (:terminals '(A))
                         (:rules '((e (e A) : (cons $2 $1)
                                      (A)   : (list $1)
                                      ()    : 0)))))
         (parser       (make-parser)))
    (parser lexer error-handler)))

;;Parse the sequence: *eoi*
(example)
@result{} 0

;;Parse the sequence: A *eoi*
(example (make-token 'A 1))
@result{} (1)

;;Parse the sequence: A A *eoi*
(example (make-token 'A 1)
         (make-token 'A 2))
@result{} (2 1)

;;Parse the sequence: A A A *eoi*
(example (make-token 'A 1)
         (make-token 'A 2)
         (make-token 'A 3))
@result{} (3 2 1)
@end example

@noindent
we notice that the values are returned in reverse order; this is
because, making the semantic clauses explicit, the following are
equivalent:

@example
(cons 2 (list 1))

(example (make-token 'A 1)
         (make-token 'A 2))
@end example

@noindent
and also the following:

@example
(cons 3 (cons 2 (list 1)))

(example (make-token 'A 1)
         (make-token 'A 2)
         (make-token 'A 3))
@end example

@noindent
in more detail, when parsing the sequence @samp{A A *eoi*} we can
imagine the following stacks:

@example
#(#f  1  2  #<eof>)
#(S   A  A   *eoi*)
  |
  p
@end example

@noindent
the first lookahead returns @samp{A} and the action is shift:

@example
#(#f  1  2  #<eof>)
#(S   A  A   *eoi*)
      |
      p
@end example

@noindent
the second lookahead returns @samp{A} and the action is reduce:

@example
#(#f  (1)  2  #<eof>)
#(S    e   A   *eoi*)
       |
       p
@end example

@noindent
the third lookahead returns @samp{A} and the action is shift:

@example
#(#f  (1)  2  #<eof>)
#(S    e   A   *eoi*)
           |
           p
@end example

@noindent
the fourth lookahead returns @samp{A} and the action is reduce:

@example
#(#f  (2 . (1))  #<eof>  #f)
#(S    e          *eoi*  #f)
       |
       p
@end example

@noindent
and we know that @samp{(2 . (1))} is @samp{(2 1)}; the fifth lookahead
returns @samp{*eoi*} and the action is accept.

@c page
@node lalr glr
@section Generalised LR parsing


GLR parsing (which stands for Generalized LR parsing) is an extension of
the traditional LR parsing technique to handle highly ambiguous
grammars.  It is especially interesting for natural language processing,
the context in which the technique has been devised.

To generate a GLR parser instead of a regular LALR parser, simply use
the @samp{:parser-type 'glr} option with @func{lalr-parser}.

GLR parsers are run in exactly the same way as regular LALR parsers; the
only difference is that the result of the parsing is a (possibly empty)
list of parses instead of a single parse.

Since the parsing of a phrase can lead to many potential parses, errors
cannot be detected as easily as with deterministic LR parsing.  For this
reason, it is advised to not put error productions in the grammar (they
will be ignored anyway).  Moreover, GLR parsers are usually not meant
for interactive parsers.

@c page
@node packrat
@chapter Packrat parser


The @library{packrat} library implements parsing combinators using the
Packrat parsing algorithm: A memoizing, backtracking, recursive descent
parsing technique that runs in time and space linear in the size of the
input text.  There is no single Scheme object which can be named
``Packrat parser'', rather a parser is a collection of combinator
functions calling each other.

The library makes use of the @class{lexical-token} and
@class{source-location} record types, and follows their protocol for
end--of--input and lexer errors handling.  @ref{parser-tools, Lexer and
parser utilities}.

When first experimenting with it, we sould import the library with the
following directive:

@example
(import (rnrs)
  (prefix (packrat) packrat:))
@end example

@noindent
to avoid imported bindings name conflicts.

@menu
* packrat intro::               Introduction to the algorithm.
* packrat calc::                Calculator example.
* packrat types::               Parser state and results.
* packrat comb::                Combinators.
@end menu

@c page
@node packrat intro
@section Introduction to the algorithm


For a generic introduction to parsers, see the tutorial for the
@library{lalr} library.  @ref{lalr intro, Introduction to the LR parser}

@menu
* packrat intro state::         Handling the parser state.
* packrat intro comb::          Combinator functions.
@end menu

@c page
@node packrat intro state
@subsection Handling the parser state


The parser state is represented by a linked list of @class{state}
records, terminated by a thunk which, if evaluated, returns the next
@class{state} record in the list, already chained.  The list is
@strong{not} a Scheme list.

@example
 -----------
|  <state>  |
|           |
| lookahead +--> #<first lexical-token>
|           |
|   next    |
 -----+-----
      |
      v
 -----------
|  <state>  |
|           |
| lookahead +--> #<second lexical-token>
|           |
|    next   |
 -----------
      |
      v
 -----------
|  <state>  |
|           |
| lookahead +--> #<third lexical-token>
|           |
|    next   |
 -----------
      |
      v
 #<procedure>
@end example

Each @class{state} record represents the sequence of subsequent tokens
drawn from the lexer.  By keeping a referenct to a @class{state} record,
we can reparse the same sequence any number of times; this is used to
backtrack from a state to a previous one.

@c page
@node packrat intro comb
@subsection Combinator functions


A @dfn{combinator} is a function accepting a single @class{state} record
as argument and returning a @class{success} or @class{error} record.
The returned record is generated by analysing the tokens in the
@class{state} records; a combinator consuming a single token looks like
this:

@example
(define (combinator state)
  (let* ((token (<state>-lookahead state))
         (value (some-operation token)))
    (if value
        (make-<success> (next-state state) value)
      (make-<error> state "an error description"))))
@end example

@noindent
notice how the returned record holds the next state if it is a
@class{success} and the current state if it is an @class{error}.  A
combinator analysing three tokens looks like this:

@example
(define (combinator state-1)
  (let* ((state-2 (next-state state-1))
         (state-3 (next-state state-2))
         (token-1 (<state>-lookahead state-1))
         (token-2 (<state>-lookahead state-2))
         (token-3 (<state>-lookahead state-3))
         (value (some-operation token-1 token-2 token-3)))
    (if value
        (make-<success> (next-state state-3) value)
      (make-<error> state-1 "an error description"))))
@end example

@noindent
here the successful return record keeps a reference to the state next to
the @strong{last} @class{state} record used to generate it; this means
that given the result of a combinator application, we can access the
deepest parser @class{state} and so continue parsing from there.

Often we chain combinator functions so the second combinator is applied
only if the first one succeeds:

@example
(define (first state)
  (let* ((token (<state>-lookahead state))
         (value (some-operation token)))
    (if value
        (second (next-state state))
      (make-<error> state "an error description"))))

(define (second state)
  (let* ((token (<state>-lookahead state))
         (value (some-operation token)))
    (if value
        (make-<success> (next-state state) value)
      (make-<error> state "an error description"))))

(first init-state)
@end example

@noindent
notice how @func{first} takes care of generating a new @class{state}
record with @func{next-state}.

There are many ways, and so much freedom, in composing combinators to
parse the tokens.  @library{packrat} provides a handful of standard ways
to compose client supplied combinators.

@c page
@node packrat calc
@section Calculator example


The following example implements a simple arithmetics calculator.  First
let's see an S--expressions lexer; the parser expects a lexer closure
returning records of type @class{lexical-token} having terminal category
symbols in the set:

@example
NUMBER OPEN-PAREN CLOSE-PAREN + - * /
@end example

@noindent
the lexer first converts an S--expression into a list of pairs:

@example
(sexp->stream '(1 + 2 + 3))
@result{} ((NUMBER . 1)
    (+)
    (NUMBER . 2)
    (+)
    (NUMBER . 3))

(sexp->stream '((1 + 2) * 3))
@result{} ((OPEN-PAREN)
    (NUMBER . 1)
    (+)
    (NUMBER . 2)
    (CLOSE-PAREN)
    (*)
    (NUMBER . 3))
@end example

@noindent
notice that @samp{(NUMBER . 3)} is a token representation with terminal
category @samp{NUMBER} and semantic value @samp{3}; also, @samp{(+)} is
a token representation with terminal category @samp{+} and semantic
value null.

@example
(define (sexp->stream sexp)
  (define (lexer sexp)
    (let loop ((sexp   (if (pair? sexp)
                           sexp
                         (list sexp)))
               (result '()))
      (if (null? sexp)
          result
        (let ((atom (car sexp)))
          (loop (cdr sexp)
                (cond ((number? atom)
                       `((NUMBER . ,atom) . ,result))
                      ((memq atom '(+ - * /))
                       `((,atom) . ,result))
                      ((pair? atom)
                       (append '((CLOSE-PAREN))
                               (lexer atom)
                               '((OPEN-PAREN))
                               result))
                      (else
                       (error #f "invalid token" atom))))))))
  (reverse (lexer sexp)))
@end example

Then let's see the lexer closure; it takes an S--expression and returns
a thunk which, when evaluated, returns records of type
@class{lexical-token}.  The source location field is set to @false{},
because for an S--expression there is no such information available.

@example
(define (make-lexer-closure sexp)
  (let ((stream (sexp->stream sexp)))
    (lambda ()
      (if (null? stream)
          (make-<lexical-token>/end-of-input #f)
        (let ((token (car stream)))
          (set! stream (cdr stream))
          (make-<lexical-token> (car token) #f
                                (cdr token) 0))))))
@end example

Finally the parser definition; it defines the following non--terminal
symbols:

@table @samp
@item expr
It is the start symbol and represents a general arithmetic expression.

@item mul-expr
It represents a multiplication, a division or a subexpression.  It is
subordinate to @samp{expr} to allow multiplication and division to have
precedence over addition and subtraction.  Also, it allows parenthesised
subexpressions to be evaluated first.

@item simple
It represents subexpressions.  It includes: simple numbers; negated
expressions; expressions preceeded by a standalone plus sign;
parenthesised subexpressions.
@end table

The @func{make-grammar-combinator} macro returns a combinator function
which can be used any number of times to parse S--expressions.

@example
(define calc
  (make-grammar-combinator expr

    (expr     ((a <- mul-expr '+ b <- expr)
               (+ a b))
              ((a <- mul-expr '- b <- expr)
               (- a b))
              ((a <- mul-expr)
               a))

    (mul-expr ((a <- simple '* b <- simple)
               (* a b))
              ((a <- simple '/ b <- simple)
               (/ a b))
              ((a <- simple)
               a))

    (simple   ((a <- 'NUMBER)
               a)
              (('+ a <- expr)
               a)
              (('- a <- expr)
               (- a))
              (('OPEN-PAREN a <- expr 'CLOSE-PAREN)
               a))))
@end example

@noindent
typical usage of the interface is represented by the following function:

@example
(define (doit sexp)
  (let* ((lexer   (make-lexer-closure sexp))
         (result  (calc (initialise-state lexer))))
    (if (<success>? result)
        (<result>-value result)
      (<error>-message result))))
@end example

@noindent
it works like this:

@example
(doit 1)
@result{} 1

(doit '(+ 1))
@result{} 1

(doit '(- 1))
@result{} -1

(doit '(- - + + - + 1))
@result{} -1

(doit '(1 * 2 - 3))
@result{} -1

(doit '((1 + 2) * 3))
@result{} 9

(doit '(+ *))
@result{} "expected token with category OPEN-PAREN"
@end example

@noindent
there are ways to return better error messages.

@c page
@node packrat types
@section Parser state and results


@menu
* packrat types state::         The parser state.
* packrat types result::        Combinators results.
@end menu

@c page
@node packrat types state
@subsection The parser state


@deftp {Record Type} <state>
Represents the state of the parser at a specific point in the input
stream.  Records of this type are the argument for the combinator
functions.  Fields description follows:

@table @samp
@item lookahead
A @class{lexical-token} record from the input stream.  It is the first
token examined by combinators.  This field is immutable.

@item next-state
A @class{state} record or a thunk returning a @class{state} record.  It
represents the next state generated by parsing the token in the
@samp{lookahead} field.  To generate a new state we must do:

@example
(let* ((state ---)
       (next  (<state>-next-state state)))
  (if (<state>? next)
      next
    (next)))
@end example

@noindent
or just call @func{next-state}.

@item memoized-results
An alist mapping keywords to @class{result} records; it represents the
result of applying a combinator to this record.  Each memoizing
combinator must have a unique symbol associated to it, to be used as
keyword for this alist.

Only combinators generated by @func{make-memoize-combinator} access this
field.
@end table
@end deftp


@defun <state>? @var{obj}
Return @true{} if @var{obj} is a record of type @class{state}.
@end defun


@defun <state>-lookahead @var{state}
@defunx <state>-next-state @var{state}
@defunx <state>-memoized-results @var{state}
Field accessors.
@end defun


@defun initialise-state @var{lexer}
Return a @class{state} record representing the whole input stream
generated by @var{lexer}.  @var{lexer} must be a thunk returning
@class{lexical-token} records.
@end defun


@defun next-state @var{state}
Return a @class{state} record representing the input stream after the
token in @var{state}, which must be a @class{state} record.
@end defun


@defun pushback @var{token} @var{state}
Return a @class{state} record representing the input stream
@strong{before} the token in @var{state}, which must be a @class{state}
record.  It can be used to fake reading tokens from the input.
@end defun


@deffn Syntax memoize-acons @var{keyword} @var{result} @var{state}
Memoize the @class{result} record @var{result} in the @class{state}
record @var{state}, associating it to @var{keyword} which must be a
value comparable with @func{eq?}.
@end deffn


@deffn Syntax memoize-assq @var{keyword} @var{state}
Search the memoized result associated to @var{keyword} in the
@class{state} record @var{state}; return @false{} if not found, else a
pair whose car is @var{keyword} and whose cdr is a @class{success} or
@class{error} record.
@end deffn


@deffn Syntax memoize-set! @var{keyword} @var{result} @var{state}
Search the memoized result associated to @var{keyword} in the
@class{state} record @var{state}, then store @var{result} in the cdr of
the entry.  It is an error if the @var{state} has no memoized result
associated to @var{keyword}.
@end deffn

@c page
@node packrat types result
@subsection Combinators results


@deftp {Record Type} <result>
Base type for the return value of the combinator functions.  It is an
``abstract'' type, meaning that it is incorrect to instantiate it
directly.  Fields description follows:

@table @samp
@item state
Immutable field holding a @class{state} record.  If the record is a
@class{success}, this state is the next, still unparsed, one; if the
record is an @class{error}, this state is the one that generated the
error.
@end table
@end deftp


@deftp {Record Type} <success>
Record type derived from @class{result}; it represents the successful
application of a combinator to a @class{state} record.  Fields
description follows:

@table @samp
@item value
An immutable field holding the semantic value generated by the
combinator application.
@end table
@end deftp


@deftp {Record Type} <error>
Record type derived from @class{result}; it represents the failed
application of a combinator to a @class{state} record.  Fields
description follows:

@table @samp
@item message
An immutable field holding a Scheme string describing the error.
@end table
@end deftp


@defun make-<success> @var{next-state} @var{value}
@defunx make-<error> @var{state} @var{error-message}
Record constructors.
@end defun


@defun <result>? @var{obj}
@defunx <success>? @var{obj}
@defunx <error>? @var{obj}
Return @true{} if @var{obj} is a record of type @class{result},
@class{success} or @class{error}.
@end defun


@defun <result>-state @var{result}
@defunx <success>-value @var{success}
@defunx <error>-message @var{error}
Field accessors.
@end defun

@c page
@node packrat comb
@section Combinators


The @dfn{parsing combinators} are functions taking as argument a
@class{state} record and returning a @class{result} record.
@library{packrat} provides a set of combinator makers which can be used
to generate commonly used combinator procedures.

@menu
* packrat comb terminal::       Expecting a token category.
* packrat comb sequence::       Applying combinators in sequence.
* packrat comb or::             Applying alternative combinators.
* packrat comb unless::         Applying failure combinators.
* packrat comb memoize::        Memoizing combinators.
* packrat comb error::          Returning error results.
* packrat comb grammar::        The grammar combinator.
* packrat comb left::           Left recursion problem.
@end menu

@c page
@node packrat comb terminal
@subsection Expecting a token category


One of the most common operations is to verify that the next token
belongs to a specific category; in the end, the state of the parser is
advanced when a combinator matches one or more tokens with the specified
category.  This is used also to check that a @class{state} record
represents the end of input, that is if it has category @samp{*eoi*}.

Basically, a combinator matching a token with category @samp{NUMBER}
should look like this:

@example
(lambda (state)
  (let ((token (<state>-lookahead state)))
    (if (eq? 'NUMBER (<lexical-token>-category token))
        (make-<success> (next-state state)
                        (<lexical-token>-value token))
      (make-<error> state "expected NUMBER token"))))
@end example

@noindent
notice how the returned @class{result} record holds the next state if it
is a @class{success}, and the current state if it is an @class{error}.
We want a method to generate such combinators with the category as
parameter.


@defun make-terminal-combinator @var{category} @var{acceptor}
Return a combinator which, if the next token has category @func{eq?} to
@var{category}, applies the procedure @var{acceptor} to its semantic
value.  The result of this application must be a combinator, which is
applied to the @class{state} record representing the remainder of the
input stream.
@end defun


The following example defines a combinator which checks that the next
token has category @samp{NUMBER} and, if successful, returns a
@samp{success} record (holding the next @class{state} record).  The
acceptor discards the semantic value and returns a combinator which just
builds a @class{success} record.

@example
(define comb
  (make-terminal-combinator 'NUMBER
    (lambda (semantic-value)
      (lambda (state)
        (make-<success> state semantic-value)))))
@end example

The following example defines combinators which check that the next two
tokens have categories @samp{A} and @samp{B} and, if successful, return
a @samp{success} record holding the semantic value of the second.

@example
(define comb-a
  (make-terminal-combinator 'A
    (lambda (semantic-value)
      comb-b)))

(define comb-b
  (make-terminal-combinator 'B
    (lambda (semantic-value)
      (lambda (state)
        (make-<success> state semantic-value)))))
@end example

The following example defines a combinator which checks that the next
two tokens have category @samp{NUMBER} and, if successful, returns a
@samp{success} record holding the sum of the semantic values; the second
combinator is dynamically generated, so that it can reference the
semantic value of the first result:

@example
(define comb
  (make-terminal-combinator 'NUMBER
    (lambda (a)
      (make-terminal-combinator 'NUMBER
        (lambda (b)
          (lambda (state)
            (make-<success> state (+ a b))))))))
@end example

@c page
@node packrat comb sequence
@subsection Applying combinators in sequence.


One of the most common operations is to apply a combinator to a
@class{state} record and, if success, apply another one to the new
state; basically, ``application if success'' goes like this:

@example
(define comb-a
  (lambda (state)
    ---))

(define comb-b
  (lambda (state)
    ---))

(lambda (state)
  (let ((result (comb-a state)))
    (if (<success>? result)
        (comb-b (<result>-state result))
      result)))
@end example

@noindent
we want a method to generate such a combinator with the sequenced
combinators as parameters.


@defun make-sequence-combinator @var{combinator} @var{acceptor}
Return a new combinator which applies @var{combinator} to the state and,
if successful, hands the resulting semantic value to the procedure
@var{acceptor}.  The result of this application must be a combinator,
which is applied to the @class{state} record representing the remainder
of the input stream.
@end defun


The following example defines a sequence combinator which checks if the
next two tokens have categories @samp{A} and @samp{B}:

@example
(define comb-a
  (make-terminal-combinator 'A
    (lambda (semantic-value)
      (lambda (state)
        (make-<success> state semantic-value)))))

(define comb-b
  (make-terminal-combinator 'B
    (lambda (semantic-value)
      (lambda (state)
        (make-<success> state semantic-value)))))

(define comb
  (make-sequence-combinator comb-a
    (lambda (discarded) comb-b)))
@end example

The following example defines a combinator which checks that the next
two tokens have category @samp{NUMBER} and, if successful, returns a
@samp{success} record holding the sum of the semantic values; the second
combinator is dynamically generated:

@example
(define comb
  (packrat:make-sequence-combinator
       (packrat:make-terminal-combinator 'NUMBER
          (lambda (a)
            (lambda (state)
              (packrat:make-<success> state a))))
    (lambda (a)
      (packrat:make-terminal-combinator 'NUMBER
         (lambda (b)
           (lambda (state)
             (packrat:make-<success> state (+ a b))))))))
@end example

@c page
@node packrat comb or
@subsection Applying alternative combinators


A common operation is to apply a combinator when another one has already
failed to match the input; basically, it is like this:

@example
(define comb-a
  (lambda (state)
    ---))

(define comb-b
  (lambda (state)
    ---))

(lambda (state)
  (let ((result (comb-a state)))
    (if (<success>? result)
        result
      (comb-b state))))
@end example

@noindent
we want a method to generate such a combinator with the alternative
combinators as parameters.


@defun make-or-combinator @vari{combinator} @varii{combinator}
Return a new combinator which applies @vari{combinator} to the state; if
successful returns the result, else applies @varii{combinator} and
returns its result.
@end defun


The following example defines an OR combinator which matches if the next
token has category @samp{A} or @samp{B}:

@example
(define comb-a
  (make-terminal-combinator 'A
    (lambda (semantic-value)
      (lambda (state)
        (make-<success> state semantic-value)))))

(define comb-b
  (make-terminal-combinator 'B
    (lambda (semantic-value)
      (lambda (state)
        (make-<success> state semantic-value)))))

(define comb
  (make-or-combinator comb-a comb-b))
@end example

The following example defines an OR combinator which is used to generate
a specific error message:

@example
(define comb
  (make-or-combinator
     (make-terminal-combinator 'A
       (lambda (semantic-value)
         (lambda (state)
           (make-<success> state semantic-value))))
     (lambda (state)
       (make-<error> state "it is not A, dammit!"))))
@end example

@c page
@node packrat comb unless
@subsection Applying failure combinators


It is possible to assert that a particular sequence of tokens does
@strong{not} occur in the current state of the parser; it goes like
this:

@example
(define comb-a
  (lambda (state)
    ---))

(define comb-b
  (lambda (state)
    ---))

(lambda (state)
  (let ((result (comb-a state)))
    (if (<error>? result)
        (comb-b (<result>-state result))
      (make-<error> state "unexpected match"))))
@end example

@noindent
we want a method to generate such a combinator with the combinators as
parameters.


@defun make-unless-combinator @vari{combinator} @varii{combinator}
Return a new combinator which applies @vari{combinator} to the state
and, if error, applies @varii{combinator} to the @class{state} record
representing the remainder of the input stream.
@end defun

@c page
@node packrat comb memoize
@subsection Memoizing combinators


It is possible to memoize the result of applying a combinator into the
@class{state} record itself; simplifying, it goes like this:

@example
(define comb
  (lambda (state)
    ---))

(lambda (state)
  (cond ((memoize-assq 'keyword state) => cdr)
        (else
         (begin0-let ((result (comb state))
           (memoize-acons 'keyword result state)))))))
@end example

@noindent
if a result has been already computed for the state and associated to
@samp{keyword} in the internal alist, then that result is returned; else
the combinator is applied.  We want a method to generate such a
combinator with the keyword and combinator as parameters.


@defun make-memoize-combinator @var{combinator}
@defunx make-memoize-combinator @var{combinator} @var{keyword}
Return a new combinator which first searches @var{keyword} between the
memoized results of the state:

@itemize
@item
If it is found, return the associated @class{result} record.

@item
Else applies @var{combinator} to the state, memoizes the result, then
returns it.
@end itemize

@var{keyword} is the key associated to the result in the @class{state}
record, it must be a value comparable with @func{eq?}; if not supplied,
it defaults to an automatically generated, @func{eq?} comparable value
(actually a sentinel value, @nauref{sentinel, The sentinel value}).
@end defun

@c page
@node packrat comb error
@subsection Returning error results


@defun make-error-combinator @var{error-message}
Return a new combinator which returns an @class{error} record with
@var{error-message} in the @samp{message} field.  The error combinator
can be used to end a sequence, which is known to be invalid, with a
descriptive error message.
@end defun




@c page
@node packrat comb grammar
@subsection The grammar combinator


@deffn Syntax make-grammar-combinator @ameta{start} @ameta{nonterminal} ...
Provide syntactic sugar for building complex parser combinators from
simpler combinators.  Each @meta{nonterminal} must be like this:

@example
@cmeta{nonterminal} -> (@cmeta{identifier} @cmeta{rule}*)

@cmeta{rule} -> (@cmeta{sequence} @cmeta{semantic-clause})

@cmeta{sequence} -> (@cmeta{part}*)
           |  (@cmeta{part}* :error @cmeta{message})
           |  (@cmeta{part}* :exception)

@cmeta{part} -> (:not @cmeta{part}*)
       |  @cmeta{var} <- (quote @cmeta{terminal})
       |  @cmeta{var} <- @cmeta{identifier}
       |  @cmeta{var} <- :source-location
       |  (quote @cmeta{terminal})
       |  @cmeta{identifier}
@end example

@noindent
and it expands into a combinator:

@example
(make-memoize-combinator (lambda (state) ---))
@end example

@noindent
each non--terminal combinator is bound by a @func{letrec*} form to the
respective @meta{identifier}:

@example
(letrec* ((@cmeta{identifier} (make-memoize-combinator ---))
          ...)
  @cmeta{start})
@end example

@noindent
the last expression in the body of the generated @func{letrec*} is
@meta{start}, which can be any expression but must evaluate to a
combinator function.  The simplest @meta{start} is an @meta{identifier},
which causes the macro to return the combinator bound to it.

Since @func{begin} forms within @func{letrec*} forms are flattened
(spliced into the @meta{body}, @nauref{baselib bodies, Bodies}): By
making @meta{start} a @func{begin} form we can introduce bindings to
hand--written combinators which can call (and can be called by) the
non--terminal combinators.

Each @meta{sequence} expands into a combinator; the @meta{sequence}
combinators of a non--terminal combinator, are all alternatives for its
matching.

When a non--terminal combinator is applied to a @class{state} record, it
attempts to match the input tokens against the @meta{sequence}
combinators in its @meta{rule} elements.  The first @meta{rule} is tried
first, then the second and so on, stopping at the first match.  If
matching is successful, the @meta{semantic-clause} is evaluated to
produce a value returned as field of a @class{success} record; else an
@class{error} record is returned.

Each @meta{part} expands to a combinator which, if successful, invokes
the combinator generated by its subsequent @meta{part}; the first
@meta{part} combinator of a @meta{sequence} is invoked by the
@meta{sequence} combinator; the last @meta{part} combinator of a
@meta{sequence} must generate a @class{result} record by itself.

If a @meta{part} combinator, which is not the last in a @meta{sequence},
matches one or more tokens: It must call @func{next-state} to generate a
new @class{state} record and hand it to the next @meta{part} combinator.

If all the @meta{part} combinators in a @meta{sequence} match the
tokens, a @class{success} record is generated by the last one and
returned.  The @class{success} record is registered in the memoized
results of the @class{state} record that started a non--terminal match,
using @meta{identifier} as keyword.

If a @meta{sequence} combinator matches, but its last @meta{part} is
@samp{:error}, an @class{error} record is returned and registered in the
memoized results of the @class{state} record that started the
non--terminal match.

If a @meta{sequence} matches, but its last @meta{part} is
@samp{:exception}, a continuable exception is raised.

If a @meta{part} fails to match: An @class{error} record is generated
and returned.  The @class{error} record is registered in the memoized
results of the @class{state} record that started the non--terminal
mismatch.

The @meta{part} elements can be of the following forms.

@table @samp
@item (quote @cmeta{terminal})
Matches if the lookahead token has category @func{eq?} to
@meta{terminal}; the semantic value of the token is discarded.  Consume
one token.  This @meta{part} makes use of a combinator generated by
@func{make-terminal-combinator}.

@item @cmeta{var} <- (quote @cmeta{terminal})
Matches if the lookahead token has category @func{eq?} to
@meta{terminal}; bind the token's semantic value to @meta{var} and
continue parsing; the subsequent combinators are evaluated in the
augmented environment.  Consume one token.  This @meta{part} makes use
of a combinator generated by @func{make-terminal-combinator}.

@item @cmeta{identifier}
Apply the combinator bound to @meta{identifier} to the current state.
The applied combinator may consume any number of tokens.

@item @cmeta{var} <- @cmeta{identifier}
Apply the combinator bound to @meta{identifier} to the current state.
If successful, bind the resulting semantic value to @meta{var}; the
subsequent combinators are evaluated in the augmented environment.  The
applied combinator may consume any number of tokens.

@item (:not @cmeta{fail-part} ...)
Matches if the lookahead tokens do not match the @meta{fail-part}
elements.  This @meta{part} makes use of a combinator generated by
@func{make-unless-combinator}.

@item @cmeta{var} <- :source-location
Bind the @class{source-location} record in the lookahead token to
@cmeta{var}; the subsequent combinators are evaluated in the augmented
environement.  Consumes no tokens.  This can be used to annotate
abstract syntax trees with source location informations.

@item :error @cmeta{message}
Matches only as last @meta{part} of a @meta{sequence} and consumes no
tokens.  Return an @class{error} record using @cmeta{message} as value
for the @samp{message} field.

@item :exception
Matches only as last @meta{part} of a @meta{sequence} and consumes no
tokens.  The @meta{semantic-clause} of the @meta{rule} is evaluated and
it must return a condition object, which is handed to
@func{raise-continuable}.  If the exception handler returns, it must
return a @class{result} record.  @nauref{stdlib exceptions conditions,
Conditions}
@end table
@end deffn

@c page
@node packrat comb left
@subsection Left recursion problem


The @library{packrat} library implements no special handling to support
left recursive combinators; the implementation of @library{packrat} has
the purpose of keeping the code simple (it is not the only parser
library distributed with @value{PACKAGE}).

To understand the left recursion problem of the Packrat algorithm, let's
examine the following example:

@example
(make-grammar-combinator digits
  (digits  ((a <- digits b <- 'NUM)
            (+ a b))
           ((d <- 'NUM)
            d)))
@end example

@noindent
this grammar defines a non--terminal @samp{digits} whose first
right--hand side rule requires matching of @samp{digits} itself as first
@meta{part}; the combinator bound to @samp{digits} is invoked once when
attempting to match the non--terminal and again when attempting to match
the first rule; the two applications are on the same @class{state}
record, so the result is an infinite recursion.

The same happens with the following grammar, in which the recursion is
indirect:

@example
(make-grammar-combinator digits
  (digits       ((a <- X b <- 'NUM)
                 (+ a b))
                ((d <- 'NUM)
                 d))
  (X            ((d <- digits)
                d)))
@end example

@c page
@node csv
@chapter Comma--separated values (@acronym{CSV}) utilities


The @library{csv} library provides lexers and parsers to read data from
``comma--separated value'' (@csv{}) files.  This format is not well
defined, so the library provides both high level parsers and low level
lexers that can be customised to fit specific needs.

@menu
* csv lexer::                   Low level tokenisation.
* csv parser::                  High level parsing.
@end menu

@c page
@node csv lexer
@section Low level tokenisation


The @library{csv} library is built upon the @library{silex} library, and
it makes available directly the lexer tables.  @ref{silex, A lexical
analyser generator}


@deffn Constant csv-unquoted-data-table
The table used to tokenise data outside of strings.  This binding is
exported by the @library{csv unquoted-data-lexer} library.

This table can be rebuilt from the source @file{unquoted-data.l} in the
@file{src/libraries/csv} directory of the source distribution, with:

@example
(lex :input-file   "unquoted-data.l"
     :output-file  "unquoted-data-lexer.sls"
     :library-spec '(csv unquoted-data-lexer)
     :table-name   'csv-unquoted-data-table
     :counters     'all)
@end example
@end deffn


@deffn Constant csv-unquoted-data-table/comma
The table used to tokenise data outside of strings, using the comma
character as fields separator.  This binding is exported by the
@library{csv unquoted-data-comma-lexer} library.

This table can be rebuilt from the source @file{unquoted-data-comma.l}
in the @file{src/libraries/csv} directory of the source distribution,
with:

@example
(lex :input-file   "unquoted-data-comma.l"
     :output-file  "unquoted-data-comma-lexer.sls"
     :library-spec '(csv unquoted-data-comma-lexer)
     :table-name   'csv-unquoted-data-table/comma
     :counters     'all)
@end example
@end deffn


@deffn Constant csv-strings-table
The table used to tokenise strings.  This binding is exported by
the @library{csv strings-lexer} library.

This table can be rebuilt from the source @file{strings.l} in the
@file{src/libraries/csv} directory of the source distribution, with:

@example
(lex :input-file   "strings.l"
     :output-file  "strings-lexer.sls"
     :library-spec '(csv strings-lexer)
     :table-name   'csv-strings-table
     :counters     'all)
@end example
@end deffn

@menu
* csv lexer strings::           Tokenising strings.
* csv lexer unquoted-data::     Tokenising unquoted data.
* csv lexer full::              Full parsing.
@end menu

@c page
@node csv lexer strings
@subsection Tokenising strings


The @library{csv} library defines strings in a @csv{} file as sequences
of characters enclosed in double--quotes @samp{"}.  Inside a string a
double double--quote @samp{""} is interpreted as a single double--quote.

To tokenise a string means to convert a string into the sequence of
characters in it; this is done by a lexer using
@samp{csv-strings-table}.  This table is meant to be used after the
opening double--quote has been tokenised, and it will consume all the
characters up to, and including, the closing double--quote.

When the lexer finds the closing double--quote it returns @false{}, else
it returns the next character.  We can take advantage of this to
tokenise strings as follows:

@example
(import (rnrs)
  (only (keywords) define-keywords)
  (silex lexer)
  (csv strings-lexer))

(define-keywords :string :counters)

(define (tokenise string)
  (let* ((IS    (lexer-make-IS :string string :counters 'all))
         (lexer (lexer-make-lexer csv-strings-table IS)))
    (do ((token (lexer) (lexer))
         (ell   '()))
        ((not token)
         (reverse ell))
      (set! ell (cons token ell)))))

;;All the test strings must end with a \" to signal
;;the end-of-string to the strings lexer.

(tokenise "\"")
@result{} ()

(tokenise "abcd\"")
@result{} (#\a #\b #\c #\d)

; Quoted double-quote.
(tokenise "ab\"\"cd\"")
@result{} (#\a #\b #\" #\c #\d)

; Nested string.
(tokenise "ab \"\"ciao\"\" cd\"")
@result{} (#\a #\b #\space #\" #\c #\i #\a #\o #\" #\space #\c #\d)

; Stop reading at the ending double-quote.
(tokenise "ab\"cd")
@result{} (#\a #\b)
@end example

@noindent
notice that the input system has to be created with @samp{:counters
'all}.  If we want to rebuild the string, we can do it as follows:

@example
(import (rnrs)
  (only (keywords) define-keywords)
  (silex lexer)
  (csv strings-lexer))

(define-keywords :string)

(define (tokenise string)
  (let* ((IS    (lexer-make-IS :string string))
         (lexer (lexer-make-lexer csv-strings-table IS)))
    (let-values (((port the-string) (open-string-output-port)))
      (do ((token (lexer) (lexer)))
          ((not token)
           (the-string))
        (write-char token port)))))

;;All the test strings must end with a \" to signal
;;the end of string to the strings lexer.

(tokenise "\"")
@result{} ""

(tokenise "abcd\"")
@result{} "abcd"

; Quoted double-quote.
(tokenise "ab\"\"cd\"")
@result{} "ab\"cd"

; Nested string.
(tokenise "ab \"\"ciao\"\" cd\"")
@result{} "ab \"ciao\" cd"

; Stop reading at the ending double-quote.
(tokenise "ab\"cd")
@result{} "ab"
@end example

@c page
@node csv lexer unquoted-data
@subsection Tokenising unquoted data


The @library{csv} library defines unquoted data as everything that is
not inside a string.  The lexer built around
@samp{csv-unquoted-data-table} will return:

@itemize
@item
The symbol @samp{eol} to represent the end of a line.  Every sequence of
any number of @samp{#\newline} and @samp{#\return} characters, in any
order, is collapsed to a single end--of--line.

@item
The symbol @samp{string} to represent the start of a string.  It is
returned when the lexer finds a @samp{"} character.

@item
In any other case the next character from the input system.
@end itemize

The @samp{csv-unquoted-data-table/comma} works the same, with the
following difference in the return values:

@itemize
@item
The symbol @samp{field} when the token is a comma character.
@end itemize


We can take advantage of this to tokenise unquoted data as follows:

@example
(import (rnrs)
  (only (keywords) define-keywords)
  (silex lexer)
  (csv unquoted-data-lexer))

(define-keywords :string :counters)

(define (tokenise string)
  (let* ((IS    (lexer-make-IS :string string :counters 'all))
         (lexer (lexer-make-lexer csv-unquoted-data-table IS)))
    (do ((token (lexer) (lexer))
         (ell   '()))
        ((or (not token) (eq? token 'string))
         (reverse ell))
      (set! ell (cons token ell)))))

(tokenise "alpha, beta")
@result{} (#\a #\l #\p #\h #\a #\, #\space #\b #\e #\t #\a)

; End of line
(tokenise "alpha\nbeta")
@result{} (#\a #\l #\p #\h #\a eol #\b #\e #\t #\a)

; End of line
(tokenise "alpha\n\rbeta")
@result{} (#\a #\l #\p #\h #\a eol #\b #\e #\t #\a)

; End of line
(tokenise "alpha\n\r\n\rbeta")
@result{} (#\a #\l #\p #\h #\a eol #\b #\e #\t #\a)

; Read until the string opening.
(tokenise "alpha \"beta")
@result{} (#\a #\l #\p #\h #\a #\space)
@end example

@c page
@node csv lexer full
@subsection Full parsing


Here we see how the high level parsers are implemented.  The following
function makes use of both the string and unquoted--data tables to
convert a @csv{} file into a list of lists, with each sublist
representing a record.  The function @func{csv->list/comma} does no
check for the number of fields on each line.

@smallexample
(define-keywords :port :counters)

(define csv->list/comma
  (case-lambda
   ((port)
    (csv->list/comma port (lambda (field) field)))

   ((port swirl-field)
    (let* ((IS            (lexer-make-IS :port port
                                         :counters 'all))
           (string-lexer  (lexer-make-lexer
                            csv-strings-table IS))
           (data-lexer    (lexer-make-lexer
                            csv-unquoted-data-table/comma IS))
           (result        '())
           (record        '()))
      (let-values (((port field) (open-string-output-port)))

        (define (%add-token-to-field token)
          (write-char token port))

        (define (%add-string-to-field)
          (%add-token-to-field #\")
          (do ((token (string-lexer) (string-lexer)))
              ((not token)
               (%add-token-to-field #\"))
            (%add-token-to-field token)))

        (define (%add-field-to-record)
          (set! record (cons (swirl-field (field)) record)))

        (define (%add-record-to-result)
          (set! result (cons (reverse record) result))
          (set! record '()))

        (do ((token (data-lexer) (data-lexer)))
            ((not token)
             (%add-field-to-record)
             (reverse (cons (reverse record) result)))
          (case token

            ((eol)
             (%add-field-to-record)
             (%add-record-to-result))

            ((field)
             (%add-field-to-record))

            ((string)
             (%add-string-to-field))

            (else
             (%add-token-to-field token)))))))))
@end smallexample

Here some examples:

@example
(import (rnrs)
  (csv)
  (strings))

; Notice how spaces around commas are preserved.
(csv->list/comma
   (open-string-input-port "alpha, beta, delta
one, two, three"))
@result{} '(("alpha" " beta" " delta")
     ("one" " two" " three"))

; Trim the spaces.
(csv->list/comma
  (open-string-input-port "alpha, beta, delta
one, two, three")
  (lambda (field)
    (string-trim-both field #\space)))
@result{} '(("alpha" "beta" "delta")
     ("one" "two" "three"))
@end example

The following is a variant that allows to specify, via the
@var{separators} argument, custom characters as field separators.

@smallexample
(define-keywords :port :counters)

(define csv->list
  (case-lambda
   ((port separators)
    (csv->list port separators (lambda (field) field)))

   ((port separators swirl-field)
    (let* ((IS            (lexer-make-IS :port port
                                         :counters 'all))
           (string-lexer  (lexer-make-lexer
                            csv-strings-table IS))
           (data-lexer    (lexer-make-lexer
                            csv-unquoted-data-table/comma IS))
           (result        '())
           (record        '()))
      (let-values (((port field) (open-string-output-port)))

        (define (%add-token-to-field token)
          (write-char token port))

        (define (%add-string-to-field)
          (%add-token-to-field #\")
          (do ((token (string-lexer) (string-lexer)))
              ((not token)
               (%add-token-to-field #\"))
            (%add-token-to-field token)))

        (define (%add-field-to-record)
          (set! record (cons (swirl-field (field)) record)))

        (define (%add-record-to-result)
          (set! result (cons (reverse record) result))
          (set! record '()))

        (do ((token (data-lexer) (data-lexer)))
            ((not token)
             (%add-field-to-record)
             (reverse (cons (reverse record) result)))
          (cond

            ((eq? 'eol token)
             (%add-field-to-record)
             (%add-record-to-result))

            ((memv token separators)
             (%add-field-to-record))

            ((eq? 'string token)
             (%add-string-to-field))

            (else
             (%add-token-to-field token)))))))))
@end smallexample

@c page
@node csv parser
@section High level parsing


@defun csv->list @var{port} @var{separators}
@defunx csv->list @var{port} @var{separators} @var{swirl-field}
Read a @csv{} file from the textual input @var{port} and convert it into
a list of lists, with each nested list representing a record.

@var{separators} must be a list of characters and used as field
separators in a line.

@var{swirl-field} must be a procedure accepting a single string argument
and returning a string argument.  It is applied to each field string
before adding it to the output list.  This procedure is allowed to raise
an exception.
@end defun


@defun csv->list/comma @var{port}
@defunx csv->list/comma @var{port} @var{swirl-field}
Like @func{csv->list}, but use only the comma as field separator.
@end defun

@c page
@node email
@chapter Email processing


@menu
* email addresses::             Parsing email addresses.
@end menu

@c page
@node email addresses
@section Parsing email addresses


The @library{email addresses} library implements a lexer and parser for
email addresses.  The parser tries to be compliant to @rfc{} 2822
``Internet Message Format'' (@url{http://www.ietf.org/rfc/rfc2822.txt}).

This library would not exist without the work Peter Simons did for the
C++ library @samp{librfc822} (@url{http://cryp.to/librfc2822/}, @aurl{}
last verified Mon Aug 24, 2009).

This library is built on top of @library{classes} and
@library{generics}.

@menu
* email addresses components::  Parsed components.
* email addresses types::       Record types.
* email addresses lexer::       Splitting an address into tokens.
* email addresses parser::      Splitting an address into logical units.
@end menu

@c page
@node email addresses components
@subsection Parsed components


The following is an overview of an email address' components.

@table @strong
@item Comments
Comments are strings enclosed in parentheses and may be present at any
point in an address.

@item Domain
A list of strings separated by dots:

@example
alpha.beta.gamma
@result{} domain strings = alpha beta gamma
@end example

@item Domain literal
A dotted quad enclosed in square brackets:

@example
[101.102.103.104]
domain literal @result{} 101.102.103.104
@end example

@item Local part
A list of strings separated by dots:

@example
alpha.beta.gamma
@result{} domain strings = alpha beta gamma
@end example

@item Address specification

@example
marco@@localhost
@result{} local part = marco
@result{} domain     = localhost
@end example

@item Route

@example
@@alpha.it,@@beta.it:
@result{} first domain  = alpha.it
@result{} second domain = beta.it
@end example

@item Route address

@example
<@@alpha.it,@@beta.it:marco@@there.it>
@result{} route      = @@alpha.it,@@beta.it
@result{} local part = marco
@result{} domain     = there.it
@end example

@item Mailbox

@example
"Marco Maggi" <@@alpha.it,@@beta.it:marco@@there.it>
@result{} phrase (quoted literal) = "Marco Maggi"
@result{} route                   = @@alpha.it,@@beta.it
@result{} local part              = marco
@result{} domain                  = there.it

my address <marco@@there.it>
@result{} phrase (atoms)          = my address
@result{} route                   =
@result{} local part              = marco
@result{} domain                  = there.it
@end example

Lists of mailboxes are mailboxes separated by @code{,}:

@example
<marco@@there.it>, <marco@@localhost>, <root@@localhost>
@result{} first mailbox  = <marco@@there.it>
@result{} second mailbox = <marco@@localhost>
@result{} third mailbox  = <root@@localhost>
@end example

@item Group
List of mailboxes enclosed in @samp{: ... ;} with optional phrase:

@example
: marco@@localhost, <marco@@there.com> ;
@result{} phrase         =
@result{} first mailbox  = marco@@localhost
@result{} second mailbox = marco@@there.com

:marco@@localhost, "Marco Maggi" (a comment) <marco@@there.com> ;
@result{} phrase         =
@result{} first mailbox  = marco@@localhost
@result{} second mailbox = "Marco Maggi" <marco@@there.com>

mailing-list :marco@@localhost, ,,, ,, ,
   ,, "Marco Maggi" <marco@@there.com> ;
@result{} phrase         = mailing-list
@result{} first mailbox  = marco@@localhost
@result{} second mailbox = "Marco Maggi" <marco@@there.com>
@end example

@item Address
An address is a list of mailboxes and groups separated by @samp{,}.
@end table

@c page
@node email addresses types
@subsection Record types


All the record types defined by @library{email addresses} are meant to
be handled with the facilities of the @library{classes} library.
@nauref{classes, Record utilities}

@menu
* email addresses domain::              Domain.
* email addresses local-part::          Local part.
* email addresses addr-spec::           Address specification.
* email addresses route::               Route.
* email addresses mailbox::             Mailbox.
* email addresses group::               Group of mailboxes.
@end menu

@c page
@node email addresses domain
@subsubsection Domain


@deftp Class @aclass{domain}
Represent the domain portion of an address specification.
@end deftp


@defcv {Immutable Field} @aclass{domain} literal?
A boolean, true if the domain is composed of four numeric components.
@end defcv


@defcv {Immutable Field} @aclass{domain} subdomains
The list of strings representing the domain components.
@end defcv


@defun <domain>-literal? @var{dom}
@defunx <domain>-subdomains @var{dom}
Field accessors.
@end defun


@defun <domain>? @var{obj}
@defunx <domain>?/or-false @var{obj}
Return @true{} if @var{obj} is a record of type @class{domain}.  The
@samp{/or-false} variant also returns @true{} if @var{obj} is @false{}.
@end defun


@defun assert-<domain>? @var{obj}
@defunx assert-<domain>?/or-false @var{obj}
Raise an exception if @var{obj} is not a record of type @class{domain}
or the values in the fields are invalid.  The @samp{/or-false} variant
allows @var{obj} to be @false{}.
@end defun


@deffn Method object->string (@var{o} <domain>)
Return the string representation of @var{o}: The subdomain strings are
joined with a dot; if @var{o} represents a literal domain, the string is
enclosed in square parentheses.
@end deffn

@c page
@node email addresses local-part
@subsubsection Local part


@deftp Class @aclass{local-part}
Holds a list of local part strings.  The local part is a single string,
but for parsing reasons it is accumulated as a list of strings.
@end deftp


@defcv {Immutable Field} @aclass{local-part} subparts
A list of strings.
@end defcv


@defun <local-part>-subparts @var{lp}
Field accessor.
@end defun


@deffn {Generic Function} object->string (@var{o} <local-part>)
Return the string representation of @var{o}.
@end deffn

@c page
@node email addresses addr-spec
@subsubsection Address specification


@deftp Class @aclass{addr-spec}
Holds an address specification: a local part and a domain.
@end deftp


@defcv {Immutable Field} @aclass{addr-spec} local-part
Holds a @class{local-part} record.
@end defcv


@defcv {Immutable Field} @aclass{addr-spec} domain
Holds a @class{domain} record.
@end defcv


@defun <addr-spec>-local-part @var{as}
@defunx <addr-spec>-domain @var{as}
Field accessors.
@end defun


@deffn Method object->string (@var{o} <addr-spec>)
Return the string representation of @var{o}.
@end deffn

@c page
@node email addresses route
@subsubsection Route


@deftp Class @aclass{route}
Holds a list of domains to be used to route the message to the final
destination.
@end deftp


@defcv {Immutable Field} @aclass{route} domains
A list of @class{domain} records.
@end defcv


@deffn Method object->string (@var{o} <route>)
Return the string representation of @var{o}.
@end deffn

@c page
@node email addresses mailbox
@subsubsection Mailbox


@deftp Class @aclass{mailbox}
Hold a mailbox specification.
@end deftp


@defcv {Immutable Field} @aclass{mailbox} display-name
Holds the phrase string.
@end defcv


@defcv {Immutable Field} @aclass{mailbox} route
Holds @false{} or a @class{route} record.
@end defcv


@defcv {Immutable Field} @aclass{mailbox} addr-spec
Holds an @class{addr-spec} record.
@end defcv


@defun <mailbox>-display-name @var{mb}
@defunx <mailbox>-route @var{mb}
@defunx <mailbox>-addr-spec @var{mb}
Field accessors.
@end defun


@deffn {Generic Function} object->string (@var{o} <mailbox>)
Return the string representation of @var{o}.
@end deffn

@c page
@node email addresses group
@subsubsection Group of mailboxes


@deftp Class @aclass{group}
Holds a list of mailboxes and a phrase.
@end deftp


@defcv {Immutable Field} @aclass{group} display-name
Holds the phrase string.
@end defcv


@defcv {Immutable Field} @aclass{group} mailboxes
Holds a list of @class{mailbox} records.
@end defcv


@defun <group>-display-name @var{gr}
@defunx <group>-mailboxes @var{gr}
Field accessors.
@end defun


@deffn {Generic Function} object->string (@var{o} <group>)
Return the string representation of @var{o}.
@end deffn

@c page
@node email addresses lexer
@subsection Splitting an address into tokens


The lexer for the @library{email addresses} library is built upon the
@library{silex} lexer.  @ref{silex, A lexical analyser generator}


@defun make-address-lexer @var{IS}
Return an email address lexer closure drawing tokens from the input
system @var{IS}.  The input system must have been created using the
@library{silex} library.
@end defun


@deffn Parameter address-lexer-allows-comments
If set to true when @func{make-address-lexer} is invoked, the lexer
closure returns also comment tokens; else comment tokens are silently
discarded.
@end deffn


@defun address->tokens @var{IS}
Wrapper for @func{make-address-lexer} which reads all the tokens and
returns them as a list.
@end defun


The lexer closure is a thunk returning @class{lexical-token} records
with the following categories:

@table @samp
@item DOT
@itemx COMMA
@itemx COLON
@itemx SEMICOLON
@itemx AT
Represent the named character; the semantic value is the character
itself.

@item ANGLE-OPEN
@itemx ANGLE-CLOSE
Represent the @samp{#\<} and @samp{#\>} characters; the semantic value
is the character itself.

@item ATOM
The component of local parts and domains; the semantic value is the
string.  See @acronym{RFC} 2822 section ``3.2.4 Atom''.

@item DOMAIN-LITERAL-OPEN
The opening of a domain literal; the semantic value is a string
containing the single character @samp{[}.

@item DOMAIN-LITERAL-CLOSE
The closing of a domain literal; the semantic value is a string
containing the single character @samp{]}.

@item DOMAIN-LITERAL-INTEGER
A component of domain literal; the semantic value is an integer number
between @math{0} included and @math{256} excluded.

@item QUOTED-TEXT
A quoted text element; the semantic value is the string.
@end table

@c page
@node email addresses parser
@subsection Parsing tokens


The parser for the @library{email addresses} library is built upon the
@library{lalr} parser generator and makes use of the @library{lalr
lr-driver} driver.  @ref{lalr, A LALR(1) parser generator}


@defun make-address-parser
Return a new parser closure, to be used as explained in @ref{lalr
parser, Running the parser}.  If the parsing completes successfully, the
return value of the closure is a list of @class{mailbox} and or
@class{group} records.  @ref{email addresses types, Record types}
@end defun


Given the helper functions:

@example
(import (rnrs)
  (email addresses)
  (silex)
  (records))

(define (error-handler message token)
  (error #f message token))

(define (doit string)
  (let* ((IS      (lexer-make-IS :string string
                                 :counters 'all))
         (lexer   (make-address-lexer IS))
         (parser  (make-address-parser)))
    (parser lexer error-handler)))
@end example

@noindent
here is an example of parsing a list of mailboxes:

@example
(define result
  (doit "marco.maggi@@here.it, <marco.maggi@@there.it>"))

(length result)
@result{} 2

(<mailbox>? (car result))
@result{} #t

(<mailbox>? (cadr result))
@result{} #t

(object->string (car result))
@result{} "<marco.maggi@@here.it>"

(object->string (cadr result))
@result{} "<marco.maggi@@there.it>"
@end example

@noindent
and here an example of parsing a group:

@example
(define result
  (doit "the group: marco.maggi@@here.it, <marco.maggi@@there.it>, \r
Marco Maggi <mrc.mgg@@here.it>;"))

(length result)
@result{} 1

(<group>? (car result))
@result{} #t

(let* ((group       (car result))
       (mailboxes   (<group>-mailboxes group)))

  (length mailboxes)
  @result{} 3

  (<group>-display-name group)
  @result{} "the group"

  (object->string (car mailboxes))
  @result{} "<marco.maggi@@here.it>"

  (object->string (cadr mailboxes))
  @result{} "<marco.maggi@@there.it>"

  (object->string (<mailbox>-addr-spec (caddr mailboxes))))
  @result{} "mrc.mgg@@here.it"
@end example

@c page
@node infix
@chapter Infix notation utilities


The @library{infix} library provides utilities to convert infix notation
expressions to prefix notation expressions; the library is built upon
@library{nausicaa}, @library{silex lexer} and @library{lalr lr-driver}.

@menu
* infix strings::               Converting strings.
* infix sexps::                 Converting S--expressions.
* infix syntax::                Infix notation expressions.
@end menu

@c page
@node infix strings
@section Converting strings


@defun infix-string->sexp @var{expr-string}
Return the prefix S--expression corresponding to @var{expr-string}.  The
S--expression can be used directly for some symbolic interpretation or
evaluated with @func{eval}.  @nauref{stdlib eval, Evaluation}

Examples:

@example
(infix-string->sexpr "1*2-3")   @result{} (- (* 1 2) 3)
(infix-string->sexpr "1//3")    @result{} (div 1 3)
(infix-string->sexpr "1%3")     @result{} (mod 1 3)
(infix-string->sexpr "1^3")     @result{} (expt 1 3)

(infix-string->sexpr "cos(sin(1.1)+4)")
@result{} (cos (+ (sin 1.1) 4))

(infix-string->sexpr "fun(1, 2, 3, 4)")
@result{} (fun 1 2 3 4)

(infix-string->sexpr "cos(a) * (tan(b) / c)")
@result{} (* (cos a) (/ (tan b) c))

(infix-string->sexp "a * (b / a ? b : c)")
@result{} (* a (if (/ b a) b c))
@end example
@end defun

Some interpretation rules:

@itemize
@item
Blank characters are ignored.

@item
Symbols in @var{expr-string} must match the following @library{silex}
regular expression:

@example
initial         [a-zA-Z_]
subsequent      @{initial@}|[0-9\.@@!$&:<=>\?~\-]
symbol          @{initial@}@{subsequent@}*
@end example

@noindent
@ref{silex syntax, Syntax of the specification}.

@item
The following infix operators are supported, in order of increasing
precedence from left to right:

@example
+ - * / // % ^ < > <= >= =
@end example

@noindent
remember that the Scheme comparison operators are meant to return a
boolean value, rather than a number object.  @samp{//} stands for
@func{div}, @samp{%} stands for @func{mod}, @samp{^} stands for
@func{expt}.

@item
The if--then--else statement involves the special symbols @code{?} and
@code{:} which cannot be variable symbols; this statement has the least
precedence.

@item
Every symbol which is not an operator is interpreted as variable
reference or function call.  If the first non--blank character following
the symbol is an open parenthesis, it is interpreted as function call.
@end itemize

@c page
@node infix sexps
@section Converting S--expressions


@defun infix->prefix @var{sexp-atom} ...
Convert the infix S--expression composed of the sequence of
@var{sexp-atom} arguments into a prefix S--expression.  The
S--expression can be used directly for some symbolic interpretation or
evaluated with @func{eval}.  @nauref{stdlib eval, Evaluation}

The simplest way to use the function is to apply it to a single
S--expression:

@example
(infix->prefix '(1 + 2 + 3))    @result{} '(+ (+ 1 2) 3)
(infix->prefix '(1 + 2 - 3))    @result{} '(- (+ 1 2) 3)
(infix->prefix '(1 + (2 + 3)))  @result{} '(+ 1 (+ 2 3))
(infix->prefix '(1 + (2 - 3)))  @result{} '(+ 1 (- 2 3))

(infix->prefix '(cos (sin (1.1))))
@result{} (cos (sin 1.1))

(infix->prefix '(cos (sin (1.1) + 4)))
@result{} (cos (+ (sin 1.1) 4))

(infix->prefix '(fun (1.1 2)))
@result{} (fun 1.1 2)

(infix->prefix '(fun (1 2 3 4)))
@result{} (fun 1 2 3 4)

(infix->prefix '(a * (b / a ? b : c)))
@result{} (* a (if (/ b a) b c))
@end example

@noindent
while applying it to multiple arguments looks like:

@example
(infix->prefix 1 '+ 2 '+ 3)     @result{} '(+ (+ 1 2) 3)
@end example

Some interpretation rules:

@itemize
@item
The following infix operators are supported, in order of increasing
precedence from left to right:

@example
+ - * / // % ^ < > <= >= =
@end example

@noindent
remember that the Scheme comparison operators are meant to return a
boolean value, rather than a number object.  @samp{//} stands for
@func{div}, @samp{%} stands for @func{mod}, @samp{^} stands for
@func{expt}.

@item
The if--then--else statement involves the special symbols @code{?} and
@code{:} which cannot be variable symbols; this statement has the least
precedence.

@item
The elements of the S--expression can be numbers, symbols, procedures,
all ``the other'' values.

@item
Symbols which are not operators are interpreted as variable references
or function calls.  If a symbol is followed by a list, it is a function
call.

@item
Function calls with one or more arguments require the arguments to be
grouped in a list.  There is no special separator in the list of
arguments.

@item
Procedures are treated like non--operator symbols.

@item
Numbers and all ``the other'' values are just put there.
@end itemize
@end defun

@c page
@node infix syntax
@section Infix notation expressions


The following bindings are exported by the @library{infix syntax}
library and reexported by the @library{infix} library.


@deffn Syntax infix @ameta{atom} ...
Expand to a prefix expression to be evaluated at runtime, in the lexical
context of the macro use; as a special case @code{(infix)} is equivalent
to @code{(values)}.  The syntax allows us to evaluate forms like:

@example
(let ((a 1) (b 2) (c 3))

  (infix cos (a) * tan (b) / c)
  @expansion{} (/ (* (cos a) (tan b)) c)

  (infix (cos (a) * tan (b) / c))
  @expansion{} (/ (* (cos a) (tan b)) c)

  (infix a ? b : c)
  @expansion{} (if a b c)

  #f)
@end example

Some interpretation rules:

@itemize
@item
The following infix operators are supported, in order of increasing
precedence from left to right:

@example
+ - * / div // div0 mod mod0 % expt ^ < > <= >= =
@end example

@noindent
remember that the Scheme comparison operators are meant to return a
boolean value, rather than a number object.  @samp{//} is an alias for
@func{div}, @samp{%} is an alias for @func{mod}, @samp{^} is an alias
for @func{expt}.  The recognised operators are bindings from both the
@library{rnrs} and @library{nausicaa} libraries; @samp{//}, @samp{%} and
@samp{^} should be free identifiers.

@item
The if--then--else statement involves the special symbols @code{?} and
@code{:} which should be free identifiers.  This statement has the least
precedence of all.

@item
Any Scheme value can be element of the S--expression.

@item
Symbols which are not operators are interpreted as variable references;
if a symbol is followed by a list, it is a function call.

@item
Function calls with one or more arguments require the arguments to be
grouped in a list; there is no special separator in the list of
arguments.

@example
(define (fun a b c)
  (+ a b c))

(infix fun (1 2 3)) @expansion{} (fun 1 2 3)

(infix fun(1 2 3))  @expansion{} (fun 1 2 3)
@end example

Notice that grouping the function arguments in a list is a requirement
of the infix expressions grammar.

@item
Numbers and all ``the other'' values are just put there as operands.

@item
As a special exception: the binding @func{begin} from @library{rnrs} is
recognised in the input form and allows us to nest prefix--notation
expressions.

@example
(infix (begin (+ 1 2)))
@result{} 3

(infix (begin
         (let ((a 3))
           (/ a 4))))
@result{} 3/4

(let ((a 3))
  (infix (begin (/ a 4))))
@result{} 3/4

(let ((a 1) (b 2) (c 3))
  (infix (1 + a ? (begin
                    (+ 2 b))
                : 3 + c - 4))
  @expansion{} (if (+ 1 a)
          (begin (+ 2 b))
        (- (+ 3 c) 4))
  #f)
@end example
@end itemize
@end deffn

@c page
@node getopts
@chapter Parsing command line arguments


The @library{getopts} library implements basic parsing of Unix--style
command line arguments.  It is meant to be used as low--level module in
an infrastructure for command line interfaces (@acronym{CLI}).  The
library is built on top of @library{classes}.

@menu
* getopts intro::               Introduction.
* getopts records::             Record types.
* getopts config::              Parser configuration.
* getopts parser::              Parsing arguments.
* getopts conditions::          Exceptions and condition objects.
@end menu

@c page
@node getopts intro
@section Introduction


Command line arguments are available through the @func{command-line}
function from the @library{rnrs programs} library.  For the purposes of
this documentation, command line arguments are divided into three
categories:

@table @asis
@item Option without value
A string selecting a configuration option that can be turned on or off.
It can be a single character (brief option) or a full--word (long
option).

@item Option with value
A string selecting a value for a configuration option; an option's value
is a string of any length, including the empty string.

@item Non--option
A value to be passed to the program.
@end table

Let's assume that:

@itemize
@item
@option{-v}, @option{-i} and @option{-h} are brief options that do not
require a value.

@item
@option{-f}, @option{-o} and @option{-I} are brief options that do
require a value.

@item
@option{--verbose}, @option{--interactive} and @option{--help} are long
options that do not require a value.

@item
@option{--file}, @option{--output} and @option{--include} are long
options that do require a value.
@end itemize

@noindent
the following command line chunks are so interpreted:

@table @code
@item -vh -o green -i -Iwhite -f red
The @option{-v}, @option{-h} and @option{-i} options without value; the
@option{-o} option with value @samp{green}; the @option{-I} option with
value @samp{white}; the @option{-f} option with value @samp{red}.

@item --verbose --help --output=green --interactive
@itemx --include white --file=red
The @option{--verbose}, @option{--help} and @option{--interactive}
options without value; the @option{--output} option with value
@samp{green}; the @option{--include} option with value @samp{white}; the
@option{--file} option with value @samp{red}.
@end table

The argument @code{--} is recognised as ``end of options'' marker: All
the arguments following it are interpreted as non--options, even if
their string starts with a dash or double dash.

Chains of brief options are allowed: The options @option{-v},
@option{-i} and @option{-h} can be selected with the single argument
@code{-vih}.  Notice, though, that only options with no value can be
chained; an option with value can appear only as last in the train, with
no value attached.  For example:

@example
-vihI white
@end example

@noindent
is interpreted as the options @option{-v}, @option{-i} and @option{-h}
with no value followed by the option @option{-I} with value
@samp{white}; the following:

@example
-vihIwhite              ;forbidden
@end example

@noindent
could be made possible but, being unreadable, it is forbidden.

Notice that a single dash, @samp{-}, is a valid non--option argument.

@c page
@node getopts records
@section Record types


@deftp Class @aclass{option}
Type of records representing command line options.
@end deftp


@defcv {Immutable Field} @aclass{option} brief
A Scheme character representing a brief option selector; to specify an
option with not brief selector, we can set this field to @false{}.
@end defcv


@defcv {Immutable Field} @aclass{option} long
A Scheme string representing a long option selector, without the
double--dash prefix; to specify an option with not long selector, we can
set this field to @false{}.
@end defcv


@defcv {Immutable Field} @aclass{option} with-arg?
Boolean, true if this option requires an argument.
@end defcv


@defcv {Immutable Field} @aclass{option} description
Scheme string describing this option, to be used in help screens.
@end defcv


@defcv {Immutable Field} @aclass{option} action
Semantic action, a closure to be invoked when this option is found.

@itemize
@item
If the field @code{with-arg?} is set to @false{}, the closure is applied
to a single value: The @class{option} record representing the option.

@item
If the field @code{with-arg?} is set to @true{}, the closure is applied
to two values: the @class{option} record representing the option and the
Scheme string representing the option's value.
@end itemize
@end defcv


@defun make-<option> @var{brief} @var{long} @var{with-arg?} @var{description} @var{action}
Build and return a new @class{option} record.
@end defun


@defun <option>? @var{obj}
Return true if @var{obj} is a record of type @class{option}.
@end defun


@defun <option>-brief @var{record}
@defunx <option>-long @var{record}
@defunx <option>-with-arg? @var{record}
@defunx <option>-description @var{record}
@defunx <option>-action @var{record}
Accessors for the fields of an @class{option} record.
@end defun


@deffn Syntax define-option @ameta{name} @ameta{clause} ...
@deffnx {Auxiliary Syntax} brief @ameta{char}
@deffnx {Auxiliary Syntax} long @ameta{string}
@deffnx {Auxiliary Syntax} with-arg? @ameta{bool}
@deffnx {Auxiliary Syntax} description @ameta{string}
@deffnx {Auxiliary Syntax} action @ameta{function}
Build a new @class{option} record and bind it to @ameta{name}, which
must be a Scheme symbol.  All the @ameta{clause} arguments must be
subforms with an auxiliary syntactic keyword as first element.  Example:

@example
(define-option interactive
  (brief        #\i)
  (long         "interactive")
  (with-arg?    #f)
  (description  "ask the user first")
  (action       (lambda (option)
                  ---)))
@end example
@end deffn

@c page
@node getopts config
@section Parser configuration


@deftp Enumeration getopts-configuration
Enumeration to be used to configure the @func{getopts} parser.  It
contains the following symbols:

@table @code
@item delayed
If given, action closures invocations are returned in a list rather that
immediately evaluated; this allows @func{getopts} to parse the whole
command line without changing the state of the program.

The returned list has a thunk for each semantic action, in the same
order in which the corresponding arguments appear on the command line.
We can evaluate the thunks with:

@example
(let ((thunks (getopts ---)))
  (for-each (lambda (T) (T)) thunks))
@end example

@item ignore-multiple-double-dashes
The first double--dash argument, @samp{--}, always marks the end of
options.  If this option is given, multiple @samp{--} after the first
are all ignored; else they are interpreted as non--option arguments.
@end table
@end deftp


@deffn Syntax getopts-options @var{symbol} ...
Expands into an enumerated set of symbols to be used to configure the
operations of the @func{getopts} parser.
@end deffn

@c page
@node getopts parser
@section Parsing arguments


@defun getopts @var{command-line} @var{options} @var{argument-action}
@defunx getopts @var{command-line} @var{options} @var{argument-action} @var{config-options}
Parse the Scheme strings in the list @var{command-line} as command line
arguments, according to the options described by the list @var{options}
of @class{option} records.  If the configuration option @code{delayed} is
not used, the return value is @false{}.

@var{argument-action} must be a Scheme function accepting a single
argument: A Scheme string representing a command line non--option.

The optional @var{config-options} must be an enumerated set of values
from the @code{getopts-configuration} enumeration.
@end defun


Meaningless usage example:

@example
(import (rnrs)
  (getopts))

(define result #f)

(let-syntax
    ((set-cons! (syntax-rules ()
                  ((_ ?name ?form)
                   (set! ?name (cons ?form ?name))))))

  (define (register-with opt val)
    (set-cons! result (list (<option>-long opt) val)))

  (define (register-without opt)
    (set-cons! result (list (<option>-long opt))))

  (define (register-non-option arg)
    (set-cons! result arg)))

(define-option interactive
  (brief #\i)
  (long "interactive")
  (with-arg? #f)
  (description "ask the user first")
  (action register-without))

(define-option force
  (brief #\f)
  (long "force")
  (with-arg? #f)
  (description "hurt me plenty")
  (action register-without))

(define-option help
  (brief #\h)
  (long "help")
  (with-arg? #f)
  (description "print help screen")
  (action register-without))

(define-option file
  (brief #\F)
  (long "file")
  (with-arg? #t)
  (description "input file")
  (action register-with))

(define-option archive
  (brief #\A)
  (long "archive")
  (with-arg? #t)
  (description "output archive")
  (action register-with))

(getopts (command-line)
         (list interactive force help file archive)
         register-non-option
         (getopts-options ignore-multiple-double-dashes))
@end example

@c page
@node getopts conditions
@section Exceptions and condition objects


When @func{getopts} detects an error in the input command line
arguments, it raises a continuable exception; returning from the
exception is possible and makes @func{getopts} go on parsing with the
next argument.  It is not always advisable to continue parsing after an
error has been signaled.

The raised exception values are compound condition of the types
described below.

@c ------------------------------------------------------------

@subsubheading Base condition object


@deftp {Condition Type} &getopts
Base type for all the condition objects thrown by @func{getopts}; it is
derived from @condition{error}.  It has no fields.
@end deftp


@defun make-getopts-condition
@defunx getopts-condition? @var{obj}
Constructor and predicate for the @condition{getopts} condition object.
@end defun

@c ------------------------------------------------------------

@subsubheading Option data object


@deftp {Condition Type} &option
Data condition type used to hold records of type @class{option}
describing an option involved in an error; it is derived from
@condition{condition}.
@end deftp


@defun make-option-condition @var{option-record}
@defunx option-condition? @var{obj}
Constructor and predicate for the @condition{option} condition object.
@end defun


@defun condition-option @var{option-condition}
Accessor for the @code{option} field of a @condition{option} condition
object.
@end defun

@c ------------------------------------------------------------

@subsubheading Argument data object


@deftp {Condition Type} &argument
Data condition type used to hold Scheme strings representing command
line arguments involved in an error; it is derived from
@condition{condition}.
@end deftp


@defun make-argument-condition @var{argument-string}
@defunx argument-condition? @var{obj}
Constructor and predicate for the @condition{argument} condition object.
@end defun


@defun condition-argument @var{argument-condition}
Accessor for the @code{argument} field of a @condition{argument} condition
object.
@end defun

@c ------------------------------------------------------------

@subsubheading Option selector data object


@deftp {Condition Type} &brief/long
Data condition type used to hold Scheme strings or characters
representing option selectors involved in an error; it is derived from
@condition{condition}.
@end deftp


@defun make-brief/long-condition @var{brief/long-string}
@defunx brief/long-condition? @var{obj}
Constructor and predicate for the @condition{brief/long} condition object.
@end defun


@defun condition-brief/long @var{brief/long-condition}
Accessor for the field of a @condition{brief/long} condition object.
@end defun

@c ------------------------------------------------------------

@subsubheading Unknown option error


@deftp {Condition Type} &unknown-option
Condition type used to signal an ``unknown option'' error; it is derived
from @condition{getopts}.  It has no fields.
@end deftp


@defun make-unknown-option-condition
@defunx unknown-option-condition? @var{obj}
Constructor and predicate for @condition{unknown-option} condition objects.
@end defun


@defun raise-unknown-option @var{who} @var{brief/long} @var{argument} @var{message}
Raise a continuable exception describing an ``unknown option'' error;
the raised object is a compound condition with components of the
following types: @condition{who}, @condition{brief/long}, @condition{argument},
@condition{message}.
@end defun

@c ------------------------------------------------------------

@subsubheading Option requires value error


@deftp {Condition Type} &option-requires-value
Condition type used to signal an ``option requires value'' error; it is
derived from @condition{getopts}.  It has no fields.
@end deftp


@defun make-option-requires-value-condition
@defunx option-requires-value-condition? @var{obj}
Constructor and predicate for @condition{option-requires-value} condition
objects.
@end defun


@defun raise-option-requires-value @var{who} @var{option} @var{argument} @var{message}
Raise a continuable exception describing an ``option requires value''
error; the raised object is a compound condition with components of the
following types: @condition{who}, @condition{option}, @condition{argument},
@condition{message}.
@end defun

@c ------------------------------------------------------------

@subsubheading Option requires no value error


@deftp {Condition Type} &option-requires-no-value
Condition type used to signal an ``option requires no value'' error; it
is derived from @condition{getopts}.  It has no fields.
@end deftp


@defun make-option-requires-no-value-condition
@defunx option-requires-no-value-condition? @var{obj}
Constructor and predicate for @condition{option-requires-no-value} condition
objects.
@end defun


@defun raise-option-requires-no-value @var{who} @var{option} @var{argument} @var{message}
Raise a continuable exception describing an ``option requires no value''
error; the raised object is a compound condition with components of the
following types: @condition{who}, @condition{option}, @condition{argument},
@condition{message}.
@end defun

@c ------------------------------------------------------------

@subsubheading Invalid option error


@deftp {Condition Type} &invalid-option
Condition type used to signal an ``invalid option'' error; it is derived
from @condition{getopts}.  It has no fields.
@end deftp


@defun make-invalid-option-condition
@defunx invalid-option-condition? @var{obj}
Constructor and predicate for @condition{invalid-option} condition objects.
@end defun


@defun raise-invalid-option @var{who} @var{option} @var{argument} @var{message}
Raise a continuable exception describing an ``invalid option'' error;
the raised object is a compound condition with components of the
following types: @condition{who}, @condition{option},
@condition{argument}, @condition{message}.
@end defun

@c page
@node armor
@chapter @ascii{} armor encoding/decoding


The encoders and decoders documented in this chapter convert a stream of
bytes into another stream of bytes which can be interpreted as @ascii{}
characters, according to a selection of encoding alphabets.  Both the
encoders and the decoders are available.

None of the encoders and decoders will process line--oriented input or
output; to split a stream of @ascii{} characters into lines, we have to
apply a specific filter; to process a sequence of lines we have to
remove the newlines first.

All the libraries are built on top of the @library{classes} library.

@menu
* armor conditions::            Condition objects.
* armor base16::                Base 16 encoder/decoder.
* armor base32::                Base 32 encoder/decoder.
* armor base64::                Base 64 encoder/decoder.
* armor base91::                Base 91 encoder/decoder.
* armor ascii85::               @ascii{} 85 encoder/decoder.
* armor qprint::                Quoted--printable encoder/decoder.
* armor newlines::              Newline insertion/removal.
* armor examples::              Examples of encoding and decoding.
@end menu

@c page
@node armor conditions
@section Condition objects


All the functions in the @ascii{} armor libraries raise exceptions when
an error occurs; all the exception types are described here.  The
bindings described in this section are exported by the @library{armor
conditions} library.

@menu
* armor conditions error::      Base error condition.
* armor conditions byte::       Invalid input byte error
                                condition.
* armor conditions length::     Invalid input length error
                                condition.
* armor conditions padding::    Invalid padded block error
                                condition.
@end menu

@c page
@node armor conditions error
@subsection Base error condition


@deftp {Condition Type} &armor-error
Base type for all the @ascii{} armor errors; it is derived from
@condition{error}.  It has no fields.
@end deftp


@defun make-armor-error-condition
@defunx armor-error-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{armor-error}.
@end defun

@c page
@node armor conditions byte
@subsection Invalid input byte error condition


@deftp {Condition Type} &armor-invalid-input-byte
Condition object used to tag ``invalid input byte'' @ascii{} armor
errors; it is derived from @condition{error}.  It has no fields.
@end deftp


@defun make-armor-invalid-input-byte-condition
@defunx armor-invalid-input-byte-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{armor-invalid-input-byte}.
@end defun

@c page
@node armor conditions length
@subsection Invalid input length error condition


@deftp {Condition Type} &armor-invalid-input-length
Condition object used to tag ``invalid input length'' @ascii{} armor
errors; it is derived from @condition{error}.  It has no fields.
@end deftp


@defun make-armor-invalid-input-length-condition
@defunx armor-invalid-input-length-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{armor-invalid-input-length}.
@end defun

@c page
@node armor conditions padding
@subsection Invalid padded block error condition


@deftp {Condition Type} &armor-invalid-padding
Condition object used to tag ``invalid padded block @ascii{} armor
errors; it is derived from @condition{error}.  It has no fields.

This condition indicates that the number of padding characters in an
encoded padded input block is invalid.
@end deftp


@defun make-armor-invalid-padding-condition
@defunx armor-invalid-padding-condition? @var{obj}
Constructor and predicate for condition objects of type
@condition{armor-invalid-padding}.
@end defun


@c page
@node armor base16
@section Base 16 encoder/decoder


The bindings documented in this section are exported by the
@library{armor base16} library.  Base16 encoding produces @math{16} bits
of output every @math{8} bits of input, @math{2} bytes of @ascii{}
characters every byte of binary data.

@menu
* armor base16 intro::          Introduction to base16 encoding.
* armor base16 encode::         Encoding byte streams with base16.
* armor base16 decode::         Decoding byte streams with base16.
* armor base16 utils::          Utilities for base16 encoders and
                                decoders.
@end menu

@c page
@node armor base16 intro
@subsection Introduction to base16 encoding


The following is the alphabet for upper case encoding:

@example
0 1 2   3 4 5   6 7 8   9    ;;  0 -  9
A B C   D E F                ;; 10 - 15
@end example

@noindent
and the following is the alphabet for lower case encoding:

@example
0 1 2   3 4 5   6 7 8   9    ;;  0 -  9
a b c   d e f                ;; 10 - 15
@end example

Binary input is consumed in single--byte blocks; @ascii{} output is
produced in @math{2}-bytes blocks.

@c page
@node armor base16 encode
@subsection Encoding byte streams with base16


@deftp Class @aclass{base16-encode-ctx}
Context descriptor for base16 encoding.  Nothing in this record depends
on the input or output data: records of this type can be reused for
different streams, both in sequence and in parallel.
@end deftp


@defcv {Immutable Field} @aclass{base16-encode-ctx} encoding-case
A Scheme symbol among: @code{lower}, @code{upper}.  Select the case of
the alphabetic characters in the encoded output data.
@end defcv


@defcv {Immutable Field} @aclass{base16-encode-ctx} table
A Scheme vector of exact integers representing the selected encoding's
alphabet.
@end defcv


@defun make-<base16-encode-ctx> @var{encoding-case}
Build and return a new record of type @class{base16-encode-ctx}.

@var{encoding-case} must be a Scheme symbol among: @code{upper},
@code{lower}; it selects the case of the encoding table.
@end defun


@defun <base16-encode-ctx>? @var{obj}
Return true if @var{obj} is a record of type @class{base16-encode-ctx}.
@end defun


@defun <base16-encode-ctx>-encoding-case @var{ctx}
@defunx <base16-encode-ctx>-table @var{ctx}
Field accessors for records of type @class{base16-encode-ctx}.
@end defun


@defun base16-encode-update-length @var{number-of-bytes}
Return the minimum number of bytes required in the output bytevector
when @func{base16-encode-update!}  is applied to @var{number-of-bytes}
of binary input data.  Notice that that function will consume input in
single--byte blocks and produce output in @math{2}-bytes blocks only, so
the return value is always zero or an exact multiple of @math{2}.
@end defun


@defun base16-encode-final-length @var{number-of-bytes}
Return the minimum number of bytes required in the output bytevector
when @func{base16-encode-final!} is applied to @var{number-of-bytes}
bytes of binary input data.
@end defun


@defun base16-encode-length @var{number-of-bytes}
Return the minimum number of bytes required in the output bytevector
when @func{base16-encode-final!}  is applied to @var{number-of-bytes} of
binary input data.  This is also the number required when both
@func{base16-encode-update!}  and @func{base16-encode-final!} are used.
@end defun


@defun base16-encode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Encode binary data from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
@ascii{} characters in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); encoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base16-encode-ctx}.

This function is meant to encode bytes from the input stream when we
know that more input bytes will be available in the future.

Return two values:

@enumerate
@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

Binary data bytes are read from @var{src-bv} in single--byte blocks;
@ascii{} characters are written to @var{dst-bv} in chunks of @math{2}
bytes.  If not enough room exists in @var{dst-bv} to store a block,
available input data is not consumed.
@end defun


@defun base16-encode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Encode binary data from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
@ascii{} characters in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); encoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base16-encode-ctx}.

This function is meant to encode the last bytes from the input stream
and produce the last bytes to the output stream.

Return three values:

@enumerate
@item
A boolean: true if success, false if the output bytevector was filled
before flushing all the bytes.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

Binary data bytes are read from @var{src-bv} in single--byte blocks;
@ascii{} characters are written to @var{dst-bv} in chunks of @math{2}
bytes.  If not enough room exists in @var{dst-bv} to store a block,
available input data is not consumed.
@end defun

@c page
@node armor base16 decode
@subsection Decoding byte streams with base16


@deftp Class @aclass{base16-decode-ctx}
Context descriptor for base16 decoding.  Nothing in this record depends
on the input or output data: records of this type can be reused for
different streams, both in sequence and in parallel.
@end deftp


@defcv {Immutable Field} @aclass{base16-decode-ctx} encoding-case
A Scheme symbol among: @code{lower}, @code{mixed}, @code{upper}.  Select
the case of the alphabetic characters in the encoded input data.
@end defcv


@defcv {Immutable Field} @aclass{base16-decode-ctx} table
A Scheme vector of exact integers representing the selected decoding's
table.
@end defcv


@defun make-<base16-decode-ctx> @var{encoding-case}
Build and return a new record of type @class{base16-decode-ctx}.

@var{encoding-case} must be a Scheme symbol selecting the expected case
of the input string: @code{lower}, @code{upper}, @code{mixed}.
@end defun


@defun <base16-decode-ctx>? @var{obj}
Return true if @var{obj} is a record of type @class{base16-decode-ctx}.
@end defun


@defun <base16-decode-ctx>-encoding-case @var{ctx}
@defunx <base16-decode-ctx>-table @var{ctx}
Field accessors for records of type @class{base16-decode-ctx}.
@end defun


@defun base16-decode-update-length @var{number-of-chars}
Return the minimum number of bytes required in the output bytevector
when @func{base16-decode-update!}  is applied to @var{number-of-chars}
@ascii{} characters of input.  Notice that the function will consume
input in @math{2}-bytes blocks only and produce output in single--byte
blocks.
@end defun


@defun base16-decode-final-length @var{number-of-chars}
@defunx base16-decode-final-length @var{number-of-chars} @var{padding?}
Return the minimum number of bytes required in the output bytevector
when @func{base16-decode-final!} is applied to @var{number-of-chars}
@ascii{} characters of input.  @var{number-of-chars} must be a multiple
of @math{2}, else the return value is @false{}.
@end defun


@defun base16-decode-length @var{number-of-chars}
@defunx base16-decode-length @var{number-of-chars} @var{padding?}
Return the minimum number of bytes required in the output bytevector
when @func{base16-decode-final!}  is applied to @var{number-of-chars}
@ascii{} characters of input.  This is also the number required when
both @func{base16-decode-update!}  and @func{base16-decode-final!} are
used.  @var{number-of-chars} must be a multiple of @math{2}, else the
return value is @false{}.
@end defun


@defvr Constant base16-decode-block-length
The length of the input block: @math{2}.
@end defvr


@defun base16-decode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Decode @ascii{} characters from the bytevector @var{src-bv} starting at
index @var{src-start} (included) up to index @var{src-past} (excluded);
store binary data bytes in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); decoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base16-decode-ctx}.

Return three values:

@enumerate
@item
A boolean always false.  This value exists to make this @api{} equal to
the one of base64.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is filled to the end, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the
characters from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

@ascii{} characters are read from @var{src-bv} in chunks of @math{2}
bytes; binary data bytes are written to @var{dst-bv} in single-byte
blocks.  If not enough room exists in @var{dst-bv} to store a block,
available input data is not consumed.
@end defun


@defun base16-decode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Decode @ascii{} characters from the bytevector @var{src-bv} starting at
index @var{src-start} (included) up to index @var{src-past} (excluded);
store binary data bytes in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); decoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base16-decode-ctx}.

Return three values:

@enumerate
@item
A boolean: true if success, false if the output bytevector was filled
before flushing all the bytes.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is filled to the end, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

@ascii{} characters are read from @var{src-bv} in chunks of @math{2}
bytes; binary data bytes are written to @var{dst-bv} in single--byte
blocks.  If not enough room exists in @var{dst-bv} to store a block,
available input data is not consumed.
@end defun

@c page
@node armor base16 utils
@subsection Utilities for base16 encoders and decoders


@defun armored-byte-of-base16/upper-case? @var{byte-integer}
@defunx armored-byte-of-base16/lower-case? @var{byte-integer}
@defunx armored-byte-of-base16/mixed-case? @var{byte-integer}
Return true if @var{byte-integer} is an exact integer representation,
according to @func{char->integer}, of an @ascii{} character in the
@code{base16} encoding's alphabet.
@end defun

@c page
@node armor base32
@section Base 32 encoder/decoder


The bindings documented in this section are exported by the
@library{armor base32} library.  Base32 encoding produces @math{8} bits
of output every @math{5} bits of input, @math{8} bytes of @ascii{}
characters every @math{5} bytes of binary data.

@menu
* armor base32 intro::          Introduction to base32 encoding.
* armor base32 encode::         Encoding byte streams with base32.
* armor base32 decode::         Decoding byte streams with base32.
* armor base32 utils::          Utilities for base32 encoders and
                                decoders.
@end menu

@c page
@node armor base32 intro
@subsection Introduction to base32 encoding


The following are the encoding alphabets (upper case and lower case) for
base32 as specified by @rfc{} 4648, which is named @code{base32}:
@samp{#\0} and @samp{#\1} (numbers zero and one) are skipped because
they are similar to @samp{#\O} and @samp{#\l} (upper case oh and lower
case ell):

@example
A B C   D E F   G H I   J    ;;  0 -  9
K L M   N O P   Q R S   T    ;; 10 - 19
U V W   X Y Z   2 3 4   5    ;; 20 - 29
6 7                          ;; 30 - 31


a b c   d e f   g h i   j    ;;  0 -  9
k l m   n o p   q r s   t    ;; 10 - 19
u v w   x y z   2 3 4   5    ;; 20 - 29
6 7                          ;; 30 - 31
@end example

The following are the encoding alphabets (upper case and lower case) for
base32 as specified by @rfc{} 2938, which is named @code{base32/hex}: it
uses all the digits first and excludes the characters @samp{#\W},
@samp{#\X}, @samp{#\Y} and @samp{#\Z}:

@example
0 1 2   3 4 5   6 7 8   9    ;;  0 -  9
A B C   D E F   G H I   J    ;; 10 - 19
K L M   N O P   Q R S   T    ;; 20 - 29
U V                          ;; 30 - 31


0 1 2   3 4 5   6 7 8   9    ;;  0 -  9
a b c   d e f   g h i   j    ;; 10 - 19
k l m   n o p   q r s   t    ;; 20 - 29
u v                          ;; 30 - 31
@end example

A block of @math{5} bytes of binary input data is encoded to @math{8}
bytes of @ascii{} characters from the alphabet by splitting the input
bits as follows:

@example
|76543210|76543210|76543210|76543210|76543210|
|--------+--------+--------+--------+--------|
|43210   |        |        |        |        |
|     432|10      |        |        |        |
|        |  43210 |        |        |        |
|        |       4|3210    |        |        |
|        |        |    4321|0       |        |
|        |        |        | 43210  |        |
|        |        |        |      43|210     |
|        |        |        |        |   43210|
@end example

@noindent
then interpreting each @math{5}-bits tuple as an index in the alphabet
vector (zero--based).  When less than @math{5} bytes are available as
input data, splitting is done as follows, with zero bits used to pad the
last @math{5}-bits tuple:

@example
|76543210|76543210|76543210|76543210|
|--------+--------+--------+--------+
|43210   |        |        |        |
|     432|10      |        |        |
|        |  43210 |        |        |
|        |       4|3210    |        |
|        |        |    4321|0       |
|        |        |        | 43210  |
|        |        |        |      43|210

|76543210|76543210|76543210|
|--------+--------+--------+
|43210   |        |        |
|     432|10      |        |
|        |  43210 |        |
|        |       4|3210    |
|        |        |    4321|0

|76543210|76543210|
|--------+--------+
|43210   |        |
|     432|10      |
|        |  43210 |
|        |       4|3210

|76543210|
|--------|
|43210   |
|     432|10
@end example

When padding of @ascii{} encoded bytes is on: padding characters are
appended to the last bytes to make the last block @math{8} bytes long;
when padding is off: the last block can have the lengths: @math{2},
@math{4}, @math{5}, @math{7}, @math{8}.

@c page
@node armor base32 encode
@subsection Encoding byte streams with base32


@deftp Class @aclass{base32-encode-ctx}
Context descriptor for base32 encoding.  Nothing in this record depends
on the input or output data: records of this type can be reused for
different streams, both in sequence and in parallel.
@end deftp


@defcv {Immutable Field} @aclass{base32-encode-ctx} encoding
A Scheme symbol among: @code{base32}, @code{base32/hex}.  It is the
``name'' of the table used for encoding.
@end defcv


@defcv {Immutable Field} @aclass{base32-encode-ctx} encoding-case
A Scheme symbol among: @code{lower}, @code{upper}.  Select the case of
the alphabetic characters in the encoded output data.
@end defcv


@defcv {Immutable Field} @aclass{base32-encode-ctx} generate-padding?
A Scheme boolean value; @true{} if the output data is padded so that its
total length in bytes is a multiple of @math{8}.
@end defcv


@defcv {Immutable Field} @aclass{base32-encode-ctx} pad-char
An exact integer representing (as defined by @func{char->integer}) the
pad character.  It is set to the integer representation of @samp{#\=}.
@end defcv


@defcv {Immutable Field} @aclass{base32-encode-ctx} table
A Scheme vector of exact integers representing the selected encoding's
alphabet.
@end defcv


@defun make-<base32-encode-ctx> @var{encoding} @var{generate-padding?} @var{encoding-case}
Build and return a new record of type @class{base32-encode-ctx}.

@var{encoding} must be a Scheme symbol selecting the encoding type:
@code{base32} or @code{rfc4648}, @code{base32/hex} or @code{rfc2938}.
The argument's value is normalised to one among: @code{base32},
@code{base32/hex}.

If @var{generate-padding?}  is true: the output is padded so that its
length is an exact multiple of @math{8}.  The argument's value is
normalised to @true{} or @false{}.

@var{encoding-case} must be a Scheme symbol among: @code{upper},
@code{lower}; it selects the case of the encoding table.
@end defun


@defun <base32-encode-ctx>? @var{obj}
Return true if @var{obj} is a record of type @class{base32-encode-ctx}.
@end defun


@defun <base32-encode-ctx>-encoding @var{ctx}
@defunx <base32-encode-ctx>-encoding-case @var{ctx}
@defunx <base32-encode-ctx>-generate-padding? @var{ctx}
@defunx <base32-encode-ctx>-pad-char @var{ctx}
@defunx <base32-encode-ctx>-table @var{ctx}
Field accessors for records of type @class{base32-encode-ctx}.
@end defun


@defun base32-encode-update-length @var{number-of-bytes}
Return the minimum number of bytes required in the output bytevector
when @func{base32-encode-update!}  is applied to @var{number-of-bytes}
of binary input data.  Notice that that function will consume input in
@math{5}-bytes blocks only and produce output in @math{8}-bytes blocks
only, so the return value is always zero or an exact multiple of
@math{8}.
@end defun


@defun base32-encode-final-length @var{number-of-bytes}
@defunx base32-encode-final-length @var{number-of-bytes} @var{padding?}
Return the minimum number of bytes required in the output bytevector
when @func{base32-encode-final!} is applied to @var{number-of-bytes}
@math{< 5} bytes of binary input data.

If @var{padding?} is true: the returned count includes padding bytes,
which means that the returned value is always @math{8}; when not used,
@var{padding?} defaults to @false{}.

If @var{number-of-bytes} is invalid (out of range): the return value is
@false{}.
@end defun


@defun base32-encode-length @var{number-of-bytes}
@defunx base32-encode-length @var{number-of-bytes} @var{padding?}
Return the minimum number of bytes required in the output bytevector
when @func{base32-encode-final!}  is applied to @var{number-of-bytes} of
binary input data.  This is also the number required when both
@func{base32-encode-update!}  and @func{base32-encode-final!} are used.

If @var{padding?} is true: the returned count includes padding bytes,
which means that the returned value is always zero or a multiple of
@math{8}; when not used, @var{padding?} defaults to @false{}.
@end defun


@defvr Constant base32-encode-block-length
The length of the input block: @math{5}.
@end defvr


@defun base32-encode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Encode binary data from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
@ascii{} characters in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); encoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base32-encode-ctx}.

This function is meant to encode bytes from the input stream when we
know that more input bytes will be available in the future.

Return two values:

@enumerate
@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

Binary data bytes are read from @var{src-bv} in chunks of @math{5}
bytes; @ascii{} characters are written to @var{dst-bv} in chunks of
@math{8} bytes.  If not enough room exists in @var{dst-bv} to store a
block, available input data is not consumed.
@end defun


@defun base32-encode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Encode binary data from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
@ascii{} characters in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); encoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base32-encode-ctx}.

This function is meant to encode the last bytes from the input stream
and produce the last bytes to the output stream.

Return three values:

@enumerate
@item
A boolean: true if success, false if the output bytevector was filled
before flushing all the bytes.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

Binary data bytes are read from @var{src-bv} in chunks of @math{5}
bytes; @ascii{} characters are written to @var{dst-bv} in chunks of
@math{8} bytes.  After that, trailing bytes from @var{src-bv} are
encoded and optionally padded as specified in @var{ctx}.  If not enough
room exists in @var{dst-bv} to store a block, available input data is
not consumed.
@end defun

@c page
@node armor base32 decode
@subsection Decoding byte streams with base32


@deftp Class @aclass{base32-decode-ctx}
Context descriptor for base32 decoding.  Nothing in this record depends
on the input or output data: records of this type can be reused for
different streams, both in sequence and in parallel.
@end deftp


@defcv {Immutable Field} @aclass{base32-decode-ctx} encoding
A Scheme symbol among: @code{base32}, @code{base32/hex}.  It is the
``name'' of the table used for decoding.
@end defcv


@defcv {Immutable Field} @aclass{base32-decode-ctx} encoding-case
A Scheme symbol among: @code{lower}, @code{mixed}, @code{upper}.  Select
the case of the alphabetic characters in the encoded input data.
@end defcv


@defcv {Immutable Field} @aclass{base32-decode-ctx} expect-padding?
A Scheme boolean; @true{} if we expect the encoded input to be padded in
length to a multiple of @math{8}.
@end defcv


@defcv {Immutable Field} @aclass{base32-decode-ctx} pad-char
An exact integer representing (as defined by @func{char->integer}) the
expected pad character.  It is set to the integer representation of
@samp{#\=}.
@end defcv


@defcv {Immutable Field} @aclass{base32-decode-ctx} table
A Scheme vector of exact integers representing the selected decoding's
table.
@end defcv


@defun make-<base32-decode-ctx> @var{encoding} @var{expect-padding?} @var{encoding-case}
Build and return a new record of type @class{base32-decode-ctx}.

@var{encoding} must be a Scheme symbol selecting the decoding table:
@code{base32} or @code{rfc4648}, @code{base32/hex} or @code{rfc2938}.
The argument's value is normalised to one among: @code{base32},
@code{base32/hex}.

If @var{expect-padding?}  is true: the input is expected to be padded in
length to an exact multiple of @math{8}.  The argument's value is
normalised to @true{} or @false{}.

@var{encoding-case} must be a Scheme symbol selecting the expected case
of the input string: @code{lower}, @code{upper}, @code{mixed}.
@end defun


@defun <base32-decode-ctx>? @var{obj}
Return true if @var{obj} is a record of type @class{base32-decode-ctx}.
@end defun


@defun <base32-decode-ctx>-encoding @var{ctx}
@defunx <base32-decode-ctx>-encoding-case @var{ctx}
@defunx <base32-decode-ctx>-expect-padding? @var{ctx}
@defunx <base32-decode-ctx>-pad-char @var{ctx}
@defunx <base32-decode-ctx>-table @var{ctx}
Field accessors for records of type @class{base32-decode-ctx}.
@end defun


@defun base32-decode-update-length @var{number-of-chars}
Return the minimum number of bytes required in the output bytevector
when @func{base32-decode-update!}  is applied to @var{number-of-chars}
@ascii{} characters of input.  Notice that the function will consume
input in @math{8}-bytes blocks only and produce output in @math{5}-bytes
blocks only, so the return value is always zero or an exact multiple of
@math{5}.
@end defun


@defun base32-decode-final-length @var{number-of-chars}
@defunx base32-decode-final-length @var{number-of-chars} @var{padding?}
Return the minimum number of bytes required in the output bytevector
when @func{base32-decode-final!} is applied to @var{number-of-chars}
@math{< 8} @ascii{} characters of input.  Not all the arguments between
@math{0} and @math{7} are valid; if @var{number-of-chars} is not valid:
the return value is @false{}.

If @var{padding?} is true: the input is expected to be padded; in this
case the only valid value for @var{number-of-chars} is zero and the
return value is zero.  If @var{padding?} is true and
@var{number-of-chars} is non--zero: the return value is @false{}.  When
not given, @var{padding?} defaults to @false{}.
@end defun


@defun base32-decode-length @var{number-of-chars}
@defunx base32-decode-length @var{number-of-chars} @var{padding?}
Return the minimum number of bytes required in the output bytevector
when @func{base32-decode-final!}  is applied to @var{number-of-chars}
@ascii{} characters of input.  This is also the number required when
both @func{base32-decode-update!}  and @func{base32-decode-final!} are
used.

If @var{padding?} is true, the input is expected to be padded; in this
case the only valid value for @var{number-of-chars} is zero and the
return value is zero.  If @var{padding?} is true and
@var{number-of-chars} is non--zero, the return value is @false{}.  When
not given, @var{padding?} defaults to @false{}.
@end defun


@defvr Constant base32-decode-block-length
The length of the input block: @math{8}.
@end defvr


@defun base32-decode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Decode @ascii{} characters from the bytevector @var{src-bv} starting at
index @var{src-start} (included) up to index @var{src-past} (excluded);
store binary data bytes in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); decoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base32-decode-ctx}.

Return three values:

@enumerate
@item
A boolean: true if padding is turned on and a full padded block was
successfully decoded; false otherwise.  If this is true: the end of
input has been reached and fully processed.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is filled to the end, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the
characters from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

@ascii{} characters are read from @var{src-bv} in chunks of @math{8}
bytes; binary data bytes are written to @var{dst-bv} in chunks of
@math{5} bytes.  If not enough room exists in @var{dst-bv} to store a
block, available input data is not consumed.
@end defun


@defun base32-decode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Decode @ascii{} characters from the bytevector @var{src-bv} starting at
index @var{src-start} (included) up to index @var{src-past} (excluded);
store binary data bytes in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); decoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base32-decode-ctx}.

Return three values:

@enumerate
@item
A boolean: true if success, false if the output bytevector was filled
before flushing all the bytes.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is filled to the end, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

@ascii{} characters are read from @var{src-bv} in chunks of @math{8}
bytes; binary data bytes are written to @var{dst-bv} in chunks of
@math{8} bytes.  If the last characters are in a chunk of less than
@math{8}, they are interpreted as unpadded characters as specified in
@var{ctx}.  If not enough room exists in @var{dst-bv} to store a block,
available input data is not consumed.
@end defun

@c page
@node armor base32 utils
@subsection Utilities for base32 encoders and decoders


@defun armored-byte-of-base32/upper-case? @var{byte-integer}
@defunx armored-byte-of-base32/lower-case? @var{byte-integer}
@defunx armored-byte-of-base32/mixed-case? @var{byte-integer}
Return true if @var{byte-integer} is an exact integer representation,
according to @func{char->integer}, of an @ascii{} character in the
@code{base32} encoding's alphabet.
@end defun


@defun armored-byte-of-base32/hex/upper-case? @var{byte-integer}
@defunx armored-byte-of-base32/hex/lower-case? @var{byte-integer}
@defunx armored-byte-of-base32/hex/mixed-case? @var{byte-integer}
Return true if @var{byte-integer} is an exact integer representation,
according to @func{char->integer}, of an @ascii{} character in the
@code{base32/hex} encoding's alphabet.
@end defun

@c page
@node armor base64
@section Base 64 encoder/decoder


The bindings documented in this section are exported by the
@library{armor base64} library.  Base64 encoding produces @math{8} bits
of output every @math{6} bits of input, @math{4} bytes of @ascii{}
characters every @math{3} bytes of binary data.

@menu
* armor base64 intro::          Introduction to base64 encoding.
* armor base64 encode::         Encoding byte streams with base64.
* armor base64 decode::         Decoding byte streams with base64.
* armor base64 utils::          Utilities for base64 encoders and
                                decoders.
@end menu

@c page
@node armor base64 intro
@subsection Introduction to base64 encoding


The following is the encoding alphabets for base64 as specified by
@rfc{} 4648; this alphabet is named @code{base64}:

@example
A B C   D E F   G H I   J    ;;  0 -  9
K L M   N O P   Q R S   T    ;; 10 - 19
U V W   X Y Z   a b c   d    ;; 20 - 29
e f g   h i j   k l m   n    ;; 30 - 31
o p q   r s t   u v w   x    ;; 40 - 49
y z 0   1 2 3   4 5 6   7    ;; 50 - 59
8 9 +   /                    ;; 60 - 63
@end example

The following is the encoding alphabets for base64 as specified by
@rfc{} 4648 for @aurl{} encoding, it replaces @samp{#\+} and @samp{#\/}
with @samp{#\-} and @samp{#\_} respectively; this alphabet is named
@code{base64/url}:

@example
A B C   D E F   G H I   J    ;;  0 -  9
K L M   N O P   Q R S   T    ;; 10 - 19
U V W   X Y Z   a b c   d    ;; 20 - 29
e f g   h i j   k l m   n    ;; 30 - 31
o p q   r s t   u v w   x    ;; 40 - 49
y z 0   1 2 3   4 5 6   7    ;; 50 - 59
8 9 -   _                    ;; 60 - 63
@end example

A block of @math{3} bytes of binary input data is encoded to @math{4}
bytes of @ascii{} characters from the alphabet by splitting the input
bits as follows:

@example
|76543210|76543210|76543210|
|--------+--------+--------|
|543210  |        |        |
|      54|3210    |        |
|        |    5432|10      |
|        |        |  543210|
@end example

@noindent
then interpreting each @math{6}-bits tuple as an index in the alphabet
vector (zero--based).  When less than @math{3} bytes are available as
input data, splitting is done as follows, with zero bits used to pad the
last @math{6}-bits tuple:

@example
|76543210|76543210|
|--------+--------|
|543210  |        |
|      54|3210    |
|        |    5432|10

|76543210|
|--------|
|543210  |
|      54|3210
@end example

When padding of @ascii{} encoded bytes is on: padding characters are
appended to the last bytes to make the last block @math{4} bytes long;
when padding is off: the last block can have the lengths: @math{2},
@math{3}, @math{4}.

@c page
@node armor base64 encode
@subsection Encoding byte streams with base64


@deftp Class @aclass{base64-encode-ctx}
Context descriptor for base64 encoding.  Nothing in this record depends
on the input or output data: records of this type can be reused for
different streams, both in sequence and in parallel.
@end deftp


@defcv {Immutable Field} @aclass{base64-encode-ctx} encoding
A Scheme symbol among: @code{base64}, @code{base64/url}.  It is the
``name'' of the table used for encoding.
@end defcv


@defcv {Immutable Field} @aclass{base64-encode-ctx} generate-padding?
A Scheme boolean value; @true{} if the output data is padded so that its
total length in bytes is a multiple of @math{4}.
@end defcv


@defcv {Immutable Field} @aclass{base64-encode-ctx} pad-char
An exact integer representing (as defined by @func{char->integer}) the
pad character.  It is set to the integer representation of @samp{#\=}.
@end defcv


@defcv {Immutable Field} @aclass{base64-encode-ctx} table
A Scheme vector of exact integers representing the selected encoding's
alphabet.
@end defcv


@defun make-<base64-encode-ctx> @var{encoding} @var{generate-padding?}
Build and return a new record of type @class{base64-encode-ctx}.

@var{encoding} must be a Scheme symbol selecting the encoding type:
@code{base64}, @code{base64/url}.

If @var{generate-padding?}  is true: the output is padded so that its
length is an exact multiple of @math{4}.  The argument's value is
normalised to @true{} or @false{}.
@end defun


@defun <base64-encode-ctx>? @var{obj}
Return true if @var{obj} is a record of type @class{base64-encode-ctx}.
@end defun


@defun <base64-encode-ctx>-encoding @var{ctx}
@defunx <base64-encode-ctx>-generate-padding? @var{ctx}
@defunx <base64-encode-ctx>-pad-char @var{ctx}
@defunx <base64-encode-ctx>-table @var{ctx}
Field accessors for records of type @class{base64-encode-ctx}.
@end defun


@defun base64-encode-update-length @var{number-of-bytes}
Return the minimum number of bytes required in the output bytevector
when @func{base64-encode-update!}  is applied to @var{number-of-bytes}
of binary input data.  Notice that that function will consume input in
@math{3}-bytes blocks only and produce output in @math{4}-bytes blocks
only, so the return value is always zero or an exact multiple of
@math{4}.
@end defun


@defun base64-encode-final-length @var{number-of-bytes}
@defunx base64-encode-final-length @var{number-of-bytes} @var{padding?}
Return the minimum number of bytes required in the output bytevector
when @func{base64-encode-final!} is applied to @var{number-of-bytes}
@math{< 3} bytes of binary input data.

If @var{padding?} is true: the returned count includes padding bytes,
which means that the returned value is always @math{4}; when not used,
@var{padding?} defaults to @false{}.

If @var{number-of-bytes} is invalid (out of range): the return value is
@false{}.
@end defun


@defun base64-encode-length @var{number-of-bytes}
@defunx base64-encode-length @var{number-of-bytes} @var{padding?}
Return the minimum number of bytes required in the output bytevector
when @func{base64-encode-final!}  is applied to @var{number-of-bytes} of
binary input data.  This is also the number required when both
@func{base64-encode-update!}  and @func{base64-encode-final!} are used.

If @var{padding?} is true: the returned count includes padding bytes,
which means that the returned value is always zero or a multiple of
@math{4}; when not used, @var{padding?} defaults to @false{}.
@end defun


@defvr Constant base64-encode-block-length
The length of the input block: @math{3}.
@end defvr


@defun base64-encode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Encode binary data from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
@ascii{} characters in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); encoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base64-encode-ctx}.

This function is meant to encode bytes from the input stream when we
know that more input bytes will be available in the future.

Return two values:

@enumerate
@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

Binary data bytes are read from @var{src-bv} in chunks of @math{3}
bytes; @ascii{} characters are written to @var{dst-bv} in chunks of
@math{4} bytes.  If not enough room exists in @var{dst-bv} to store a
block, available input data is not consumed.
@end defun


@defun base64-encode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Encode binary data from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
@ascii{} characters in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); encoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base64-encode-ctx}.

This function is meant to encode the last bytes from the input stream
and produce the last bytes to the output stream.

Return three values:

@enumerate
@item
A boolean: true if success, false if the output bytevector was filled
before flushing all the bytes.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

Binary data bytes are read from @var{src-bv} in chunks of @math{3}
bytes; @ascii{} characters are written to @var{dst-bv} in chunks of
@math{4} bytes.  After that, trailing bytes from @var{src-bv} are
encoded and optionally padded as specified in @var{ctx}.  If not enough
room exists in @var{dst-bv} to store a block, available input data is
not consumed.
@end defun

@c page
@node armor base64 decode
@subsection Decoding byte streams with base64


@deftp Class @aclass{base64-decode-ctx}
Context descriptor for base64 decoding.  Nothing in this record depends
on the input or output data: records of this type can be reused for
different streams, both in sequence and in parallel.
@end deftp


@defcv {Immutable Field} @aclass{base64-decode-ctx} encoding
A Scheme symbol among: @code{base64}, @code{base64/url}.  It is the
``name'' of the table used for decoding.
@end defcv


@defcv {Immutable Field} @aclass{base64-decode-ctx} expect-padding?
A Scheme boolean; @true{} if we expect the encoded input to be padded in
length to a multiple of @math{4}.
@end defcv


@defcv {Immutable Field} @aclass{base64-decode-ctx} pad-char
An exact integer representing (as defined by @func{char->integer}) the
expected pad character.  It is set to the integer representation of
@samp{#\=}.
@end defcv


@defcv {Immutable Field} @aclass{base64-decode-ctx} table
A Scheme vector of exact integers representing the selected decoding's
table.
@end defcv


@defun make-<base64-decode-ctx> @var{encoding} @var{expect-padding?}
Build and return a new record of type @class{base64-decode-ctx}.

@var{encoding} must be a Scheme symbol selecting the decoding table:
@code{base64}, @code{base64/url}.

If @var{expect-padding?}  is true: the input is expected to be padded in
length to an exact multiple of @math{4}.  The argument's value is
normalised to @true{} or @false{}.
@end defun


@defun <base64-decode-ctx>? @var{obj}
Return true if @var{obj} is a record of type @class{base64-decode-ctx}.
@end defun


@defun <base64-decode-ctx>-encoding @var{ctx}
@defunx <base64-decode-ctx>-expect-padding? @var{ctx}
@defunx <base64-decode-ctx>-pad-char @var{ctx}
@defunx <base64-decode-ctx>-table @var{ctx}
Field accessors for records of type @class{base64-decode-ctx}.
@end defun


@defun base64-decode-update-length @var{number-of-chars}
Return the minimum number of bytes required in the output bytevector
when @func{base64-decode-update!}  is applied to @var{number-of-chars}
@ascii{} characters of input.  Notice that the function will consume
input in @math{4}-bytes blocks only and produce output in @math{3}-bytes
blocks only, so the return value is always zero or an exact multiple of
@math{3}.
@end defun


@defun base64-decode-final-length @var{number-of-chars}
@defunx base64-decode-final-length @var{number-of-chars} @var{padding?}
Return the minimum number of bytes required in the output bytevector
when @func{base64-decode-final!} is applied to @var{number-of-chars}
@math{< 4} @ascii{} characters of input.  Not all the arguments between
@math{0} and @math{3} are valid; if @var{number-of-chars} is not valid:
the return value is @false{}.

If @var{padding?} is true: the input is expected to be padded; in this
case the only valid value for @var{number-of-chars} is zero and the
return value is zero.  If @var{padding?} is true and
@var{number-of-chars} is non--zero: the return value is @false{}.  When
not given, @var{padding?} defaults to @false{}.
@end defun


@defun base64-decode-length @var{number-of-chars}
@defunx base64-decode-length @var{number-of-chars} @var{padding?}
Return the minimum number of bytes required in the output bytevector
when @func{base64-decode-final!}  is applied to @var{number-of-chars}
@ascii{} characters of input.  This is also the number required when
both @func{base64-decode-update!}  and @func{base64-decode-final!} are
used.

If @var{padding?} is true, the input is expected to be padded; in this
case the only valid value for @var{number-of-chars} is zero and the
return value is zero.  If @var{padding?} is true and
@var{number-of-chars} is non--zero, the return value is @false{}.  When
not given, @var{padding?} defaults to @false{}.
@end defun


@defvr Constant base64-decode-block-length
The length of the input block: @math{4}.
@end defvr


@defun base64-decode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Decode @ascii{} characters from the bytevector @var{src-bv} starting at
index @var{src-start} (included) up to index @var{src-past} (excluded);
store binary data bytes in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); decoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base64-decode-ctx}.

Return three values:

@enumerate
@item
A boolean: true if padding is turned on and a full padded block was
successfully decoded; false otherwise.  If this is true: the end of
input has been reached and fully processed.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is filled to the end, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the
characters from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

@ascii{} characters are read from @var{src-bv} in chunks of @math{4}
bytes; binary data bytes are written to @var{dst-bv} in chunks of
@math{3} bytes.  If not enough room exists in @var{dst-bv} to store a
block, available input data is not consumed.
@end defun


@defun base64-decode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Decode @ascii{} characters from the bytevector @var{src-bv} starting at
index @var{src-start} (included) up to index @var{src-past} (excluded);
store binary data bytes in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); decoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base64-decode-ctx}.

Return three values:

@enumerate
@item
A boolean: true if success, false if the output bytevector was filled
before flushing all the bytes.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is filled to the end, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

@ascii{} characters are read from @var{src-bv} in chunks of @math{4}
bytes; binary data bytes are written to @var{dst-bv} in chunks of
@math{3} bytes.  If the last characters are in a chunk of less than
@math{4}, they are interpreted as unpadded characters as specified in
@var{ctx}.  If not enough room exists in @var{dst-bv} to store a block,
available input data is not consumed.
@end defun

@c page
@node armor base64 utils
@subsection Utilities for base64 encoders and decoders


@defun armored-byte-of-base64? @var{byte-integer}
Return true if @var{byte-integer} is an exact integer representation,
according to @func{char->integer}, of an @ascii{} character in the
@code{base64} encoding's alphabet.
@end defun


@defun armored-byte-of-base64/url? @var{byte-integer}
Return true if @var{byte-integer} is an exact integer representation,
according to @func{char->integer}, of an @ascii{} character in the
@code{base64/url} encoding's alphabet.
@end defun

@c page
@node armor base91
@section Base 91 encoder/decoder


The bindings documented in this section are exported by the
@library{armor base91} library.  The base91 encoding specification is by
Joachim Henke, published in the basE91 C language software package.

@menu
* armor base91 intro::          Introduction to base91 encoding.
* armor base91 encode::         Encoding byte streams with base91.
* armor base91 decode::         Decoding byte streams with base91.
* armor base91 utils::          Utilities for base91 encoders and
                                decoders.
@end menu

@c page
@node armor base91 intro
@subsection Introduction to base91 encoding


This encoding differs from @code{base32} and @code{base64} in that:

@itemize
@item
The output length depends upon the input data.

@item
There is no padding.

@item
The encoder/decoder context buffers input data.
@end itemize

The overhead produced by base91 depends on the input data: the encoder
outputs @math{16} bits of @ascii{} characters every @math{13} or
@math{14} bits of binary input.  The overhead amounts at most to
@math{23\%} (versus @math{33\%} for base64) and can range down to
@math{14\%}, which typically occurs on zero--byte blocks.

As the name suggests, base91 needs @math{91} characters to represent the
encoded binary data in @ascii{}; from the @math{94} printable @ascii{}
characters (@samp{#x21}..@samp{#x7E}), the following three have been
omitted to build the base @math{91} alphabet:

@example
#\-     dash, 0x2D
#\'     apostrophe, 0x27
#\\     backslash, 0x5C
@end example

@noindent
the alphabet is composed of the remaining characters:

@example
A B C   D E F   G H I   J    ;;  0 -  9
K L M   N O P   Q R S   T    ;; 10 - 19
U V W   X Y Z   a b c   d    ;; 20 - 29
e f g   h i j   k l m   n    ;; 30 - 39
o p q   r s t   u v w   x    ;; 40 - 49
y z 0   1 2 3   4 5 6   7    ;; 50 - 59
8 9 !   # $ %   & ( )   *    ;; 60 - 69
+ , .   / : ;   < = >   ?    ;; 70 - 79
@@ [ ]   ^ _ `   @{ | @}   ~    ;; 80 - 89
"                            ;; 90
@end example

@c page
@node armor base91 encode
@subsection Encoding byte streams with base91


@deftp Class @aclass{base91-encode-ctx}
Context descriptor for base91 encoding.  The fields of this record
depend on the input data: records of this type @strong{cannot} be reused
for different streams.
@end deftp


@defun make-<base91-encode-ctx>
@defunx <base91-encode-ctx>? @var{obj}
Constructor and predicate for records of type @class{base91-encode-ctx}.
@end defun


@defun base91-encode-update-length @var{number-of-bytes}
Return the minimum number of bytes required in the output bytevector
when @func{base91-encode-update!}  is applied to @var{number-of-bytes}
of binary input data.
@end defun


@defun base91-encode-final-length @var{unused}
Return the minimum number of bytes required in the output bytevector
when @func{base91-encode-final!} is applied to an encoding context to
flush the buffered bits.  @var{unused} is ignored: it is here only to
provide an @api{} equal to the one of the base64 encoder.
@end defun


@defun base91-encode-length @var{number-of-bytes}
Return the minimum number of bytes required in the output bytevector
when @func{base91-encode-final!}  is applied to @var{number-of-bytes} of
binary input data.  This is also the number required when both
@func{base91-encode-update!}  and @func{base91-encode-final!} are used.
@end defun


@defun base91-encode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Encode binary data from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
@ascii{} characters in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); encoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base91-encode-ctx}.

This function is meant to encode bytes from the input stream when we
know that more input bytes will be available in the future.

Return two values:

@enumerate
@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate
@end defun


@defun base91-encode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Encode binary data from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
@ascii{} characters in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); encoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base91-encode-ctx}.

This function is meant to encode the last bytes from the input stream
and produce the last bytes to the output stream.

After all the bytes from the source bytevector have been consumed, the
bits buffered in the context are flushed to the output buffer.

Return three values:

@enumerate
@item
A boolean: true if success, false if the output bytevector was filled
before flushing all the bytes.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate
@end defun

@c page
@node armor base91 decode
@subsection Decoding byte streams with base91


@deftp Class @aclass{base91-decode-ctx}
Context descriptor for base91 decoding.  The fields of this record
depend on the input data: records of this type @strong{cannot} be reused
for different streams.
@end deftp


@defun make-<base91-decode-ctx>
@defunx <base91-decode-ctx>? @var{obj}
Constructor and predicate for records of type @class{base91-decode-ctx}.
@end defun


@defun base91-decode-update-length @var{number-of-chars}
Return the minimum number of bytes required in the output bytevector
when @func{base91-decode-update!}  is applied to @var{number-of-chars}
@ascii{} characters of input.
@end defun


@defun base91-decode-final-length @var{unused}
Return the minimum number of bytes required in the output bytevector
when @func{base91-decode-final!} is applied to a decoding context to
flush the buffered bits.  @var{unused} is ignored: it is here only to
provide an @api{} equal to the one of base64.
@end defun


@defun base91-decode-length @var{number-of-chars}
Return the minimum number of bytes required in the output bytevector
when @func{base91-decode-final!}  is applied to @var{number-of-chars}
@ascii{} characters of input.  This is also the number required when
both @func{base91-decode-update!}  and @func{base91-decode-final!} are
used.
@end defun


@defun base91-decode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Decode @ascii{} characters from the bytevector @var{src-bv} starting at
index @var{src-start} (included) up to index @var{src-past} (excluded);
store binary data bytes in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); decoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base91-decode-ctx}.

Return three values:

@enumerate
@item
A boolean always false.  It is here to provide an @api{} equal to the
one of the base64 decoder.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is filled to the end, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the
characters from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate
@end defun


@defun base91-decode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Decode @ascii{} characters from the bytevector @var{src-bv} starting at
index @var{src-start} (included) up to index @var{src-past} (excluded);
store binary data bytes in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); decoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{base91-decode-ctx}.

After all the bytes from the source bytevector have been consumed, the
bits buffered in the context are flushed to the output buffer.

Return three values:

@enumerate
@item
A boolean: true if success, false if the output bytevector was filled
before flushing all the bytes.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is filled to the end, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate
@end defun

@c page
@node armor base91 utils
@subsection Utilities for base91 encoders and decoders


@defun base91-encode-flushed? @var{ctx}
@defunx base91-decode-flushed? @var{ctx}
Return true if the bits buffered in the context have been flushed.
@end defun


@defun armored-byte-of-base91? @var{byte-integer}
Return true if @var{byte-integer} is an exact integer representation,
according to @func{char->integer}, of an @ascii{} character in the
@code{base91} encoding's alphabet.
@end defun

@c page
@node armor ascii85
@section @ascii{} 85 encoder/decoder


The bindings documented in this section are exported by the
@library{armor ascii85} library.  @ascii{}85 encoding produces @math{5}
bytes of @ascii{} characters every @math{4} bytes of binary data.

@menu
* armor ascii85 intro::         Introduction to @ascii{}85 encoding.
* armor ascii85 encode::        Encoding byte streams with @ascii{}85.
* armor ascii85 decode::        Decoding byte streams with @ascii{}85.
* armor ascii85 utils::         Utilities for @ascii{}85 encoders and
                                decoders.
@end menu

@c page
@node armor ascii85 intro
@subsection Introduction to @ascii{}85 encoding


This encoding differs from @code{base32} and @code{base64} in that:

@itemize
@item
The output length depends upon the input data.

@item
There is no padding.
@end itemize

@c ------------------------------------------------------------

@subsubheading The encoder algorithm

The encoder is meant to prefix the encoded data with the sequence
@samp{<~} and to append after the last byte the sequence @samp{~>}.

A string of @math{4} bytes @math{Bn} of binary input are encoded as
follows:

@enumerate
@item
A tuple bytevector is formed as in:

@example
(define tuple-bv '#vu8(B0 B1 B2 B3))
@end example

@noindent
and a tuple number is formed as in:

@example
(define tuple
  (bytevector-u32-ref tuple-bv 0 (endianness big)))
@end example

@item
@math{5} moduli @math{Mn} resulting from division by @math{85} are
computed:

@example
(define D0 (div tuple 85))
(define D1 (div D0 85))
(define D2 (div D1 85))
(define D3 (div D2 85))

(define M0 (mod tuple 85))
(define M1 (mod D0 85))
(define M2 (mod D1 85))
(define M3 (mod D2 85))
(define M4 (mod D3 85))
@end example

@item
Character integers @math{Cn} are computed:

@example
(define bang-char (char->integer #\!))

(define C0 (+ bang-char M0))
(define C1 (+ bang-char M1))
(define C2 (+ bang-char M2))
(define C3 (+ bang-char M3))
(define C4 (+ bang-char M4))
@end example

@item
The output bytevector is filled with the integers in ``reverse'' order:

@example
(define ascii-bv
  '#vu8(C4 C3 C2 C1 C0))
@end example
@end enumerate

The integers in the output bytevector are associated (according to
@func{integer->char}) to the characters between @samp{#\!} (included)
and @samp{#\u} (included).  As a special exception: when there are
@math{4} input bytes and the corresponding tuple number is zero, a
single output byte is encoded, the one corresponding to the @ascii{}
character @samp{#\z}.

Binary input is encoded in blocks of length @math{4}, producing blocks
of length @math{5}; the trailing bytes (less than @math{4}) are encoded
in a similar way, starting with tuple bytevectors like:

@example
(define tuple-bv-3 '#vu8(B0 B1 B2  0))
(define tuple-bv-2 '#vu8(B0 B1  0  0))
(define tuple-bv-1 '#vu8(B0  0  0  0))
@end example

@noindent
computing the character integers @math{Cn} exaclty as above; finally
storing the characters as follows:

@example
(define ascii-out-3 '#vu8(C4 C3 C2 C1))
(define ascii-out-2 '#vu8(C4 C3 C2))
(define ascii-out-1 '#vu8(C4 C3))
@end example

@noindent
we see that: whichever the number of input bytes, we always have to
compute @math{5} moduli @math{Mn}.

@c ------------------------------------------------------------

@subsubheading The decoder algorithm

The decoder is meant to detect the opening sequence @samp{<~} at the
beginning of the encoded stream and the closing sequence @samp{~>} at
the end of the decoded stream.

A string of @math{5} bytes @math{Cn} of @ascii{} input characters is
decoded as follows:

@enumerate
@item
@math{5} moduli @math{Mn} are computed:

@example
(define encoded-input
  '#vu8(C4 C3 C2 C1 C0))

(define M4 (- C4 bang-char))
(define M3 (- C3 bang-char))
(define M2 (- C2 bang-char))
(define M1 (- C1 bang-char))
(define M0 (- C0 bang-char))
@end example

@item
A tuple number is computed:

@example
(define bang-char (char->integer #\!))

(define tuple
  (+ (* M4 85 85 85 85)
     (* M3 85 85 85)
     (* M2 85 85)
     (* M1 85)
        M0))
@end example

@item
@math{4} bytes @math{Bn} of binary output are extracted:

@example
(define >> bitwise-arithmetic-shift-right)

(define B0 (bitwise-and #xFF (>> tuple 24)))
(define B1 (bitwise-and #xFF (>> tuple 16)))
(define B2 (bitwise-and #xFF (>> tuple  8)))
(define B3 (bitwise-and #xFF     tuple))
@end example

@item
The output bytevector is formed:

@example
(define binary-output
  '#vu8(B0 B1 B2 B3))
@end example
@end enumerate

@ascii{} input is decoded in blocks of length @math{5}, producing blocks
of length @math{4}; the trailing bytes (less than @math{5} more than
@math{1}) are decoded in a similar way, starting with tuple numbers
like:

@example
(define tuple-4
  (+ (* M4 85 85 85 85)
     (* M3 85 85 85)
     (* M2 85 85)
     (* M1 85)
           85))

(define tuple-3
  (+ (* M4 85 85 85 85)
     (* M3 85 85 85)
     (* M2 85 85)
     (*    85 85)))

(define tuple-2
  (+ (* M4 85 85 85 85)
     (* M3 85 85 85)
     (*    85 85 85)))
@end example

@noindent
and forming output bytevectors like:

@example
(define binary-output-4 '#vu8(B0 B1 B2))
(define binary-output-3 '#vu8(B0 B1))
(define binary-output-2 '#vu8(B0))
@end example

As a special exception: when an input byte associated to the character
@samp{#\z} is found in the @ascii{} input, @math{4} zero bytes are
appended to the binary output.  The @samp{#\z} character is legal only
at the @strong{beginning} of an input block of @math{5} characters and
at the @strong{beginning} of the last block of trailing characters.
Trailing characters must come in blocks of at least @math{2} bytes.

@c page
@node armor ascii85 encode
@subsection Encoding byte streams with @ascii{}85


@deftp Class @aclass{ascii85-encode-ctx}
Context descriptor for @ascii{}85 encoding.
@end deftp


@defun make-<ascii85-encode-ctx>
@defunx <ascii85-encode-ctx>? @var{obj}
Constructor and predicate for records of type
@class{ascii85-encode-ctx}.
@end defun


@defun ascii85-encode-update-length @var{number-of-bytes}
Return the minimum number of bytes required in the output bytevector
when @func{ascii85-encode-update!}  is applied to @var{number-of-bytes}
bytes of binary input data.  Notice that the function will consume input
in @math{4}-bytes blocks only and produce output in @math{5}-bytes
blocks only, so the return value is always zero or an exact multiple of
@math{5}.
@end defun


@defun ascii85-encode-final-length @var{number-of-bytes}
Return the minimum number of bytes required in the output vector when
@func{ascii85-encode-final!}  is applied to @var{number-of-bytes}
@math{< 4} bytes of binary input data.  The returned value does
@strong{not} take into account the ending @samp{~>} sequence.  If
@var{number-of-bytes} is invalid: the return value is @false{}.
@end defun


@defun ascii85-encode-length @var{number-of-bytes}
Return the minimum number of bytes required in the output vector when
@func{ascii85-encode-final!}  is applied to @var{number-of-bytes} bytes
of binary input data.  This is also the number required when both
@func{ascii85-encode-update!}  and @func{ascii85-encode-final!} are
used.
@end defun


@defvr Constant ascii85-encode-block-length
The length of the input block: @math{4}.
@end defvr


@defun ascii85-encode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Encode binary data from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
@ascii{} characters in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); encoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{ascii85-encode-ctx}.

This function is meant to encode bytes from the input stream when we
know that more input bytes will be available in the future.

Return two values:

@enumerate
@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate
@end defun


@defun ascii85-encode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Encode binary data from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
@ascii{} characters in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); encoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{ascii85-encode-ctx}.

This function is meant to encode the last bytes from the input stream
and produce the last bytes to the output stream.  This function does
@strong{not} output the trailing @samp{~>} sequence.

Return three values:

@enumerate
@item
A boolean: true if success, false if the output bytevector was filled
before flushing all the bytes.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate
@end defun

@c page
@node armor ascii85 decode
@subsection Decoding byte streams with @ascii{}85


None of the following functions will take care to recognise and parse
the opening @samp{<~} or closing @samp{~>} sequences of the @ascii{}85
encoding.


@deftp Class @aclass{ascii85-decode-ctx}
Context descriptor for @ascii{}85 decoding.
@end deftp


@defun make-<ascii85-decode-ctx>
@defunx <ascii85-decode-ctx>? @var{obj}
Constructor and predicate for records of type
@class{ascii85-decode-ctx}.
@end defun


@defun ascii85-decode-update-length @var{number-of-chars}
Return the minimum number of bytes required in the output vector when
@func{ascii85-decode-update!}  is applied to @var{number-of-chars}
@ascii{} characters of input.  Notice that the function will consume
input in @math{5}-bytes blocks only and produce output in @math{4}-bytes
blocks only, so the return value is always zero or an exact multiple of
@math{4}.

This function does @strong{not} take into account that an input
character could be @samp{#\z}, corresponding to @math{4} output bytes.
@end defun


@defun ascii85-decode-final-length @var{number-of-chars}
Return the minimum number of bytes required in the output vector when
@func{ascii85-decode-final!}  is applied to @var{number-of-chars}
@math{< 5} @ascii{} characters of input.  All the arguments between
@math{0} and @math{4} are valid; if the argument is not valid the return
value is @false{}.  If the argument is @math{1}, the return value is
@math{4}: this is to allow a single @samp{#\z} character to be
processed.
@end defun


@defun ascii85-decode-length @var{number-of-chars}
@defunx ascii85-decode-length @var{number-of-chars} @var{padding?}
Return the minimum number of bytes required in the output vector when
@func{ascii85-decode-final!}  is applied to @var{number-of-chars}
@ascii{} characters of input.  This is also the number required when
both @func{ascii85-decode-update!} and @func{ascii85-decode-final!} are
used.

This function does @strong{not} take into account that an input
character could be @samp{#\z}, corresponding to @math{4} output bytes.
@end defun


@defvr Constant ascii85-decode-block-length
The length of the input block: @math{5}.
@end defvr


@defun ascii85-decode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Decode @ascii{} characters from the bytevector @var{src-bv} starting at
index @var{src-start} (included) up to index @var{src-past} (excluded);
store binary data bytes in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); decoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{ascii85-decode-ctx}.

Return three values:

@enumerate
@item
A boolean always false.  This return value is used to make the
@ascii{}85 @api{} equal to the one of the base64 decoder.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is filled to the end, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the
characters from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

@ascii{} characters are read from @var{src-bv} in chunks of @math{5}
bytes; binary data bytes are written to @var{dst-bv} in chunks of
@math{4} bytes.  If not enough room exists in @var{dst-bv} to store a
block, available input data is not consumed.  As a special exception: if
the first character to be read in a chunk is @samp{#\z}, it is decoded
to a sequence of @math{4} zero bytes.
@end defun


@defun ascii85-decode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Decode @ascii{} characters from the bytevector @var{src-bv} starting at
index @var{src-start} (included) up to index @var{src-past} (excluded);
store binary data bytes in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); decoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{ascii85-decode-ctx}.

Return three values:

@enumerate
@item
A boolean: true if success, false if the output bytevector was filled
before flushing all the bytes.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is filled to the end, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

@ascii{} characters are read from @var{src-bv} in chunks of @math{5}
bytes; binary data bytes are written to @var{dst-bv} in chunks of
@math{4} bytes.  After that the trailing characters are decoded.  If not
enough room exists in @var{dst-bv} to store a block, available input
data is not consumed.  As a special exception: if the first character to
be read in a chunk is @samp{#\z}, it is decoded to a sequence of
@math{4} zero bytes.
@end defun

@c page
@node armor ascii85 utils
@subsection Utilities for @ascii{}85 encoders and decoders


@defun armored-byte-of-ascii85? @var{byte-integer}
Return true if @var{byte-integer} is an exact integer representation,
according to @func{char->integer}, of an @ascii{} character in the
@ascii{}85 encoding's alphabet.
@end defun


@defun ascii85-encode-opening! @var{ctx} @var{dst-bv} @var{dst-start}
Writes the opening sequence @samp{<~} to the bytevector @var{dst-bv}
starting at index @var{dst-start} (included).  Return the index of the
next non--written byte in @var{dst-bv}, or @false{} if there is not
enough room in @var{dst-bv}.
@end defun


@defun ascii85-encode-closing! @var{ctx} @var{dst-bv} @var{dst-start}
Writes the closing sequence @samp{~>} to the bytevector @var{dst-bv}
starting at index @var{dst-start} (included).  Return the index of the
next non--written byte in @var{dst-bv}, or @false{} if there is not
enough room in @var{dst-bv}.
@end defun

@c page
@node armor qprint
@section Quoted--printable encoder/decoder


The bindings documented in this section are exported by the
@library{armor quoted-printable} library.

@menu
* armor qprint intro::          Introduction to quoted--printable
                                encoding.
* armor qprint encode::         Encoding byte streams with
                                quoted--printable.
* armor qprint decode::         Decoding byte streams with
                                quoted--printable.
* armor qprint utils::          Utilities for quoted--printable
                                encoders and decoders.
@end menu

@c page
@node armor qprint intro
@subsection Introduction to quoted--printable encoding


The encoding algorithm implemented by @library{armor quoted-printable}
has two variants; the @code{default} encoder implements the following
rules:

@itemize
@item
Every input byte whose character representation (according to
@func{integer->char}) is between @samp{#\!} (included) and @samp{#\<}
(included) or between @samp{#\>} (included) and @samp{#\~} (included) is
duplicated ``as is'' to the output.  That is the following characters
may appear in the output as one--on--one representation of input bytes:

@example
! " #   $ % &   ' ( )
* + ,   - . /   0 1 2
3 4 5   6 7 8   9 : ;
<

> ? @@   A B C   D E F
G H I   J K L   M N O
P Q R   S T U   V W X
Y Z [   \ ] ^   _ ` a
b c d   e f g   h i j
k l m   n o p   q r s
t u v   w x y   z @{ |
@} ~
@end example

@item
All the other input bytes are encoded as in upper--case base16 and the
result is appended to the output with a @samp{#\=} character prepended.
So the input byte @math{31} is encoded to the sequence @samp{=1F}.
@end itemize

@noindent
the @code{strong} encoder implements the following rules:

@itemize
@item
Every input byte whose character representation (according to
@func{integer->char}) is between @samp{#\0} (included) and @samp{#\9}
(included) or between @samp{#\A} (included) and @samp{#\Z} (included) or
between @samp{#\a} (included) and @samp{#\z} (included) is duplicated
``as is'' to the output.  That is the following characters may appear in
the output as one--on--one representation of input bytes:

@example
0 1 2   3 4 5   6 7 8
9

A B C   D E F   G H I
J K L   M N O   P Q R
S T U   V W X   Y Z

a b c   d e f   g h i
j l m   n o p   q r s
t u v   w x y   z
@end example

@item
All the other input bytes are encoded as in upper--case base16 and the
result is appended to the output with a @samp{#\=} character prepended.
So the input byte @math{31} is encoded to the sequence @samp{=1F}.
@end itemize

Notice the @code{default} encoder and the @code{strong} encoder produce
strings which can be correctly processed by the same decoder.

@c page
@node armor qprint encode
@subsection Encoding byte streams with quoted--printable


@deftp Class @aclass{qprint-encode-ctx}
Context descriptor for quoted--printable encoding.  Nothing in records
of this type depends upon the input or output data, so they can be
reused for multiple streams.
@end deftp


@defcv {Immutable Field} @aclass{qprint-encode-ctx} encoding
A Scheme symbol among: @code{default}, @code{strong}.
@end defcv


@defun make-<qprint-encode-ctx> @var{encoding}
Build and return a new record of type @class{qprint-encode-ctx}.
@var{encoding} must be a Scheme symbol among: @code{default},
@code{strong}.
@end defun


@defun <qprint-encode-ctx>? @var{obj}
Return true if @var{obj} is a record of type @class{qprint-encode-ctx}.
@end defun


@defun <qprint-encode-ctx>-encoding @var{ctx}
Accessor for the field of records of type @class{qprint-encode-ctx}.
@end defun


@defun qprint-encode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Encode binary data from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
@ascii{} characters in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); encoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{qprint-encode-ctx}.

Return two values:

@enumerate
@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

Binary data bytes are read from @var{src-bv} in single--byte blocks;
@ascii{} characters are written to @var{dst-bv} as single bytes or as
triplets of bytes.
@end defun


@defun qprint-encode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Encode binary data from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
@ascii{} characters in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); encoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{qprint-encode-ctx}.

Return three values:

@enumerate
@item
A boolean: true if success, false if the output bytevector was filled
before flushing all the bytes.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

Binary data bytes are read from @var{src-bv} in single--byte blocks;
@ascii{} characters are written to @var{dst-bv} as single bytes or as
triplets of bytes.
@end defun

@c page
@node armor qprint decode
@subsection Decoding byte streams with quoted--printable


@deftp Class @aclass{qprint-decode-ctx}
Context descriptor for quoted--printable decoding.  Nothing in records
of this type depends upon the input or output data, so they can be
reused for multiple streams.
@end deftp


@defun make-<qprint-decode-ctx>
@defunx <qprint-decode-ctx>? @var{obj}
Constructor and predicate for records of type @class{qprint-decode-ctx}.
@end defun


@defun qprint-decode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Decode @ascii{} characters from the bytevector @var{src-bv} starting at
index @var{src-start} (included) up to index @var{src-past} (excluded);
store binary data bytes in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); decoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{qprint-decode-ctx}.

Return three values:

@enumerate
@item
A boolean always false.  This value exists to make this @api{} equal to
the one of base64.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is filled to the end, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the
characters from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

@ascii{} characters are read from @var{src-bv} in @math{3}-byte blocks;
binary data bytes are written to @var{dst-bv} in single--byte blocks.
@end defun


@defun qprint-decode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Decode @ascii{} characters from the bytevector @var{src-bv} starting at
index @var{src-start} (included) up to index @var{src-past} (excluded);
store binary data bytes in the bytevector @var{dst-bv} starting at
@var{dst-start} (included); decoding is performed according to the
specification in the context @var{ctx}, which must be a record of type
@class{qprint-decode-ctx}.

Return three values:

@enumerate
@item
A boolean: true if success, false if the output bytevector was filled
before flushing all the bytes.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is filled to the end, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

@ascii{} characters are read from @var{src-bv} in single--byte blocks or
in chunks of @math{3} bytes; binary data bytes are written to
@var{dst-bv} in single--byte blocks.
@end defun

@c page
@node armor qprint utils
@subsection Utilities for quoted--printable encoders and decoders


@defun armored-byte-of-qprint? @var{byte-integer}
Return true if @var{byte-integer} would be encoded as is by the
@code{default} quoted--printable encoder.
@end defun


@defun armored-byte-of-qprint?/strong @var{byte-integer}
Return true if @var{byte-integer} would be encoded as is by the
@code{strong} quoted--printable encoder.
@end defun

@c page
@node armor newlines
@section Newline insertion/removal


The bindings documented in this section are exported by the
@library{armor newlines} library.

@menu
* armor newline insertion::     Inserting sequences of bytes.
* armor newline removal::       Removing sequences of bytes.
@end menu

@c page
@node armor newline insertion
@subsection Inserting sequences of bytes


@deftp Class @aclass{newlines-encode-ctx}
Context record for newline insertion.
@end deftp


@defcv {Immutable Field} @aclass{newlines-encode-ctx} width
The line width in bytes.  This field is immutable.
@end defcv


@defcv {Immutable Field} @aclass{newlines-encode-ctx} sequence
A bytevector representing the newline sequence of characters.  This
field is immutable.
@end defcv


@defcv {Immutable Field} @aclass{newlines-encode-ctx} column
The current colum number.
@end defcv


@defun make-<newlines-encode-ctx> @var{width} @var{sequence} @var{column}
@defunx <newlines-encode-ctx>? @var{obj}
Constructor and predicate for records of type
@class{newlines-encode-ctx}.
@end defun


@defun newlines-encode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Copy bytes from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
the output in the bytevector @var{dst-bv} starting at @var{dst-start}
(included); newline sequences are inserted according to the
specification in the context @var{ctx}, which must be a record of type
@class{newlines-encode-ctx}.

Return two values:

@enumerate
@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate
@end defun


@defun newlines-encode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Copy bytes from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
the output in the bytevector @var{dst-bv} starting at @var{DST-START}
(included); newline sequences are inserted according to the the
specification in the context @var{ctx}, which must be a record of type
@class{newlines-encode-ctx}.

Return three values:

@enumerate
@item
A boolean: true if all the data from @var{src-bv} has been processed,
false otherwise.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate
@end defun

@c page
@node armor newline removal
@subsection Removing sequences of bytes


@deftp Class @aclass{newlines-decode-ctx}
Context record for newline removal.
@end deftp


@defcv {Immutable Field} @aclass{newlines-decode-ctx} sequence
A bytevector representing the newline sequence of characters.
@end defcv


@defun make-<newlines-decode-ctx> @var{sequence}
@defunx <newlines-decode-ctx>? @var{obj}
Constructor and predicate for records of type
@class{newlines-decode-ctx}.
@end defun


@defun newlines-decode-update! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Copy bytes from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
the output in the bytevector @var{dst-bv} starting at @var{dst-start}
(included); newline sequences are removed according to the specification
in the context @var{ctx}, which must be a record of type
@class{newlines-decode-ctx}.

Return three values:

@enumerate
@item
A boolean always false.  This value is here to make this @api{} equal to
the one of the base64 decoder.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate

Bytes are read from @var{src-bv} until their number is less than the
sequence length.
@end defun


@defun newlines-decode-final! @var{ctx} @var{dst-bv} @var{dst-start} @var{src-bv} @var{src-start} @var{src-past}
Copy bytes from the bytevector @var{src-bv} starting at index
@var{src-start} (included) up to index @var{src-past} (excluded); store
the output in the bytevector @var{dst-bv} starting at @var{DST-START}
(included); newline sequences are removed according to the the
specification in the context @var{ctx}, which must be a record of type
@class{newlines-decode-ctx}.

Return three values:

@enumerate
@item
A boolean: true if all the data from @var{src-bv} has been processed,
false otherwise.

@item
The index of the next non--written byte in @var{dst-bv}; if @var{dst-bv}
is left full, this value is the length of @var{dst-bv}.

@item
The index of the next non--read byte in @var{src-bv}; if all the bytes
from @var{src-bv} are consumed, this value is @var{src-past}.
@end enumerate
@end defun

@c page
@node armor examples
@section Examples of encoding and decoding


@menu
* armor examples encode::       Encoding example.
* armor examples decode::       Decoding example.
@end menu

@c page
@node armor examples encode
@subsection Encoding example


Let's say we want to encode with @code{base32} encoding, a byte stream
which comes in three chunks; we want the output to be padded and in
upper case:

@example
(import (nausicaa)
  (armor base32))

(define ctx
  (make-<base32-encode-ctx> 'base32 #t 'upper))
@end example

@noindent
we will need this helper function:

@example
(define (subbytevector src start past)
  (let ((dst (make-bytevector (- past start))))
    (do ((i 0     (+ 1 i))
         (j start (+ 1 j)))
        ((= j past)
         dst)
      (bytevector-u8-set! dst i
          (bytevector-u8-ref src j)))))
@end example

@noindent
the first chunk is @samp{bin-1}, we notice that its length is exactly
@math{5} bytes so the output will be exactly @math{8} characters:

@example
(define bin-1.bv
  '#vu8(0 1 2 3 4))

(define bin-1.len
  (bytevector-length bin-1.bv)) @result{} 5
@end example

@noindent
we allocate the output bytevector:

@example
(define asc-1.len
  (base32-encode-update-length bin-1.len)) @result{} 8

(define asc-1.bv
  (make-bytevector asc-1.len))
@end example

@noindent
and process the data:

@example
(define-values (dst-next-1 src-next-1)
  (base32-encode-update! ctx
                         asc-1.bv 0
                         bin-1.bv 0 bin-1.len))

;; (utf8->string asc-1.bv) @result{} "AAAQEAYE"
;; dst-next-1 @result{} 8
;; src-next-1 @result{} 5
@end example

@noindent
all the input has been consumed and the output bytevector is full.

The second chunk is @samp{bin-2} and we notice that its length is not an
exact multiple of @math{5}:

@example
(define bin-2.bv
  '#vu8(0 1 2 3 4 5 6))

(define bin-2.len
  (bytevector-length bin-2.bv)) @result{} 7

(define asc-2.len
  (base32-encode-update-length bin-2.len)) @result{} 8

(define asc-2.bv
  (make-bytevector asc-2.len))

(define-values (dst-next-2 src-next-2)
  (base32-encode-update! ctx
                         asc-2.bv 0
                         bin-2.bv 0 bin-2.len))

;; (utf8->string (subbytevector asc-2.bv 0 dst-next-2))
;; @result{} "AAAQEAYE"
;; dst-next-2 @result{} 8
;; src-next-2 @result{} 5
@end example

@noindent
the last bytes from the input are still to be consumed; the output
bytevector is full.

The last chunk is @samp{bin-3}, but we have to append it to the leftover
from @samp{bin-2}:

@example
(define bin-3.bv
  '#vu8(0 1 2 3 4 5 6))

(define bin-3.len
  (bytevector-length bin-3.bv)) @result{} 7

(define delta
  (- bin-2.len src-next-2)) @result{} 2

(define bin-23.len
  (+ bin-3.len delta)) @result{} 9

(define bin-23.bv
  (let ((bv (make-bytevector bin-23.len)))
    (do ((i 0          (+ 1 i))
         (j src-next-2 (+ 1 j)))
        ((= i delta))
      (bytevector-u8-set! bv i
          (bytevector-u8-ref bin-2.bv j)))
    (do ((i delta (+ 1 i))
         (j 0     (+ 1 j)))
        ((= j bin-3.len)
         bv)
      (bytevector-u8-set! bv i
          (bytevector-u8-ref bin-3.bv j)))))

(define asc-3.len
  (base32-encode-length bin-23.len #t)) @result{} 16

(define asc-3.bv
  (make-bytevector asc-3.len))

(define-values (result dst-next-3 src-next-3)
  (base32-encode-final! ctx
                        asc-3.bv 0
                        bin-23.bv 0 bin-23.len))

;; (utf8->string asc-3.bv) @result{} "AUDAAAICAMCAKBQ="
;; result     @result{} #t
;; dst-next-3 @result{} 16
;; src-next-3 @result{} 9
@end example

@noindent
all the input has been consumed and the output bytevector is full.  At
the end of it the sequence of bytes:

@example
|0 1 2 3 4|0 1 2 3 4 5 6|0 1 2 3 4 5 6|
|  bin-1  |    bin-2    |    bin-3    |
                    |    bin-23       |
@end example

@noindent
is encoded in the string:

@example
AAAQEAYEAAAQEAYEAUDAAAICAMCAKBQ=
@end example

@c page
@node armor examples decode
@subsection Decoding example


Let's say we want to decode with @code{base32}, a character stream which
comes in three chunks; the stream is padded and in upper case:

@example
(import (nausicaa)
  (armor base32))

(define ctx
  (make-<base32-decode-ctx> 'base32 #t 'upper))
@end example

@noindent
we will need this helper function:

@example
(define (subbytevector src start past)
  (let ((dst (make-bytevector (- past start))))
    (do ((i 0     (+ 1 i))
         (j start (+ 1 j)))
        ((= j past)
         dst)
      (bytevector-u8-set! dst i
          (bytevector-u8-ref src j)))))
@end example

@noindent
the first chunk is @samp{asc-1}, we notice that its length is exactly
@math{8} characters so the output will be exactly @math{5} bytes:

@example
(define asc-1.bv
  (string->utf8 "AAAQEAYE"))

(define asc-1.len
  (bytevector-length asc-1.bv)) @result{} 8

(define bin-1.len
  (base32-decode-update-length asc-1.len)) @result{} 5

(define bin-1.bv
  (make-bytevector bin-1.len))

(define-values (finished-1? dst-next-1 src-next-1)
  (base32-decode-update! ctx
                         bin-1.bv 0
                         asc-1.bv 0 asc-1.len))

;; bin-1.bv    @result{} #vu8(0 1 2 3 4)
;; finished-1? @result{} #f
;; dst-next-1  @result{} 5
;; src-next-1  @result{} 8
@end example

@noindent
all the input has been consumed and the output bytevector is full.

The second chunk is @samp{asc-2} and we notice that its length is not an
exact multiple of @math{8}:

@example
(define asc-2.bv
  (string->utf8 "AAAQEAYEAU"))

(define asc-2.len
  (bytevector-length asc-2.bv)) @result{} 10

(define bin-2.len
  (base32-decode-update-length asc-2.len)) @result{} 5

(define bin-2.bv
  (make-bytevector bin-2.len))

(define-values (finished-2? dst-next-2 src-next-2)
  (base32-decode-update! ctx
                         bin-2.bv 0
                         asc-2.bv 0 asc-2.len))

;; bin-2.bv    @result{} #vu8(0 1 2 3 4)
;; finished-2? @result{} #f
;; dst-next-2  @result{} 5
;; src-next-2  @result{} 8
@end example

@noindent
the last bytes from the input are still to be consumed; the output
bytevector is full.

The last chunk is @samp{asc-3}, but we have to append it to the leftover
from @samp{asc-2}:

@example
(define asc-3.bv
  (string->utf8 "DAAAICAMCAKBQ="))

(define asc-3.len
  (bytevector-length asc-3.bv)) @result{} 14

(define delta
  (- asc-2.len src-next-2)) @result{} 2

(define asc-23.len
  (+ asc-3.len delta)) @result{} 16

(define asc-23.bv
  (let ((bv (make-bytevector asc-23.len)))
    (do ((i 0          (+ 1 i))
         (j src-next-2 (+ 1 j)))
        ((= i delta))
      (bytevector-u8-set! bv i (bytevector-u8-ref asc-2.bv j)))
    (do ((i delta (+ 1 i))
         (j 0     (+ 1 j)))
        ((= j asc-3.len)
         bv)
      (bytevector-u8-set! bv i (bytevector-u8-ref asc-3.bv j)))))

(define bin-3.len
  (base32-decode-length asc-23.len #t)) @result{} 10

(define bin-3.bv
  (make-bytevector bin-3.len))

(define-values (result dst-next-3 src-next-3)
  (base32-decode-final! ctx
                        bin-3.bv 0
                        asc-23.bv 0 asc-23.len))

;; (subbytevector bin-3.bv 0 dst-next-3)
;; @result{} #vu8(5 6 0 1 2 3 4 5 6)
;; result     @result{} #t
;; dst-next-3 @result{}  9
;; src-next-3 @result{} 16
@end example

@noindent
all the input has been consumed and the output bytevector is a bit
oversized, this is because before decoding we do not know if and how
many padding characters are there.  At the end of it the sequence of
characters:

@example
|AAAQEAYE|AAAQEAYEAU|DAAAICAMCAKBQ=|
| asc-1  |  asc-2   |    asc-3     |
                 |     asc-23      |
@end example

@noindent
is decoded in the sequence of bytes:

@example
0 1 2 3 4 0 1 2 3 4 5 6 0 1 2 3 4 5 6
@end example

@c page
@node json
@chapter Parsing and generating @json{} text


The @library{json} library implements a parser which converts @json{}
text to Scheme S-expressions and a set of functions to generate @json{}
text from Scheme values.

@menu
* json intro::                  Introduction to @json{}.
* json decoding::               Decoding @json{} text.
* json encoding::               Encoding @json{} text.
* json error::                  Error handlers and condition objects.
@end menu

@c page
@node json intro
@section Introduction to @json{}


@json{} (JavaScript Object Notation) is a lightweight data--interchange
format; full informations on the notation are available
at:@footnote{@aurl{} last verified Mon May 31, 2010.}

@center @url{http://www.json.org/}

@noindent
the specification is also available in @rfc{} 4627.

The @library{json} library parses @json{} text using the @library{silex
lexer} and @library{lalr lr-driver} libraries; given the terminals,
optionally surrounded by white spaces:

@example
BEGIN_ARRAY             [
END_ARRAY               ]
BEGIN_OBJECT            @{
END_OBJECT              @}
NAME_SEPARATOR          :
VALUE_SEPARATOR         ,

FALSE                   "false"
NULL                    "null"
TRUE                    "true"
@end example

@noindent
with the addition of @samp{NUMBER} and @samp{STRING}, the grammar is:

@example
((json-text     (object)
                (array))

 (object        (BEGIN_OBJECT END_OBJECT)
                (BEGIN_OBJECT pair END_OBJECT)
                (BEGIN_OBJECT pair pair-rest END_OBJECT))

 (pair          (STRING NAME_SEPARATOR value))
 (pair-rest     (VALUE_SEPARATOR pair)
                (VALUE_SEPARATOR pair pair-rest))

 (array         (BEGIN_ARRAY END_ARRAY)
                (BEGIN_ARRAY value END_ARRAY)
                (BEGIN_ARRAY value value-rest END_ARRAY))

 (value         (FALSE)
                (NULL)
                (TRUE)
                (NUMBER)
                (STRING)
                (object)
                (array))
 (value-rest    (VALUE_SEPARATOR value)
                (VALUE_SEPARATOR value value-rest)))
@end example

@library{json} turns @json{} text into a Scheme S--expression; @json{}
pairs become Scheme pairs:

@example
"Height": 600           @expansion{} ("Height" . 600)
"Hello" : "Ciao"        @expansion{} ("Hello"  . "Ciao")
@end example

@noindent
objects become lists:

@example
@{ "Height": 600" @}
@expansion{} (("Height" . 600))

@{ "Height": 600, "Hello" : "Ciao" @}
@expansion{} (("Height" . 600) ("Hello"  . "Ciao"))
@end example

@noindent
arrays become vectors:

@example
[ "Ciao", "Hello", "Salut" ]
@expansion{} #("Ciao" "Hello" "Salut")
@end example

@noindent
the literal @samp{true} becomes @true{}, the literal @samp{false}
becomes @false{}, the literal @samp{null} becomes @code{()}.

@c page
@node json decoding
@section Decoding @json{} text


@menu
* json decoding intro::         Introduction to decoding @json{}.
* json decoding lexer::         Lexing @json{} text.
* json decoding parser::        Parsing @json{} text.
* json decoding string::        Decoding @json{} strings.
@end menu

@c page
@node json decoding intro
@subsection Introduction to decoding @json{}


The @api{} documented in this section allows parsing of @json{} text.
There are two types of parsers: one converting a full @json{} fragment
into an S--expression; one calling functions for each ``event'' in
incoming @json{} text.  To setup conversion to S--expression we do:

@example
(import (rnrs)
  (silex lexer)
  (json))

(define json-text
  "@{ \"Hello\" : true, \"Ciao\": false @}")

(define IS
  (lexer-make-IS (:string json-text)
                 (:counters 'all)))

(define lexer
  (make-json-rfc-lexer IS))

(define parser
  (make-json-parser))

(define (error-handler msg tok)
  (error 'json-parser msg tok))

(parser lexer error-handler)
@result{} (("Hello" . #t) ("Ciao" . #f))
@end example

Here is a set of meaningless examples using the event parser:

@example
(import (nausicaa)
  (json)
  (silex lexer))


(define (doit string)
  (let* ((IS      (lexer-make-IS (:string string)
                                 (:counters 'all)))
         (lexer   (make-json-rfc-lexer IS))
         (result  '())
         (handler (lambda args
                    (set-cons! result args)))
         (parser  (make-json-event-parser
                    (:begin-object  handler)
                    (:end-object    handler)
                    (:begin-array   handler)
                    (:end-array     handler)
                    (:begin-pair    handler)
                    (:end-pair      handler)
                    (:atom          handler))))
    (parser lexer (make-json-error-handler 'json-parser))
    (reverse result)))

(doit "@{ @}")
@result{} '((begin-object) (end-object))

(doit "@{ \"key\" : 123 @}")
@result{} ((begin-object)
    (begin-pair "key")
    (number 123)
    (end-pair)
    (end-object))

(doit "@{ \"key\" : \"value\" @}")
@result{} ((begin-object)
    (begin-pair "key")
    (string "value")
    (end-pair)
    (end-object))

(doit "@{ \"key\" : true, \"yek\": false @}")
@result{} ((begin-object)
    (begin-pair "key")
    (true #t)
    (end-pair)
    (begin-pair "yek")
    (false #f)
    (end-pair)
    (end-object))

(doit "[ 1 ]")
@result{} ((begin-array)
    (number 1)
    (end-array))

(doit "[ 1, 2, 3 ]")
@result{} ((begin-array)
    (number 1)
    (number 2)
    (number 3)
    (end-array))

(doit "[ 1, \"ciao\", true ]")
@result{} '((begin-array)
    (number 1)
    (string "ciao")
    (true #t)
    (end-array))

(doit "[ 1, @{ \"ciao\": 123 @}, true ]")
@result{} ((begin-array)
    (number 1)
    (begin-object)
    (begin-pair "ciao")
    (number 123)
    (end-pair)
    (end-object)
    (true #t)
    (end-array))
@end example

@c page
@node json decoding lexer
@subsection Lexing @json{} text


The following bindings are exported by the @library{json} library.


@defun make-json-rfc-lexer @var{input-system}
Build and return a @library{silex} lexer for @json{} text using
@var{input-system}; the lexer will parse @json{} text conforming to
@rfc{} 4627.

Each time the lexer function is invoked, it returns a
@class{lexical-token} record with category in the following set of
symbols:

@example
BEGIN_ARRAY             END_ARRAY
BEGIN_OBJECT            END_OBJECT
NAME_SEPARATOR          VALUE_SEPARATOR

FALSE TRUE NULL NUMBER STRING
@end example

@noindent
with the addition of @code{*eoi*} for end--of--input and
@code{*lexer-error*} for invalid input.  The semantic values in the
records are the @json{} values converted to Scheme values: strings,
numbers, true, false, null, and characters for the @json{} structural
characters.

When a token with category @code{*lexer-error*} is returned: its
semantic value is set to the offending fragment from the input; at most
@math{10} characters from the input are included, followed by an
ellipsis if the fragment is not at the end of input.  For example the
following @json{} object:

@example
@{ \"Count\" . 12, \"ciao\": false @}
@end example

@noindent
has the dot as first offending character, the @code{*lexer-error*} token
will have the string @code{" . 12, \"ci..."} as semantic value.
@end defun


@defun make-json-extended-lexer @var{input-system}
Like @func{make-json-rfc-lexer} but supports the following non--@rfc{}
extensions:

@itemize
@item
The literal @samp{Infinity} is decoded as the positive infinity,
@samp{+inf.0}.

@item
The literal @samp{-Infinity} is decoded as the negative infinity,
@samp{-inf.0}.

@item
The literal @samp{NaN} is decoded as not--a--number, @samp{+nan.0}.

@item
Numbers are accepted in binary, octal and hexadecimal format when they
are prefixed, respectively, by: @samp{#b} or @samp{#B}, @samp{#o} or
@samp{#O}, @samp{#x} or @samp{#X}.  Decoding is performed by
@func{number->string}.
@end itemize
@end defun


@defun json->tokens @var{input-system}
Read @json{} text from @var{input-system} and return a list of
@class{lexical-token} records.  Processing of input stops at the first
token with category @code{*eoi*} or @code{*lexer-error*}.
@end defun

@c page
@node json decoding parser
@subsection Parsing @json{} text


The following bindings are exported by the @library{json} library.


@defun make-json-parser
Build and return a new @json{} parser using @library{lalr lr-driver};
the returned value is a parser function as described in @ref{lalr
parser}.  The parser function returns the S--expression representing the
@json{} text; notice that strings in the S--expression are @strong{not}
processed by @func{json-decode-string}.
@end defun


@deffn Syntax make-json-event-parser @ameta{clause} ...
Build and return a new @json{} parser which calls provided functions
when parsing elements.  The returned parser function matches the
interface of the parser functions based upon @library{lalr lr-driver}.

Parsing is driven by the clauses described below.
@end deffn


@deffn {Event Parser Clause} :begin-object @var{handler}
Used when the parser receives a @code{BEGIN_OBJECT} token.
@var{handler} is called with the symbol @code{begin-object} as single
argument.
@end deffn


@deffn {Event Parser Clause} :end-object @var{handler}
Used when the parser receives a @code{END_OBJECT} token.  @var{handler}
is called with the symbol @code{end-object} as single argument.
@end deffn


@deffn {Event Parser Clause} :begin-array @var{handler}
Used when the parser receives a @code{BEGIN_ARRAY} token.  @var{handler}
is called with the symbol @code{begin-array} as single argument.
@end deffn


@deffn {Event Parser Clause} :end-array @var{handler}
Used when the parser receives a @code{END_ARRAY} token.  @var{handler}
is called with the symbol @code{end-array} as single argument.
@end deffn


@deffn {Event Parser Clause} :begin-pair @var{handler}
Used when the parser processes the name of a pair.  @var{handler} is
called with the symbol @code{begin-pair} as first argument and the
string representing the pair's name as second argument.
@end deffn


@deffn {Event Parser Clause} :end-pair @var{handler}
Used when the parser terminates processing of a pair.  @var{handler} is
called with the symbol @code{end-pair} as single argument.
@end deffn


@deffn {Event Parser Clause} :atom @var{handler}
Used when the parser parses the value of a pair or an array element
being a string, a literal or a number.  When the value is:

@table @asis
@item A number
@var{handler} is called with the symbol @code{number} as first argument
and the number itself as second argument.

@item A string
@var{handler} is called with the symbol @code{string} as first argument
and the string itself as second argument.  The string is @strong{not}
processed with @func{json-decode-string}.

@item The literal true
@var{handler} is called with the symbol @code{true} as first argument
and @true{} as second argument.

@item The literal false
@var{handler} is called with the symbol @code{false} as first argument
and @false{} as second argument.

@item The literal null
@var{handler} is called with the symbol @code{null} as first argument
and @code{()} as second argument.
@end table
@end deffn

@c page
@node json decoding string
@subsection Decoding @json{} strings


The following bindings are exported by the @library{json} library.


@defun json-decode-string @var{input-string}
Decode a @json{} string returning a Scheme string.  @var{input-string}
must not be enclosed in double quotes.  Examples:

@example
(json-decode-string "")         @result{} ""
(json-decode-string "a")        @result{} "a"
(json-decode-string "ciao")     @result{} "ciao"
(json-decode-string "\\\"")     @result{} "\""
(json-decode-string "\\/")      @result{} "/"
(json-decode-string "\\b")      @result{} "\b"
(json-decode-string "\\f")      @result{} "\f"
(json-decode-string "\\n")      @result{} "\n"
(json-decode-string "\\r")      @result{} "\r"
(json-decode-string "\\t")      @result{} "\t"
(json-decode-string "\\u005C")  @result{} "\\"

(json-decode-string "inizio\\\"\\/\\b\\f\\n\\r\\tfine")
@result{} "inizio\"/\b\f\n\r\tfine"

(json-decode-string "\\u0063\\u0069\\u0061\\u006f")
@result{} "ciao"

(json-decode-string "ciao \\\"hello\\\" salut")
@result{} "ciao \"hello\" salut"
@end example
@end defun

@c page
@node json encoding
@section Encoding @json{} text


@defun json-make-pair @var{name} @var{value}
@defunx json-make-pair @var{name} @var{value} @var{encode-value?}
Build and return a string representing a @json{} pair.

@var{name} must be a string and it is always encoded with
@func{json-encode-string}.

@var{value} can be a string, a number, @true{}, @false{} or @code{()}.
When @var{value} is a string and @var{encode-value?} is true:
@var{value} is encoded with @func{json-encode-string};
@var{encode-value?} defaults to true.
@end defun


@defun json-make-pair* @var{name} @var{value}
@defunx json-make-pair* @var{name} @var{value} @var{encode-value?}
Like @func{json-make-pair} but with the following extensions:

@itemize
@item
If @var{value} is positive infinity, it is encoded as the literal
@samp{Infinity}.

@item
If @var{value} is positive infinity, it is encoded as the literal
@samp{-Infinity}.

@item
If @var{value} is not--a--number, it is encoded as the literal
@samp{NaN}.
@end itemize
@end defun


@defun json-make-object @var{pair} ...
Given a list of strings representing @json{} pairs return a string
representing a @json{} object.
@end defun


@defun json-make-array @var{list-or-vector}
Given a list or vector of strings representing @json{} values return a
string representing a @json{} array.

@example
(json-make-array '("12" "34" "56"))
@result{} "[ 12, 34, 56 ]"

(json-make-array '#("12" "34" "56"))
@result{} "[ 12, 34, 56 ]"
@end example
@end defun


@defun json-encode-string @var{input-string}
Encode a Scheme string to its representation as @json{} string; return a
string.  All the characters whose integer representation is outside the
range @math{[32, 126]} are represented with the @samp{\uXXXX} sequence,
where @samp{X} is a hexadecimal digit.  Examples:

@example
(json-encode-string "")         @result{} ""
(json-encode-string "ciao")     @result{} "ciao"
(json-encode-string "\"")       @result{} "\\\""
(json-encode-string "/")        @result{} "\\/"
(json-encode-string "\b")       @result{} "\\b"
(json-encode-string "\f")       @result{} "\\f"
(json-encode-string "\n")       @result{} "\\n"
(json-encode-string "\r")       @result{} "\\r"
(json-encode-string "\t")       @result{} "\\t"
(json-encode-string " ")        @result{} " "
(json-encode-string "\x127;")   @result{} "\\u0127"
(json-encode-string "\x1234;")  @result{} "\\u1234"
@end example
@end defun

@c page
@node json error
@section Error handlers and condition objects


@menu
* json error conditions::       @json{}--related condition objects.
* json error handlers::         Error handlers for @json{} parsers.
@end menu

@c page
@node json error conditions
@subsection @json{}--related condition objects


@deftp {Condition Type} &json-parser-error
Tag condition objects as being generated by the @json{} parser.  It is
derived from @condition{error}.
@end deftp


@defun make-json-parser-error-condition
Return a new @condition{json-parser-error} condition object.
@end defun


@defun json-parser-error-condition? @var{obj}
Return true if @var{obj} is a condition object of type
@condition{json-parser-error}.
@end defun

@c page
@node json error handlers
@subsection Error handlers for @json{} parsers


@defun make-json-error-handler @var{who}
Return a closure to be used as error handler for @json{} parsers.
@var{who} must be the value for the @condition{who} condition.

When the handler is invoked it raises an exception of types:
@condition{json-parser-error}, @condition{who}, @condition{message},
@condition{irritants}.

The value in the @condition{irritants} object is a list with a single
element: the offending string from the input.
@end defun

@c page
@node net
@chapter Network--related libraries


@menu
* net ipv4address::             IPv4 address objects.
* net ipv6address::             IPv6 address objects.
@end menu

@c page
@node net ipv4address
@section Ipv4 address objects


The library @library{net ipv4addresses} exports utilities to handle IPv4
addresses specifications, according to @rfc{} 5735.

@menu
* net ipv4address lexer::       Tokenising an IPv4 address.
* net ipv4address parser::      Parsing an IPv4 address.
* net ipv4address errors::      Condition objects and error handlers.
* net ipv4address class::       IPv4 address and address prefix
                                class objects.
@end menu

@c page
@node net ipv4address lexer
@subsection Tokenising an Ipv4 address string


The following bindings are exported by the @library{net helpers
ipv4address-lexer} library.


@defvr Constant ipv4-address-lexer-table
A lexer table to be used by @library{silex lexer} to tokenise textual
IPv4 address or IPv4 address prefix representations.
@end defvr


To tokenise an IPv4 address string we can do:

@example
(import (nausicaa)
  (silex lexer)
  (net helpers ipv4address-lexer)
  (parser-tools lexical-token)
  (parser-tools source-location))

(define (make-address-lexer address-string)
  (let ((IS (lexer-make-IS (:string address-string)
                           (:counters 'all))))
    (lexer-make-lexer ipv4-address-lexer-table IS)))
@end example

@noindent
every time the lexer thunk is evaluated, it returns an object of type
@class{lexical-token}.

The token categories are: @code{DOT}, @code{PREFIX-LENGTH},
@code{NUMBER}.  The tokens of category @code{DOT} hold, as semantic
value, the character @code{#\.}; tokens of category @code{NUMBER} hold
as semantic value a number in the input IPv4 address; the tokens of
category @code{PREFIX-LENGTH} hold as semantic value the number of bits
in the prefix as exact integer.

The longest IPv4 address string has: @math{4} numbers as address
components, @math{3} separators between address components, a final
slash and number to specify the address prefix length; the total is
@math{4 + 3 + 1 = 8} tokens.  We may want to use
@func{make-max-count-lexer} from @library{silex utilities} to limit the
number of returned tokens.

@c page
@node net ipv4address parser
@subsection Parsing an IPv4 address


The following bindings are exported by the @library{net helpers
ipv4address-parser} library.


@defun make-ipv4-address-parser
Return a parser function for textual IPv4 address or IPv4 address prefix
representations, it works as described in @ref{lalr parser}; the lexer
must work as described in @ref{net ipv4address lexer}.

The returned parser function, when applied to the lexer and error
handler, returns a list of values representing the address; this list
must be further parsed and validated as described below.
@end defun


To parse an IPv4 address string we can do:

@example
(import (nausicaa)
  (silex lexer)
  (net helpers ipv4address-lexer)
  (net helpers ipv4address-parser)
  (parser-tools lexical-token)
  (parser-tools source-location))

(define (make-ipv4-address-parser-error-handler who string)
  (lambda (message (token <lexical-token>))
    (assertion-violation who
      (let (((pos <source-location>) token.location))
        (string-append "invalid IPv4 address input at column "
                       pos.column-string ": " message))
      string token.value)))

(define (parse-address string)
  (let* ((IS      (lexer-make-IS (:string string)
                                 (:counters 'all)))
         (lexer   (lexer-make-lexer ipv4-address-lexer-table IS))
         (parser  (make-ipv4-address-parser)))
    (parser lexer
            (make-ipv4-address-parser-error-handler
             'parse-address string))))
@end example

@noindent
here are some examples of address parsing:

@example
(parse-address "1.2.3.4")       @result{} (1 2 3 4)
(parse-address "192.168.99.1")  @result{} (192 168 99 1)
@end example

@noindent
and here are some examples of address prefix parsing:

@example
(parse-address "1.2.3.4/8")      @result{} (1 2 3 4 (8))
(parse-address "192.168.99.1/8") @result{} (192 168 99 1 (8))
@end example

From the examples we see that:

@enumerate
@item
If the input is an address prefix: the list has @math{5} elements and
the last element of the returned list is a list of one value, the value
being the prefix length: a number specifying how many of the leftmost
contiguous bits of the address comprise the prefix.

@item
If the input is an address: the list has @math{4} elements and the last
element is a number.
@end enumerate

@c page
@node net ipv4address errors
@subsection Condition objects and error handlers


The following bindings are exported by the @library{net ipv4-addresses}
library.


@deftp {Condition Type} &ipv4-address-parser-error
Tags compound condition objects as raised by the IPv4 parser or lexer.
It is derived from @condition{condition}.
@end deftp


@defun make-ipv4-address-parser-error-condition
Return a new condition object of type
@condition{ipv4-address-parser-error}.
@end defun


@defun ipv4-address-parser-error-condition? @var{obj}
Return true if @var{obj} is a condtion object of type
@condition{ipv4-address-parser-error}.
@end defun


@defun make-ipv4-address-parser-error-handler @var{who} @var{irritants}
@defunx make-ipv4-address-parser-error-handler @var{who} @var{irritants} @var{condition-maker}
Build and return a procedure to be used as error handler by the Ipv4
address and address prefix parsers.  It raises an exception with
compound condition object of types:

@example
&ipv4-address-parser-error
&who
&message
&irritants
@end example

The optional @var{condition-maker} must be a condition object
constructor and defaults to @func{make-error}; its result is added to
the raised compound object.  @var{condition-maker} is meant to be used
to tag the compound object as @condition{error} or
@condition{assertion}.
@end defun

@c page
@node net ipv4address class
@subsection IPv4 address and address prefix class objects


The following bindings are exported by the @library{net ipv4-addresses}
library.


@deftp Class @aclass{ipv4-address}
Represents an IPv4 address.  Its constructor accepts as single argument
the list of numbers returned by the IPv4 address parser, already
validated.

@example
(let (((o <ipv4-address>)
      (make <ipv4-address>
        (ipv4-address-parse "1.2.3.4"))))
  (list o.third o.second o.first o.zeroth))
@result{} (1 2 3 4)
@end example
@end deftp


@defcv {Immutable Field} @aclass{ipv4-address} zeroth
@defcvx {Immutable Field} @aclass{ipv4-address} first
@defcvx {Immutable Field} @aclass{ipv4-address} second
@defcvx {Immutable Field} @aclass{ipv4-address} third
The numeric components of the address, each representing @math{8} bits.
@code{zeroth} is the rightmost component, @code{first} is the second
from the right, etc.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} bignum
A single exact integer of @math{32} bits representing the whole address
number.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} string
The string representation of the address.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} private?
True if the address' prefix is @code{10.0.0.0/8} or
@code{172.16.0.0/12} or @code{192.168.0.0/16}.

See Section 3 ``Global and Other Specialized Address Blocks'' of @rfc{}
5735.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} loopback?
True if the address' prefix is @code{127.0.0.0/8}.

See Section 3 ``Global and Other Specialized Address Blocks'' of @rfc{}
5735.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} localhost?
True if the address is @code{127.0.0.1}.

See Section 3 ``Global and Other Specialized Address Blocks'' of @rfc{}
5735.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} link-local?
True if the address' prefix is @code{169.254.0.0/16}.

See Section 3 ``Global and Other Specialized Address Blocks'' of @rfc{}
5735.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} reserved?
True if the address' prefix is @code{192.0.0.0/24} or
@code{240.0.0.0/4}.

See Section 3 ``Global and Other Specialized Address Blocks'' of @rfc{}
5735.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} test-net-1?
True if the address' prefix is @code{192.0.2.0/24}.

See Section 3 ``Global and Other Specialized Address Blocks'' of @rfc{}
5735.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} six-to-four-relay-anycast?
True if the address' prefix is @code{192.88.99.0/24}.

See Section 3 ``Global and Other Specialized Address Blocks'' of @rfc{}
5735.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} benchmark-tests?
True if the address' prefix is @code{198.18.0.0/15}.

See Section 3 ``Global and Other Specialized Address Blocks'' of @rfc{}
5735.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} test-net-2?
True if the address' prefix is @code{198.51.100.0/24}.

See Section 3 ``Global and Other Specialized Address Blocks'' of @rfc{}
5735.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} test-net-3?
True if the address' prefix is @code{203.0.113.0/24}.

See Section 3 ``Global and Other Specialized Address Blocks'' of @rfc{}
5735.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} multicast?
True if the address' prefix is @code{224.0.0.0/4}.

See Section 3 ``Global and Other Specialized Address Blocks'' of @rfc{}
5735.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address} limited-broadcast?
True if the address prefix is @code{255.255.255.255}.

See Section 3 ``Global and Other Specialized Address Blocks'' of @rfc{}
5735.
@end defcv


@deftp Class @aclass{ipv4-address-prefix}
Represents an IPv4 address prefix; it is derived from
@class{ipv4-address}.  Its constructor accepts two arguments: the list
of numbers returned by the IPv4 address parser, already validated; a
number specifying how many of the leftmost contiguous bits of the
address comprise the prefix.
@end deftp


@defcv {Immutable Field} @aclass{ipv4-address-prefix} prefix-length
A number specifying how many of the leftmost contiguous bits of the
address comprise the prefix.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv4-address-prefix} string
The string representation of the address prefix.
@end defcv

@c page
@node net ipv6address
@section IPv6 address objects


The library @library{net ipv6addresses} exports utilities to handle IPv6
addresses specifications, according to @rfc{} 4291.

@menu
* net ipv6address lexer::       Tokenising an IPv6 address.
* net ipv6address parser::      Parsing an IPv6 address.
* net ipv6address utilities::   IPv6 address parsing utilities.
* net ipv6address errors::      Condition objects and error handlers.
* net ipv6address class::       IPv6 address and address prefix
                                class objects.
@end menu

@c page
@node net ipv6address lexer
@subsection Tokenising an IPv6 address string


The following bindings are exported by the @library{net helpers
ipv6address-lexer} library.


@defvr Constant ipv6-address-lexer-table
A lexer table to be used by @library{silex lexer} to tokenise textual
IPv6 address or IPv6 address prefix representations.
@end defvr


To tokenise an IPv6 address string we can do:

@example
(import (nausicaa)
  (silex lexer)
  (net helpers ipv6address-lexer)
  (parser-tools lexical-token)
  (parser-tools source-location))

(define (make-address-lexer address-string)
  (let ((IS (lexer-make-IS (:string address-string)
                           (:counters 'all))))
    (lexer-make-lexer ipv6-address-lexer-table IS)))
@end example

@noindent
every time the lexer thunk is evaluated, it returns an object of type
@class{lexical-token}.

The token categories are: @code{COLON}, @code{DOT}, @code{SLASH},
@code{NUMBER}.  The tokens of category @code{COLON}, @code{DOT} and
@code{SLASH} hold, as semantic value, the characters @code{#\:},
@code{#\.} and @code{#\/} respectively; the tokens of category
@code{NUMBER} hold as semantic value the string representing a value in
the input IPv6 address.  The interpretation of numbers, especially their
base, cannot be determined by the lexer.

The longest IPv6 address string has: @math{8} numbers as address
components, @math{7} separators between address components, a final
slash and number to specify the address prefix length; the total is
@math{8 + 7 + 2 = 17} tokens.  We may want to use
@func{make-max-count-lexer} from @library{silex utilities} to limit the
number of returned tokens.

@c page
@node net ipv6address parser
@subsection Parsing an IPv6 address


The following bindings are exported by the @library{net helpers
ipv6address-parser} library.


@defun make-ipv6-address-parser
Return a parser function for textual IPv6 address or IPv6 address prefix
representations, it works as described in @ref{lalr parser}; the lexer
must work as described in @ref{net ipv6address lexer}.

The returned parser function, when applied to the lexer and error
handler, returns a list of values representing the address; this list
must be further parsed and validated as described below.
@end defun


To parse an IPv6 address string we can do:

@example
(import (nausicaa)
  (silex lexer)
  (net helpers ipv6address-lexer)
  (net helpers ipv6address-parser)
  (parser-tools lexical-token)
  (parser-tools source-location))

(define (make-ipv6-address-parser-error-handler who string)
  (lambda (message (token <lexical-token>))
    (assertion-violation who
      (let (((pos <source-location>) token.location))
        (string-append "invalid IPv6 address input at column "
                       pos.column-string ": " message))
      string token.value)))

(define (parse-address string)
  (let* ((IS      (lexer-make-IS (:string string)
                                 (:counters 'all)))
         (lexer   (lexer-make-lexer ipv6-address-lexer-table IS))
         (parser  (make-ipv6-address-parser)))
    (parser lexer
            (make-ipv6-address-parser-error-handler
             'parse-address string))))
@end example

@noindent
here are some examples of address parsing:

@example
(parse-address "1:2:3:4:5:6:7:8")
@result{} (1 2 3 4 5 6 7 8)

(parse-address "1::")           @result{} (1 #f)
(parse-address "1::2")          @result{} (1 #f 2)
(parse-address "1:2::3")        @result{} (1 2 #f 3)
(parse-address "1::2:3")        @result{} (1 #f 2 3)
(parse-address "1:2::3:4")      @result{} (1 2 #f 3 4)

(parse-address "::192.168.99.1")
@result{} (#f #xC0A8 #x6301)

(parse-address "1:2:3:4:172.30.67.254")
@result{} (1 2 3 4 #xac1e #x43fe)

(parse-address "1:2:3:4::172.30.67.254")
@result{} (1 2 3 4 #f #xac1e #x43fe)

(parse-address "::1:2:3:4:172.30.67.254")
@result{} (#f 1 2 3 4 #xac1e #x43fe)

(parse-address "1:2::3:4:172.30.67.254")
@result{} (1 2 #f 3 4 #xac1e #x43fe)

(parse-address "::ffff:192.168.99.1")
@result{} (#f #xFFFF #xC0A8 #x6301)
@end example

@noindent
and here are some examples of address prefix parsing:

@example
(parse-address "::1/60")        @result{} (#f 1 (60))
(parse-address "1::/60")        @result{} (1 #f (60))
(parse-address "1::2/60")       @result{} (1 #f 2 (60))
(parse-address "1:2::3/60")     @result{} (1 2 #f 3 (60))
(parse-address "1::2:3/60")     @result{} (1 #f 2 3 (60))
(parse-address "1:2::3:4/60")   @result{} (1 2 #f 3 4 (60))

(parse-address "1:2:3::4:5:6/60")
@result{} (1 2 3 #f 4 5 6 (60))
@end example

From the examples we see that:

@enumerate
@item
If the input is an address prefix: the last element of the returned list
is a list of one value, the value being the prefix length: a number
specifying how many of the leftmost contiguous bits of the address
comprise the prefix.

@item
If the input is an address: the last element is a number or @false{}.

@item
Whenever the input has the double--colon sequence, the returned list has
@false{}; the parser enforces the presence of only one double--colon
sequence.
@end enumerate

The list must be processed and validated as follows:

@enumerate
@item
If the numeric address components are more than @math{8} the address is
invalid.

@item
If the @false{} value is present and the numeric address components are
more than @math{7} the address is invalid; @false{} represents at least
one implicit zero element.

@item
The @false{} value, if present, must be expanded to the number of zeros
required to make the address numeric components of length @math{8}.

@item
The prefix length, if present, must be validated as explained in the
@rfc{} 4291 (Section 2.3 ``Text Representation of Address Prefixes''):
all the bits not in the prefix must be zero.
@end enumerate

@c page
@node net ipv6address utilities
@subsection IPv6 address parsing utilities


The following bindings are exported by the @library{net ipv6-addresses}
library.


@defun ipv6-address-parsed-list-split @var{ell}
Given a list returned by the parser, return two values: the list of
address components, the number of bits in the prefix length or @false{}
if there is no prefix length.

@example
(ipv6-address-parsed-list-split '(1 2 3 #f 4 5))
@result{} (1 2 3 #f 4 5) #f

(ipv6-address-parsed-list-split '(1 2 3 #f 4 5 (60)))
@result{} (1 2 3 #f 4 5) 60
@end example
@end defun


@defun ipv6-address-parsed-list-expand @var{ell}
Given a list returned by the parser, with the prefix length element
stripped, expand the @false{} value if present.  Return the resulting
list or @false{} if the list is invalid.

@example
(ipv6-address-parsed-list-expand '(1 2 3 4 5 6 7 8))
@result{} (1 2 3 4 5 6 7 8)

(ipv6-address-parsed-list-expand '(#f 2 3 4 5 6 7 8))
@result{} (0 2 3 4 5 6 7 8)

(ipv6-address-parsed-list-expand '(1 2 3 #f 5 6 7 8))
@result{} (1 2 3 0 5 6 7 8)

(ipv6-address-parsed-list-expand '(1 2 3 4 5 6 7 #f))
@result{} (1 2 3 4 5 6 7 0)

(ipv6-address-parsed-list-expand '(1 2 #f 6 7 8))
@result{} (1 2 0 0 0 6 7 8)

(ipv6-address-parsed-list-expand '(#f 4 5 6 7 8))
@result{} (0 0 0 4 5 6 7 8)

(ipv6-address-parsed-list-expand '(1 2 3 4 5 #f))
@result{} (1 2 3 4 5 0 0 0)
@end example
@end defun

@defun ipv6-address-parsed-list-validate-prefix @var{number-of-bits-in-prefix} @var{ell}
Given the number of bits in the prefix and the expanded list returned by
the parser (of length @math{8}): return true if all the unused bits are
set to zero; else return false.

@example
(ipv6-address-parsed-list-validate-prefix 60
   '(1 2 3 4 0 0 0 0))
@result{} #t

(ipv6-address-parsed-list-validate-prefix (* 16 7)
    '(1 2 3 4 0 0 0 0))
@result{} #t

(ipv6-address-parsed-list-validate-prefix (* 16 2)
    '(1 2 3 4 0 0 0 0))
@result{} #f
@end example
@end defun


@deffn Syntax make-ipv6-address-lexer @ameta{clause}
Evaluate to a IPv6 address and address prefix lexer, taking input as
specified by @ameta{clause}.

@ameta{clause} can be one of the @code{:string}, @code{:port},
@code{:procedure} clauses of @func{lexer-make-IS}, @ref{silex input} for
details.
@end deffn


@defun make-ipv6-address-parser @var{who} @var{lexer} @var{irritants}
Return a parser function which, when evaluated, returns a list
representing a parsed IPv6 address or address prefix.  @var{lexer} must
be an appropriate lexer function.

@var{who} and @var{irritants} are used as condition object components
when an error occurs.  If parsing fails: an exception is raised with
compound condition objects of types
@condition{ipv6-address-parser-error}, @condition{error},
@condition{who}, @condition{message}, @condition{irritants}.
@end defun


@defun ipv6-address-parse @var{string}
Parse @var{string} as IPv6 address and return a validated list of
@math{8} numbers representing the numerical components of the address.

If an error occurs: an exception is raised with compound condition
objects of types @condition{ipv6-address-parser-error},
@condition{error}, @condition{who}, @condition{message},
@condition{irritants}.
@end defun


@defun ipv6-address-prefix-parse @var{string}
Parse @var{string} as IPv6 address prefix and return two values: a
validated list of @math{8} numbers representing the numerical components
of the address, a number specifying how many of the leftmost contiguous
bits of the address comprise the prefix.

If an error occurs: an exception is raised with compound condition
objects of types @condition{ipv6-address-parser-error},
@condition{error}, @condition{who}, @condition{message},
@condition{irritants}.
@end defun

@c page
@node net ipv6address errors
@subsection Condition objects and error handlers


The following bindings are exported by the @library{net ipv6-addresses}
library.


@deftp {Condition Type} &ipv6-address-parser-error
Tags compound condition objects as raised by the IPv6 parser or lexer.
It is derived from @condition{condition}.
@end deftp


@defun make-ipv6-address-parser-error-condition
Return a new condition object of type
@condition{ipv6-address-parser-error}.
@end defun


@defun ipv6-address-parser-error-condition? @var{obj}
Return true if @var{obj} is a condtion object of type
@condition{ipv6-address-parser-error}.
@end defun


@defun make-ipv6-address-parser-error-handler @var{who} @var{irritants}
@defunx make-ipv6-address-parser-error-handler @var{who} @var{irritants} @var{condition-maker}
Build and return a procedure to be used as error handler by the IPv6
address and address prefix parsers.  It raises an exception with
compound condition object of types:

@example
&ipv4-address-parser-error
&who
&message
&irritants
@end example

The optional @var{condition-maker} must be a condition object
constructor and defaults to @func{make-error}; its result is added to
the raised compound object.  @var{condition-maker} is meant to be used
to tag the compound object as @condition{error} or
@condition{assertion}.
@end defun

@c page
@node net ipv6address class
@subsection IPv6 address and address prefix class objects


The following bindings are exported by the @library{net ipv6-addresses}
library.


@deftp Class @aclass{ipv6-address}
Represents an IPv6 address.  Its constructor accepts as single argument
the list of numbers returned by the IPv6 address parser, already
validated.

@example
(let (((o <ipv6-address>)
      (make <ipv6-address>
        (ipv6-address-parse "1:2:3:4:5:6:7:8"))))
  (list o.seventh o.sixth o.fifth o.fourth
        o.third o.second o.first o.zeroth))
@result{} (1 2 3 4 5 6 7 8)
@end example
@end deftp


@defcv {Immutable Field} @aclass{ipv6-address} zeroth
@defcvx {Immutable Field} @aclass{ipv6-address} first
@defcvx {Immutable Field} @aclass{ipv6-address} second
@defcvx {Immutable Field} @aclass{ipv6-address} third
@defcvx {Immutable Field} @aclass{ipv6-address} fourth
@defcvx {Immutable Field} @aclass{ipv6-address} fifth
@defcvx {Immutable Field} @aclass{ipv6-address} sixth
@defcvx {Immutable Field} @aclass{ipv6-address} seventh
The numeric components of the address, each representing @math{16} bits.
@code{zeroth} is the rightmost component, @code{first} is the second
from the right, etc.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv6-address} bignum
A single big exact integer of @math{128} bits representing the whole
address number.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv6-address} string
The string representation of the address.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv6-address} unspecified?
@defcvx {Immutable Virtual Field} @aclass{ipv6-address} loopback?
@defcvx {Immutable Virtual Field} @aclass{ipv6-address} multicast?
@defcvx {Immutable Virtual Field} @aclass{ipv6-address} link-local-unicast?
@defcvx {Immutable Virtual Field} @aclass{ipv6-address} global-unicast?
True if the address has type, respectively: unspecified, loopback,
multicast, link--local unicast, global unicast.  See Section 2.4
``Address Type Identification'' of @rfc{} 4291.
@end defcv


@deftp Class @aclass{ipv6-address-prefix}
Represents an IPv6 address prefix; it is derived from
@class{ipv6-address}.  Its constructor accepts two arguments: the list
of numbers returned by the IPv6 address parser, already validated; a
number specifying how many of the leftmost contiguous bits of the
address comprise the prefix.
@end deftp


@defcv {Immutable Field} @aclass{ipv6-address-prefix} prefix-length
A number specifying how many of the leftmost contiguous bits of the
address comprise the prefix.
@end defcv


@defcv {Immutable Virtual Field} @aclass{ipv6-address-prefix} string
The string representation of the address prefix.
@end defcv

@c page
@node uri
@chapter Uniform resource identifiers


The @library{uri} library implements a parser and class type to handle
@uri{}s compliant with @rfc{} 3986.@footnote{@aurl{} last verified Thu
Jun 17, 2010:

@center @url{http://datatracker.ietf.org/doc/rfc3986/}
}

@menu
* uri string::                  Plain conversion between strings
                                and bytevectors.
* uri percent::                 Percent encoding of characters.
@end menu

@c page
@node uri string
@section Plain conversion between strings and bytevectors


The following bindings are exported by the @library{uri low} library; it
is suggested to prefix them when importing this library.


@defun to-bytevector @var{obj}
If @var{obj} is a bytevector: @var{obj} itself is returned.  If
@var{obj} is a string: convert it to a bytevector representation;
characters are taken from @var{obj} and inserted into the resulting
bytevector after decoding them, char to byte, as @ascii{}.
@end defun


@defun to-string @var{obj}
If @var{obj} is a string: @var{obj} itself is returned.  If @var{obj} is
a bytevector: convert it to a string representation; bytes are taken
from @var{obj} and inserted into the resulting string after encoding
them, byte to char, as @ascii{}.
@end defun

@c page
@node uri percent
@section Percent encoding of characters


A string is valid as @uri{} component only if its characters match the
following @library{silex} specification:

@example
ALPHA           [a-zA-Z]
DIGIT           [0-9]
HEXDIG          [0-9a-fA-F]

pct-encoded     %@{HEXDIG@}@{HEXDIG@}

gen-delims      [:/\?#\[\]@@]
sub-delims      [\!\$&\'()\*\+,\;=]

reserved        @{gen-delims@}|@{sub-delims@}
unreserved      @{ALPHA@}|@{DIGIT@}|[\-\._~]
@end example

@noindent
@ref{silex syntax} for the syntax of the specification.  All the
characters which are not unreserved are meant to be percent--encoded in
a @uri{} string; in particular the following must be encoded:

@example
: / ? # [ ] @ \ ! $ & ' ( ) * + , ; =
@end example

@noindent
the characters in the unreserved set can, but should not, be encoded.

The following bindings are exported by the @library{uri low} library; it
is suggested to prefix them when importing this library.


@defun unreserved-char? @var{obj}
Return true if @var{obj} represents an unreserved character according to
@rfc{} 3986.  @var{obj} can be either a character or an integer
representing a character according to @func{char->integer}.
@end defun


@deffn Syntax percent-encode @ameta{obj} @ameta{clause} ...
This syntax is a maker, @nauref{makers, Maker syntaxes}.
Percent--encode the given object, return the result; characters outside
a selected range are percent--encoded.

@var{obj} must be an expression evaluating to any character, or string,
or bytevector; the character is converted to a string and the string is
converted to a bytevector with @func{string->utf8}.

The following clauses are supported:

@table @code
@item :char-selector @var{pred}
@var{pred} must be a predicate function which, applied to an integer
representing a character according to @func{char->integer}, returns true
if the character must be percent encoded.  The default is to encode all
the character not unreserved.

@item :string-result? @var{bool}
If @var{bool} is true: return a string, else return a bytevector; the
default is to return a bytevector.
@end table
@end deffn


@deffn Syntax percent-decode @ameta{obj} @ameta{clause} ...
This syntax is a maker, @nauref{makers, Maker syntaxes}.
Percent--decode the given @var{obj}, return the result.

@var{obj} must be an expression evaluating to any string or bytevector;
the string is converted to a bytevector with @func{string->utf8}.

The following clauses are supported:

@table @code
@item :string-result? @var{bool}
If @var{bool} is true: return a string, else return a bytevector; the
default is to return a bytevector.
@end table
@end deffn


@defun normalise-percent-encoded-bytevector @var{bv}
Normalise the given percent--encoded bytevector; bytes that are encoded
but should not are decoded; return the normalised bytevector.  Assume
that @var{bv} is composed by bytes in the valid range for @uri{}s.

Notice that this function does @strong{not} percent--encode bytes which
are already not so.
@end defun


@defun normalise-percent-encoded-string @var{str}
Normalise the given percent--encoded string; characters that are encoded
but should not are decoded; return the normalised string.  Assume that
@var{str} is composed by characters in the valid range for @uri{}s.

Notice that this function does @strong{not} percent--encode characters
which are already not so.
@end defun

@c page
@node interps
@chapter Evaluating code in a limited environment


The @library{interps} library exports an interface to @rsixlibrary{eval}
which allows evaluation of code in chunks with retention of global
variables; @library{interps} uses the facilities of @library{classes}.
Evaluation of code is handled by ``interpreter'' objects; examples:

@example
(import (nausicaa) (interps))

(let (((o <interp>) (make* <interp>
                      (:imports '((rnrs))))))
  (o.eval '(let ()
             (define a 1)
             (define b 2)
             (+ a b))))
@result{} 3

(let (((o <interp>) (make* <interp>
                      (:imports '((rnrs))))))
  (o.eval '(let ()
             (define-global a 1)
             #f))
  (o.eval '(+ a 2)))
@result{} 3
@end example

@menu
* interps conditions::          Errors in limited evaluation.
* interps class::               Interpreter objects.
* interps eval::                Semantics of code evaluation.
* interps examples::            Interpreter user examples.
@end menu

@c page
@node interps conditions
@section Errors in limited evaluation


Whenever evaluation of code in an interpreter fails: an exception is
raised with compound condition object of type @condition{interp-error}.
The following bindings are exported by the @library{interps} library.


@deftp {Condition Type} &interp-error
Tag a compound condition object as being an error in interpreted code;
it is derived from @condition{error}.
@end deftp


@defun make-interp-error-condition @var{interp}
Build and return a new condition object of type @condition{interp-error}
representing an error in code evaluation for @var{interp}, which must be
an @class{interp} object.
@end defun


@defun interp-error-condition? @var{obj}
Return true if @var{obj} is a condition object of type
@condition{interp-error}.
@end defun


@defun condition-interp-error/interp @var{interp-error}
Given an argument of type @condition{interp-error} return the
interpreter object in which the error occurred.
@end defun

@c page
@node interps class
@section Interpreter objects


The following bindings are exported by the @library{interps} library.


@deftp Class @aclass{interp}
Hold the state of subsequent code evaluations.
@end deftp


@defcv {Immutable Field} @aclass{interp} table-of-variables
A hash table mapping Scheme symbols to values; one for each persistent
variable currently in the interpreter.
@end defcv


@defcv {Immutable Field} @aclass{interp} eval-environment
The environment object to be used when evaluating code in the
interpreter.
@end defcv


@deffn Syntax {make @aclass{interp}} @ameta{import specs}
Expand to an expression which evaluates to a new @class{interp} object.

@meta{import specs} must be an expression evaluating to a list of
library import specifications; the list is used to build the environment
in which code will be evaluated.  The environment cannot be modified.
@end deffn


@deffn Syntax {make* @aclass{interp}} @ameta{clause}
This syntax is a maker, @nauref{makers, Makers}.  Expand to an
expression which evaluates to a new @class{interp} object.  The
following clauses are recognised:

@table @code
@item :imports @cmeta{import specs}
@meta{import specs} must be an expression evaluating to a list of
library import specifications; the list is used to build the environment
in which code will be evaluated.  The environment cannot be modified.
The default value causes the @library{rnrs} library to be imported.
@end table
@end deffn


@defmethod @aclass{interp} eval @var{sexp}
Evaluate @var{sexp} in the environment of the interpreter.  Return the
return value of the expression; @var{sexp} must return a single value.
@end defmethod


@defmethod @aclass{interp} variable-ref @var{varname} @var{default}
Retrieve the value of variable name @var{varname}, a Scheme symbol;
return @var{default} if the variable is not defined.
@end defmethod


@defmethod @aclass{interp} variable-set! @var{varname} @var{obj}
Set @var{obj} as new value for variable @var{varname}, a Scheme symbol.
If such a variable does not exist: it is created.
@end defmethod

@c page
@node interps eval
@section Semantics of code evaluation


The following bindings are available to the code evaluated in an
interpreter.


@deffn Syntax define-global @ameta{varname}
@deffnx Syntax define-global @ameta{varname} @ameta{expression}
@deffnx Syntax define-global (@ameta{varname} . @ameta{formals}) @ameta{expression}
Define a global variable which will persist between successive code
evaluations.  The first form binds @meta{varname} to the sentinel value,
@nauref{sentinel, The sentinel value} for details.

What @func{define-global} does is to create an identifier macro which
accesses and mutates an entry in the interp's table of variables; by
default: when code is evaluated in an interp, all the global variables
are bound at the top level, but @func{define-global} can be used
anywhere definitions are allowed to define, access and mutate global
variables.
@end deffn

@c page
@node interps examples
@section Interpreter user examples


Plain expression evaluation:

@example
(import (nausicaa) (interps))

(let (((o <interp>) (make <interp> '((rnrs)))))
  (o.eval '(+ 1 2)))
@result{} 3
@end example

@noindent
variables definitions:

@example
(import (nausicaa) (interps))

(let* (((o <interp>) (make <interp> '((rnrs))))
       (return-value (o.eval '(let ()
                                (define-global woppa)
                                (define-global wippa 456)
                                (set! woppa 123)
                                (list woppa wippa)))))
  (list (o.variable-ref 'woppa #f)
        (o.variable-ref 'wippa #f)
        return-value))
@result{} (123 456 (123 456))
@end example

@noindent
set a variable in one @func{eval}, retrieve its value in a subsequent
@func{eval}:

@example
(import (nausicaa) (interps))

(let (((o <interp>) (make <interp> '((rnrs)))))
  (o.eval '(let ()
             (define-global woppa 123)
             #f))
  (o.eval 'woppa))
@result{} 123
@end example

@noindent
predefine a variable and retrieve its value in a subsequent @func{eval}:

@example
(import (nausicaa) (interps))

(let (((o <interp>) (make <interp> '((rnrs)))))
  (o.variable-set! 'woppa 123)
  (o.eval '(begin woppa)))
@result{} 123
@end example

@noindent
function evaluation:

@example
(let (((o <interp>) (make <interp> '((rnrs)))))
  (o.eval '(let ()
             (define-global (woppa a)
               (cons 123 a))
             #f))
  (o.eval '(woppa #\b)))
@result{} (123 . #\b)
@end example

@c page
@node libraries
@chapter Libraries inspection


The @library{libraries} library implements routines to inspect
@func{library} forms as defined by @rnrs{6}.

@menu
* libraries jargon::            Definition of terms.
* libraries names::             Handling @rnrs{6} library names.
* libraries references::        Handling @rnrs{6} library references.
* libraries imports::           Handling @rnrs{6} library import
                                specifications.
* libraries searching::         Finding libraries on the system.
* libraries libraries::         Handling @rnrs{6} libraries.
@end menu

@c page
@node libraries jargon
@section Definition of terms


@subsubheading List of renamings


A ``list of renamings'' is a list of lists; each sublist has two symbols
as elements:

@example
((@cmeta{internal symbol0}      @cmeta{external symbol0})
 (@cmeta{internal symbol}       @cmeta{external symbol})
 ...)
@end example

@noindent
a list of renamings represents the identifiers exported by a library or
the identifiers imported by a library.

In the first case: the external symbol is the one visible by code which
imports this library; the internal symbol is the one bound with
@func{define} or @func{define-syntax} in the body of this library.

In the second case: the external symbol is the one visible in the body
of this library; the internal symbol is the one exported by the imported
library.

If we know the library reference and the list of renamings, we can build
an import set with:

@example
(only (rename <library reference> . <renamings>))
@end example

@c page
@node libraries names
@section Handling @rnrs{6} library names


The bindings documented in this section are exported by the
@library{libraries names} library.

@menu
* libraries names typedefs::    Type definitions.
* libraries names utilities::   Utility functions.
@end menu

@c page
@node libraries names typedefs
@subsection Type definitions


@deftp Class @aclass{library-name}
Class type representing library names as specified by @rnrs{6}.
@end deftp


@defcv {Immutable Field} @aclass{library-name} identifiers
List of identifiers in the library reference specification.
@end defcv


@defcv {Immutable Field} @aclass{library-name} version
The version specification as a, possibly null, list of exact,
non--negative, integers.
@end defcv


@defun make-<library-name> @var{sexp}
Parse @var{sexp} as an symbolic expression representing a library name
as specified by @rnrs{6}; build and return a new @class{library-name}
object representing it.  If @var{sexp} is not valid: raise an assertion
violation.
@end defun


@defun <library-name>? @var{obj}
Return @true{} if @var{obj} is an object of type @class{library-name}.
@end defun


@defun <library-name>-identifiers @var{name}
@defunx <library-name>-version @var{name}
Accessors for the fields of @class{library-name} objects.
@end defun


@deftypemethod @aclass{library-name} <boolean> identifiers=? (@var{name} @aclass{library-name})
Return @true{} if the arguments are library names having equal list of
identifiers; else return @false{}.
@end deftypemethod


@deftypemethod @aclass{library-name} <boolean> = (@var{name} @aclass{library-name})
@deftypemethodx @aclass{library-name} <boolean> < (@var{name} @aclass{library-name})
@deftypemethodx @aclass{library-name} <boolean> <= (@var{name} @aclass{library-name})
Return @true{} if the arguments have equal list of identifiers and
version specifications satisfying the selected predicate; else return
@false{}.
@end deftypemethod


Examples:

@example
(let ((a (make-<library-name> '(x y (1 2))))
      (b (make-<library-name> '(x y (1 3))))
      (c (make-<library-name> '(x y (1 4))))
      (d (make-<library-name> '(x y (2 1)))))

  (list-sort (lambda/with ((a <library-name>) (b <library-name>))
               (a.< b))
    (list a d c b))
  @result{} (list a b c d)

  )
@end example


@c page
@node libraries names utilities
@subsection Utility functions


@defun library-name? @var{obj}
Return @true{} if @var{obj} is a valid library name as specified by
@rnrs{6}.
@end defun


@defun library-name-decompose @var{obj}
Interpret @var{obj} as an symbolic expression representing a library
name as specified by @rnrs{6}.  Return two values: the list of
identifiers, the version specification.  If @var{obj} is not a valid
library name: return @false{} and @false{}.
@end defun


@defun library-name->identifiers @var{obj}
If @var{obj} is a valid library name as specified by @rnrs{6}, return
the list of identifiers; else return @false{}.
@end defun


@defun library-name->version @var{obj}
If @var{obj} is a valid library name as specified by @rnrs{6}, return
the version specification; else return @false{}.
@end defun


@defun library-name-identifiers=? @vari{name} @varii{name}
Return @true{} if the arguments are library names having equal list of
identifiers; else return @false{}.  If the arguments are not valid
library names: the behaviour of this function is undefined.
@end defun


@defun library-name=? @vari{name} @varii{name}
@defunx library-name<? @vari{name} @varii{name}
@defunx library-name<=? @vari{name} @varii{name}
Return @true{} if the arguments are library names having equal list of
identifiers and version specifications satisfying the selected
predicate; else return @false{}.  If the arguments are not valid library
names: the behaviour of this function is undefined.
@end defun


@defun library-version=? @vari{version} @varii{version}
@defunx library-version<? @vari{version} @varii{version}
@defunx library-version<=? @vari{version} @varii{version}
Return @true{} if the arguments are library versions satisfying the
selected predicate; else return @false{}.  If the arguments are not
valid library names: the behaviour of this function is undefined.
@end defun

@c page
@node libraries references
@section Handling @rnrs{6} library references

The bindings documented in this section are exported by the
@library{libraries references} library.

@menu
* libraries references typedefs::   Type definitions.
* libraries references utilities::  Utility functions.
@end menu

@c page
@node libraries references typedefs
@subsection Type definitions


@deftp Class @aclass{library-reference}
Class type representing library references as specified by @rnrs{6}.
@end deftp


@defcv {Immutable Field} @aclass{library-reference} identifiers
List of identifiers in the library reference specification.
@end defcv


@defcv {Immutable Field} @aclass{library-reference} version-reference
The version specification as a, possibly null, list of exact,
non--negative, integers.
@end defcv


@defcv {Immutable Field} @aclass{library-reference} reference
The full library reference specification.
@end defcv


@defun make-<library-reference> @var{sexp}
Parse @var{sexp} as an symbolic expression representing a library
reference as specified by @rnrs{6}; build and return a new
@class{library-reference} object representing it.  If @var{sexp} is not
valid: raise an assertion violation.
@end defun


@defun <library-reference>? @var{obj}
Return @true{} if @var{obj} is an object of type @class{library-reference}.
@end defun


@defun <library-reference>-identifiers @var{reference}
@defunx <library-reference>-version-reference @var{reference}
Accessors for the fields of @class{library-reference} objects.
@end defun


@deftypemethod @aclass{library-reference} @aclass{boolean} conforming? (@var{name} @aclass{library-name})
Return @true{} if the name conforms to the reference; else return
@false{}.
@end deftypemethod

@c page
@node libraries references utilities
@subsection Utility functions


@defun library-reference? @var{obj}
Return @true{} if @var{obj} is a valid library reference as specified by
@rnrs{6}.
@end defun


@defun library-reference-decompose @var{obj}
Interpret @var{obj} as an symbolic expression representing a library
reference as specified by @rnrs{6}.  Return two values: the list of
identifiers, the version reference.  If @var{obj} is not a valid library
reference: return @false{} and @false{}.
@end defun


@defun library-reference->identifiers @var{obj}
If @var{obj} is a valid library reference as specified by @rnrs{6},
return the list of identifiers; else return @false{}.
@end defun


@defun library-reference->version @var{obj}
If @var{obj} is a valid library reference as specified by @rnrs{6},
return the version reference; else return @false{}.
@end defun


@defun library-reference-identifiers=? @vari{reference} @varii{reference}
Return @true{} if the arguments are library references having equal list
of identifiers; else return @false{}.  If the arguments are not valid
library references: the behaviour of this function is undefined.
@end defun


@defun conforming-sub-version-and-sub-version-reference? @var{sub-version} @var{sub-version-reference}
Interpret @var{sub-version} as a sub--version number as specified by
@rnrs{6} and @var{sub-version-reference} as a sub--version reference as
specified by @rnrs{6}.  Return @true{} if the sub--version conforms to
the sub--version reference; else return @false{}.  If the arguments are
not valid sub--version and sub--version reference: the behaviour of this
function is undefined.
@end defun


@defun conforming-version-and-version-reference? @vari{version} @varii{version-reference}
Interpret @var{version} as a version symbolic expression as specified by
@rnrs{6} and @var{version-reference} as a version reference symbolic
expression as specified by @rnrs{6}.  Return @true{} if the version
conforms to the version reference; else return @false{}.  If the
arguments are not valid version and version reference: the behaviour of
this function is undefined.
@end defun


@defun conforming-library-name-and-library-reference? @var{name} @var{reference}
Interpret @var{name} as a library name symbolic expression as specified
by @rnrs{6} and @var{reference} as a library reference symbolic
expression as specified by @rnrs{6}.  Return @true{} if the name
conforms to the reference; else return @false{}.  If the arguments are
not valid name and reference: the behaviour of this function is
undefined.
@end defun

@c page
@node libraries imports
@section Handling @rnrs{6} library import specifications


The bindings documented in this section are exported by the
@library{libraries import-specs} library.

@menu
* libraries imports typedefs::  Type definitions.
* libraries imports utilities:: Utility functions.
@end menu

@c page
@node libraries imports typedefs
@subsection Type definitions


@subsubheading Import sets


@deftp Class @aclass{import-set}
Type representing import sets as specified by @rnrs{6}.
@end deftp


@defcv {Immutable Field} @aclass{import-set} subset
The core of this import set; it can be another @class{import-set} object
or a @class{library-reference} object.
@end defcv


@defcv {Immutable Field} @aclass{import-set} bindings-transformer
A function to apply to a list renamings to obtain the imported bindings.
@end defcv


@defcv {Immutable Field} @aclass{import-set} original
The original symbolic expression of this import set.
@end defcv


@defcv {Immutable Field} @aclass{import-set} library-reference
The @class{library-reference} object nested in this import set.
@end defcv


@defun make-<import-set> @var{sexp}
Parse the symbolic expression @var{sexp} as an import sets as specified
by @rnrs{6}; return a new @class{import-set} object.  Raise an assertion
violation if @var{sexp} is invalid.
@end defun


@defun <import-set>? @var{obj}
Return @true{} if @var{obj} is a record of type @class{import-set}.
@end defun


@defun <import-set>-subset @var{iset}
@defunx <import-set>-bindings-transformer @var{iset}
@defunx <import-set>-original @var{iset}
@defunx <import-set>-library-reference @var{iset}
Accessors for the fields of @class{import-set} records.
@end defun


@defmethod @aclass{import-set} apply @var{renamings}
Apply the import set specification to the list of @var{renamings},
returning the processed list of renamings (which can be null).  It
applies recursively the specifications of the nested import sets.
@end defmethod

@c ------------------------------------------------------------

@subsubheading Import specifications


@deftp Class @aclass{import-spec}
Type representing import specifications as specified by @rnrs{6}.
@end deftp


@defcv {Immutable Field} @aclass{import-spec} import-set
The core of this import specification; it can be an @class{import-set}
object or a @class{library-reference} object.
@end defcv


@defcv {Immutable Field} @aclass{import-spec} import-levels
A list of exact integers representing the import levels for which this
import set was requested.  It contains at least one element.
@end defcv


@defcv {Immutable Field} @aclass{import-spec} original
The original symbolic expression of this import set.
@end defcv


@defcv {Immutable Field} @aclass{import-spec} library-reference
The @class{library-reference} object nested in this import set.
@end defcv


@defun make-<import-spec> @var{sexp}
Parse the symbolic expression @var{sexp} as an import specification as
specified by @rnrs{6}; return a new @class{import-spec} object.  Raise
an assertion violation if @var{sexp} is invalid.
@end defun


@defun <import-spec>? @var{obj}
Return @true{} if @var{obj} is a record of type @class{import-spec}.
@end defun


@defun <import-spec>-import-set @var{iset}
@defunx <import-spec>-import-levels @var{iset}
@defunx <import-spec>-original @var{iset}
@defunx <import-spec>-library-reference @var{iset}
Accessors for the fields of @class{import-spec} records.
@end defun


@defmethod @aclass{import-spec} apply @var{renamings}
Apply the import set specification to the list of @var{renamings},
returning the processed list of renamings (which can be null).  It
applies recursively the specifications of the nested import sets.

@example
(let-fields (((o <import-spec>)
              (make <import-spec>
                '(prefix
                     (except
                       (only
                         (rename (alpha beta (1))
                                 (ae aee)
                                 (be bee)
                                 (ce cee))
                          bee cee)
                       bee)
                    px:))))
  (o.apply '((a ae)
             (b be)
             (c ce)
             (d de)
             (f fe)
             (g ge))))
@result{} ((c px:cee))
@end example
@end defmethod

@c page
@node libraries imports utilities
@subsection Utility functions


@defun apply-import-spec/only renamings list-of-identifiers
Apply the @code{only} import specification.  @var{renamings} must be a
list of renamings.  @var{list-of-identifiers} must be the list of
symbols to accept in the @var{renamings}, all the others are discarded.

@example
(apply-import-spec/only '((a ea) (b eb) (c ec))
                        '(eb ec))
@result{} ((b eb) (c ec))
@end example
@end defun


@defun apply-import-spec/except @var{renamings} @var{list-of-identifiers}
Apply the @code{except} import specification.  @var{renamings} must be a
list of renamings.  @var{list-of-identifiers} must be the list of
symbols to discard in the @var{renamings}, all the others are accepted.

@example
(apply-import-spec/except '((a ea) (b eb) (c ec))
                          '(eb ec))
@result{} ((a ea))
@end example
@end defun


@defun apply-import-spec/prefix @var{renamings} @var{prefix-symbol}
Apply the @code{prefix} import specification.  @var{renamings} must be a
list of renamings.  @var{prefix-symbol} must be the symbol to prefix to
the second symbol in the @var{renamings}.

@example
(apply-import-spec/prefix '((a ea) (b eb) (c ec))
                          'ciao:)
@result{} ((a ciao:ea) (b ciao:eb) (c ciao:ec))
@end example
@end defun


@defun apply-import-spec/rename @var{renamings} @var{renamings-spec}
Apply the @code{rename} import specification.  @var{renamings} must be a
list of renamings.  @var{renamings-spec} must be the list of renamings
specifying the rename operation for @var{renamings}.

@example
(apply-import-spec/rename '((a ea) (b eb) (c ec))
                          '((eb ebb) (ec ecc)))
@result{} ((a ea) (b ebb) (c ecc))
@end example
@end defun

@c page
@node libraries searching
@section Finding libraries on the system


The bindings documented in this section are exported by the
@library{libraries} library.

@menu
* libraries searching system::  Searching libraries on file systems.
@end menu

@c page
@node libraries searching system
@subsection Searching libraries on file systems


@subsubheading Search path


@deffn Parameter library-search-path-environment-variable
Holds a string representing the system environment variable holding the
search path for libraries; it is initialised to @samp{SCHEME_LIBPATH}.
The search path is meant to be a colon--separated list of directory
pathnames.
@end deffn


@defun library-search-path
Read the value of the @code{library-search-path-environment-variable}
parameter and return a list of strings representing the directory
pathnames in the search path.
@end defun


@deffn Parameter library-search-path-function
Hold a thunk which, when evaluated, returns a list of strings
representing the directories pathnames in the search path; it is
initialised to @func{library-search-path}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Finding pathnames


@defvr Constant library-file-extensions
A list of strings representing extensions for library files; its value
is:

@table @asis
@item @samp{.ikarus.sls} @samp{.sls} @samp{.scm} @samp{.ss}
For Ikarus Scheme.

@item @samp{.larceny.sls} @samp{.sls} @samp{.scm} @samp{.ss}
For Larceny Scheme.

@item @samp{.mosh.sls} @samp{.sls} @samp{.scm} @samp{.ss}
For Mosh Scheme.

@item @samp{.petite.sls} @samp{.sls} @samp{.scm} @samp{.ss}
For Petite Chez Scheme.

@item @samp{.ypsilon.sls} @samp{.sls} @samp{.scm} @samp{.ss}
For Ypsilon Scheme.
@end table
@end defvr


@defun scan-library-search-path @var{reference}
Given the @class{library-reference} record @var{reference}, make use of
the thunk in @func{library-search-path-function} and the extensions in
@code{library-file-extensions} to scan the file systems in search of
compliant libraries.  Return a list of strings, possibly null,
representing the file pathnames.

This function searches for all the files whose pathname is prefixed with
a directory in the search path and suffixed with a relative pathname
built by joining the identifiers in the library reference with a
separator; finally the extensions are tried in turn.  This function
ignores library version specifications in pathnames.
@end defun


@deffn Parameter scan-library-search-path-function
Holds a function which, when applied to a @class{library-reference}
record, scans the file systems and returns a list of file pathnames
matching the reference.  It is initialised to
@func{scan-library-search-path}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Loading libraries


@defun load-libraries-from-files @var{reference}
Given the @class{library-reference} record @var{reference}, make use of
the function in @func{scan-library-search-path-function} to find
matching libraries and return a list of @class{library} records
representing them.  If loading a library fails: the error is ignored and
that pathname skipped.
@end defun

@c page
@node libraries libraries
@section Handling @rnrs{6} libraries


The bindings documented in this section are exported by the
@library{libraries} library.

@menu
* libraries libraries typedefs::    Type definitions.
* libraries libraries utilities::   Utility functions.
@end menu

@c page
@node libraries libraries typedefs
@subsection Type definitions

@c page
@node libraries libraries utilities
@subsection Utility functions



@c page
@node kmp
@chapter Knuth-Morris-Pratt searching


The Knuth--Morris--Pratt (@acronym{KMP}) sequence--search algorithm is a
method of rapidly scanning a sequence of values for the occurrence of
some fixed pattern.  It has the advantage of never requiring
backtracking; hence, it is useful for searching sequences that do not
support backtracking or random--access, such as input ports.

For an explanation of the algorithm:

@center @url{http://en.wikipedia.org/wiki/Knuth-Morris-Pratt_algorithm}

The following routines package up the initialisation and searching
phases of the algorithm for general use in the library
@library{knuth-morris-pratt}.  They also support searching through
sequences that arrive in buffered chunks, in that intermediate search
state can be carried across applications of the search loop from the end
of one buffer application to the next.

A second critical property of @acronym{KMP} search is that it requires
the allocation of auxiliary memory proportional to the length of the
pattern, but constant in the size of the value type.  Alternate
searching algorithms frequently require the construction of a table with
an entry for every possible value, which can be prohibitively expensive,
for example, in a 16-bit or 32-bit character representation.

The algorithm is especially suited to search patterns of characters in
text, so many examples are given for strings.  However the library
supports searching any values in any sequence.

@menu
* kmp intro::                   Introduction.
* kmp conv::                    Conventions.
* kmp vector::                  The restart vector.
* kmp step::                    Single step of the search.
* kmp partial::                 Partial search.
* kmp full::                    Full sequence search.
@end menu

@c page
@node kmp intro
@section Introduction


When searching for a pattern string in a text string:

@example
(define pattern "ciao")
(define text    "Oh, ciao!")
@end example

@noindent
we start looking for the first char in the pattern:

@example
(define match-start
  (let loop ((i 0))
    (if (char=? (string-ref text i)
                (string-ref pattern 0))
        i
      (loop (+ 1 i)))))
@result{} 3
@end example

@noindent
now that we know a match for the first char, we go on looking for the
full pattern:

@example
(define match-past
  (let loop ((pi 1)                     ;; pattern index
             (ti (+ 1 match-start)))    ;; text index
    (cond
     ((= pi (string-length pattern)) pi)    ;; found
     ((= ti (string-length text))    #f)    ;; not found
     (else
      (if (char=? (string-ref ti text)
                  (string-ref pi pattern))
          (loop (+ 1 pi) (+ 1 ti))
        #f)))))                             ;; not found
@end example

@noindent
we have the following possible outcomes:

@itemize
@item
@code{match-past} is true: We have found a match in the substring
@code{[match-start, match-past)} of @code{text}.

@item
@code{match-past} is false: We have to restart matching @code{pattern}
from character @code{(+ 1 match-start)} of @code{text}.
@end itemize

The action ``restart matching'' involves backtracking (to go back) in
the @code{text} string; this can be avoided if we do the following
considerations.

@itemize
@item
Let's say we have to perform the search:

@example
(define pattern "ciao mamma")
(define text    "Oh, ciao papa e ciao mamma!")

;;               0123456789012345678901234567
;;               0         1         2
@end example

@noindent
we notice that the first char @code{c} is never repeated in the pattern;
so after we have matched the first occurrence of @code{"ciao "} in the
substring @math{[4, 9)} of @code{text}, we do not need to restart from
index @math{5}, we just try to match @code{pattern} from index @math{10}
of @code{text}.

@item
Let's say we have to perform the search:

@example
(define pattern "ciao ciao mamma")
(define text    "Oh, ciao ciao ciao mamma!")

;;               01234567890123456789012345
;;               0         1         2
@end example

@noindent
after we have matched the first occurrence of @code{"ciao ciao "} in the
substring @math{[4, 14)} of @code{text}, we find a @code{c} rather than
a @code{m}; we could restart matching @code{pattern} from index
@math{5}, but we notice that we already have matched substring @math{[0,
5)} of @code{pattern} in substring @math{[9, 14)} of @code{text}; so we
can avoid backtracking and go on matching index @math{5} of
@code{pattern} with index @math{14} of @code{text}.
@end itemize

Summary: We can implement an efficient algorithm if we precompute where
to restart from, after a partial match.  Of course, since the algorithm
needs no backtracking, we can also search for multiple patterns in
``parallel''.


@c page
@node kmp conv
@section Conventions


The following conventions for arguments documentation hold:

@table @var
@item @var{pattern}
It is the sequence of elements to search for.  It must support random
access by indexing.

@item @var{pattern-start}
@itemx @var{pattern-past}
The half--open range of elements in @var{pattern} to search for.
@var{pattern-start} is the index of the first (included) element;
@var{pattern-past} is the index of the last (excluded) element.

@item @var{text}
It is a fixed sequence in which to do the search.  It must support
random access by indexing.

@item @var{text-start}
@itemx @var{text-past}
The half--open range of elements in @var{text} in which to do the
search.  @var{text-start} is the index of the first (included) element;
@var{text-past} is the index of the last (excluded) element.

@item item=
It is an equality function used to construct the restart vector; for
characters it is typically @func{char=?} or @func{char-ci=?}, while for
numbers it is @func{=}.

@item item-ref
It is an element extraction function to be applied to @var{pattern} to
retrieve an element by index; if @var{pattern} is a string, it is
@func{string-ref}; if @var{pattern} is a vector it is @func{vector-ref};
if @var{pattern} is a list it is @func{list-ref}.

@item restart-vector
It is the @acronym{KMP} restart vector for @var{pattern}, as constructed
by @func{%kmp-make-restart-vector}.
@end table


@c page
@node kmp vector
@section The restart vector


@defun %kmp-make-restart-vector @var{item=} @var{item-ref} @var{pattern} @var{pattern-start} @var{pattern-past}
Build a @dfn{restart vector}, to be used to search sequences for the
occurrence of the selected subsequence of @var{pattern}.

The definition of the restart vector @math{V} for string @math{P} is: If
we have matched elements @math{0 ... i-1} of @math{P} against some
search sequence @math{T}:
@iftex
@tex
$$
P[i-1] = T[k]
P[i-2] = T[k-1]
...
P[0] = T[k-(i-1)]
$$
@end tex
@end iftex
@ifnottex

@example
P[i-1] = T[k]
P[i-2] = T[k-1]
...
P[0] = T[k-(i-1)]
@end example

@end ifnottex
and @math{P[i]} does not match @math{T[k]}, then reset @math{i := V[i]},
and try again to match @math{T[k]}.  If @math{V[i] = -1}: move on to
@math{T[k+1]} and @math{P[0]}.
@end defun

@c page
@node kmp step
@section Single step of the search


@defun %kmp-step @var{item=} @var{item-ref} @var{restart-vector} @var{next-value-from-text} @var{next-index-in-pattern} @var{pattern} @var{pattern-start}
This function encapsulates the work performed by one step of the
@acronym{KMP} search.  Return the new index in the pattern; that is, how
much of the pattern we have matched, including the given value from
text.
@end defun


Searching for the pattern @code{"hello"} in the text @code{"ciao hello
salut"} looks like this:

@example
(let* ((text          "ciao hello salut")
       ;;              01234567890123456
       ;;              0         1
       (text-past     (string-length text))

       (pattern       "ciao")
       (pattern-start 0)
       (pattern-past  (string-length pattern))

       (rv            (%kmp-make-restart-vector char=? string-ref
                         pattern pattern-start pattern-past)))
  (let loop ((ti 0)
             (pi pattern-start))
    (or (and (= pi pattern-past) ti) ; found
        (and (not (= ti text-past))  ; not found
             (loop (+ 1 ti)
                   (%kmp-step char=? string-ref rv
                              (string-ref text ti)
                              pi pattern pattern-start))))))
@result{} 10
@end example

@noindent
if the pattern was not found the return value is @false{}; if the
pattern was found the return value is the index in the text of the
character past the last matched one.

Abstracting the search from a string to a generic source of characters,
we can write the following function, whose return value is the same as
the loop above:

@example
(define (return-match-past end-of-text? get-next-char
                           pattern pattern-start pattern-past)
  (let ((rv (%kmp-make-restart-vector char=? string-ref
               pattern pattern-start pattern-past)))
    (let loop ((ti 0)
               (pi pattern-start))
      (or (and (= pi pattern-past) ti) ; found
          (and (not (end-of-text?))    ; not found
               (loop (+ 1 ti)
                     (%kmp-step char=? string-ref rv
                        (get-next-char)
                        pi pattern pattern-start)))))))
@end example

@noindent
a usage example with a string looks like this:

@example
(let* ((text           "ciao hello salut")
       ;;               01234567890123456
       ;;               0         1
       (pattern        "hello")
       (ti             0)
       (end-of-text?   (lambda ()
                         (= ti (string-length text))))
       (get-next-char  (lambda ()
                         (begin0
                             (string-ref text ti)
                           (set! ti (+ 1 ti))))))
  (return-match-past end-of-text? get-next-char
                     pattern 0 (string-length pattern)))
@result{} 10
@end example

@noindent
a usage example with an input port looks like this:

@example
(let* ((text           "ciao hello salut")
       ;;               01234567890123456
       ;;               0         1
       (pattern        "salut")
       (port           (open-string-input-port text))
       (end-of-text?   (lambda ()
                         (eof-object? (peek-char port))))
       (get-next-char  (lambda ()
                         (read-char port))))
  (return-match-past end-of-text? get-next-char
                     pattern 0 (string-length pattern)))
@result{} 16
@end example

@c page
@node kmp partial
@section Partial search


@defun %kmp-partial-search @var{item=} @var{item-ref} @var{restart-vector} @var{next-index-in-pattern} @var{text} @var{text-start} @var{text-end} @var{pattern} @var{pattern-start}
Using this function is equivalent to apply @func{%kmp-step} across the
selected subsequence of @var{text} in search of the selected subsequence
of @var{pattern}; the pattern is @code{(vector-length rv)} characters
long.

@itemize
@item
If the pattern is found: Return @math{-j} (a strictly negative integer)
where @math{j} is the index of the value past the one that last matched
the pattern in @var{text}.

@item
If the pattern is not found: Return the index in the restart vector (a
non negative integer) to be used in the next call to this function.
@end itemize

This utility is designed to allow searching for occurrences of a fixed
sequence that might extend across multiple buffers of data.  Notice
that, in this case, when the returned value is negative: It is the index
in the last buffer, not in the whole text.
@end defun


A simple one--shot search over a given string looks like the following:

@example
(let* ((text            "ciao hello salut")
       ;;                01234567890123456
       ;;                0         1
       (text-start      0)
       (text-past       (string-length text))

       (pattern         "hello")
       (pattern-start   0)
       (pattern-past    (string-length pattern))

       (restart-vector  (%kmp-make-restart-vector
                           char=? string-ref
                           pattern pattern-start pattern-past)))
  (let ((i (%kmp-partial-search
              char=? string-ref restart-vector pattern-start
              text text-start text-past
              pattern pattern-start)))
    (or (<= 0 i) ;; not found
        (- i)))) ;; found, return match past index
@result{} 10
@end example

@noindent
if the pattern was not found: Return @false{}.  If the pattern was
found: Return the index in the string of the character past the one that
matched the end of the pattern.

Generalising this to a generic source of strings (represented by a list
of strings):

@smallexample
(let* ((strings         '("ciao h " "he hel h"
                          "ell hel" "lo salut"))
       (end-of-data?    (lambda ()
                          (null? strings)))
       (get-next-chunk  (lambda ()
                          (begin0
                              (car strings)
                            (set! strings (cdr strings))))))

  (let* ((pattern         "hello")
         (pattern-start   0)
         (pattern-past    (string-length pattern))

         (restart-vector  (%kmp-make-restart-vector char=? string-ref
                             pattern pattern-start pattern-past)))

    (let loop ((pi 0))
      (and (not (end-of-data?))          ; not found
           (let* ((buf (get-next-chunk))
                  (pi  (%kmp-partial-search
                          char=? string-ref
                          restart-vector pi
                          buf 0 (string-length buf)
                          pattern pattern-start)))
             (if (< pi 0)
                 (cons buf (- pi)) ; found
               (loop pi)))))))
@result{} ("lo salut" . 2)
@end smallexample

@noindent
if the pattern was not found: Return @false{}.  If the pattern was
found: Return a cons whose car is the string chunk holding the end of
the text that matched, and whose cdr is the index in the chunk of the
character past the one that matched the end of the pattern.

@c page
@node kmp full
@section Full sequence search


@defun %kmp-search @var{item=} @var{item-ref} @var{text} @var{text-start} @var{text-past} @var{pattern} @var{pattern-start} @var{pattern-past}
Search the selected subsequence of @var{text} for the selected
subsequence of @var{pattern}.  Return the index of the @strong{first}
value in @var{text} that matched the @strong{first} value in the
pattern.

This function is like @func{%string-contains} and
@func{%string-contains-ci}, in facts those are implemented as:

@smallexample
(define (%string-contains text text-beg text-past
                          pattern pattern-beg pattern-past)
  (%kmp-search char=? string-ref
               text text-beg text-past
               pattern pattern-beg pattern-past))

(define (%string-contains-ci text text-beg text-past
                             pattern pattern-beg pattern-past)
  (%kmp-search char-ci=? string-ref
               text text-beg text-past
               pattern pattern-beg pattern-past))
@end smallexample
@end defun

@c page
@node one-dimension
@chapter One dimensional extended ranges


The one--dimension libraries implement low level operations over
generalised ranges of a coordinate.  They can be used to operate on
ranges of numbers or characters or whatever objects upon which we can
define an ordering.  There are two versions of the library:

@table @library
@item one-dimension-co
Represents domains of values using disjoint half--open ranges; each
range has a lower--included and an upper--excluded limit.

@item one-dimension-cc
Represents domains of values using disjoint double--closed ranges; each
range has a lower--included and an upper--included limit.
@end table

Both the libraries have the same interface, meaning that the functions
names and arguments are the same; the only difference in semantics is
that @library{one-dimension-co} interprets argument ranges as
half--open, while @library{one-dimension-cc} interprets argument ranges
as double--closed.  @library{one-dimension-cc} is the backbone of the
@library{char-sets} library.

@menu
* one-dimension intro::         Data types and conventions.
* one-dimension make::          Constructors.
* one-dimension pred::          Predicates.
* one-dimension inspect::       Inspection.
* one-dimension ops::           Operations.
@end menu

@c page
@node one-dimension intro
@section Data types and conventions


A @dfn{range} is a pair representing a half--open interval of items.
The car of the pair if the included lower--limit, called @var{start};
the cdr is the excluded upper--limit, called @var{past}, or the included
upper--limit, called @var{last}.  Empty ranges are @strong{not} valid.

A @dfn{domain} is a sorted list of ranges.  Empty domains are empty
lists.  Ranges in a domain do not overlap and are not contiguous.  A
domain of half--open ranges has the following format:

@example
((start1 . past1) (start2 . past2) (start3 . past3) ...)
@end example

@noindent
with the constraints:

@example
start1 < past1 < start2 < past2 < start3 < past3 < ...
@end example

@noindent
a domain of double--closed ranges has the following format:

@example
((start1 . last1) (start2 . last2) (start3 . last3) ...)
@end example

@noindent
with the constraints:

@example
start1 <= last1 < start2 <= last2 < start3 <= last3 < ...
@end example

The range and domain functions accept the following arguments:

@table @var
@item obj
Any object.

@item item
An object that satisfies the @var{item?} predicate of the selected type.

@item range
A valid range according to @func{%range?}.

@item domain
A valid domain according to @func{%domain?}.

@item start
The included left--limit of a range.

@item past
The excluded lower--limit of a range.

@item last
The included upper--limit of a range.

@item item?
A unary predicate returning @true{} if the argument is a valid item.
For integers it can be @func{integer?}, while for characters it can be
@func{char?}.

If we need to exclude some range of values, we can do it by properly
define this function.  For example, to exclude the integers in the
half--open range @math{[10, 23)} we can use:

@example
(lambda (n)
  (and (integer? n)
       (<= 10  n)
       (<   n 23)))
@end example

@item item=?
An n--ary predicate returning @true{} if the all the arguments are
equal.  @func{char=?} is an example of such a function.

@item item<?
An n--ary predicate returning @true{} if the all the arguments, in the
given order, are in strict increasing order.  @func{char<?} is an
example of such a function.

@item item<=?
An n--ary predicate returning @true{} if the all the arguments, in the
given order, are in non--strict increasing order.  @func{char<=?} is an
example of such a function.

@item item-min
An n--ary function returning the minimum between its arguments.  For
numbers it can be @func{min}, for characters we can use:

@example
(lambda (a b) (if (char<? a b) a b))
@end example

@item item-max
An n--ary function returning the maximum between its arguments.  For
numbers it can be @func{max}, for characters we can use:

@example
(lambda (a b) (if (char<? a b) b a))
@end example

@item item-prev
A binary function accepting an item and a range, or false, as arguments.
The second argument can be @false{}, meaning that no range is specified,
or a pair whose car is the left--limit and whose cdr is the
right--limit; when the range is true, it is guaranteed that the item is
inside the range.

This function must return the value previous to item inside the range;
if it is not possible to compute the previous value, because the lower
bound has been reached: The function must return @false{}.

For integers it can be:

@example
(lambda (x range)       ; with both (one-dimension-cc)
  (let ((x (- x 1)))    ; and (one-dimension-co)
    (if range
        (and (<= (car range) x)
             x)
      x)))
@end example

@noindent
for characters it can be:

@example
(lambda (ch range)      ; with (one-dimension-cc)
  (let* ((x  (- (char->integer ch) 1)))
    (and (number-in-range? x)
         (let ((ch (integer->char x)))
           (if range
               (and (<= x (char->integer (car range)))
                    ch)
             ch)))))

(define (number-in-range? x)
  (or (and (<= 0 x)
           (<  x #xD800))
      (and (<  #xDFFF x)
           (<= x #x10FFFF))))
@end example

@item item-next
A binary function accepting an item and a range, or false, as arguments.
The second argument can be @false{}, meaning that no range is specified,
or a pair whose car is the left--limit and whose cdr is the
right--limit; when the range is true, it is guaranteed that the item is
inside the range.

This function must return the value next to item inside the range; if it
is not possible to compute the next value, because the upper bound has
been reached: The function must return @false{}.

For integers it can be:

@example
(lambda (x range)       ; with (one-dimension-cc)
  (let ((x (+ 1 x)))
    (if range
        (and (<= x (cdr range))
             x)
      x)))

(lambda (x range)       ; with (one-dimension-co)
  (let ((x (+ 1 x)))
    (if range
        (and (< x (cdr range))
             x)
      x)))
@end example

@noindent
for characters it can be:

@example
(lambda (ch range)      ; with (one-dimension-cc)
  (let* ((x  (+ 1 (char->integer c))))
    (and (number-in-range? x)
         (let ((ch (integer->char x)))
           (if range
               (and (<= x (char->integer (cdr range)))
                    ch)
             ch)))))

(define (number-in-range? x)
  (or (and (<= 0 x)
           (<  x #xD800))
      (and (<  #xDFFF x)
           (<= x #x10FFFF))))
@end example

@item item-minus
A binary function:

@itemize
@item
For half--open ranges: It must return the number of items between the
first argument included and the second argument excluded.

@item
For double--closed ranges: It must return the number of items between
the first argument included and the second argument included.
@end itemize

The arithmetic @func{-} applied to integers is an example of such a
function for half--open ranges; for characters and double--closed ranges
we can use:

@example
(lambda (past start)
  (+ 1 (- (char->integer past)
          (char->integer start))))
@end example

@item item-copy
A unary function returning a copy of an item.  For ranges holding atomic
values (like characters or integers) it is fine to use @code{(lambda (x)
x)}.

@item type
A record used as type descriptor for collected items.  It is used as
first arguments to all almost all the functions.  Type descriptors are
built by @func{%make-type-descriptor}.
@end table

@c page
@node one-dimension make
@section Constructors


@defun %make-type-descriptor @var{item?} @var{item=?} @var{item<?} @var{item<=?} @var{item-min} @var{item-max} @var{item-prev} @var{item-next} @var{item-minus} @var{item-copy}
Build and return a new type descriptor.
@end defun


@defun %make-range @var{type} @var{start} @var{past}
@defunx %make-range @var{type} @var{start} @var{last}
Compose @var{start} and @var{past}/@var{last} into a range.  This
function validates the arguments to make sure the resulting range is
valid.
@end defun


@defun %range-copy @var{type} @var{range}
Return a clone of @var{range}.
@end defun


@defun %make-domain @var{type} @var{item/range} ...
Build and return a new domain.  The list of @var{item/range} may be the
empty list or a mixed list of items and ranges.  See
@func{%domain-add-item} and @func{%domain-add-range} for details.
@end defun


@defun %domain-copy @var{type} @var{domain}
Return a newly allocated domain holding a copy of @var{domain}.
@end defun


@defun %domain-add-item @var{type} @var{domain} @var{obj}
Add the single value @var{obj} to @var{domain}, return the new domain.
The returned domain may share some structure with @var{domain}.  If
@var{obj} does not satisfy the @var{item?} function of @var{type}: An
assertion violation is raised.

@var{obj} is interpreted as lower limit of a range and the
@var{item-next} function of @var{type} is used to generate the
corresponding upper limit.  If generating the next item fails: An
assertion violation is raised.
@end defun


@defun %domain-add-range @var{type} @var{domain} @var{range}
Add @var{range} to @var{domain}, return the new domain.  The returned
domain may share some structure with @var{domain}.

@var{range} is a pair of items; it is interpreted as double--closed
range by @library{one-dimension-cc} and as half--open range by
@library{one-dimensionc-co}.
@end defun

@c page
@node one-dimension pred
@section Predicates


@subsubheading Range predicates


@defun %range? @var{type} @var{obj}
Return @true{} if @var{obj} is a valid range.
@end defun


@defun %range-contains? @var{type} @var{range} @var{obj}
Return @true{} if @var{obj} is a member of @var{range}.
@end defun


@defun %range=? @var{type} @var{range-a} @var{range-b}
Return @true{} if the ranges are equal.
@end defun


@defun %range<? @var{type} @var{range-a} @var{range-b}
Return @true{} if @var{range-a} has all members less than all members of
@var{range-b}.
@end defun


@defun %range<=? @var{type} @var{range-a} @var{range-b}
Return @true{} if @var{range-a} has all members less than, or equal to,
all members of @var{range-b}.
@end defun


@defun %range-start<? @var{type} @var{range-a} @var{range-b}
Return @true{} if the start of @var{range-a} is less than the start of
@var{range-b}.
@end defun


@defun %range-start<=? @var{type} @var{range-a} @var{range-b}
Return @true{} if the start of @var{range-a} is less than, or equal to,
the start of @var{range-b}.
@end defun


@defun %range-past<? @var{type} @var{range-a} @var{range-b}
@defunx %range-last<? @var{type} @var{range-a} @var{range-b}
Return @true{} if the past/last of @var{range-a} is less than the past
of @var{range-b}.
@end defun


@defun %range-last<=? @var{type} @var{range-a} @var{range-b}
@defunx %range-past<=? @var{type} @var{range-a} @var{range-b}
Return @true{} if the past/last of @var{range-a} is less than, or equal
to, the past of @var{range-b}.
@end defun


@defun %range-contiguous? @var{type} @var{range-a} @var{range-b}
Return @true{} if @var{range-a} and @var{range-b} are contiguous.  It
does not matter which range has start less than the other.
@end defun


@defun %range-overlapping? @var{type} @var{range-a} @var{range-b}
Return @true{} if the ranges have some elements in common.
@end defun


@defun %range-superset? @var{type} @var{range-a} @var{range-b}
@defunx %range-superset?/strict @var{type} @var{range-a} @var{range-b}
Return @true{} if @var{range-a} is a superset or a strict superset of
@var{range-a}.
@end defun


@defun %range-subset? @var{type} @var{range-a} @var{range-b}
@defunx %range-subset?/strict @var{type} @var{range-a} @var{range-b}
Return @true{} if @var{range-a} is a subset or a strict subset of
@var{range-a}.
@end defun

@c ------------------------------------------------------------

@subsubheading Domain predicates


@defun %domain? @var{type} @var{domain}
Return true if @var{domain} is a valid domain.
@end defun


@defun %domain-empty? @var{domain}
Return true if the domain is empty.
@end defun


@defun %domain-contains? @var{type} @var{domain} @var{obj}
Return true if @var{obj} is an element of @var{domain}.
@end defun


@defun %domain=? @var{type} @var{domain-a} @var{domain-b}
Return true if the arguments represent the same domain.
@end defun


@defun %domain<? @var{type} @var{domain-a} @var{domain-b}
Return true if all the elements of @var{domain-a} are strictly less than
all the elements of @var{domain-b}.  Empty domains cannot be ordered, so
if an argument is empty the return value is @false{}.
@end defun


@defun %domain-subset? @var{type} @var{domain-a} @var{domain-b}
@defunx %domain-subset?/strict @var{type} @var{domain-a} @var{domain-b}
Return @true{} if @var{domain-a} is a subset or strict subset of
@var{domain-b}.
@end defun


@defun %domain-superset? @var{type} @var{domain-a} @var{domain-b}
@defunx %domain-superset?/strict @var{type} @var{domain-a} @var{domain-b}
Return @true{} if @var{domain-a} is a superset or strict superset of
@var{domain-b}.
@end defun


@c page
@node one-dimension inspect
@section Inspection


@defun %range-length @var{type} @var{range}
Return the number of items in the range.
@end defun


@defun %domain-size @var{type} @var{domain}
Return the number of items in the domain.
@end defun

@c page
@node one-dimension ops
@section Operations


@subsubheading Set operations


@defun %range-intersection @var{type} @var{range-a} @var{range-b}
Return a range representing the intersection of the argument ranges.  It
does not matter which range has start less than the other.

Intersection is a closed operation on the space of ranges: The
intersection of two ranges is a range (possibly empty).  If the ranges
are not overlapping return @false{} to represent the empty range.
@end defun


@defun %range-union @var{type} @var{range-a} @var{range-b}
Return two values representing the union of the argument ranges.  It
does not matter which range has start less than the other.

Union is @strong{not} a closed operation on the space of ranges: The
union of two contiguous or overlapping ranges is a single range, but the
union of two disjoint ranges is the set holding the two argument ranges.

If the argument ranges are disjoint and non--contiguous: Return two
values being @var{range-a} and @var{range-b}.  If the argument ranges
are contiguous or overlapping: Return two values being @false{} and a
new range representing the union.

This function should be called like this:

@example
(let-values (((head tail) (%range-union type r-a r-b)))
  (when head ---)
  (when tail ---))
@end example
@end defun


@defun %range-difference @var{type} @var{range-a} @var{range-b}
Return two values representing the difference between the argument
ranges; the difference is the set of elements present in one range and
not in the other.  It does not matter which range has start less than
the other.

Difference is @strong{not} a closed operation on the space of ranges: In
genreral the result is a couple of ranges.  The first one represents
values which are all less than the values in the second one.  Both the
returned values can be @false{}.

This function should be called like this:

@example
(let-values (((head tail) (%range-difference type r-a r-b)))
  (when head ---)
  (when tail ---))
@end example
@end defun


@defun %range-in-first-only @var{type} @var{range-a} @var{range-b}
Return two values representing the elements of @var{range-a} that are
not in @var{range-b}.

This operation is @strong{not} a closed operation on the space of
ranges: In genreral the result is a couple of ranges.  The first one
represents values which are all less than the values in the second one.
Both the returned values can be @false{}.

This function should be called like this:

@example
(let-values (((head tail) (%range-in-first-only type r-a r-b)))
  (when head ---)
  (when tail ---))
@end example
@end defun


@defun %domain-intersection @var{type} @var{domain-a} @var{domain-b}
Return a new domain representing the intersection of the arguments.  The
intersection is the set of values present in both the arguments.

The returned value may share some structure with the arguments.
@end defun


@defun %domain-union @var{type} @var{domain-a} @var{domain-b}
Return a new domain representing the union of the arguments.  The union
is the set of values present in one and/or the other argument.

The returned value may share some structure with the arguments.
@end defun


@defun %domain-difference @var{type} @var{domain-a} @var{domain-b}
Return a new domain representing the difference of the arguments.  The
difference is the set of values present in one or the other argument.

The returned value may share some structure with the arguments.
@end defun


@defun %domain-complement @var{type} @var{domain} @var{domain-universe}
Return a new domain representing the complement of @var{domain} in the
space defined by @var{domain-universe}.  The returned value holds all
the items from @var{domain-universe} that are not in @var{domain}.

The returned value may share some structure with the arguments.
@end defun

@c ------------------------------------------------------------

@subsubheading List operations


@defun %range-for-each @var{type} @var{proc} @var{range}
Apply @var{proc} to each value in the range.
@end defun


@defun %range-every @var{type} @var{proc} @var{range}
Apply @var{proc} to each value in the range and return true if all the
return values are true.  The application stops at the first @false{}
return value.
@end defun


@defun %range-any @var{type} @var{proc} @var{range}
Apply @var{proc} to each value in the range and return true if at least
one of the returned values is true.  The application stops at the first
true return value.
@end defun


@defun %range-fold @var{type} @var{kons} @var{knil} @var{range}
Fold @var{kons} over the values in the range.
@end defun


@defun %range->list @var{type} @var{range}
Return a list holding all the elements in the range.
@end defun


@defun %domain-for-each @var{type} @var{proc} @var{domain}
Apply @var{proc} to each element of @var{domain}.
@end defun


@defun %domain-every @var{type} @var{proc} @var{domain}
Apply @var{proc} to each value in the domain and return true if all the
return values are true.  The application stops at the first @false{}
return value.
@end defun


@defun %domain-any @var{type} @var{proc} @var{domain}
Apply @var{proc} to each value in the domain and return true if at least
one of the returned values is true.  The application stops at the first
true return value.
@end defun


@defun %domain-fold @var{type} @var{kons} @var{knil} @var{domain}
Fold @var{kons} over the values in the domain.
@end defun


@defun %domain->list @var{type} @var{domain}
Return a list holding all the elements in the domain.
@end defun

@c ------------------------------------------------------------

@subsubheading Miscellaneous operations


@defun %range-concatenate @var{type} @var{range-a} @var{range-b}
Concatenate the ranges and return the resulting range.  It does not
matter which range has start less than the other.  It makes sense to
apply this function to ranges that satisfy @func{%range-contiguous?}.

The returned range may share some value with the original ranges.
@end defun

@c page
@node old-generics
@appendix Old multimethods dispatching


In the context of the @library{old-generics} library, @dfn{generic
functions} are procedures that can be specialised to the (possibly
conventional) class types of their arguments; each specialisation of a
generic function is called @dfn{method}.  When applying a generic
function to a set of arguments, the most specific method with respect to
the arguments' types is chosen.

The @library{old-generics} library is deprecated, use @library{generics}
instead.  The @library{old-generics} library is built on top of the
@library{classes} library.

@menu
* old-generics application::    How generic functions and methods
                                are invoked.
* old-generics dispatching::    How methods are dispatched.
* old-generics define::         Defining generic functions and methods.
* old-generics next::           Invoking the next method.
* old-generics examples::       Examples of method dispatching.
* old-generics predefined::     Predefined generic functions.
@end menu

@c page
@node old-generics application
@appendixsec How generic functions and methods are invoked


When a generic function is applied to a tuple of arguments, the
following happens:

@enumerate
@item
For each argument in the tuple a class type is determined, then the list
of unique @uid{}s representing the class hierarchy is acquired.  The
tuple of @uid{} lists is called @dfn{signature}.  Each generic function
maintains an internal collection in which every method's closure is
associated to a signature.

@item
The internal collection of methods is queried for all the methods
applicable to the tuple of arguments, using the signature as search key.

@item
The list of applicable methods is sorted from the more specific to the
least specific for the signature.  From now on the list of sorted,
applicable methods is handled as a stack.

@item
The next method is popped from the stack and its closure is applied to
the tuple of arguments.  The return value of this application becomes
the return value of the generic function application.  If the function
calls the next method, recurse to step 4.
@end enumerate

@c page
@node old-generics dispatching
@appendixsec How methods are dispatched


Here we attempt the formulation of the rules of method dispatching.  A
method is identified by a triplet of values: the signature; a boolean
value telling if the closure accepts rest arguments; the closure.

@c ------------------------------------------------------------

@subsubheading Applicability

First we need to understand when a method is applicable to a tuple of
arguments.  Class types are identified by the list of @uid{}s
representing the hierarchy: the expansion of @func{class-uid-list}.
Given a tuple of arguments, a method supporting no rest arguments is
applicable to the tuple if:

@enumerate
@item
The length of the signature is equal to the length of the arguments'
tuple.

@item
Position by position, the class of the method's argument is equal to, or
a parent of, the class of the given argument.
@end enumerate

@noindent
a method supporting rest arguments is applicable to the tuple if:

@enumerate
@item
The length of the signature is less than, or equal to, the length of the
arguments' tuple.

@item
Position by position, up to the last element in the signature, the class
of the method's argument is equal to, or a parent of, the class of the
given argument.
@end enumerate

@c ------------------------------------------------------------

@subsubheading Specificity

Now we can understand how to determine which one, among two applicable
methods, is more specific for a tuple of arguments.  Let's call the
methods @var{A} and @var{B}.

Notice that it is impossible for two distinct methods, in the same
generic function, to have the same signature and the same support for
rest arguments.

Also, classes support only single inheritance, so if two methods are
applicable: the homologous classes in their signatures are equal or one
parent of the other.

@enumerate
@item
If both @var{A} and @var{B} support rest arguments: the one with the
longest signature is more specific.

@item
The classes in the signatures are compared in couples, position by
position from the beginning to the end.

@enumerate a
@item
If the classes are equal: the next couple is inspected.

@item
If the class from @var{A} is a subclass of the one from @var{B}: @var{A}
is more specific than @var{B}.
@end enumerate

@item
If the methods' signatures have the same length, and, position by
position, the classes of @var{A} are equal to the classes of @var{B},
but @var{A} supports rest arguments while @var{B} does not: then @var{B}
is more specific than @var{A}.
@end enumerate

@c page
@node old-generics define
@appendixsec Defining generic functions and methods


The number of arguments (arity) of a generic function is undefined:
every method can have a different number of arguments.


@deffn Syntax define-generic @ameta{name}
Define a new generic function and bind it to @meta{name}.
@end deffn


@defun make-generic-function
Build and return a new generic function.
@end defun


@deffn Syntax define-generic/merge @ameta{name} @ametao{generic} @ameta{generic} ...
Define a new generic function and bind it to @meta{name}.  The internal
collection of methods holds the union of the method collections from the
@meta{generic} arguments, which must be generic functions.

The union is performed visiting arguments from left to right; when two
methods have the same signature and the same support for rest arguments,
the one from the leftmost generic function has precedence.

Merging methods is useful when two different libraries export generic
functions bound to the same identifier.
@end deffn


@deffn Syntax define-method @ameta{generic} (@ameta{arg-spec} ...) @ameta{body}
@deffnx Syntax define-method (@ameta{generic} @ameta{arg-spec} ...) @ameta{body}
Add a new method to an already existent generic function,
@ameta{generic}.

The list of @meta{arg-spec} specifies the classes of the arguments for
which this method specialises the generic function.  Notice that rest
arguments are supported and specified with the usual syntax.  An
@meta{arg-spec} can be:

@table @code
@item (@meta{arg} @meta{class name})
Where @meta{arg} is the formal name of the argument and @meta{class
name} the (possibly conventional) class name of expected values.

@item @meta{arg}
Where @meta{arg} is the formal name of the argument.  In this case the
class defaults to the conventional @class{top}, which is interpreted as
parent of every other class (and so it has the least specificity).
@end table

If a method is defined with the same signature, and support for rest
arguments, of an already registered method: the old method is
overwritten by the new one.  Two methods having, position by position,
arguments of the same class, but such that one supports rest arguments
and the other does not, are different.
@end deffn


@deffn Syntax add-method @ameta{generic} @ameta{classes} @ameta{has-rest} @ameta{closure}
Add a new method to an already existent generic function,
@meta{generic}.  @meta{classes} must be a list of class names for which
this method specialises the generic function.  @meta{closure} must be
the method's closure.  @meta{has-rest} must be @true{} or @false{}, when
@true{} it means that the closure supports rest arguments.
@end deffn

@c page
@node old-generics next
@appendixsec Invoking the next method


@defun call-next-method
Call the next most specific method.
@end defun


@defun next-method?
Return true if a next method is available.
@end defun

@c page
@node old-generics examples
@appendixsec Examples of method dispatching


Here we show with some examples what we have to expect from the
multimethod dispatching of @library{old-generics}.  In the following
examples the string @code{%apple} is written in place of the value bound
to the symbol @class{apple}.

Let's examine this example:

@example
(define-class <one> (parent <top>))
(define-class <two> (parent <one>))
(define-class <c>   (parent <two>))
@end example

@noindent
the class hierarchy is:

@example
<top> -> <one> -> <two> -> <c>
@end example

@noindent
so for the generic function:

@example
(define-generic doit)
(define-method (doit (o <one>)) 'one)
(define-method (doit (o <two>)) 'two)
@end example

@noindent
applied to a value of type @class{c}: the method with @class{two} in the
signature is @emph{more specific} than the method with @class{one} in
the signature:

@example
(doit (make-<c>)) @result{} two
@end example

@noindent
also the method with @class{one} in the signature is the ``next method''
of the method with @class{two} in the signature, we can call it using
@func{call-next-method}.

The following example shows a call to the next method:

@example
(define-generic fluff)

(define-method (fluff (o <one>))
  'one)

(define-method (fluff (o <two>))
  (cons 'two (call-next-method)))

(define o (make-<c>))

(fluff o)
@result{} (two . one)
@end example

@c page
@node old-generics predefined
@appendixsec Predefined generic functions


@deffn {Generic Function} object->string @var{obj}
Return a string representation for @var{obj}.  A non--specialised method
is predefined to use the following implementation:

@example
(call-with-string-output-port
   (lambda (port)
     (display obj port)))
@end example
@end deffn

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c mode: texinfo
@c TeX-master: t
@c End:
