\input texinfo.tex
@c %**start of header
@setfilename nausicaa-srfi.info
@settitle SRFI for R6RS Scheme
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@include version.texiinc


@c ------------------------------------------------------------
@c License macros.
@c ------------------------------------------------------------

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@macro bsd{}
@acronym{BSD}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro aurl{}
@acronym{URL}
@end macro

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro ram{}
@acronym{RAM}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@c Remember that @url is already used by Texinfo.
@macro urla{}
@acronym{URL}
@end macro

@c ------------------------------------------------------------
@c Software related macros.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@macro glibc{}
@gnu{} C Library
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro tcp{}
@acronym{TCP}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro icmp{}
@acronym{ICMP}
@end macro

@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro https{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@macro snmp{}
@acronym{SNMP}
@end macro

@c ------------------------------------------------------------
@c Arguments macros.
@c ------------------------------------------------------------

@macro vari{ARG}
@var{\ARG\1}
@end macro

@macro varii{ARG}
@var{\ARG\2}
@end macro

@macro variii{ARG}
@var{\ARG\3}
@end macro

@macro variv{ARG}
@var{\ARG\4}
@end macro

@macro varn{ARG}
@var{\ARG\n}
@end macro

@macro vark{ARG}
@var{\ARG\k}
@end macro

@macro varj{ARG}
@var{\ARG\j}
@end macro

@c ------------------------------------------------------------

@macro meta{ARG}
<\ARG\>
@end macro

@macro metai{ARG}
@meta{\ARG\1}
@end macro

@macro metaii{ARG}
@meta{\ARG\2}
@end macro

@macro metaiii{ARG}
@meta{\ARG\3}
@end macro

@macro metaiv{ARG}
@meta{\ARG\4}
@end macro

@macro metan{ARG}
@meta{\ARG\n}
@end macro

@macro metak{ARG}
@meta{\ARG\k}
@end macro

@macro metaj{ARG}
@meta{\ARG\j}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro null{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{NAME}
@code{(\NAME\)}
@end macro

@macro module{NAME}
@code{\NAME\}
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@ignore
Separating the @srfi{}  macro from the number with a  '--' rather than a
'-' makes the expansion look ugly in menu entries under the Info reader.
IMHO this should not happen, but  it does; so we live with this, because
the main purpose of this document is to provide an Info version.
@end ignore
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@c ------------------------------------------------------------

@macro func{NAME}
@code{@sc{\NAME\}}
@end macro

@macro nil{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro

@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@macro rsixref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@end macro

@macro rfiveref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,r5rs}
@end macro

@macro ikarusref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,ikarus}
@end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro


@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      @srfi{} for @rnrs{6} Scheme

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Nausicaa/@srfi{}

@c To be used as @value{PACKAGE} whenever we need to include the
@c nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           nausicaa-srfi

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marcomaggi@@gna.org}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2008



@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a
packaging of @srfi{}s for @rnrs{6} Scheme.  The original @srfi{}
documents are the work of many authors and are available at:

@center @url{http://srfi.schemers.org/}

@noindent
the original source code was ported to @rnrs{6} and Ikarus Scheme by
Derick Eddington with contributions by Abdulaziz Ghuloum, and is
available at:

@center @url{http::/code.launchpad.net/ikarus-libraries}

@noindent
upon inclusion in Nausicaa the code was further modified by Marco Maggi.
The code in this package is covered by the original @srfi{} license, see
the copyright notices in the source files.

This document was assembled by reformatting the original @srfi{}
documents, with changes and additions to make it fit the Nausicaa
distribution.  Each chapter includes the original copyright notice and
author citation: refer to those for copying conditions.

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with
Invariant Sections being ``@gnu{} Free Documentation License'', no
Front--Cover Texts, and no Back--Cover Texts.  A copy of the license is
included in the section entitled ``@gnu{} Free Documentation License''.
@end quotation
@end copying


@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* nausicaa-srfi: (nausicaa-srfi). @srfi{} for @rnrs{6} Scheme.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.

* cond-expand::                 Feature based conditional expansion
                                construct.
* list::                        List library.
* and-let-star::                An @func{and} with local bindings.
* string-ports::                Basic string ports.
* receive::                     Binding to multiple values.
* records::                     Defining record types.
* strings::                     The string library.
* case-lambda::                 Syntax for procedures of variable arity.
* time::                        Time data types and procedures.
* cut::                         Notation for specializing parameters
                                without currying.
* random::                      Sources of random bits.
* rec::                         A special form @func{rec} for recursive
                                evaluation.
* args-fold::                   A program argument processor.
* parameters::                  Parameter objects.
* streams::                     Streams library.
* eager-comp::                  Extended loops.
* vector::                      Vectors library.
* general-cond::                A more general @func{cond} clause.
* lightweight-testing::         Lightweight testing.
* environment-variables::       Environment variables.

Appendices

* Documentation License::       GNU Free Documentation License.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

Overview of the package

* overview srfi::               The @srfi{} libraries.
* overview stub::               Stub libraries.

Feature based conditional expansion construct

* cond-expand license::         Original license.
* cond-expand abstract::        Abstract.
* cond-expand rationale::       Rationale.
* cond-expand spec::            Specifications.

@ansrfi{1} list library

* list license::                Original license.
* list abstract::               Abstract.
* list rationale::              Rationale.
* list discussion::             Discussion.
* list spec::                   Specifications.
* list ack::                    Acknowledgements.
* list references::             References.

Discussion

* list disc general::           General discussion.
* list disc linear update::     ``Linear update'' procedures.
* list disc improper::          Improper lists.
* list disc errors::            Errors.
* list disc not included::      Not included in this library.

Specifications

* list spec intro::             Introduction.
* list spec cons::              Constructors.
* list spec pred::              Predicates.
* list spec select::            Selectors.
* list spec misc::              Miscellaneous: length, append,
                                concatenate, reverse, zip and
                                count.
* list spec fold::              Fold, unfold and map.
* list spec filter::            Filtering and partitioning.
* list spec search::            Searching.
* list spec delete::            Deletion.
* list spec alist::             Association lists.
* list spec set::               Set operations on lists.
* list spec side::              Primitive side--effects.

An @func{and} with local bindings

* and-let-star license::        Original license.
* and-let-star abstract::       Abstract.
* and-let-star rationale::      Rationale.
* and-let-star spec::           Specification.

Basic string ports

* string-ports license::        Original license.
* string-ports abstract::       Abstract.
* string-ports rationale::      Rationale.
* string-ports spec::           Specification.

Binding to multiple values

* receive license::             Original license.
* receive abstract::            Abstract.
* receive rationale::           Rationale.
* receive spec::                Specification.

Defining record types

* records license::             Original license.
* records abstract::            Abstract.
* records rationale::           Rationale.
* records spec::                Specification.

@ansrfi{13} string library

* strings license::             Original license.
* strings abstract::            Abstract.
* strings rationale::           Rationale.
* strings spec::                Specification.
* strings ack::                 Acknowledgments.
* strings references::          References.

Rationale

* strings ratio code-point::    Strings are code-point sequences.
* strings ratio i18n::          Internationalisation and
                                super-@ascii{} character types.

Specification

* strings spec intro::          Introduction.
* strings spec pred::           Predicates.
* strings spec cons::           Constructors.
* strings spec list::           List and string conversion.
* strings spec select::         Selection.
* strings spec modify::         Modification.
* strings spec compar::         Comparison.
* strings spec prefix::         Prefixes and suffixes.
* strings spec search::         Searching.
* strings spec case-map::       Alphabetic case mapping.
* strings spec append::         Reverse and append.
* strings spec fold::           Fold, unfold and map.
* strings spec replicate::      Replicate and rotate.
* strings spec misc::           Miscellaneous: intertion, parsing.
* strings spec filter::         Filtering and deleting.

Low level procedures

* strings spec parsing::        Start/end optional-argument parsing
                                and checking utilities.
* strings spec knuth::          Knuth-Morris-Pratt searching.

Syntax for procedures of variable arity

* case-lambda license::         Original license.
* case-lambda abstract::        Abstract.
* case-lambda rationale::       Rationale.
* case-lambda spec::            Specification.

Time data types and procedures

* time license::                Original license.
* time abstract::               Abstract.
* time rationale::              Rationale.
* time spec::                   Specification.
* time ack::                    Acknowledgements.

Specification

* time spec intro::             Introduction.
* time spec const::             Constants.
* time spec current::           Current time and clock resolution.
* time spec timeobj::           Time object and accessors.
* time spec timeobj compar::    Time object comparison procedures.
* time spec timeobj arithm::    Time object arithmetic procedures.
* time spec dateobj::           Date object and accessors.
* time spec julian::            Time/Date/Julian Day/Modified
                                Julian Day Converters.
* time spec string::            Date to string/string to date
                                converters.

Notation for specializing parameters without currying

* cut license::                 Original license.
* cut abstract::                Abstract.
* cut rationale::               Rationale.
* cut spec::                    Specification.
* cut design::                  Rationale design.
* cut ack::                     Acknowledgements.

Sources of random bits

* random license::              Original license.
* random abstract::             Abstract.
* random rationale::            Rationale.
* random spec::                 Specification.
* random design::               Design rationale.
* random usage::                Recommended usage patterns.
* random ack::                  Acknowledgements.
* random references::           References.

A special form @func{rec} for recursive evaluation

* rec license::                 Original license.
* rec abstract::                Abstract.
* rec rationale::               Rationale.
* rec spec::                    Specification.
* rec ack::                     Acknowledgements.
* rec references::              References.

A program argument processor

* args-fold license::           Original license.
* args-fold abstract::          Abstract.
* args-fold rationale::         Rationale.
* args-fold spec::              Specification.

Parameter objects

* parameters license::          Document license.
* parameters abstract::         Abstract.
* parameters rationale::        Rationale.
* parameters spec::             Specification.

Streams

* streams license::             Streams document license.
* streams abstract::            Abstract.
* streams rationale::           Rationale.
* streams primitive::           The @library{streams primitive} library.
* streams primitive example::   Streams primitive library example.
* streams derived::             The @library{streams derived} library.
* streams utilities::           Utilities.
* streams examples::            Examples.
* streams ack::                 Acknowledgments.
* streams references::          References.

Examples

* streams examples infinite::   Infinite streams.
* streams examples generators:: Generators and co--routines.
* streams examples pipeline::   A pipeline of procedures.
* streams examples persistent:: Persistent data.
* streams examples passes::     Reducing two passes to one.
* streams examples pitfalls::   Pitfalls.

Eager comprehensions

* eager-comp license::          Original license.
* eager-comp abstract::         Abstract.
* eager-comp rationale::        Rationale.
* eager-comp spec::             Specification.
* eager-comp design::           Design rationale.
* eager-comp ack::              Related work and acknowledgements.
* eager-comp references::       References.

Specification

* eager-comp spec comprehensions::      Comprehensions.
* eager-comp spec qualifiers::          Qualifiers.
* eager-comp spec generators::          Generators.
* eager-comp spec suggest::             Suggestions for application
                                        specific extensions.

Vector library

* vector license::              Original license.
* vector abstract::             Abstract.
* vector rationale::            Rationale.
* vector spec::                 Specification.
* vector ack::                  Acknowledgements.
* vector references::           References.

Specification

* vector spec intro::           Introduction.
* vector spec cons::            Constructors.
* vector spec pred::            Predicates.
* vector spec select::          Selectors.
* vector spec iter::            Iteration.
* vector spec search::          Searching.
* vector spec mutators::        Mutators.
* vector spec conv::            Conversion.

A more general @func{cond} clause

* general-cond license::        Original license.
* general-cond abstract::       Abstract.
* general-cond rationale::      Rationale.
* general-cond spec::           Specification.

Lightweight testing

* lightweight-testing license::         Original license.
* lightweight-testing abstract::        Abstract.
* lightweight-testing rationale::       Rationale.
* lightweight-testing spec::            Specification.
* lightweight-testing references::      References.

Environment variables

* environment-variables license::       Original license.
* environment-variables abstract::      Abstract.
* environment-variables rationale::     Rationale.
* environment-variables spec::          Specification.
* environment-variables issues::        Issues.
* environment-variables ack::           Acknowledgements.

@end detailmenu
@end menu

@end ifnottex

@c page
@node overview
@chapter Overview of the package


@noindent
This document describes version @version{} of @value{PACKAGE}, a
packaging of @srfi{}s for @rnrs{6} Scheme.  All the libraries can be
loaded with:

@example
(import (srfi @meta{name}))
@end example

@noindent
where @meta{name} is the ``name'' of the @srfi{}, for example:

@example
(import (srfi and-let-star))
@end example

Usage notices:

@itemize
@item
Additional stub libraries are installed, and they export @strong{almost}
the same bindings of the original @srfi{}s.

@item
All the bindings documented by the original @srfi{}s are exported by the
@library{srfi ---} libraries.  This will cause conflicts for some
@srfi{}; for example @library{srfi lists} redefines @func{map} and some
other functions.  These conflicts can be solved using the @rnrs{6}
selective import features of the @func{library} form.

@item
The stub libraries resolve the conflicts by exporting the redefined
functions with the @code{srfi:} prefix applied to the name.  Refer to
the @srfi{} documentation chapters for the list of redefined bindings.

@item
Whenever a binding is defined by both the @rnrs{6} and an @srfi{}, the
binding from the @rnrs{6} library is re-exported by the @srfi{} and stub
library.  There will be no conflicts with those.
@end itemize


@menu
* overview credits::            Credits and copying conditions.
* overview srfi::               The @srfi{} libraries.
* overview stub::               Stub libraries.
@end menu


@c page
@node overview credits
@section Credits and copying conditions


@insertcopying


@c page
@node overview srfi
@section The @srfi{} libraries


The following is a list of the available @srfi{} libraries.

@table @asis
@item @ansrfi{0}
@itemx @library{srfi cond-expand}
Feature based conditional expansion construct.

@item @ansrfi{1}
@itemx @library{srfi lists}
The list library.

@item @ansrfi{2}
@itemx @library{srfi and-let-star}
An @func{and} with local bindings.

@item @ansrfi{6}
@itemx @library{srfi string-ports}
Basic string ports.

@item @ansrfi{8}
@itemx @library{srfi receive}
Binding multiple values.

@item @ansrfi{9}
@itemx @library{srfi records}
Record types definition.

@item @ansrfi{13}
@itemx @library{srfi strings}
The string library.

@item @ansrfi{14}
@itemx @library{srfi char-set}
The character sets library.

@item @ansrfi{16}
@itemx @library{srfi case-lambda}
Syntax for procedures of variable arity.

@item @ansrfi{19}
@itemx @library{srfi time}
Time data types and procedures.

@item @ansrfi{23}
@itemx @library{srfi error-reporting}
Error reporting mechanism.

@item @ansrfi{26}
@itemx @library{srfi cut}
Notation for specialising parameters without currying.

@item @ansrfi{27}
@itemx @library{srfi random}
Sources of random bits.

@item @ansrfi{31}
@itemx @library{srfi rec}
A special form for recursive evaluation.

@item @ansrfi{37}
@itemx @library{srfi args-fold}
A program arguments processor.

@item @ansrfi{39}
@itemx @library{srfi parameters}
Parameter objects.

@item @ansrfi{41}
@itemx @library{srfi streams)}
The streams library.

@item @ansrfi{42}
@itemx @library{srfi eager-comprehensions}
Extended loop constructs.

@item @ansrfi{43}
@itemx @library{srfi vectors}
The vector library.

@item @ansrfi{61}
@itemx @library{srfi general-cond}
A more general @func{cond} clause.

@item @ansrfi{67}
@itemx @library{srfi compare}
Comparison functions.

@item @ansrfi{78}
@itemx @library{srfi lightweight-testing}
Library for lightweight test suites.

@item @ansrfi{98}
@itemx environment-variables
Environment variables.
@end table


@c page
@node overview stub
@section Stub libraries


Another way to import the @srfi{} bindings is to import the following
stub libraries.  See the @srfi{} documentation chapters for differences
between the bindings exported by the @library{srfi ---} libraries and
the bindings exported by the stub libraries.


@table @library
@item features-lib
Imports @library{srfi cond-expand} and exports all its bindings.

@item check-lib
Imports @library{srfi lightweight-testing} and exports all its bindings.

@item env-lib
Imports @library{srfi environment-variables} and exports all its
bindings.

@item format-lib
Imports @library{srfi format} and exports all its bindings.

@item list-lib
Imports @library{srfi lists} and exports all its bindings.

@item loop-lib
Imports @library{srfi eager-comprehensions} and exports all its
bindings.

@item parm-lib
Imports @library{srfi parameters} and exports all its bindings.

@item receive-lib
Imports @library{srfi receive} and exports all its bindings.

@item string-lib
Imports @library{srfi strings} and @library{srfi string-ports} and
exports all their bindings.

@item vector-lib
Imports @library{srfi vectors} and exports all its bindings.
@end table


@c page
@node cond-expand
@chapter Feature based conditional expansion construct


@ansrfi{0} was written by Marc Feeley, the @value{PACKAGE}
implementation was written by Derick Eddington.

@menu
* cond-expand license::         Original license.
* cond-expand abstract::        Abstract.
* cond-expand rationale::       Rationale.
* cond-expand spec::            Specifications.
* cond-expand features::        Feature identifiers.
@end menu


@c page
@node cond-expand license
@section Original license


Copyright @copyright{} Marc Feeley 1999.  All Rights Reserved.

This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it or
assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are included
on all such copies and derivative works.  However, this document itself
may not be modified in any way, such as by removing the copyright notice
or references to the Scheme Request For Implementation process or
editors, except as needed for the purpose of developing SRFIs in which
case the procedures for copyrights defined in the SRFI process must be
followed, or as required to translate it into languages other than
English.

The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.

This document and the information contained herein is provided on an
``AS IS'' basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.


@c page
@node cond-expand abstract
@section Abstract


@noindent
It is desirable that programs which depend on additions to standard
Scheme name those additions.  @srfi{}s provide the specifications of
these additions (``features''), and @ansrfi{0} provides the means to
actually check that these features are present in the Scheme system by
means of the @func{cond-expand} construct.  It is anticipated that there
will be two main classes of features:

@itemize
@item
sets of values and syntax bindings;

@item
reader syntax extensions;
@end itemize

@noindent
``reader syntax'' refers to aspects of the syntax described by the
grammars in the Scheme reports.

The former class of features will probably include most @srfi{}s,
exemplified by the list library specified in @ansrfi{1}.  The latter class
includes Unicode source code support and different kinds of parentheses.

Control over the presence of individual features will vary over
different Scheme systems.  A given feature may be absent or provided by
default in some Scheme systems and in others some mechanism (such as an
@func{import} clause in the code or a program configuration file, a
command line option, a dependency declaration in a module definition,
etc.) will be required for the feature to be present in the system.

Moreover, in some systems a given feature may be in effect throughout
the entire program if it is in effect anywhere at all.  Other systems
may have more precise mechanisms to control the scope of a feature (this
might be the case for example when a module system is supported).  In
general it is thus possible that a feature is in effect in some parts of
the program and not in others.  This allows conflicting @srfi{}s to be
present in a given program as long as their scope do not intersect.

@ansrfi{0} does not prescribe a particular mechanism for controlling the
presence of a feature as it is our opinion that this should be the role
of a module system.  We expect that future module system @srfi{}s will
need to extend the semantics of @ansrfi{0} for their purposes, for
example by defining feature scoping rules or by generalizing the feature
testing construct.

@c page
@node cond-expand rationale
@section Rationale


@noindent
Most Scheme systems extend the language with some additional features
(such as the ability to manipulate Unicode characters and strings, to do
binary I/O, or to handle asynchronous interrupts).  Such features may be
provided in a variety of ways including new procedures, new program
syntax, and extended behavior of standard procedures and special--forms.

A particular functionality may exist in several or even most Scheme
systems but its @api{} may be different (use of a procedure or
special--form, name, number of parameters, etc).  To write code that
will run on several Scheme systems, it is useful to have a common
construct to enable or disable sections of code based on the existence
or absence of a feature in the Scheme system being used.  For example,
the construct could be used to check if a particular binary I/O
procedure is present, and if not, load a portable library which
implements that procedure.

Features are identified by feature identifiers.  In order for the
semantics of this construct to be well--defined, the feature identifier
must of course refer to a feature which has a well--defined meaning.
There is thus a need for a registry, independent of this @srfi{}, to
keep track of the formal specification associated with each valid
feature--identifier.  The @srfi{} registry is used for this purpose.
It is expected that features will eventually be assigned meaningful
names (aliases) by the @srfi{} editors to make reading and writing code
less tedious than when using @code{srfi-N} feature identifiers.

Another issue is the binding time of this construct (i.e. the moment
when it operates).  It is important that the binding time be early so
that a compiler can discard the sections of code that are not needed,
and perform better static analyses.  Expressing this construct through a
procedure returning a boolean, such as:

@example
(feature-implemented? 'srfi-5)
@end example

@noindent
would not achieve this goal, as its binding time is too late
(i.e. program run--time).  A read--time construct, such as Common Lisp's
@code{#+} read-macro, is very early but would require non--trivial
changes to the reader of existing Scheme systems and the syntax is not
particularly human friendly.  Instead, a macro--expansion--time
construct is used.

The construct is restricted to the top level of a program in order to
simplify its implementation and to force a more disciplined use of the
construct (to facilitate reading and understanding programs) and to
avoid (some) misunderstandings related to the scope of features.  These
restrictions can of course be lifted by some Scheme systems or by other
@srfi{}s (in particular module system @srfi{}s).


@c page
@node cond-expand spec
@section Specifications


@findex cond-expand


@noindent
Syntax:

@example
<command or definition>
    --> <command>
      | <definition>
      | <syntax definition>
      | (begin <command or definition>+)
      | <conditional expansion form>
<conditional expansion form>
    --> (cond-expand <cond-expand clause>+)
      | (cond-expand <cond-expand clause>* (else <command or definition>*))
<cond-expand clause>
    --> (<feature requirement> <command or definition>*)
<feature requirement>
    --> <feature identifier>
      | (and <feature requirement>*)
      | (or <feature requirement>*)
      | (not <feature requirement>)
<feature identifier>
    --> a symbol which is the name or alias of a SRFI
@end example

The @func{cond-expand} form tests for the existence of features at
macro--expansion time.  It either expands into the body of one of its
clauses or signals an error during syntactic processing.
@func{cond-expand} expands into the body of the first clause whose
feature requirement is currently satisfied (the else clause, if present,
is selected if none of the previous clauses is selected).

A feature requirement has an obvious interpretation as a logical
formula, where the @code{<feature identifier>} variables have meaning
TRUE if the feature corresponding to the feature identifier, as
specified in the @srfi{} registry, is in effect at the location of the
@func{cond-expand} form, and FALSE otherwise.  A feature requirement is
satisfied if its formula is true under this interpretation.

Examples:

@example
(cond-expand
  [(and srfi-1 srfi-10)
   (write 1)]
  [(or srfi-1 srfi-10)
   (write 2)]
  [else])

(cond-expand
  (command-line
   (define (program-name) (car (argv)))))
@end example

The second example assumes that @func{command-line} is an alias for some
feature which gives access to command line arguments.  Note that an
error will be signaled at macro--expansion time if this feature is not
present.


@c page
@node cond-expand features
@section Feature identifiers


What follows is a list of features that can be queried using the
@value{PACKAGE} implementation of this library.


@table @code
@item srfi-0
@itemx srfi-1
@itemx srfi-2
@itemx srfi-6
@itemx srfi-8
@itemx srfi-9
@itemx srfi-13
@itemx srfi-14
@itemx srfi-16
@itemx srfi-19
@itemx srfi-26
@itemx srfi-27
@itemx srfi-31
@itemx srfi-37
@itemx srfi-38
@itemx srfi-39
@itemx srfi-41
@itemx srfi-42
@itemx srfi-43
@itemx srfi-48
@itemx srfi-61
@itemx srfi-67
@itemx srfi-78
@itemx (srfi cond-expand)
@itemx (srfi lists)
@itemx (srfi and-let*)
@itemx (srfi string-ports)
@itemx (srfi receive)
@itemx (srfi records)
@itemx (srfi strings)
@itemx (srfi char-set)
@itemx (srfi case-lambda)
@itemx (srfi time)
@itemx (srfi cut)
@itemx (srfi random)
@itemx (srfi rec)
@itemx (srfi args-fold)
@itemx (srfi sharing)
@itemx (srfi parameters)
@itemx (srfi streams)
@itemx (srfi eager-comprehensions)
@itemx (srfi vectors)
@itemx (srfi format)
@itemx (srfi general-cond)
@itemx (srfi compare)
@itemx (srfi lightweight-testing)
One feature for each @srfi{}.
@end table


@c page
@node list
@chapter @ansrfi{1} list library


@cindex @srfi{} list library


The @library{srfi lists} library has been written by Olin Shivers
@email{shivers@@ai.mit.edu} as the reference implementation for
@ansrfi{1}etails.

@menu
* list license::                Original license.
* list abstract::               Abstract.
* list rationale::              Rationale.
* list discussion::             Discussion.
* list spec::                   Specifications.
* list ack::                    Acknowledgements.
* list references::             References.
@end menu


@c page
@node list license
@section Original license


Certain portions of this document (the specific, marked segments of text
describing the R5RS procedures) were adapted with permission from the
@rnrs{5} report.

All other text is copyright @copyright{} 1998, 1999 Olin Shivers.  All
Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node list abstract
@section Abstract


@rnrs{5} Scheme has an impoverished set of list--processing utilities,
which is a problem for authors of portable code.  This @srfi{} proposes
a coherent and comprehensive set of list--processing procedures; it is
accompanied by a reference implementation of the spec.  The reference
implementation is:

@itemize
@item
portable;

@item
efficient;

@item
completely open, public--domain source.
@end itemize


@c page
@node list rationale
@section Rationale


The set of basic list and pair operations provided by @rnrs{4}/@rnrs{5}
Scheme is far from satisfactory.  Because this set is so small and
basic, most implementations provide additional utilities, such as a
list--filtering function, or a ``left fold'' operator, and so forth.
But, of course, this introduces incompatibilities----different Scheme
implementations provide different sets of procedures.

I have designed a full--featured library of procedures for list
processing.  While putting this library together, I checked as many
Schemes as I could get my hands on.  (I have a fair amount of experience
with several of these already.)  I missed Chez (no on--line manual that
I can find) but I hit most of the other big, full--featured Schemes.
The complete list of list--processing systems I checked is:

@example
R4RS/R5RS Scheme
MIT Scheme
Gambit
RScheme
MzScheme
slib
Common Lisp
Bigloo
guile
T
APL and the SML standard basis
@end example

As a result, the library I am proposing is fairly rich.

Following this initial design phase, this library went through several
months of discussion on the @srfi{} mailing lists, and was altered in
light of the ideas and suggestions put forth during this discussion.

In parallel with designing this @api{}, I have also written a reference
implementation.  I have placed this source on the Net with an
unencumbered, ``open'' copyright.  A few notes about the reference
implementation:

@itemize
@item
Although I got procedure names and specs from many Schemes, I wrote this
code myself.  Thus, there are no entanglements.  Any Scheme implementor
can pick this library up with no worries about copyright problems, both
commercial and non--commercial systems.

@item
The code is written for portability and should be trivial to port to any
Scheme.  It has only four deviations from @rnrs{4}, clearly discussed in
the comments:

@itemize
@item
use of an error procedure;

@item
use of the @rnrs{5} values and a simple receive macro for producing and
consuming multiple return values;

@item
use of simple @code{:optional} and @func{let-optionals} macros for
optional argument parsing and defaulting;

@item
use of a simple @func{check-arg} procedure for argument checking.
@end itemize

@item
It is written for clarity and well--commented.  The current source is
768 lines of source code and 826 lines of comments and white space.

@item
It is written for efficiency.  Fast paths are provided for common cases.
Side--effecting procedures such as @func{filter!} avoid unnecessary,
redundant @func{set-cdr!} calls which would thrash a generational
garbage--collection's write barrier and the store buffers of fast
processors.  Functions reuse longest common tails from input parameters
to construct their results where possible.  Constant--space iterations
are used in preference to recursions; local recursions are used in
preference to consing temporary intermediate data structures.
@end itemize

This is not to say that the implementation can't be tuned up for a
specific Scheme implementation.  There are notes in comments addressing
ways implementors can tune the reference implementation for performance.

In short, I've written the reference implementation to make it as
painless as possible for an implementor, or a regular programmer, to
adopt this library and get good results with it.


@c page
@node list discussion
@section Discussion


@menu
* list disc general::           General discussion.
* list disc linear update::     ``Linear update'' procedures.
* list disc improper::          Improper lists.
* list disc errors::            Errors.
* list disc not included::      Not included in this library.
@end menu


@c page
@node list disc general
@subsection General discussion


A set of general criteria guided the design of this library.

I don't require ``destructive'' (what I call ``linear update'')
procedures to alter and recycle cons cells from the argument lists.
They are allowed to, but not required to.  (And the reference
implementations I have written do recycle the argument lists.)

List--filtering procedures such as @func{filter} or @func{delete} do not
disorder lists.  Elements appear in the answer list in the same order as
they appear in the argument list.  This constrains implementation, but
seems like a desirable feature, since in many uses of lists, order
matters.  (In particular, disordering an alist is definitely a bad
idea.)

Contrariwise, although the reference implementations of the
list--filtering procedures share longest common tails between argument
and answer lists, it not is part of the spec.

Because lists are an inherently sequential data structure (unlike, say,
vectors), list--inspection functions such as @func{find},
@func{find-tail}, @func{for-each}, any and every commit to a
left--to--right traversal order of their argument list.

However, constructor functions, such as @func{list-tabulate} and the
mapping procedures (@func{append-map}, @func{append-map!}, @func{map!},
@func{pair-for-each}, @func{filter-map}, @func{map-in-order}), do not
specify the dynamic order in which their procedural argument is applied
to its various values.

Predicates return useful true values wherever possible.  Thus any must
return the true value produced by its predicate, and every returns the
final true value produced by applying its predicate argument to the last
element of its argument list.

Functionality is provided both in pure and linear--update (potentially
destructive) forms wherever this makes sense.

No special status accorded Scheme's built--in equality functions.  Any
functionality provided in terms of @func{eq?}, @func{eqv?},
@func{equal?} is also available using a client--provided equality
function.

Proper design counts for more than backwards compatibility, but I have
tried, ceteris paribus, to be as backwards--compatible as possible with
existing list--processing libraries, in order to facilitate porting old
code to run as a client of the procedures in this library.  Name choices
and semantics are, for the most part, in agreement with existing
practice in many current Scheme systems.  I have indicated some
incompatibilities in the following text.

These procedures are not ``sequence generic''----i.e. procedures that
operate on either vectors and lists.  They are list--specific.  I prefer
to keep the library simple and focused.

I have named these procedures without a qualifying initial @code{list-}
lexeme, which is in keeping with the existing set of list--processing
utilities in Scheme.  I follow the general Scheme convention
(@func{vector-length}, @func{string-ref}) of placing the type--name
before the action when naming procedures----so we have @func{list-copy}
and @func{pair-for-each} rather than the perhaps more fluid, but less
consistent, @func{copy-list} or @func{for-each-pair}.

I have generally followed a regular and consistent naming scheme,
composing procedure names from a set of basic lexemes.


@c page
@node list disc linear update
@subsection ``Linear update'' procedures


Many procedures in this library have ``pure'' and ``linear update''
variants.  A ``pure'' procedure has no side--effects, and in particular
does not alter its arguments in any way.  A ``linear update'' procedure
is allowed, but not required, to side--effect its arguments in order to
construct its result.  ``Linear update'' procedures are typically given
names ending with an exclamation point.

So, for example, @code{(append!  list1 list2)} is allowed to construct
its result by simply using @func{set-cdr!} to set the cdr of the last
pair of @var{list1} to point to @var{list2}, and then returning
@var{list1} (unless @var{list1} is the empty list, in which case it
would simply return @var{list2}).  However, @func{append!} may also
elect to perform a pure append operation, this is a legal definition of
append!:

@example
(define append! append)
@end example

This is why we do not call these procedures ``destructive'', because
they aren't required to be destructive.  They are @emph{potentially}
destructive.

What this means is that you may only apply linear--update procedures to
values that you know are ``dead'', values that will never be used again
in your program.  This must be so, since you can't rely on the value
passed to a linear--update procedure after that procedure has been
called.  It might be unchanged; it might be altered.

The ``linear'' in ``linear update'' doesn't mean ``linear time'' or
``linear space'' or any sort of multiple--of--n kind of meaning.  It's a
fancy term that type theorists and pure functional programmers use to
describe systems where you are only allowed to have exactly one
reference to each variable.  This provides a guarantee that the value
bound to a variable is bound to no other variable.  So when you use a
variable in a variable reference, you ``use it up''.  Knowing that no
one else has a pointer to that value means the a system primitive is
free to side--effect its arguments to produce what is, observationally,
a pure--functional result.

In the context of this library, ``linear update'' means you, the
programmer, know there are no other live references to the value passed
to the procedure; after passing the value to one of these procedures,
the value of the old pointer is indeterminate.  Basically, you are
licensing the Scheme implementation to alter the data structure if it
feels like it; you have declared you don't care either way.

You get no help from Scheme in checking that the values you claim are
``linear'' really are.  So you better get it right.  Or play it safe and
use the non--@code{!} procedures; it doesn't do any good to compute
quickly if you get the wrong answer.

Why go to all this trouble to define the notion of ``linear update'' and
use it in a procedure spec, instead of the more common notion of a
``destructive'' operation?

First, note that destructive list--processing procedures are almost
always used in a linear--update fashion.  This is in part required by
the special case of operating upon the empty list, which can't be
side--effected.  This means that destructive operators are not pure
side--effects, they have to return a result.

Second, note that code written using linear--update operators can be
trivially ported to a pure, functional subset of Scheme by simply
providing pure implementations of the linear--update operators.

Finally, requiring destructive side--effects ruins opportunities to
parallelise these operations, and the places where one has taken the
trouble to spell out destructive operations are usually exactly the code
one would want a parallelising compiler to parallelise: the
efficiency--critical kernels of the algorithm.

Linear--update operations are easily parallelised.  Going with a
linear--update spec doesn't close off these valuable alternative
implementation techniques.  This list library is intended as a set of
low--level, basic operators, so we don't want to exclude these possible
implementations.

The linear--update procedures in this library are:

@example
alist-delete!           append!
append-map!             append-reverse!
break!                  concatenate!
delete!                 delete-duplicates!
drop-right!             filter!
lset-adjoin!            lset-diff+intersection!
lset-difference!        lset-xor!
lset-intersection!      lset-union!
map!                    partition!
remove!                 reverse!
span!                   split-at!
take!                   take-while!
@end example



@c page
@node list disc improper
@subsection Improper Lists


Scheme does not properly have a list type, just as the C language does
not have a string type.  Rather, Scheme has a binary--tuple type, from
which one can build binary trees.  There is an interpretation of Scheme
values that allows one to treat these trees as lists.  Further
complications ensue from the fact that Scheme allows side--effects to
these tuples, raising the possibility of lists of unbounded length, and
trees of unbounded depth (that is, circular data structures).

However, there is a simple view of the world of Scheme values that
considers every value to be a list of some sort.  That is, every value
is either:

@itemize
@item
a ``proper list'' (a finite, nil--terminated list) such as:

@example
(a b c)
()
(32)
@end example

@item
a ``dotted list'' (a finite, non--nil terminated list) such as:

@example
(a b c . d)
(x . y)
42
george
@end example

@item
or a ``circular list'' (an infinite, unterminated list).
@end itemize

Note that the zero--length dotted lists are simply all the non--null,
non--pair values.

This view is captured by the predicates @func{proper-list?},
@func{dotted-list?}, and @func{circular-list?}.  This list library users
should note that dotted lists are not commonly used, and are considered
by many Scheme programmers to be an ugly artifact of Scheme's lack of a
true list type.  However, dotted lists do play a noticeable role in the
syntax of Scheme, in the ``rest'' parameters used by n--ary lambdas:

@example
(lambda (x y . rest) ...)
@end example

Dotted lists are not fully supported by this list library.  Most
procedures are defined only on proper lists, that is: finite,
nil--terminated lists.  The procedures that will also handle circular or
dotted lists are specifically marked.  While this design decision
restricts the domain of possible arguments one can pass to these
procedures, it has the benefit of allowing the procedures to catch the
error cases where programmers inadvertently pass scalar values to a list
procedure by accident, e.g., by switching the arguments to a procedure
call.



@c page
@node list disc errors
@subsection Errors


Note that statements of the form ``it is an error'' merely mean ``don't
do that''.  They are no a guarantees that a conforming implementation
will ``catch'' such improper use by, for example, raising some kind of
exception.  Regrettably, @rnrs{5} Scheme requires no firmer guarantee
even for basic operators such as @func{car} and @func{cdr}, so there's
little point in requiring these procedures to do more.  Here is the
relevant section of the @rnrs{5}:

@quotation
When speaking of an error situation, this report uses the phrase ``an
error is signalled'' to indicate that implementations must detect and
report the error.  If such wording does not appear in the discussion of
an error, then implementations are not required to detect or report the
error, though they are encouraged to do so.  An error situation that
implementations are not required to detect is usually referred to simply
as ``an error''.

For example, it is an error for a procedure to be passed an argument
that the procedure is not explicitly specified to handle, even though
such domain errors are seldom mentioned in this report.  Implementations
may extend a procedure's domain of definition to include such arguments.
@end quotation


@c page
@node list disc not included
@subsection Not included in this library


The following items are not in this library:

@itemize
@item
sort routines;

@item
destructuring/pattern--matching macro;

@item
tree--processing routines.
@end itemize

@noindent
they should have their own @srfi{} specs.


@c page
@node list spec
@section Specifications


@cindex List library interface


@menu
* list spec intro::             Introduction.
* list spec stub::              Stub library bindings.
* list spec cons::              Constructors.
* list spec pred::              Predicates.
* list spec select::            Selectors.
* list spec misc::              Miscellaneous: length, append,
                                concatenate, reverse, zip and
                                count.
* list spec fold::              Fold, unfold and map.
* list spec filter::            Filtering and partitioning.
* list spec search::            Searching.
* list spec delete::            Deletion.
* list spec alist::             Association lists.
* list spec set::               Set operations on lists.
* list spec side::              Primitive side--effects.
@end menu


@c page
@node list spec intro
@subsection Introduction


In a Scheme system that has a module or package system, these procedures
should be contained in a module named @code{list-lib}.  The templates
given below obey the following conventions for procedure formals:

@table @code
@item list
a proper (finite, nil--terminated) list;

@item clist
a proper or circular list;

@item flist
a finite (proper or dotted) list;

@item pair
a pair;

@item x, y, d, a
any value;

@item object, value
any value;

@item n, i
a natural number (an integer >= 0);

@item proc
a procedure;

@item pred
a procedure whose return value is treated as a boolean;

@item =
a boolean procedure taking two arguments.
@end table

It is an error to pass a circular or dotted list to a procedure not
defined to accept such an argument.


@c page
@node list spec stub
@subsection Stub library bindings


The bindings exported by @library{srfi lists} are re--exported by
@library{list-lib} with the following changes:

@enumerate
@item
The @func{map} function from the @srfi{} is renamed to @func{srfi:map}.

@item
The @func{fold-right} function from the @srfi{} is renamed to
@func{srfi:fold-right}.
@end enumerate


Additionally the following bindings are defined.


@defun tree-copy @var{ell}
Copy the whole tree of the list @var{ell}, not only the spine (which is
what @func{list-copy} does).
@end defun


@c page
@node list spec cons
@subsection Constructors


@cindex List constructors


@menu
* list spec cons pair::         Pair constructors.
* list spec cons list::         List constructors.
@end menu


@c page
@node list spec cons pair
@subsubsection Pair constructors


@defun cons @var{a} @var{d}
@rnrs{5} The primitive constructor.  Return a newly allocated pair whose
car is @var{a} and whose cdr is @var{d}.  The pair is guaranteed to be
different (in the sense of @func{eqv?}) from every existing object.

@example
(cons 'a '())        => (a)
(cons '(a) '(b c d)) => ((a) b c d)
(cons "a" '(b c))    => ("a" b c)
(cons 'a 3)          => (a . 3)
(cons '(a b) 'c)     => ((a b) . c)
@end example
@end defun


@defun xcons @var{d} @var{a}
Defined as @code{(lambda (d a) (cons a d))}.  Of utility only as a value
to be conveniently passed to higher--order procedures.

@example
(xcons '(b c) 'a) => (a b c)
@end example

The name stands for ``eXchanged CONS''.
@end defun


@defun {cons*} @var{elt1} @var{elt2} ...
Like @func{list}, but the last argument provides the tail of the
constructed list, returning:

@example
(cons elt1 (cons elt2 (cons ... eltn)))
@end example

This function is called @func{list*} in Common Lisp and about half of
the Schemes that provide it, and @func{cons*} in the other half.

@example
(cons* 1 2 3 4) => (1 2 3 . 4)
(cons* 1) => 1
@end example
@end defun


@c page
@node list spec cons list
@subsubsection List constructors


@defun list @var{object} ...
@rnrs{5} Return a newly allocated list of its arguments.

@example
(list 'a (+ 3 4) 'c) =>  (a 7 c)
(list)               =>  ()
@end example
@end defun


@defun make-list @var{n} [@var{fill}]
Return an @var{n}--element list, whose elements are all the value
@var{fill}.  If the fill argument is not given, the elements of the list
may be arbitrary values.

@example
(make-list 4 'c) => (c c c c)
@end example
@end defun


@defun list-tabulate @var{n} @var{init-proc}
Return an @var{n}--element list.  Element @var{i} of the list, where
@code{0 <= i < n}, is produced by @code{(init-proc i)}.  No guarantee is
made about the dynamic order in which @var{init-proc} is applied to
these indices.

@example
(list-tabulate 4 values) => (0 1 2 3)
@end example
@end defun


@defun list-copy @var{flist}
Copy the spine of the argument.
@end defun


@defun circular-list @var{elt1} @var{elt2} ...
Construct a circular list of the elements.

@example
(circular-list 'z 'q) => (z q z q z q ...)
@end example
@end defun


@defun iota @var{count} [@var{start} @var{step}]
Return a list containing the elements:

@example
(start start+step ... start+(count-1)*step)
@end example

The @var{start} and @var{step} parameters default to @code{0} and
@code{1}, respectively.  This procedure takes its name from the
@acronym{APL} primitive.

@example
(iota 5) => (0 1 2 3 4)
(iota 5 0 -0.1) => (0 -0.1 -0.2 -0.3 -0.4)
@end example

@quotation
@strong{Nausicaa note:} When @var{count} is negative the return value is
the empty list.
@end quotation
@end defun


@c page
@node list spec pred
@subsection Predicates


@cindex List predicates


@menu
* list spec pred kind::         Kinds of list.
* list spec pred null::         Null predicates.
* list spec pred pair::         Pair predicates.
@end menu


@c page
@node list spec pred kind
@subsubsection Kind of list


The predicates @func{proper-list?}, @func{circular-list?}, and
@func{dotted-list?} partition the entire universe of Scheme values.


@defun proper-list? @var{x}
Return true if, and only if, @var{x} is a proper list: a finite,
nil--terminated list.  More carefully: The empty list is a proper list.
A pair whose cdr is a proper list is also a proper list:

@example
<proper-list> ::= ()                        (Empty proper list)
              |   (cons <x> <proper-list>)  (Proper-list pair)
@end example

Note that this definition rules out circular lists.  This function is
required to detect this case and return @false{}.  Nil--terminated lists
are called ``proper'' lists by @rnrs{5} and Common Lisp.  The opposite
of proper is improper.

@rnrs{5} binds this function to the variable @func{list?}.

@example
(not (proper-list? x)) = (or (dotted-list? x)
                             (circular-list? x))
@end example
@end defun


@defun circular-list? @var{x}
Return @true{} if @var{x} is a circular list.  A circular list is a
value such that for every @code{n >= 0}, @code{cdrn(x)} is a pair.

Terminology: The opposite of circular is finite.

@example
(not (circular-list? x)) = (or (proper-list? x)
                               (dotted-list? x))
@end example
@end defun


@defun dotted-list? @var{x}
Return @true{} if @var{x} is a finite, non--nil--terminated list.  That
is, there exists an @code{n >= 0} such that @code{cdrn(x)} is neither a
pair nor @code{()}.  This includes non--pair, non--@code{()} values
(e.g. symbols, numbers), which are considered to be dotted lists of
length 0.

@example
(not (dotted-list? x)) = (or (proper-list? x)
                             (circular-list? x))
@end example
@end defun


@c page
@node list spec pred null
@subsubsection Null predicates


@defun null? @var{object}
Return @true{} if object is the empty list; otherwise @false{}.
@end defun


@defun null-list? list
@var{list} is a proper or circular list.  This procedure returns @true{}
if the argument is the empty list, and @false{} otherwise.  It is an
error to pass this procedure a value which is not a proper or circular
list.  This procedure is recommended as the termination condition for
list--processing procedures that are not defined on dotted lists.
@end defun


@c page
@node list spec pred pair
@subsubsection Pair predicates


@defun pair? @var{object}
Return @true{} if object is a pair; otherwise @false{}.

@example
(pair? '(a . b)) =>  #t
(pair? '(a b c)) =>  #t
(pair? '())      =>  #f
(pair? '#(a b))  =>  #f
(pair? 7)        =>  #f
(pair? 'a)       =>  #f
@end example
@end defun


@defun not-pair? @var{x}
Defined as: @code{(lambda (x) (not (pair? x)))}.  Provided as a
procedure as it can be useful as the termination condition for
list--processing procedures that wish to handle all finite lists, both
proper and dotted.
@end defun


@defun list= @var{elt=} @var{list1} ...
Determines list equality, given an element--equality procedure
@var{elt=}.  Proper list @var{AL} equals proper list @var{BL} if they
are of the same length, and their corresponding elements are equal, as
determined by @var{elt=}.  If the element--comparison procedure's first
argument is from @var{listi}, then its second argument is from
@var{listi+1}, i.e. it is always called as @code{(elt= a b)} for @var{a}
an element of list @var{AL}, and @var{b} an element of list @var{BL}.

In the n--ary case, every @var{listi} is compared to @var{listi+1} (as
opposed, for example, to comparing @var{list1} to every @var{listi}, for
@code{i>1}).  If there are no list arguments at all, @func{list=} simply
returns true.

It is an error to apply @func{list=} to anything except proper lists.
While implementations may choose to extend it to circular lists, note
that it cannot reasonably be extended to dotted lists, as it provides no
way to specify an equality procedure for comparing the list terminators.

Note that the dynamic order in which the @var{elt=} procedure is applied
to pairs of elements is not specified.  For example, if @func{list=} is
applied to three lists, @var{AL}, @var{BL}, and @var{CL}, it may first
completely compare @var{AL} to @var{BL}, then compare @var{BL} to
@var{CL}, or it may compare the first elements of @var{AL} and @var{BL},
then the first elements of @var{BL} and @var{CL}, then the second
elements of @var{AL} and @var{BL}, and so forth.

The equality procedure must be consistent with @func{eq?}.  That is, it
must be the case that:

@example
(eq? x y) => (elt= x y)
@end example

Note that this implies that two lists which are @func{eq?} are always
@func{list=}, as well; implementations may exploit this fact to
``short--cut'' the element--by--element comparisons.

@example
(list= eq?) => #t       ; Trivial cases
(list= eq? '(a)) => #t
@end example
@end defun


@c page
@node list spec select
@subsection Selectors


@cindex List selectors


@defun car @var{pair}
@defunx cdr @var{pair}
@rnrs{5} These functions return the contents of the car and cdr field of
their argument, respectively.  Note that it is an error to apply them to
the empty list.

@example
(car '(a b c))     =>  a       | (cdr '(a b c))     =>  (b c)
(car '((a) b c d)) =>  (a)     | (cdr '((a) b c d)) =>  (b c d)
(car '(1 . 2))     =>  1       | (cdr '(1 . 2))     =>  2
(car '())          =>  *error* | (cdr '())          =>  *error*
@end example
@end defun


@defun caar @var{pair}
@defunx cadr @var{pair}
@defunx c...r @var{pair}
@defunx cdddar @var{pair}
@defunx cddddr @var{pair}
@rnrs{5} These procedures are compositions of @func{car} and @func{cdr},
where for example @func{caddr} could be defined by:

@example
(define caddr (lambda (x) (car (cdr (cdr x)))))
@end example

Arbitrary compositions, up to four deep, are provided. There are
twenty-eight of these procedures in all.
@end defun


@defun list-ref @var{clist} @var{i}
@rnrs{5} Return the @var{i}-th element of clist.  This is the same as
the car of @code{(drop clist i)}.  It is an error if @code{i >= n},
where @var{n} is the length of clist.

@example
(list-ref '(a b c d) 2) => c
@end example
@end defun


@defun first @var{pair}
@defunx second  @var{pair}
@defunx third   @var{pair}
@defunx fourth  @var{pair}
@defunx fifth   @var{pair}
@defunx sixth   @var{pair}
@defunx seventh @var{pair}
@defunx eighth  @var{pair}
@defunx ninth   @var{pair}
@defunx tenth   @var{pair}
Synonyms for @func{car}, @func{cadr}, @func{caddr}, ...

@example
(third '(a b c d e)) => c
@end example
@end defun


@defun {car+cdr} @var{pair}
The fundamental pair deconstructor:

@example
(lambda (p) (values (car p) (cdr p)))
@end example

This can, of course, be implemented more efficiently by a compiler.
@end defun


@defun take @var{x} @var{i}
@defunx drop @var{x} @var{i}
@func{take} returns the first @var{i} elements of list @var{x}.
@func{drop} returns all but the first @var{i} elements of list @var{x}.

@example
(take '(a b c d e)  2) => (a b)
(drop '(a b c d e)  2) => (c d e)
@end example

@var{x} may be any value: a proper, circular, or dotted list:

@example
(take '(1 2 3 . d) 2) => (1 2)
(drop '(1 2 3 . d) 2) => (3 . d)
(take '(1 2 3 . d) 3) => (1 2 3)
(drop '(1 2 3 . d) 3) => d
@end example

For a legal @var{i}, @func{take} and @func{drop} partition the list in a
manner which can be inverted with append:

@example
(append (take x i) (drop x i)) = x
@end example

@func{drop} is exactly equivalent to performing @var{i} @func{cdr}
operations on @var{x}; the returned value shares a common tail with
@var{x}.

If the argument is a list of non--zero length, @func{take} is guaranteed
to return a freshly--allocated list, even in the case where the entire
list is taken, e.g. @code{(take lis (length lis))}.
@end defun


@defun take-right @var{flist} @var{i}
@defunx drop-right @var{flist} @var{i}
@func{take-right} returns the last @var{i} elements of @var{flist}.
@func{drop-right} returns all but the last @var{i} elements of
@var{flist}.

@example
(take-right '(a b c d e) 2) => (d e)
(drop-right '(a b c d e) 2) => (a b c)
@end example

The returned list may share a common tail with the argument list.

@var{flist} may be any finite list, either proper or dotted:

@example
(take-right '(1 2 3 . d) 2) => (2 3 . d)
(drop-right '(1 2 3 . d) 2) => (1)
(take-right '(1 2 3 . d) 0) => d
(drop-right '(1 2 3 . d) 0) => (1 2 3)
@end example

For a legal @var{i}, @func{take-right} and @var{drop-right} partition
the list in a manner which can be inverted with append:

@example
(append (take flist i) (drop flist i)) = flist
@end example

The return value of @func{take-right} is guaranteed to share a common
tail with @var{flist}.

If the argument is a list of non--zero length, @func{drop-right} is
guaranteed to return a freshly--allocated list, even in the case where
nothing is dropped, e.g. @code{(drop-right lis 0)}.
@end defun


@defun take! @var{x} @var{i}
@defunx drop-right! @var{flist} @var{i}
@func{take!} and @func{drop-right!} are linear--update variants of
@func{take} and @func{drop-right}: the procedure is allowed, but not
required, to alter the argument list to produce the result.

If @var{x} is circular, @func{take!} may return a
shorter--than--expected list:

@example
(take! (circular-list 1 3 5) 8) => (1 3)
(take! (circular-list 1 3 5) 8) => (1 3 5 1 3 5 1 3)
@end example
@end defun


@defun split-at @var{x} @var{i}
@defunx split-at! @var{x} @var{i}
@func{split-at} splits the list @var{x} at index @var{i}, returning a
list of the first @var{i} elements, and the remaining tail.  It is
equivalent to:

@example
(values (take x i) (drop x i))
@end example

@func{split-at!} is the linear--update variant.  It is allowed, but not
required, to alter the argument list to produce the result.

@example
(split-at '(a b c d e f g h) 3)
=> (a b c)
   (d e f g h)
@end example
@end defun


@defun last @var{pair}
@defunx last-pair @var{pair}
@func{last} returns the last element of the non--empty, finite list
@var{pair}.  @func{last-pair} returns the last pair in the non--empty,
finite list @var{pair}.

@example
(last '(a b c)) => c
(last-pair '(a b c)) => (c)
@end example
@end defun


@c page
@node list spec misc
@subsection Miscellaneous: length, append, concatenate, reverse, zip and count


@cindex List length
@cindex List appending
@cindex List contatenation
@cindex List reversing
@cindex List zip
@cindex List counting


@defun length @var{list}
@defunx {length+} @var{clist}
Both @func{length} and @func{length+} return the length of the argument.
It is an error to pass a value to @func{length} which is not a proper
list (finite and nil--terminated).  In particular, this means an
implementation may diverge or signal an error when @func{length} is
applied to a circular list.

@func{length+}, on the other hand, returns @false{} when applied to a
circular list.

The length of a proper list is a non--negative integer @var{n} such that
@func{cdr} applied @var{n} times to the list produces the empty list.
@end defun


@defun append @var{list1} ...
@defunx append! @var{list1} ...
@func{append} returns a list consisting of the elements of @var{list1}
followed by the elements of the other list parameters.

@example
(append '(x) '(y))        =>  (x y)
(append '(a) '(b c d))    =>  (a b c d)
(append '(a (b)) '((c)))  =>  (a (b) (c))
@end example

The resulting list is always newly allocated, except that it shares
structure with the final @var{listi} argument.  This last argument may
be any value at all; an improper list results if it is not a proper
list.  All other arguments must be proper lists.

@example
(append '(a b) '(c . d))  =>  (a b c . d)
(append '() 'a)           =>  a
(append '(x y))           =>  (x y)
(append)                  =>  ()
@end example

@func{append!} is the linear--update variant of @func{append}; it is
allowed, but not required, to alter cons cells in the argument lists to
construct the result list.  The last argument is never altered; the
result list shares structure with this parameter.
@end defun


@defun concatenate @var{list-of-lists}
@defunx concatenate! @var{list-of-lists}
These functions append the elements of their argument together.  That
is, @func{concatenate} returns:

@example
(apply append list-of-lists)
@end example

@noindent
or, equivalently:

@example
(reduce-right append '() list-of-lists)
@end example

@func{concatenate!} is the linear--update variant, defined in terms
of @func{append!} instead of @func{append}.

Note that some Scheme implementations do not support passing more than a
certain number (e.g. 64) of arguments to an n--ary procedure.  In these
implementations, the @code{(apply append ...)} idiom would fail when
applied to long lists, but concatenate would continue to function
properly.

As with @func{append} and @func{append!}, the last element of the input
list may be any value at all.
@end defun


@defun reverse @var{list}
@defunx reverse! @var{list}
@func{reverse} returns a newly allocated list consisting of the elements
of @var{list} in reverse order.

@example
(reverse '(a b c))              =>  (c b a)
(reverse '(a (b c) d (e (f))))  =>  ((e (f)) d (b c) a)
@end example

@func{reverse!} is the linear--update variant of @func{reverse}.  It
is permitted, but not required, to alter the argument's cons cells to
produce the reversed list.
@end defun


@defun append-reverse @var{rev-head} @var{tail}
@defunx append-reverse! @var{rev-head} @var{tail}
@func{append-reverse} returns:

@example
(append (reverse rev-head) tail)
@end example

It is provided because it is a common operation, a common
list--processing style calls for this exact operation to transfer values
accumulated in reverse order onto the front of another list, and because
the implementation is significantly more efficient than the simple
composition it replaces.

@quotation
But note that this pattern of iterative computation followed by a
@func{reverse} can frequently be rewritten as a recursion, dispensing
with the @func{reverse} and @func{append-reverse} steps, and shifting
temporary, intermediate storage from the heap to the stack, which is
typically a win for reasons of cache locality and eager storage
reclamation.
@end quotation

@func{append-reverse!} is just the linear--update variant; it is
allowed, but not required, to alter @var{rev-head}'s cons cells to
construct the result.
@end defun


@defun zip @var{clist1} @var{clist2} ...
Defined as:

@example
(lambda lists (apply map list lists))
@end example

If @func{zip} is passed @var{n} lists, it returns a list as long as the
shortest of these lists, each element of which is an @var{n}--element
list comprised of the corresponding elements from the parameter lists.

@example
(zip '(one two three)
     '(1 2 3)
     '(odd even odd even odd even odd even))
  => ((one 1 odd) (two 2 even) (three 3 odd))

(zip '(1 2 3))
  => ((1) (2) (3))
@end example

At least one of the argument lists must be finite:

@example
(zip '(3 1 4 1) (circular-list #f #t))
  => ((3 #f) (1 #t) (4 #f) (1 #t))
@end example
@end defun


@defun unzip1 @var{list}
@defunx unzip2 @var{list}
@defunx unzip3 @var{list}
@defunx unzip4 @var{list}
@defunx unzip5 @var{list}
@func{unzip1} takes a list of lists, where every list must contain at
least one element, and returns a list containing the initial element of
each such list.  That is, it returns @code{(map car lists)}.

@func{unzip2} takes a list of lists, where every list must contain at
least two elements, and returns two values: a list of the first
elements, and a list of the second elements.

@func{unzip3} does the same for the first three elements of the lists,
and so forth.

@example
(unzip2 '((1 one) (2 two) (3 three)))
  => (1 2 3)
     (one two three)
@end example
@end defun


@defun count @var{pred} @var{clist1} ...
@var{pred} is a procedure taking as many arguments as there are lists
and returning a single value.  It is applied element--wise to the
elements of the lists, and a count is tallied of the number of elements
that produce a true value.  This count is returned.

@func{count} is ``iterative'' in that it is guaranteed to apply
@var{pred} to the list elements in a left--to--right order.  The
counting stops when the shortest list expires.

@example
(count even? '(3 1 4 1 5 9 2 5 6))                => 3
(count <     '(1 2 4 8) '(2 4 6 8 10 12 14 16))   => 3
@end example

At least one of the argument lists must be finite:

@example
(count < '(3 1 4 1) (circular-list 1 10)) => 2
@end example
@end defun


@c page
@node list spec fold
@subsection Fold, unfold and map


@cindex List fold, unfold and map


@menu
* list spec fold fold::         Folding.
* list spec fold reduce::       Reducing.
* list spec fold unfold::       Unfolding.
* list spec fold map::          Mapping.
@end menu


@c page
@node list spec fold fold
@subsubsection Folding


@defun fold @var{kons} @var{knil} @var{clist1} @var{clist2} ...
The fundamental list iterator.  First, consider the single
list--parameter case: if @code{clist1 = (e1 e2 ... en)}, then this
procedure returns:

@example
(kons en ... (kons e2 (kons e1 knil)) ... )
@end example

@noindent
that is, it obeys the (tail) recursion:

@example
(fold kons knil ell) = (fold kons (kons (car ell) knil)
                             (cdr ell))
(fold kons knil '()) = knil
@end example

Examples:

@example
;; add the elements
(fold + 0 '(1 2 3))
=> 6

;; reverse a list
(fold cons '() '(1 2 3))
=> (3 2 1)

;; append in reverse order
(fold cons '(4 5 6) '(3 2 1))
=> (1 2 3 4 5 6)

;; how many symbols?
(fold (lambda (x count)
        (if (symbol? x)
            (+ count 1)
          count))
      0
      '(a 1 b 2 c 3))
=> 3

;; length of the longest string
(fold (lambda (s len)
        (max len (string-length s)))
      0
      '("ciao" "hello" "salut" "hola"))
=> 5
@end example

If @var{n} list arguments are provided, then the @var{kons} function
must take @var{n+1} parameters: one element from each list, and the
``seed'' or fold state, which is initially @var{knil}.  The fold
operation terminates when the shortest list runs out of values:

@example
(fold cons* '() '(a b c)
                '(1 2 3 4 5))
=> (c 3
    b 2
    a 1)

(fold (lambda (a b c knil)
        (cons (list a b c) knil))
      '()
      '(1 2 3)
      '(10 20 30)
      '(100 200 300))
=> '((3 30 300)
     (2 20 200)
     (1 10 100))
@end example

At least one of the list arguments must be finite.
@end defun


@defun fold-right @var{kons} @var{knil} @var{clist1} @var{clist2} ...
The fundamental list recursion operator.  First, consider the single
list--parameter case.  If @code{clist1 = (e1 e2 ... en)}, then this
procedure returns:

@example
(kons e1 (kons e2 ... (kons en knil)))
@end example

@noindent
that is, it obeys the recursion:

@example
(fold-right kons knil ell) = (kons (car ell)
                                   (fold-right kons knil (cdr ell)))
(fold-right kons knil '()) = knil
@end example

Examples:

@example
;; copy the list
(fold-right cons '() '(1 2 3))
=> (1 2 3)

;; add elements
(fold-right + 0 numbers)
=> 45

;; prepend elements
(fold-right cons '(4 5 6) '(1 2 3))
=> (1 2 3 4 5 6)

;; filter the even numbers
(fold-right (lambda (x l)
              (if (even? x)
                  (cons x l)
                l))
            '()
            '(0 1 2 3 4 5 6 7 8 9))
=> (0 2 4 6 8)
@end example

If @var{n} list arguments are provided, then the @var{kons} function
must take @var{n}+1 parameters: one element from each list, and the
``seed'' or fold state, which is initially @var{knil}.  The fold
operation terminates when the shortest list runs out of values:

@example
(fold-right cons*
            '()
            '(a b c)
            '(1 2 3 4 5))
=> (a 1 b 2 c 3)
@end example

At least one of the list arguments must be finite.
@end defun


@defun pair-fold @var{kons} @var{knil} @var{clist1} @var{clist2} ...
Analogous to @func{fold}, but @var{kons} is applied to successive
sublists of the lists, rather than successive elements; that is,
@var{kons} is applied to the pairs making up the lists, giving this
(tail) recursion:

@example
(pair-fold kons knil lis) = (let ((tail (cdr lis)))
                              (pair-fold kons (kons lis knil) tail))
(pair-fold kons knil '()) = knil
@end example

For finite lists, the @var{kons} function may reliably apply
@func{set-cdr!} to the pairs it is given without altering the sequence
of execution.

Example:

@example
;;; Destructively reverse a list.
(pair-fold (lambda (pair tail) (set-cdr! pair tail) pair) '() lis))
@end example

At least one of the list arguments must be finite.
@end defun


@defun pair-fold-right @var{kons} @var{knil} @var{clist1} @var{clist2} ...
Holds the same relationship with @func{fold-right} that @func{pair-fold}
holds with fold.  Obeys the recursion:

@example
(pair-fold-right kons knil lis) =
    (kons lis (pair-fold-right kons knil (cdr lis)))
(pair-fold-right kons knil '()) = knil
@end example

Example:

@example
(pair-fold-right cons '() '(a b c)) => ((a b c) (b c) (c))
@end example

At least one of the list arguments must be finite.
@end defun


@c page
@node list spec fold reduce
@subsubsection Reducing


@defun reduce @var{f} @var{ridentity} @var{list}
@func{reduce} is a variant of @func{fold}.  @var{ridentity} should be a
``right identity'' of the procedure @var{f}; that is, for any value
@var{x} acceptable to @var{f}:

@example
(f x ridentity) = x
@end example

@func{reduce} has the following definition:

@example
if list = (), return ridentity;
otherwise, return (fold f (car list) (cdr list)).
@end example

@noindent
in other words, we compute @code{(fold f ridentity list)}.

Note that @var{ridentity} is used only in the empty--list case.

You typically use @func{reduce} when applying @var{f} is expensive and
you'd like to avoid the extra application incurred when fold applies
@var{f} to the head of list and the identity value, redundantly
producing the same value passed in to @var{f}.  For example, if @var{f}
involves searching a file directory or performing a database query, this
can be significant.

In general, however, @func{fold} is useful in many contexts where
@func{reduce} is not (consider the examples given in the @func{fold}
definition: only one of the five folds uses a function with a right
identity; the other four may not be performed with @func{reduce}).

Note: @acronym{MIT} Scheme and Haskell flip @var{f}'s arguments order
for their @func{reduce} and @func{fold} functions.

@example
;; Take the max of a list of non-negative integers.
(reduce max 0 nums) ; i.e., (apply max 0 nums)
@end example
@end defun


@defun reduce-right @var{f} @var{ridentity} @var{list}
@func{reduce-right} is the @func{fold-right} variant of
@func{reduce}.  It obeys the following definition:

@example
(reduce-right f ridentity '()) = ridentity
(reduce-right f ridentity '(e1)) = (f e1 ridentity) = e1
(reduce-right f ridentity '(e1 e2 ...)) =
    (f e1 (reduce f ridentity (e2 ...)))
@end example

@noindent
in other words, we compute @code{(fold-right f ridentity list)}.

@example
;; Append a bunch of lists together.
;; I.e., (apply append list-of-lists)
(reduce-right append '() list-of-lists)
@end example
@end defun


@c page
@node list spec fold unfold
@subsubsection Unfolding


@defun unfold @var{stop?} @var{map-to-elm} @var{seed-step} @var{first-seed} [@var{tail-gen}]
Generate a list from a starting value; return the result.  It is is the
fundamental recursive list constructor, just as @func{fold-right} is the
fundamental recursive list consumer.  It is best described by its basic
recursion:

@example
(unfold stop? map-to-elm seed-step seed tail-gen) =
    (if (stop? seed)
        (tail-gen seed)
      (cons (map-to-elm seed)
            (unfold stop? map-to-elm
                    seed-step (seed-step seed)
                    tail-gen)))
@end example

The arguments are:

@table @var
@item stop?
Determines when to stop: it is applied to the current seed value, and if
the return value is @true{}: unfolding stops.  If it evaluates to
@true{} at the first invocation: the return value of @func{unfold} is
the return value of @var{tail-gen}.

@item map-to-elm
Maps each seed value to the corresponding list element.  It is applied
to the current seed value and must return the value to append to the
result list.

@item seed-step
Maps each seed value to next seed value.

@item first-seed
The ``state'' value for the unfold.  It is the first seed value.

@item tail-gen
Applied to the seed value that caused @func{stop?} to return @true{},
must return the tail of the result list.  Defaults to @code{(lambda (x)
'())}.
@end table

While @func{unfold} may seem a bit abstract to novice functional
programmers, it can be used in a number of ways:

@example
;; List of squares: 1^2 ... 5^2
(unfold (lambda (x) (> x 5))
        (lambda (x) (* x x))
        (lambda (x) (+ x 1))
        1)
=> (1 4 9 16 25)

;; Copy a proper list.
(unfold null-list? car cdr '(1 2 3 4 5))
=> (1 2 3 4 5)

;; Read current input port into a list of values.
(unfold eof-object? values (lambda (x) (read)) (read))

;; Copy a possibly non-proper list:
(unfold not-pair? car cdr '(1 2 3 4 . 5) values)
=> (1 2 3 4 . 5)

;; Append HEAD onto TAIL:
(unfold null-list? car cdr '(1 2 3) (lambda (x) '(4 5 6)))
=> (1 2 3 4 5 6)
@end example

@quotation
@emph{Note:} Interested functional programmers may enjoy noting that
@func{fold-right} and @func{unfold} are in some sense inverses.  That
is, given operations @var{knull?}, @var{kar}, @var{kdr}, @var{kons}, and
@var{knil} satisfying:

@example
(kons (kar x) (kdr x)) = x and (knull? knil) = #t
@end example

@noindent
then:

@example
(fold-right kons knil (unfold knull? kar kdr x)) = x
@end example

@noindent
and:

@example
(unfold knull? kar kdr (fold-right kons knil x)) = x
@end example

This combinator sometimes is called an ``anamorphism''; when an explicit
@var{tail-gen} procedure is supplied, it is called an ``apomorphism''.
@end quotation
@end defun

@c ------------------------------------------------------------

@defun unfold-right @var{stop?} @var{map-to-elm} @var{seed-step} @var{first-seed} [@var{tail}]
Generate a list from a starting value; return the result.  It is the
fundamental iterative list constructor, just as @func{fold} is the
fundamental iterative list consumer.  Construct a list with the
following loop:

@example
(let loop ((seed seed)
           (ell  tail))
  (if (stop? seed)
      ell
    (loop (seed-step seed)
          (cons (map-to-elm seed) ell))))
@end example

Arguments are:

@table @var
@item stop?
Determine when to stop unfolding.

@item map-to-elm
Map each seed value to the corresponding list element.

@item seed-step
Map each seed value to next seed value.

@item first-seed
The ``state'' value for the unfold.

@item tail
List terminator; defaults to @code{'()}.
@end table

While @func{unfold-right} may seem a bit abstract to novice functional
programmers, it can be used in a number of ways:

@example
;; List of squares: 1^2 ... 10^2
(unfold-right zero?
              (lambda (x) (* x x))
              (lambda (x) (- x 1))
              5)
=> (1 4 9 16 25)

;; Reverse a proper list.
(unfold-right null-list? car cdr '(1 2 3 4 5))
=> (5 4 3 2 1)

;; Read current input port into a list of values.
(unfold-right eof-object? values (lambda (x) (read)) (read))

;; Equivalent to: (append-reverse rev-head tail)
(unfold-right null-list? car cdr '(3 2 1) '(4 5 6))
=> (1 2 3 4 5 6)
@end example

@quotation
@emph{Note:} Interested functional programmers may enjoy noting that
@func{fold} and @func{unfold-right} are in some sense inverses.  That
is, given operations @var{knull?}, @var{kar}, @var{kdr}, @var{kons}, and
@var{knil} satisfying:

@example
(kons (kar x) (kdr x)) = x and (knull? knil) = #t
@end example

@noindent
then:

@example
(fold kons knil (unfold-right knull? kar kdr x)) = x
@end example

@noindent
and:

@example
(unfold-right knull? kar kdr (fold kons knil x)) = x.
@end example

This combinator presumably has some pretentious mathematical name;
interested readers are invited to communicate it to the author.
@end quotation
@end defun


@c page
@node list spec fold map
@subsubsection Mapping


@defun map @var{proc} @var{clist1} @var{clist2} ...
@var{proc} is a procedure taking as many arguments as there are list
arguments and returning a single value.  @func{map} applies @var{proc}
element--wise to the elements of the lists and returns a list of the
results, in order.  The dynamic order in which @var{proc} is applied to
the elements of the lists is unspecified.

@example
(map cadr '((a b) (d e) (g h))) =>  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))
  =>  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6)) =>  (5 7 9)

(let ([count 0])
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b)))
  =>  (1 2) or (2 1)
@end example

This procedure is extended from its @rnrs{5} specification to allow the
arguments to be of unequal length; it terminates when the shortest list
runs out.

At least one of the argument lists must be finite:

@example
(map + '(3 1 4 1) (circular-list 1 0)) => (4 1 5 1)
@end example
@end defun


@defun for-each @var{proc} @var{clist1} @var{clist2} ...
The arguments to @func{for-each} are like the arguments to @func{map},
but @func{for-each} calls @var{proc} for its side effects rather than
for its values.  Unlike @func{map}, @func{for-each} is guaranteed to
call @var{proc} on the elements of the lists in order from the first
element(s) to the last, and the value returned by @func{for-each} is
unspecified.

@example
(let ([v (make-vector 5)])
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)  =>  #(0 1 4 9 16)
@end example

This procedure is extended from its @rnrs{5} specification to allow the
arguments to be of unequal length; it terminates when the shortest list
runs out.

At least one of the argument lists must be finite.
@end defun


@defun append-map @var{f} @var{clist1} @var{clist2} ...
@defunx append-map! @var{f} @var{clist1} @var{clist2} ...
Equivalent to:

@example
(apply append (map f clist1 clist2 ...))
@end example

@noindent
and:

@example
(apply append! (map f clist1 clist2 ...))
@end example

Map @var{f} over the elements of the lists, just as in the @func{map}
function.  However, the results of the applications are appended
together to make the final result.  @func{append-map} uses @func{append}
to append the results together; @func{append-map!} uses @func{append!}.

The dynamic order in which the various applications of @var{f} are made
is not specified.

Example:

@example
(append-map! (lambda (x) (list x (- x))) '(1 3 8))
  => (1 -1 3 -3 8 -8)
@end example

At least one of the list arguments must be finite.
@end defun


@defun {map!} @var{f} @var{list1} @var{clist2} ...
Linear--update variant of @func{map}, @func{map!} is allowed, but not
required, to alter the cons cells of @var{list1} to construct the result
list.

The dynamic order in which the various applications of @var{f} are made
is not specified.  In the n--ary case, @var{clist2}, @var{clist3},
... must have at least as many elements as @var{list1}.
@end defun


@defun map-in-order @var{f} @var{clist1} @var{clist2} ...
A variant of the @func{map} procedure that guarantees to apply @var{f}
across the elements of the @var{listi} arguments in a left--to--right
order.  This is useful for mapping procedures that both have side
effects and return useful values.

At least one of the list arguments must be finite.
@end defun


@defun pair-for-each @var{f} @var{clist1} @var{clist2} ...
Like @func{for-each}, but @var{f} is applied to successive sublists of
the argument lists.  That is, @var{f} is applied to the cons cells of
the lists, rather than the lists' elements.  These applications occur in
left--to--right order.

The @var{f} procedure may reliably apply @func{set-cdr!} to the pairs it
is given without altering the sequence of execution.

@example
(pair-for-each (lambda (pair) (display pair) (newline)) '(a b c)) ==>
    (a b c)
    (b c)
    (c)
@end example

At least one of the list arguments must be finite.
@end defun


@defun filter-map @var{f} @var{clist1} @var{clist2} ...
Like @func{map}, but only true values are saved.

@example
(filter-map (lambda (x)
              (and (number? x) (* x x)))
            '(a 1 b 3 c 7))
  => (1 9 49)
@end example

The dynamic order in which the various applications of @var{f} are made
is not specified.

At least one of the list arguments must be finite.
@end defun


@c page
@node list spec filter
@subsection Filtering and partitioning


@cindex List filtering


@defun filter @var{pred} @var{list}
@defunx filter! @var{pred} @var{list}
Return all the elements of @var{list} that satisfy predicate @var{pred}.
The list is not disordered: elements that appear in the result list
occur in the same order as they occur in @var{list}.  The returned list
may share a common tail with @var{list}.  The dynamic order in which the
various applications of @var{pred} are made is not specified.

@example
(filter even? '(0 7 8 8 43 -4)) => (0 8 8 -4)
@end example

@func{filter!} is the linear--update variant of @func{filter}.  It is
allowed, but not required, to alter the cons cells in @var{list} to
construct the result lists.
@end defun


@defun partition @var{pred} @var{list}
@defunx partition! @var{pred} @var{list}
Partition the elements of @var{list} with predicate @var{pred}, and
return two values: the list of in--elements and the list of
out--elements.  The list is not disordered: elements occur in the result
lists in the same order as they occur in @var{list}.  The dynamic order
in which the various applications of @var{pred} are made is not
specified.  One of the returned lists may share a common tail with
@var{list}.

@example
(partition symbol? '(one 2 3 four five 6))
  => (one four five)
     (2 3 6)
@end example

@func{partition!} is the linear--update variant of @func{partition}.
It is allowed, but not required, to alter the cons cells in @var{list}
to construct the result lists.
@end defun


@defun remove @var{pred} @var{list}
@defunx remove! @var{pred} @var{list}
Return @var{list} without the elements that satisfy predicate
@var{pred}:

@example
(lambda (pred list)
  (filter (lambda (x)
            (not (pred x)))
          list))
@end example

The list is not disordered: elements that appear in the result list
occur in the same order as they occur in @var{list}.  The returned list
may share a common tail with @var{list}.  The dynamic order in which the
various applications of pred are made is not specified.

@example
(remove even? '(0 7 8 8 43 -4)) => (7 43)
@end example

@func{remove!} is the linear--update variant of @func{remove}.  It is
allowed, but not required, to alter the cons cells in @var{list} to
construct the result lists.
@end defun


@c page
@node list spec search
@subsection Searching


@cindex List searching
@cindex Searching in lists


The following procedures all search lists for a leftmost element
satisfying some criteria.  This means they do not always examine the
entire list; thus, there is no efficient way for them to reliably detect
and signal an error when passed a dotted or circular list.  Here are the
general rules describing how these procedures work when applied to
different kinds of lists:

@table @emph
@item proper lists
The standard, canonical behavior happens in this case.

@item dotted lists
It is an error to pass these procedures a dotted list that does not
contain an element satisfying the search criteria.  That is, it is an
error if the procedure has to search all the way to the end of the
dotted list.

However, this @srfi{} does not specify anything at all about the
behavior of these procedures when passed a dotted list containing an
element satisfying the search criteria.  It may finish successfully,
signal an error, or perform some third action.

Different implementations may provide different functionality in this
case; code which is compliant with this @srfi{} may not rely on any
particular behavior.  Future @srfi{}'s may refine @ansrfi{1} to define
specific behavior in this case.

In brief, @ansrfi{1} compliant code may not pass a dotted list argument to
these procedures.

@item circular lists
It is an error to pass these procedures a circular list that does not
contain an element satisfying the search criteria.  Note that the
procedure is not required to detect this case; it may simply diverge.
It is, however, acceptable to search a circular list if the search is
successful; that is, if the list contains an element satisfying the
search criteria.
@end table

Here are some examples, using the @func{find} and @func{any} procedures
as canonical representatives:

@example
;; Proper list -- success
(find even? '(1 2 3))	=> 2
(any  even? '(1 2 3))	=> #t

;; proper list -- failure
(find even? '(1 7 3))	=> #f
(any  even? '(1 7 3))	=> #f

;; Failure is error on a dotted list.
(find even? '(1 3 . x))	=> error
(any  even? '(1 3 . x))	=> error

;; The dotted list contains an element satisfying the search.
;; This case is not specified -- it could be success, an error,
;; or some third possibility.
(find even? '(1 2 . x))	=> error/undefined
(any  even? '(1 2 . x))	=> error/undefined ; success, error or other.

;; circular list -- success
(find even? (circular-list 1 6 3)) => 6
(any  even? (circular-list 1 6 3)) => #t

;; circular list -- failure is error. Procedure may diverge.
(find even? (circular-list 1 3)) => error
(any  even? (circular-list 1 3)) => error
@end example


@defun find @var{pred} @var{clist}
Return the first element of @var{clist} that satisfies predicate
@var{pred}; return @false{} if no element does.

@example
(find even? '(3 1 4 1 5 9)) => 4
@end example

Note that @func{find} has an ambiguity in its lookup semantics: if
@func{find} returns @false{}, you cannot tell (in general) if it found a
@false{} element that satisfied @var{pred}, or if it did not find any
element at all.  In many situations, this ambiguity cannot arise: either
the list being searched is known not to contain any @false{} elements,
or the list is guaranteed to have an element satisfying @var{pred}.
However, in cases where this ambiguity can arise, you should use
@func{find-tail} instead of @func{find}, @func{find-tail} has no such
ambiguity:

@example
(cond [(find-tail pred lis) => (lambda (pair) ...)] ; Handle (CAR PAIR)
      [else ...]) ; Search failed.
@end example
@end defun


@defun find-tail @var{pred} @var{clist}
Return the first pair of @var{clist} whose car satisfies @var{pred}.  If
no pair does, return @false{}.

@func{find-tail} can be viewed as a general--predicate variant of the
@func{member} function.

Examples:

@example
(find-tail even? '(3 1 37 -8 -5 0 0)) => (-8 -5 0 0)
(find-tail even? '(3 1 37 -5)) => #f

;; MEMBER X LIS:
(find-tail (lambda (elt) (equal? x elt)) lis)
@end example

In the circular--list case, this procedure ``rotates'' the list.

@func{find-tail} is essentially @func{drop-while}, where the sense of
the predicate is inverted: @func{find-tail} searches until it finds an
element satisfying the predicate; @func{drop-while} searches until it
finds an element that doesn't satisfy the predicate.
@end defun


@defun take-while @var{pred} @var{clist}
@defunx take-while! @var{pred} @var{clist}
Return the longest initial prefix of @var{clist} whose elements all
satisfy the predicate @var{pred}.

@func{take-while!} is the linear--update variant.  It is allowed, but
not required, to alter the argument list to produce the result.

Example:

@example
(take-while even? '(2 18 3 10 22 9)) => (2 18)
@end example
@end defun


@defun drop-while @var{pred} @var{clist}
Drops the longest initial prefix of @var{clist} whose elements all
satisfy the predicate @var{pred}, and returns the rest of the list.

Example:

@example
(drop-while even? '(2 18 3 10 22 9)) => (3 10 22 9)
@end example

The circular--list case may be viewed as ``rotating'' the list.
@end defun


@defun span @var{pred} @var{clist}
@defunx span! @var{pred} @var{list}
@defunx break @var{pred} @var{clist}
@defunx break! @var{pred} @var{list}
@func{span} splits the list into the longest initial prefix whose
elements all satisfy @var{pred}, and the remaining tail.  @func{break}
inverts the sense of the predicate: the tail commences with the first
element of the input list that satisfies the predicate.

In other words: @func{span} finds the intial span of elements satisfying
@var{pred}, and @func{break} breaks the list at the first element
satisfying @var{pred}.

@func{span} is equivalent to:

@example
(values (take-while pred clist)
        (drop-while pred clist))
@end example

@func{span!} and @func{break!} are the linear--update variants.  They
are allowed, but not required, to alter the argument list to produce the
result.

Examples:

@example
(span even? '(2 18 3 10 22 9))
  => (2 18)
     (3 10 22 9)

(break even? '(3 1 4 1 5 9))
  => (3 1)
     (4 1 5 9)
@end example
@end defun


@defun any @var{pred} @var{clist1} @var{clist2} ...
Apply the predicate across the lists, returning true if the predicate
returns true on any application.

If there are n list arguments @var{clist1} ... @var{clistn}, then
@var{pred} must be a procedure taking n arguments and returning a
boolean result.

@func{any} applies @var{pred} to the first elements of the @var{clisti}
parameters.  If this application returns a true value, @func{any}
immediately returns that value.  Otherwise, it iterates, applying pred
to the second elements of the @var{clisti} parameters, then the third,
and so forth.  The iteration stops when a true value is produced or one
of the lists runs out of values; in the latter case, @func{any} returns
@false{}.  The application of @var{pred} to the last element of the
lists is a tail call.

Note the difference between @func{find} and @func{any}: @func{find}
returns the element that satisfied the predicate; @func{any} returns the
true value that the predicate produced.

Like @func{every}, @func{any}'s name does not end with a question mark:
this is to indicate that it does not return a simple boolean (@true{} or
@false{}), but a general value.

Examples:

@example
(any integer? '(a 3 b 2.7))   => #t
(any integer? '(a 3.1 b 2.7)) => #f
(any < '(3 1 4 1 5)
       '(2 7 1 8 2)) => #t
@end example
@end defun


@defun every @var{pred} @var{clist1} @var{clist2} ...
Apply the predicate across the lists, returning true if the predicate
returns true on every application.

If there are n list arguments @var{clist1} ... @var{clistn}, then
@var{pred} must be a procedure taking n arguments and returning a
boolean result.

@func{every} applies @var{pred} to the first elements of the
@var{clisti} parameters.  If this application returns @false{},
@func{every} immediately returns @false{}.  Otherwise, it iterates,
applying @var{pred} to the second elements of the @var{clisti}
parameters, then the third, and so forth.  The iteration stops when a
@false{} value is produced or one of the lists runs out of values.  In
the latter case, @func{every} returns the true value produced by its
final application of @var{pred}.  The application of @var{pred} to the
last element of the lists is a tail call.

If one of the @var{clisti} has no elements, @func{every} simply returns
@true{}.

Like @func{any}, @func{every}'s name does not end with a question mark:
this is to indicate that it does not return a simple boolean (@true{} or
@false{}), but a general value.
@end defun


@defun list-index @var{pred} @var{clist1} @var{clist2} ...
Return the index of the leftmost element that satisfies @var{pred}.

If there are n list arguments, then @var{pred} must be a function taking
n arguments and returning a boolean result.

@func{list-index} applies @var{pred} to the first elements of the
@var{clisti} parameters.  If this application returns true,
@func{list-index} immediately returns zero.  Otherwise, it iterates,
applying @var{pred} to the second elements of the @var{clisti}
parameters, then the third, and so forth.  When it finds a tuple of list
elements that cause @var{pred} to return true, it stops and returns the
zero--based index of that position in the lists.

The iteration stops when one of the lists runs out of values; in this
case, @func{list-index} returns @false{}.

Examples:

@example
(list-index even? '(3 1 4 1 5 9)) => 2
(list-index < '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) => 1
(list-index = '(3 1 4 1 5 9 2 5 6) '(2 7 1 8 2)) => #f
@end example
@end defun


@defun member @var{x} @var{list} [@var{=}]
@defunx memq @var{x} @var{list}
@defunx memv @var{x} @var{list}
@rnrs{5}+ These procedures return the first sublist of @var{list} whose
car is @var{x}, where the sublists of list are the non--empty lists
returned by @code{(drop list i)} for @var{i} less than the length of
@var{list}.  If @var{x} does not occur in @var{list}, then @false{} is
returned.

@func{memq} uses @func{eq?} to compare @var{x} with the elements of
@var{list}, while @var{memv} uses @func{eqv?}, and @func{member} uses
@func{equal?}.

Examples:

@example
(memq 'a '(a b c))          =>  (a b c)
(memq 'b '(a b c))          =>  (b c)
(memq 'a '(b c d))          =>  #f
(memq (list 'a) '(b (a) c)) =>  #f
(member (list 'a)
        '(b (a) c))         =>  ((a) c)
(memq 101 '(100 101 102))   =>  *unspecified*
(memv 101 '(100 101 102))   =>  (101 102)
@end example

@func{member} is extended from its @rnrs{5} definition to allow the
client to pass in an optional equality procedure @var{=} used to compare
keys.

The comparison procedure is used to compare the elements @var{ei} of
list to the key @var{x} in this way:

@example
(= x ei) ; list is (E1 ... En)
@end example

@noindent
that is, the first argument is always @var{x}, and the second argument
is one of the list elements.  Thus one can reliably find the first
element of list that is greater than five with @code{(member 5 list <)}.

Note that fully general list searching may be performed with the
@func{find-tail} and @func{find} procedures:

@example
(find-tail even? list) ; Find the first elt with an even key.
@end example
@end defun


@c page
@node list spec delete
@subsection Deletion


@cindex List deletion


@defun delete @var{x} @var{list} [@var{=}]
@defunx delete! @var{x} @var{list} [@var{=}]
Use the comparison procedure @var{=} (which defaults to @func{equal?})
to find all elements of list that are equal to @var{x}, and delete them
from @var{list}.  The dynamic order in which the various applications of
@var{=} are made is not specified.

The list is not disordered: elements that appear in the result list
occur in the same order as they occur in the argument list.  The result
may share a common tail with the argument list.

Note that fully general element deletion can be performed with the
@func{remove} and @func{remove!} procedures:

@example
;; Delete all the even elements from LIS:
(remove even? lis)
@end example

The comparison procedure is used in this way: @code{(= x ei)}; that is,
@var{x} is always the first argument, and a list element is always the
second argument.  The comparison procedure will be used to compare each
element of list exactly once; the order in which it is applied to the
various @var{ei} is not specified.  Thus, one can reliably remove all
the numbers greater than 5 from a list with @code{(delete 5 list <)}.

@func{delete!} is the linear--update variant of @func{delete}.  It is
allowed, but not required, to alter the cons cells in its argument list
to construct the result.
@end defun


@defun delete-duplicates @var{list} [@var{=}]
@defunx {delete-duplicates!} @var{list} [@var{=}]
Remove duplicate elements from the list argument.  If there are multiple
equal elements in @var{list}, the result list only contains the first or
leftmost of these elements in the result.  The order of these surviving
elements is the same as in the original list: @func{delete-duplicates}
does not disorder the list (hence it is useful for ``cleaning up''
association lists).

The @var{=} parameter is used to compare the elements of the list; it
defaults to @func{equal?}.  If @var{x} comes before @var{y} in
@var{list}, then the comparison is performed @code{(= x y)}.  The
comparison procedure will be used to compare each pair of elements in
list no more than once; the order in which it is applied to the various
pairs is not specified.

Implementations of @func{delete-duplicates} are allowed to share common
tails between argument and result lists; for example, if the list
argument contains only unique elements, it may simply return exactly
this list.

Be aware that, in general, @func{delete-duplicates} runs in time O(n2)
for n--element lists.  Uniquifying long lists can be accomplished in O(n
lg n) time by sorting the list to bring equal elements together, then
using a linear--time algorithm to remove equal elements.  Alternatively,
one can use algorithms based on element--marking, with linear--time
results.

@func{delete-duplicates!} is the linear--update variant of
@func{delete-duplicates}; it is allowed, but not required, to alter the
cons cells in its argument list to construct the result.

@example
(delete-duplicates '(a b a c a b c z)) => (a b c z)

;; Clean up an alist:
(delete-duplicates '((a . 3) (b . 7) (a . 9) (c . 1))
                   (lambda (x y)
                     (eq? (car x) (car y))))
  => ((a . 3) (b . 7) (c . 1))
@end example
@end defun


@c page
@node list spec alist
@subsection Association lists


@cindex List, association lists
@cindex Association lists
@cindex Alists


An ``association list'' (or ``alist'') is a list of pairs.  The car of
each pair contains a key value, and the cdr contains the associated data
value.  They can be used to construct simple look--up tables in Scheme.
Note that association lists are probably inappropriate for
performance--critical use on large data; in these cases, hash tables or
some other alternative should be employed.


@defun assoc @var{key} @var{alist} [@var{=}]
@defunx assq @var{key} @var{alist}
@defunx assv @var{key} @var{alist}
@rnrs{5}+ @var{alist} must be an association list: a list of pairs.
These procedures find the first pair in @var{alist} whose car field is
@var{key}, and returns that pair.  If no pair in @var{alist} has
@var{key} as its car, then @false{} is returned.

@func{assq} uses @func{eq?} to compare @var{key} with the car fields of
the pairs in @var{alist}, while @func{assv} uses @func{eqv?} and
@func{assoc} uses @func{equal?}.

Example:

@example
(define e '((a 1) (b 2) (c 3)))
(assq 'a e)                            =>  (a 1)
(assq 'b e)                            =>  (b 2)
(assq 'd e)                            =>  #f
(assq (list 'a) '(((a)) ((b)) ((c))))  =>  #f
(assoc (list 'a) '(((a)) ((b)) ((c)))) =>  ((a))
(assq 5 '((2 3) (5 7) (11 13)))    =>  *unspecified*
(assv 5 '((2 3) (5 7) (11 13)))    =>  (5 7)
@end example

@func{assoc} is extended from its @rnrs{5} definition to allow the
client to pass in an optional equality procedure @var{=} used to compare
keys.

The comparison procedure is used to compare the elements @var{ei} of
list to the key parameter in this way:

@example
(= key (car ei)) ; list is (E1 ... En)
@end example

@noindent
that is, the first argument is always @var{key}, and the second argument
is one of the list elements.  Thus one can reliably find the first entry
of @var{alist} whose @var{key} is greater than five with @code{(assoc 5
alist <)}.

Note that fully general alist searching may be performed with the
@func{find-tail} and @func{find} procedures:

@example
;; Look up the first association in alist with an even key:
(find (lambda (a)
        (even? (car a)))
      alist)
@end example
@end defun


@defun alist-cons @var{key} @var{datum} @var{alist}
Defined as:

@example
(lambda (key datum alist)
  (cons (cons key datum) alist))
@end example

Cons a new alist entry mapping @var{key} to @var{datum} onto
@var{alist}.
@end defun


@defun alist-copy @var{alist}
Make a fresh copy of @var{alist}.  This means copying each pair that
forms an association as well as the spine of the list:

@example
(lambda (a)
  (map (lambda (elt)
         (cons (car elt) (cdr elt)))
       a))
@end example
@end defun


@defun alist-delete @var{key} @var{alist} [@var{=}]
@defunx alist-delete! @var{key} @var{alist} [@var{=}]
Delete all associations from @var{alist} with the given @var{key}, using
the key-comparison procedure @var{=}, which defaults to @func{equal?}.
The dynamic order in which the various applications of @var{=} are made
is not specified.

Return values may share common tails with the @var{alist} argument.  The
alist is not disordered: elements that appear in the result alist occur
in the same order as they occur in @var{alist}.

The comparison procedure is used to compare the element keys @var{ki} of
@var{alist}'s entries to the key parameter in this way: @code{(= key
ki)}.  Thus, one can reliably remove all entries of @var{alist} whose
key is greater than five with @code{(alist-delete 5 alist <)}.

@func{alist-delete!} is the linear--update variant of
@func{alist-delete}; it is allowed, but not required, to alter cons
cells from the alist parameter to construct the result.
@end defun


@c page
@node list spec set
@subsection Set operations on lists


@cindex List set operations
@cindex Set operations on lists


These procedures implement operations on sets represented as lists of
elements.  They all take an @var{=} argument used to compare elements of
lists.  This equality procedure is required to be consistent with
@func{eq?}.  That is, it must be the case that:

@example
(eq? x y) => (= x y)
@end example

Note that this implies, in turn, that two lists that are @func{eq?} are
also set--equal by any legal comparison procedure.  This allows for
constant--time determination of set operations on @func{eq?} lists.

Be aware that these procedures typically run in time O(n * m) for n--
and m--element list arguments.  Performance--critical applications
operating upon large sets will probably wish to use other data
structures and algorithms.


@defun lset<= @var{=} @var{list1} ...
Return true if, and only if, every @var{listi} is a subset of
@var{listi+1}, using @var{=} for the element--equality procedure.  List
@var{AL} is a subset of list @var{BL} if every element in @var{AL} is
equal to some element of @var{BL}.  When performing an element
comparison, the @var{=} procedure's first argument is an element of
@var{AL}, its second argument an element of @var{BL}.

Examples:

@example
(lset<= eq? '(a) '(a b a) '(a b c c)) => #t

(lset<= eq?) => #t             ; Trivial cases
(lset<= eq? '(a)) => #t
@end example
@end defun


@defun lset= @var{=} @var{list1} @var{list2} ...
Return true if, and only if, every @var{listi} is set--equal to
@var{listi+1}, using @var{=} for the element--equality procedure.
``Set--equal'' simply means that @var{listi} is a subset of
@var{listi+1}, and @var{listi+1} is a subset of @var{listi}.  The
@var{=} procedure's first argument is an element of @var{listi}, its
second argument is an element of @var{listi+1}.

Examples:

@example
(lset= eq? '(b e a) '(a e b) '(e e b a)) => #t

(lset= eq?) => #t               ; Trivial cases
(lset= eq? '(a)) => #t
@end example
@end defun


@defun lset-adjoin @var{=} @var{list} @var{elt1} ...
Add the @var{elti} elements not already in the @var{list} parameter to
the result list.  The result shares a common tail with the @var{list}
parameter.  The new elements are added to the front of the list, but no
guarantees are made about their order.  The @var{=} parameter is an
equality procedure used to determine if an elti is already a member of
list.  Its first argument is an element of @var{list}, its second is one
of the @var{elti}.

The @var{list} parameter is always a suffix of the result; even if the
list parameter contains repeated elements, these are not reduced.

Example:

@example
(lset-adjoin eq? '(a b c d c e) 'a 'e 'i 'o 'u)
  => (u o i a b c d c e)
@end example
@end defun


@defun lset-union @var{=} @var{list1} ...
@defunx lset-union! @var{=} @var{list1} ...
Return the union of the lists, using @var{=} for the element--equality
procedure.

The union of lists @var{AL} and @var{BL} is constructed as follows:

@enumerate
@item
If @var{AL} is the empty list, the answer is @var{BL} (or a copy of
@var{BL}).

@item
Otherwise, the result is initialised to be list @var{AL} (or a copy of
@var{AL}).

@item
Proceed through the elements of list @var{BL} in a left--to--right
order.  If @var{b} is such an element of @var{BL}, compare every element
@var{r} of the current result list to @var{b}: @code{(= r b)}.  If all
comparisons fail, @var{b} is consed onto the front of the result.
@end enumerate

However, there is no guarantee that @var{=} will be applied to every
pair of arguments from @var{AL} and @var{BL}.  In particular, if
@var{AL} is @func{eq?} to @var{BL}, the operation may immediately
terminate.

In the n--ary case, the two--argument @func{list-union} operation is
simply folded across the argument lists.

Examples:

@example
(lset-union eq? '(a b c d e) '(a e i o u))
  => (u o i a b c d e)

;; Repeated elements in LIST1 are preserved.
(lset-union eq? '(a a c) '(x a x)) => (x a a c)

;; Trivial cases
(lset-union eq?) => ()
(lset-union eq? '(a b c)) => (a b c)
@end example

@func{lset-union!} is the linear--update variant of @func{lset-union}.
It is allowed, but not required, to use the cons cells in the first list
parameter to construct its answer.  @func{lset-union!} is permitted to
recycle cons cells from any of its list arguments.
@end defun


@defun lset-intersection @var{=} @var{list1} @var{list2} ...
@defunx lset-intersection! @var{=} @var{list1} ...
Return the intersection of the lists, using @var{=} for the
element--equality procedure.

The intersection of lists @var{AL} and @var{BL} is comprised of every
element of @var{AL} that is @var{=} to some element of @var{BL}:
@code{(= a b)}, for @var{a} in @var{AL}, and @var{b} in @var{BL}.  Note
this implies that an element which appears in @var{BL} and multiple
times in list @var{AL} will also appear multiple times in the result.

The order in which elements appear in the result is the same as they
appear in @var{list1}; that is, @func{lset-intersection} essentially
filters @var{list1}, without disarranging element order.  The result may
share a common tail with @var{list1}.

In the n--ary case, the two--argument @func{list-intersection} operation
is simply folded across the argument lists.  However, the dynamic order
in which the applications of @var{=} are made is not specified.  The
procedure may check an element of @var{list1} for membership in every
other list before proceeding to consider the next element of
@var{list1}, or it may completely intersect @var{list1} and @var{list2}
before proceeding to @var{list3}, or it may go about its work in some
third order.

Examples:

@example
(lset-intersection eq? '(a b c d e) '(a e i o u))
  => (a e)

;; Repeated elements in LIST1 are preserved.
(lset-intersection eq? '(a x y a) '(x a x z))
  => '(a x a)

(lset-intersection eq? '(a b c))        ; Trivial case
  => (a b c)
@end example

@func{lset-intersection!} is the linear--update variant of
@func{lset-intersection}.  It is allowed, but not required, to use the
cons cells in the first list parameter to construct its answer.
@end defun


@defun lset-difference @var{=} @var{list1} @var{list2} ...
@defunx lset-difference! @var{=} @var{list1} ...
Return the difference of the lists, using @var{=} for the
element--equality procedure: all the elements of @var{list1} that are
not @var{=} to any element from one of the other @var{listi} parameters.

The @var{=} procedure's first argument is always an element of
@var{list1}; its second is an element of one of the other @var{listi}.
Elements that are repeated multiple times in the @var{list1} parameter
will occur multiple times in the result.

The order in which elements appear in the result is the same as they
appear in @var{list1}; that is, @func{lset-difference} essentially
filters @var{list1}, without disarranging element order.  The result may
share a common tail with @var{list1}.

The dynamic order in which the applications of @var{=} are made is not
specified.  The procedure may check an element of @var{list1} for
membership in every other list before proceeding to consider the next
element of @var{list1}, or it may completely compute the difference of
@var{list1} and @var{list2} before proceeding to @var{list3}, or it may
go about its work in some third order.

@example
(lset-difference eq? '(a b c d e) '(a e i o u))
  => (b c d)

(lset-difference eq? '(a b c))   ; Trivial case
  => (a b c)
@end example

@func{lset-difference!} is the linear--update variant of
@func{lset-difference}.  It is allowed, but not required, to use the
cons cells in the first list parameter to construct its answer.
@end defun


@defun lset-xor @var{=} @var{list1} ...
@defunx lset-xor! @var{=} @var{list1} ...
Return the exclusive--or of the sets, using @var{=} for the
element--equality procedure.  If there are exactly two lists, this is
all the elements that appear in exactly one of the two lists.  The
operation is associative, and thus extends to the n--ary case, in which
the result is a list of the elements that appear in an odd number of the
lists.  The result may share a common tail with any of the @var{listi}
parameters.

More precisely, for two lists @var{AL} and @var{BL}, @var{AL} xor
@var{BL} is a list of:

@itemize
@item
every element @var{a} of @var{AL} such that there is no element @var{b}
of @var{BL} such that @code{(= a b)}, and

@item
every element @var{b} of @var{BL} such that there is no element @var{a}
of @var{AL} such that @code{(= b a)}.
@end itemize

However, an implementation is allowed to assume that @var{=} is
symmetric; that is, that @code{(= a b) => (= b a)}.

This means, for example, that if a comparison @code{(= a b)} produces
true for some @var{a} in @var{AL} and @var{b} in @var{BL}, both @var{a}
and @var{b} may be removed from inclusion in the result.

In the n--ary case, the binary--xor operation is simply folded across
the lists.

Examples:

@example
(lset-xor eq? '(a b c d e) '(a e i o u))
  => (d c b i o u)

;; Trivial cases.
(lset-xor eq?) => ()
(lset-xor eq? '(a b c d e)) => (a b c d e)
@end example

@func{lset-xor!} is the linear--update variant of @func{lset-xor}.  It
is allowed, but not required, to use the cons cells in the first list
parameter to construct its answer.
@end defun


@defun {lset-diff+intersection} @var{=} @var{list1} @var{list2} ...
@defunx {lset-diff+intersection!} @var{=} @var{list1} @var{list2} ...
Return two values: the difference and the intersection of the lists.  It
is equivalent to:

@example
(values (lset-difference = list1 list2 ...)
        (lset-intersection = list1
                             (lset-union = list2 ...)))
@end example

@noindent
but can be implemented more efficiently.

The @var{=} procedure's first argument is an element of @var{list1}; its
second is an element of one of the other @var{listi}.

Either of the answer lists may share a common tail with @var{list1}.
This operation essentially partitions @var{list1}.

@func{lset-diff+intersection!} is the linear--update variant of
@func{lset-diff+intersection}.  It is allowed, but not required, to use
the cons cells in the first list parameter to construct its answer.
@end defun



@c page
@node list spec side
@subsection Primitive side--effects


@cindex List side effects
@cindex Side effects on lists


These two procedures are the primitive, @rnrs{5} side--effect operations
on pairs.

@defun set-car! @var{pair} @var{object}
@defunx set-cdr! pair @var{object}
@rnrs{5} These procedures store object in the car and cdr field of pair,
respectively.  The returned value is unspecified.

@example
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3) =>  *unspecified*
(set-car! (g) 3) =>  *error*
@end example
@end defun


@c page
@node list ack
@section Acknowledgements


The design of this library benefited greatly from the feedback provided
during the @srfi{} discussion phase.  Among those contributing
thoughtful commentary and suggestions, both on the mailing list and by
private discussion, were Mike Ashley, Darius Bacon, Alan Bawden, Phil
Bewig, Jim Blandy, Dan Bornstein, Per Bothner, Anthony Carrico, Doug
Currie, Kent Dybvig, Sergei Egorov, Doug Evans, Marc Feeley, Matthias
Felleisen, Will Fitzgerald, Matthew Flatt, Dan Friedman, Lars Thomas
Hansen, Brian Harvey, Erik Hilsdale, Wolfgang Hukriede, Richard Kelsey,
Donovan Kolbly, Shriram Krishnamurthi, Dave Mason, Jussi Piitulainen,
David Pokorny, Duncan Smith, Mike Sperber, Maciej Stachowiak, Harvey
J. Stein, John David Stone, and Joerg F. Wittenberger.  I am grateful to
them for their assistance.

I am also grateful the authors, implementors and documentors of all the
systems mentioned in the rationale.  Aubrey Jaffer and Kent Pitman
should be noted for their work in producing Web--accessible versions of
the @rnrs{5} and Common Lisp spec, which was a tremendous aid.

This is not to imply that these individuals necessarily endorse the
final results, of course.


@c page
@node list references
@section References


This document, in @acronym{HTML}:

@center @url{http://srfi.schemers.org/srfi-1/srfi-1.html}

@noindent
source code for the reference implementation:

@center @url{http://srfi.schemers.org/srfi-1/srfi-1-reference.scm}

@noindent
archive of @ansrfi{1} discussion--list email:

@center @url{http://srfi.schemers.org/srfi-1/mail-archive/maillist.html}

@noindent
@srfi{} web site:

@center @url{http://srfi.schemers.org/}

@noindent
@emph{Common Lisp: the Language}.  Guy L. Steele Jr. (editor).  Digital
Press, Maynard, Mass., second edition 1990.  Available at:

@center @url{http://www.elwood.com/alu/table/references.htm#cltl2}

@noindent
@emph{The Common Lisp "HyperSpec"}, produced by Kent Pitman, is
essentially the @ansi{} spec for Common Lisp:

@center @url{http://www.harlequin.com/education/books/HyperSpec/}

@emph{Revised^5 report on the algorithmic language Scheme}.  R. Kelsey,
W. Clinger, J. Rees (editors).  Higher--Order and Symbolic Computation,
Vol. 11, No. 1, September, 1998, and ACM SIGPLAN Notices, Vol. 33,
No. 9, October, 1998.  Available at

@center @url{http://www.schemers.org/Documents/Standards/}


@c page
@node and-let-star
@chapter An @func{and} with local bindings


@cindex @srfi{} and-let-star


@noindent
The @library{srfi and-let-star} library has been written by Oleg
Kiselyov as reference implementation for @ansrfi{2}.


@menu
* and-let-star license::        Original license.
* and-let-star abstract::       Abstract.
* and-let-star rationale::      Rationale.
* and-let-star spec::           Specification.
@end menu


@c page
@node and-let-star license
@section Original license


Copyright @copyright{} 1998 Oleg Kiselyov.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node and-let-star abstract
@section Abstract


Like an ordinary @func{and}, an @func{and-let*} special form evaluates
its arguments (expressions) one after another in order, till the first
one that yields @false{}.  Unlike @func{and}, however, a non--@false{}
result of one expression can be bound to a fresh variable and used in
the subsequent expressions.  @func{and-let*} is a cross--breed between
@func{let*} and @func{and}.



@c page
@node and-let-star rationale
@section Rationale


In case of an ordinary @func{and} formed of proper boolean expressions:

@example
(and e1 e2 ...)
@end example

@noindent
expression @var{e2}, if it gets to be evaluated, knows that @var{e1} has
returned non--@false{}.  Moreover, @var{e2} knows exactly what the
result of @var{e1} was (true) which @var{e2} can use to its advantage.
If @var{e1} however is an extended boolean expression, @var{e2} can no
longer tell which particular non--@false{} value @var{e1} has returned.
Chances are it took a lot of work to evaluate @var{e1}, and the produced
result (a number, a vector, a string, etc) may be of value to @var{e2}.
Alas, the @func{and} form merely checks that the result is not an
@false{}, and throws it away.  If @var{e2} needs it, it has to compute
that value anew.

This proposed @func{and-let*} special form lets constituent expressions
get hold of the results of already evaluated expressions, without
re--doing their work.

@func{and-let*} can be thought of as a combination of @func{let*} and
@func{and}, or a generalization of @func{cond}'s send operator,
@code{=>}.  An @func{and-let*} form can also be considered a sequence of
guarded expressions.

In a regular program, forms may produce results, bind them to variables
and let other forms use these results.  @func{and-let*} differs in that
it checks to make sure that every produced result ``makes sense'' (that
is, not an @false{}).  The first ``failure'' triggers the guard and
aborts the rest of the sequence (which presumably would not make any
sense to execute anyway).  Examples:

@example
(and-let* ([my-list     (compute-list)]
           [            (not (null? my-list))])
  (do-something my-list))

(define (look-up key alist)
  (and-let* ([x (assq key alist)])
    (cdr x)))

(or
  (and-let* ([c (read-char)]
             [  (not (eof-object? c))])
    (string-set! some-str i c)
    (set! i (+ 1 i)))
  (begin
    (do-process-eof)))

;; A more realistic example
;; Parse the 'timestamp' ::= 'token1' 'token2'
;;   token1 ::= 'YY' 'MM' 'J'
;;   token2 ::= 'GG' 'gg' "/"
(define (parse-full-timestamp token1 token2)
  (and-let* ([  (= 5 (string-length token1))]
             [  (= 5 (string-length token2))]
             [timestamp
                (OS:string->time "%m/%d/%y %H:%M"
                  (string
                    (string-ref token1 2) (string-ref token1 3) #\/
                    (string-ref token1 0) (string-ref token1 1) #\/
                    (case (string-ref token1 4)
                      ((#\8 #\9) #\9) (else #\0))
                    (string-ref token1 4) #\space
                    (string-ref token2 0) (string-ref token2 1) #\:
                    (string-ref token2 2) (string-ref token2 3)))]
             [  (positive? timestamp)])
           timestamp))
@end example

@func{and-let*} is also similar to an ``anaphoric @func{and}'' Lisp
macro@footnote{Rob Warnock, comp.lang.scheme, 26 Feb 1998 09:06:43 GMT,
Message-ID: @url{6d3bb3$3804h@@fido.asd.sgi.com}}.  @func{and-let*}
allows however more than one intermediate result, each of which
continues to be bound through the rest of the form.


@c page
@node and-let-star spec
@section Specification


@findex and-let*


@example
AND-LET* (CLAWS) BODY

CLAWS ::= '() | (cons CLAW CLAWS)
CLAW  ::=  (VARIABLE EXPRESSION) | (EXPRESSION) |
           BOUND-VARIABLE
@end example

@itemize
@item
The @code{CLAWS} are evaluated in the strict left--to--right order.

@item
For each @code{CLAW}, the @code{EXPRESSION} part is evaluated first (or
@code{BOUND-VARIABLE} is looked up)

@item
If the result is @false{}, @func{and-let*} immediately returns
@func{#f}.

@item
Otherwise, if the @code{claw} is of the form @code{(VARIABLE
EXPRESSION)} the @code{EXPRESSION}'s value is bound to a freshly made
@code{VARIABLE}.

@item
The @code{VARIABLE} is available for the rest of the @code{CLAWS}, and
the @code{BODY}.

@item
As usual, all @code{VARIABLE}s must be unique (like in @func{let*}).
@end itemize


@subsubheading Formal (denotational) semantics


@example
eval[ (AND-LET* (CLAW1 ...) BODY), env] =
   eval_claw[ CLAW1, env ] andalso
   eval[ (AND-LET* ( ...) BODY), ext_claw_env[CLAW1, env]]

eval[ (AND-LET* (CLAW) ), env] = eval_claw[ CLAW, env ]
eval[ (AND-LET* () FORM1 ...), env] = eval[ (BEGIN FORM1 ...), env ]
eval[ (AND-LET* () ), env] = #t

eval_claw[ BOUND-VARIABLE, env ] =
   eval[ BOUND-VARIABLE, env ]
eval_claw[ (EXPRESSION), env ] =
   eval[ EXPRESSION, env ]
eval_claw[ (VARIABLE EXPRESSION), env ] =
   eval[ EXPRESSION, env ]

ext_claw_env[ BOUND-VARIABLE, env ] = env
ext_claw_env[ (EXPRESSION), env ] =
   env-after-eval[ EXPRESSION, env ]
ext_claw_env[ (VARIABLE EXPRESSION), env ] =
   extend-env[ env-after-eval[ EXPRESSION, env ],
              VARIABLE boundto eval[ EXPRESSION, env ]]
@end example

@c page
@node string-ports
@chapter Basic string ports


@cindex @srfi{} string-ports


The @library{srfi string-ports} library has been written by William D
Clinger as the reference implementation for @ansrfi{6}.

@menu
* string-ports license::        Original license.
* string-ports abstract::       Abstract.
* string-ports rationale::      Rationale.
* string-ports spec::           Specification.
@end menu


@c page
@node string-ports license
@section Original license


Copyright @copyright{} 1999 William D Clinger.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node string-ports abstract
@section Abstract


Scheme's I/O primitives are extended by adding three new procedures that

@itemize
@item
create an input port from a string;

@item
create an output port whose contents are accumulated in Scheme's working
memory instead of an external file;

@item
extract the accumulated contents of an in--memory output port and return
them in the form of a string.
@end itemize


@c page
@node string-ports rationale
@section Rationale


Scheme's procedures for performing input and output from and to ports
become more useful when extended by string ports.  The interface
described here has been in use since 1986 or before, and is currently
supported by several of the major implementations.


@c page
@node string-ports spec
@section Specification


@cindex @srfi{} string-ports api


This specification is taken from the MacScheme Reference Manual.

@defun open-input-string @var{string}
Take a string and return an input port that delivers characters from the
string.  The port can be closed by @func{close-input-port}, though its
storage will be reclaimed by the garbage collector if it becomes
inaccessible.

Example:

@example
(define p (open-input-string "(a . (b . c . ())) 34"))

(input-port? p)                 =>  #t
(read p)                        =>  (a b c)
(read p)                        =>  34
(eof-object? (peek-char p))     =>  #t
@end example
@end defun


@defun open-output-string
Return an output port that will accumulate characters for retrieval by
@func{get-output-string}.  The port can be closed by the procedure
@code{close-output-port}, though its storage will be reclaimed by the
garbage collector if it becomes inaccessible.

@example
(let ([q (open-output-string)]
      [x '(a b c)])
  (write (car x) q)
  (write (cdr x) q)
  (get-output-string q))
  =>  "a(b c)"
@end example
@end defun


@defun get-output-string @var{output-port}
Given an output port created by @func{open-output-string}, return a
string consisting of the characters that have been output to the port so
far.
@end defun


@c page
@node receive
@chapter Binding to multiple values


@cindex @srfi{} receive


The @library{srfi receive} has been written by John David Stone
(Department of Mathematics and Computer Science, Grinnell College,
Grinnell, Iowa 50112, @email{stone@@cs.grinnell.edu}) as reference
implementation for @ansrfi{8}.


@menu
* receive license::             Original license.
* receive abstract::            Abstract.
* receive rationale::           Rationale.
* receive spec::                Specification.
@end menu


@c page
@node receive license
@section Original license


Copyright @copyright{} 1999 John David Stone.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



@c page
@node receive abstract
@section Abstract


The only mechanism that @rnrs{5} provides for binding identifiers to the
values of a multiple--valued expression is the primitive
@func{call-with-values}.  This @srfi{} proposes a more concise, more
readable syntax for creating such bindings.

@c page
@node receive rationale
@section Rationale


Although @rnrs{5} supports multiple--valued expressions, it provides
only the essential procedures @func{values} and @func{call-with-values}.
It is evident that the authors expected Scheme programmers to define
other constructs in terms of these, abstracting common patterns of use.

One such pattern consists in binding an identifier to each of the values
of a multiple--valued expression and then evaluating an expression in
the scope of the bindings.  As an instance of this pattern, consider the
following excerpt from a quicksort procedure:

@example
(call-with-values
  [lambda ()
    (partition (precedes pivot) others)]
  [lambda (fore aft)
    (append (qsort fore) (cons pivot (qsort aft)))])
@end example

Here @func{partition} is a multiple--valued procedure that takes two
arguments, a predicate and a list, and returns two lists, one comprising
the list elements that satisfy the predicate, the other those that do
not.  The purpose of the expression shown is to partition the list
@var{others}, sort each of the sublists, and recombine the results into
a sorted list.

For our purposes, the important step is the binding of the identifiers
fore and aft to the values returned by @func{partition}.  Expressing the
construction and use of these bindings with the @func{call-by-values}
primitive is cumbersome: One must explicitly embed the expression that
provides the values for the bindings in a parameterless procedure, and
one must explicitly embed the expression to be evaluated in the scope of
those bindings in another procedure, writing as its parameters the
identifiers that are to be bound to the values received.

These embeddings are boilerplate, exposing the underlying binding
mechanism but not revealing anything relevant to the particular program
in which it occurs.  So the use of a syntactic abstraction that exposes
only the interesting parts (the identifiers to be bound, the
multiple--valued expression that supplies the values, and the body of
the receiving procedure) makes the code more concise and more readable:

@example
(receive (fore aft)
    [partition (precedes pivot) others]
  [append (qsort fore)
          (cons pivot (qsort aft))])
@end example

The advantages are similar to those of a @func{let}--expression over a
procedure call with a @func{lambda}--expression as its operator.  In
both cases, cleanly separating a ``header'' in which the bindings are
established from a ``body'' in which they are used makes it easier to
follow the code.


@c page
@node receive spec
@section Specification


@cindex @srfi{} receive api


@deffn Syntax receive @var{formals} @var{expression} @var{body}
@var{formals}, @var{expression}, and @var{body} are as described in
@rnrs{5}.  Specifically, @var{formals} can have any of three forms:

@table @code
@item (variable1 ... variablen)
The environment in which the @func{receive}--expression is evaluated is
extended by binding @var{variable1}, ..., @var{variablen} to fresh
locations.  The @var{expression} is evaluated, and its values are stored
into those locations (it is an error if @var{expression} does not have
exactly @var{n} values).

@item variable
The environment in which the @func{receive}--expression is evaluated is
extended by binding @var{variable} to a fresh location.  The
@var{expression} is evaluated, its values are converted into a newly
allocated list, and the list is stored in the location bound to
@var{variable}.

@item (variable1 ... variablen . variablen+1)
The environment in which the @func{receive}--expression is evaluated is
extended by binding @var{variable1}, ..., @var{variablen+1} to fresh
locations.  The @var{expression} is evaluated.  Its first @var{n} values
are stored into the locations bound to @var{variable1}, ...,
@var{variablen}.  Any remaining values are converted into a newly
allocated list, which is stored into the location bound to
@var{variablen+1} (it is an error if @var{expression} does not have at
least @var{n} values.
@end table

In any case, the expressions in @var{body} are evaluated sequentially in
the extended environment.  The results of the last expression in the
body are the values of the @var{receive}--expression.
@end deffn


@c page
@node records
@chapter Defining record types


@cindex @srfi{} records


The @library{srfi records} library has been written by Richard Kelsey as
reference implementation for @ansrfi{9}.

@menu
* records license::             Original license.
* records abstract::            Abstract.
* records rationale::           Rationale.
* records spec::                Specification.
@end menu


@c page
@node records license
@section Original license


Copyright @copyright{} 1999 Richard Kelsey.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



@c page
@node records abstract
@section Abstract


This @srfi{} describes syntax for creating new data types, called
record types.  A predicate, a constructor, and field accessors and
modifiers are defined for each record type.  Each new record type is
distinct from all existing types, including other record types and
Scheme's predefined types.

@c page
@node records rationale
@section Rationale


Many Scheme implementations provide means for creating new types,
usually called either records or structures.  The
@func{DEFINE-RECORD-TYPE} syntax described here is a slight
simplification of one written for Scheme 48 by Jonathan Rees.  Unlike
many record--defining macros or special forms, it does not create any
new identifiers.  Instead, the names of the record type, predicate,
constructor, and so on are all listed explicitly in the source.  This
has the following advantages:

@itemize
@item
It can be defined using a simple @func{syntax-rules} macro in Scheme
implementations that provide a procedural interface for creating record
types.

@item
It does not restrict users to a particular naming convention.

@item
Tools like grep and @gnu{} Emacs's tag facility will see the defining
occurance of each identifier.
@end itemize


@c page
@node records spec
@section Specification


@cindex @srfi{} record @api{}
@findex define-record-type


The syntax of a record--type definition is:

@example
<command or definition>
  -> <record type definition>           ; addition to 8.1.6 in R5RS

<record type definition>
  -> (define-record-type <type name>
       (<constructor name> <field tag> ...)
       <predicate name>
       <field spec> ...)

<field spec> -> (<field tag> <accessor name>)
             -> (<field tag> <accessor name> <modifier name>)

<field tag> -> <identifier>
<... name>  -> <identifier>
@end example

@func{define-record-type} is generative: each use creates a new record
type that is distinct from all existing types, including other record
types and Scheme's predefined types.  Record--type definitions may only
occur at top--level (there are two possible semantics for ``internal''
record--type definitions, generative and nongenerative, and no consensus
as to which is better).

An instance of @func{define-record-type} is equivalent to the following
definitions:

@itemize
@item
@code{<type name>} is bound to a representation of the record type
itself.  Operations on record types, such as defining print methods,
reflection, etc. are left to other @srfi{}s.

@item
@code{<constructor name>} is bound to a procedure that takes as many
arguments as there are @code{<field tag>}s in the @code{(<constructor
name> ...)}  subform and returns a new @code{<type name>} record.
Fields whose tags are listed with @code{<constructor name>} have the
corresponding argument as their initial value.  The initial values of
all other fields are unspecified.

@item
@code{<predicate name>} is a predicate that returns @true{} when given a
value returned by @code{<constructor name>} and @false{} for everything
else.

@item
Each @code{<accessor name>} is a procedure that takes a record of type
@code{<type name>} and returns the current value of the corresponding
field.  It is an error to pass an accessor a value which is not a record
of the appropriate type.

@item
Each @code{<modifier name>} is a procedure that takes a record of type
@code{<type name>} and a value which becomes the new value of the
corresponding field; an unspecified value is returned.  It is an error
to pass a modifier a first argument which is not a record of the
appropriate type.
@end itemize

Records are disjoint from the types listed in Section 4.2 of @rnrs{5}.

@func{set!}--ing the value of any of these identifiers has no effect on
the behavior of any of their original values.

The following:

@example
(define-record-type :pare
  (kons x y)
  pare?
  (x kar set-kar!)
  (y kdr))
@end example

@noindent
defines @var{kons} to be a constructor, @var{kar} and @var{kdr} to be
accessors, @var{set-kar!} to be a modifier, and @var{pare?} to be a
predicate for @code{:pare}s.

Example:

@example
(pare? (kons 1 2))        => #t
(pare? (cons 1 2))        => #f
(kar (kons 1 2))          => 1
(kdr (kons 1 2))          => 2
(let ([k (kons 1 2)])
  (set-kar! k 3)
  (kar k))                => 3
@end example


@c page
@node strings
@chapter @ansrfi{13} string library


@cindex @srfi{} strings


The @library{srfi strings} library has been written by Olin Shivers as
the reference implementation for @ansrfi{13}.

@menu
* strings license::             Original license.
* strings abstract::            Abstract.
* strings rationale::           Rationale.
* strings spec::                Specification.
* strings ack::                 Acknowledgments.
* strings references::          References.
@end menu


@c page
@node strings license
@section Strings document license


Certain portions of this document, the specific, marked segments of text
describing the @rnrs{5} procedures, were adapted with permission from
the @rnrs{5} report.

All other text is copyright @copyright{} 1998, 1999, 2000 Olin Shivers.
All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



@c page
@node strings abstract
@section Abstract


@rnrs{5} Scheme has an impoverished set of string--processing utilities,
which is a problem for authors of portable code.  This @srfi{} proposes
a coherent and comprehensive set of string--processing procedures; it is
accompanied by a reference implementation of the specification.  The
reference implementation is: portable, efficient, open source .

The routines in this @srfi{} are backwards--compatible with the
string--processing routines of @rnrs{5}.



@c page
@node strings rationale
@section Rationale


This @srfi{} defines two libraries that provide a rich set of
operations for manipulating strings.  These are frequently useful for
scripting and other text--manipulation applications.  The library's
design was influenced by the string libraries found in @acronym{MIT}
Scheme, Gambit, RScheme, MzScheme, slib, Common Lisp, Bigloo, guile,
Chez, @acronym{APL}, Java, and the @acronym{SML} standard basis.

All procedures involving character comparison are available in both
case--sensitive and case--insensitive forms.

All functionality is available in substring and full--string forms.

@menu
* strings ratio code-point::    Strings are code-point sequences.
* strings ratio i18n::          Internationalisation and
                                super-@ascii{} character types.
@end menu


@c page
@node strings ratio code-point
@subsection Strings are code--point sequences


This @srfi{} considers strings simply to be a sequence of ``code
points'' or character encodings.  Operations such as comparison or
reversal are always done code point by code point.  See the comments
below on super--@ascii{} character types for implications that follow.

It's entirely possible that a legal string might not be a sensible
``text'' sequence.  For example, consider a string comprised entirely of
zero--width Unicode accent characters with no preceding base character
to modify; this is a legal string, albeit one that does not make a great
deal of sense when interpreted as a sequence of natural--language text.
The routines in this @srfi{} do not handle these ``text'' concerns;
they restrict themselves to the underlying view of strings as merely a
sequence of ``code points''.

This @srfi{} defines string operations that are locale--independent and
context--independent.  While it is certainly important to have a
locale--sensitive comparison or collation procedure when processing
text, it is also important to have a suite of operations that are
reliably invariant for basic string processing; otherwise, a change of
locale could cause data structures such as hash tables, b--trees, symbol
tables, directories of filenames, etc. to become corrupted.

Locale--sensitive and context--sensitive text operations, such as
collation, are explicitly deferred to a subsequent, companion ``text''
@srfi{}.


@c page
@node strings ratio i18n
@subsection Internationalisation and super-@ascii{} character types


The major issue confronting this @srfi{} is the existence of
super--@ascii{} character encodings, such as eight--bit Latin--1 or
16--bit and 32--bit Unicode.  It is a design goal of this @srfi{} for
the @api{} to be portable across string implementations based on at
least these three standard encodings.  Unfortunately, this places strong
limitations on the @api{} design.  Here are some relevant issues.  Be
warned that life in a super--@ascii{} world is significantly more
complex; there are no easy answers for many of these issues.

@c ------------------------------------------------------------

@subsubheading Case mapping and case--folding


@noindent
Upper--casing and lower--casing characters is complex in super--@ascii{}
encodings.

@itemize
@item
Some characters case--map to more than one character.  For example, the
Latin--1 German @code{eszet} character upper--cases to @code{SS}.

@itemize --
@item
This means that the @rnrs{5} function @func{char-upcase} is not
well--defined, since it is defined to produce a (single) character
result.

@item
It means that an in--place @func{string-upcase!} procedure cannot be
reliably defined, since the original string may not be long enough to
contain the result; an @var{N}--character string might upcase to a
@var{2N}--character result.

@item
It means that case--insensitive string--matching or searching is quite
tricky.  For example, an @var{n}--character string @var{s} might match a
@var{2N}--character string @var{s'}.
@end itemize

@item
Some characters case--map in different ways depending upon their
surrounding context.  For example, the Unicode Greek capital sigma
character downcases differently depending upon whether or not it is the
final character in a word.  Again, this spells trouble for the simple
@rnrs{5} char--downcase function.

@item
Unicode defines three cases: lowercase, uppercase and titlecase.  The
distinction between uppercase and titlecase arises in the presence of
Unicode's compound characters.  For example, Unicode has a single
character representing the compound pair @code{dz}.  Uppercasing the
@code{dz} character produces the compound character @code{DZ}, while
titlecasing (or, as Americans say, capitalizing) it produces compound
character @code{Dz}.

@item
Turkish actually has different case--mappings from other languages.
@end itemize

The Unicode Consortium's web site:

@center @url{http://www.unicode.org/}

@noindent
has detailed discussions of the issues.  See in particular technical
report 21 on case mappings:

@center @url{http://www.unicode.org/unicode/reports/tr21/}

@ansrfi{13} makes no attempt to deal with these issues; it uses a simple
one--to--ont locale--independent and context--independent case--mapping,
specifically Unicode's one--to--one case--mappings given in:

@center @url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt}

The format of this file is explained in:

@center @url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.html}

Note that this means that German @code{eszet} upper--cases to itself,
not @code{SS}.

Case--mapping and case--folding operations in @ansrfi{13} are
locale--independent so that shifting locales won't wreck hash tables,
b--trees, symbol tables, etc.

@c ------------------------------------------------------------

@subsubheading String equality and string normalisation


@noindent
Comparing strings for equality is complicated because in some cases
Unicode actually provides multiple encodings for the ``same'' character,
and because what we usually think of as a ``character'' can be
represented in Unicode as a sequence of several code--points.  For
example, consider the letter @code{e} with an acute accent.  There is a
single Unicode character for this.  However, Unicode also allows one to
represent this with a two--character sequence: the @code{e} character
followed by a zero--width acute--accent character.  As another example,
Unicode provides some Asian characters in ``narrow'' and ``full''
widths.

There are multiple ways we might want to compare strings for equality.
In (roughly) decreasing order of precision:

@itemize
@item
we might want a precise comparison of the actual encoding, so that
@code{<e-acute>} would not compare equal to @code{<e, acute>};

@item
we might want a ``normalised'' comparison, where these two sequences
would compare equal;

@item
we might want an even more--permissive normalisation, where
visually--distinct properties of ``the same'' character would be
ignored; for example, we might want narrow/full--width versions of the
same Asian character to compare equal;a

@item
we might want comparisons that are insensitive to accents and
diacritical marks;

@item
we might want comparisons that are case--insensitive;

@item
we might want comparisons that are insensitive to several of the above
properties;

@item
we might want ways to ``normalise'' strings into various canonical
forms.
@end itemize

This library does not address these complexities.  @ansrfi{13} string
equality is simply based upon comparing the encoding values used for the
characters.  Accent--insensitive and other types of comparison are not
provided; only a simple form of case--insensitive comparison is
provided, which uses the one--to--one case mappings specified by Unicode
in:

@center @url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt}

These are adequate for ``program'' or ``systems'' use of strings (e.g.
to manipulate program identifiers and operating--system filenames).

@c ------------------------------------------------------------

@subsubheading String inequality


@noindent
Above and beyond the issues arising in string--equality, when we attempt
to order strings there are even further considerations.

@itemize
@item
French orders accents with right--to--left significance; the reverse of
the significance of the characters.

@item
Case--insensitive ordering is not well defined by simple code--point
considerations, even for simple @ascii{}: there are punctuation
characters between the @ascii{}'s upper--case range of letters and its
lower--case range (left--bracket, backslash, right--bracket, caret,
underbar and backquote).  Does left--bracket compare less--than or
greater--than @code{a} in a case--insensitive comparison?

@item
The German @code{eszet} character should sort as if it were the pair of
letters @code{ss}.
@end itemize

Unicode defines a complex set of machinery for ordering or ``collating''
strings, which involves mapping each string to a multi--byte sort key,
and then doing simple lexicographic sorting with these keys.  These
rules can be overlaid by additional domain--specific or
language--specific rules.  Again, this @srfi{} does not address these
issues.  @ansrfi{13} string ordering is strictly based upon a
character--by--character comparison of the values used for representing
the string.

@c ------------------------------------------------------------

@subsubheading Naming conventions


@noindent
This library contains a large number of procedures, but they follow a
consistent naming scheme, and are consistent with the conventions
developed in @ansrfi{1}.  The names are composed of smaller lexemes in a
regular way that exposes the structure and relationships between the
procedures.  This should help the programmer to recall or reconstitute
the name of the particular procedure that he needs when writing his own
code.  In particular:

@itemize
@item
Procedures whose names end in @code{-ci} are case--insensitive variants.

@item
Procedures whose names end in @code{!} are side--effecting variants.
What values these procedures return is usually not specified.

@item
The order of common parameters is consistent across the different
procedures.

@item
Left/right/both directionality: Procedures that have left/right
directional variants use the following convention:

@multitable {right--to--left} {Suffix}
@headitem Direction @tab Suffix
@item left-to-right @tab none
@item right-to-left @tab --right
@item both @tab --both
@end multitable

This is a general convention that was established in @ansrfi{1}.  The
value of a convention is proportional to the extent of its use.
@end itemize

@c ------------------------------------------------------------

@subsubheading Shared storage


@noindent
Some Scheme implementations, e.g. Guile and T, provide ways to construct
substrings that share storage with other strings.  This facility is
called ``shared--text substrings''.  Shared--text substrings can be used
to eliminate the allocation and copying time and space required to
produce substrings, which can be a tremendous savings for some
applications, reducing a linear--time operation to constant time.
Additionally, some algorithms rely on the sharing property of these
substrings: the application assumes that if the underlying storage is
mutated, then all strings sharing that storage will show the change.
However, shared--text substrings are not a common feature; most Scheme
implementations do not provide them.

@ansrfi{13} takes a middle ground with respect to shared--text substrings.
In particular, a Scheme implementation does not need to have
shared--text substrings in order to implement this @srfi{}.

There is an additional form of storage sharing enabled by some @ansrfi{13}
procedures, even without the benefit of shared--text substrings.  In
some cases, some @ansrfi{13} routines are allowed to return as a result
one of the strings that was passed in as a parameter.  For example, when
constructing a substring with the @func{substring/shared} procedure, if
the requested substring is the entire string, the procedure is permitted
simply to return the original value.  That is:

@example
(eq? s (substring/shared s 0 (string-length s))) => true or false
@end example

@noindent
whereas the @rnrs{5} @func{substring} function is required to allocate a
fresh copy:

@example
(eq? s (substring s 0 (string-length s))) => false.
@end example

In keeping with @ansrfi{13}'s general approach to sharing, compliant
implementations are allowed, but not required, to provide this kind of
sharing.  Hence, procedures may not rely upon sharing in these cases.

Most procedures that permit results to share storage with inputs have
equivalent procedures that require allocating fresh storage for results.
If an application wishes to be sure a new, fresh string is allocated,
then these ``pure'' procedures should be used.

@multitable {string-concatenate-reverse} {string-concatenate-reverse/shared}
@headitem Fresh copy guaranteed @tab Sharing permitted
@item @func{string-copy} @tab @func{substring/shared}
@item @func{string-copy} @tab @func{string-take} @func{string-take-right}
@item @func{string-copy} @tab @func{string-drop} @func{string-drop-right}
@item @func{string-concatenate} @tab @func{string-concatenate/shared}
@item @func{string-append} @tab @func{string-append/shared}
@item @func{string-concatenate-reverse} @tab @func{string-concatenate-reverse/shared}
@item @tab @func{string-pad string-pad-right}
@item @tab @func{string-trim string-trim-right}
@item @tab @func{string-trim-both}
@item @tab @func{string-filter string-delete}
@end multitable

On the other hand, the functionality is present to allow one to write
efficient code without shared--text substrings.  You can write efficient
code that works by passing around start/end ranges indexing into a
string instead of simply building a shared--text substring.  The @api{}
would be much simpler without this consideration; if we had cheap
shared--text substrings, all the start/end index parameters would
vanish.  However, since @ansrfi{13} does not require implementations to
provide shared--text substrings, the extended @api{} is provided.

@c ------------------------------------------------------------

@subsubheading @rnrs{4}/@rnrs{5} procedures


@noindent
The @rnrs{4} and @rnrs{5} reports define 22 string procedures.  The
@ansrfi{13} package includes 8 of these exactly as defined, 3 in an
extended, backwards--compatible way, and drops the remaining 11 (whose
functionality is available via other bindings).

The 8 procedures provided exactly as documented in the reports are:

@example
string?         make-string     string
string-length   string-ref      string-set!
string-append   list->string
@end example

The 11 functions not included are:

@example
string=?        string-ci=?     string<?
string-ci<?     string>?        string-ci>?
string<=?       string-ci<=?    string>=?
string-ci>=?    substring
@end example

The @ansrfi{13} package provides alternate bindings and extended
functionality.

Additionally, the three extended procedures are:

@example
string-fill! s char [start end] -> unspecified
string->list s [start end] -> char-list
string-copy  s [start end] -> string
@end example

They are uniformly extended to take optional start/end parameters
specifying substring ranges.

@c ------------------------------------------------------------

@subsubheading Extra--@srfi{} recommendations


@noindent
This @srfi{} recommends the following:

@itemize
@item
A @srfi{} be defined for shared--text substrings, allowing programs to
be written that actually rely on the shared--storage properties of these
data structures.

@item
A @srfi{} be defined for manipulating Unicode text: various
normalisation operations, collation, searching, etc.  Collation
operations might be parameterised by a ``collation'' structure
representing collation rules for a particular locale or language.

Alternatively, a data structure specifying collation rules could be
activated with dynamic scope by special procedures, possibly overridden
by allowing collation rules to be optional arguments to procedures that
need to order strings, e.g.

@example
(with-locale* denmark-locale
  (lambda ()
    (f x)
    (g 42)))

(with-locale taiwan-locale
  (f x)
  (h denmark-locale)
  (g 42))

(set-locale! denmark-locale)
@end example

@item
A @srfi{} be defined for manipulating characters that is portable
across at least @ascii{}, Latin--1 and Unicode.

@itemize
@item
For backwards--compatibility, @func{char-upcase} and
@func{char-downcase} should be defined to use the one--to--one
locale--insensitive and context--insensitive case mappings given by
Unicode's @file{UnicodeData.txt} table.

@item
Numeric codes for standard functions that map between characters and
integers should be required to use the Unicode/Latin--1/@ascii{}
mapping.  This allows programmers to write portable code.

@item
@func{char-titlecase} be added to @func{char-upcase} and
@func{char-downcase}.

@item
@func{char-titlecase?} be added to @func{char-upcase?} and
@func{char-downcase?}.

@item
Title/up/down--case functions be added to the character--processing
suite which allow 1->n case maps by returning immutable,
possibly--multi--character strings instead of single characters.  These
case mappings need not be locale--sensitive or context--sensitive.
@end itemize
@end itemize

These recommendations are not a part of the @ansrfi{13} spec.  Note also
that requiring a Unicode/Latin-1/@ascii{} interface to integer/char
mapping functions does not imply anything about the actual underlying
encodings of characters.


@c page
@node strings spec
@section Specification


@menu
High level procedures

* strings spec intro::          Introduction.
* strings spec pred::           Predicates.
* strings spec cons::           Constructors.
* strings spec list::           List and string conversion.
* strings spec select::         Selection.
* strings spec modify::         Modification.
* strings spec compar::         Comparison.
* strings spec prefix::         Prefixes and suffixes.
* strings spec search::         Searching.
* strings spec case-map::       Alphabetic case mapping.
* strings spec append::         Reverse and append.
* strings spec fold::           Fold, unfold and map.
* strings spec replicate::      Replicate and rotate.
* strings spec misc::           Miscellaneous: intertion, parsing.
* strings spec filter::         Filtering and deleting.

Low level procedures

* strings spec parsing::        Start/end optional-argument parsing
                                and checking utilities.
* strings spec knuth::          Knuth-Morris-Pratt searching.
@end menu


@c page
@node strings spec intro
@subsection Introduction


In the following procedure specifications:

@itemize
@item
An @var{s} parameter is a string.

@item
A @var{char} parameter is a character.

@item
@var{start} and @var{end} parameters are half--open string indices
specifying a substring within a string parameter; when optional, they
default to @code{0} and the length of the string, respectively.  When
specified, it must be the case that:

@example
0 <= start <= end <= (string-length s)
@end example

@noindent
for the corresponding parameter @var{s}.  They typically restrict a
procedure's action to the indicated substring.

@item
A @var{pred} parameter is a unary character predicate procedure,
returning a true/false value when applied to a character.

@item
A @var{char}/@var{char-set}/@var{pred} parameter is a value used to
select/search for a character in a string.  If it is a character, it is
used in an equality test; if it is a character set, it is used as a
membership test; if it is a procedure, it is applied to the characters
as a test predicate.

@item
An @var{i} parameter is an exact non--negative integer specifying an
index into a string.

@item
@var{len} and @var{nchars} parameters are exact non--negative integers
specifying a length of a string or some number of characters.

@item
An @var{obj} parameter may be any value at all.
@end itemize

Passing values to procedures with these parameters that do not satisfy
these types is an error.

Parameters given in square brackets are optional.  Unless otherwise
noted in the text describing the procedure, any prefix of these optional
parameters may be supplied, from zero arguments to the full list.  When
a procedure returns multiple values, this is shown by listing the return
values in square brackets, as well.  So, for example, the procedure with
signature:

@example
halts? f [x init-store]
@end example

@noindent
would take one (@var{f}), two (@var{f}, @var{x}) or three (@var{f},
@var{x}, @var{init-store}) input parameters.

A parameter followed by @code{...} means zero--or--more elements.  So
the procedure with the signature:

@example
sum-squares x ...
@end example

@noindent
takes zero or more arguments (@var{x} ...), while the procedure with
signature:

@example
spell-check doc dict1 dict2 ...
@end example

@noindent
takes two required parameters (@var{doc} and @var{dict1}) and zero or
more optional parameters (@var{dict2} ...).

If a procedure is said to return ``unspecified'', this means that
nothing at all is said about what the procedure returns.  Such a
procedure is not even required to be consistent from call to call.  It
is simply required to return a value (or values) that may be passed to a
command continuation, e.g. as the value of an expression appearing as a
non--terminal subform of a begin expression.  Note that in @rnrs{5},
this restricts such a procedure to returning a single value;
non--@rnrs{5} systems may not even provide this restriction.


Unless explicitly stated, for all the functions: Case--insensitive
comparison is done by case--folding characters with the operation

@example
(char-downcase (char-upcase c))
@end example

@noindent
where the two case--mapping operations are assumed to be one--to--one,
locale--insensitive and context--insensitive, and compatible with the
one--to--one case mappings specified by Unicode's @file{UnicodeData.txt}
table:

@center @url{ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt}

Comparison is simply done on individual code--points of the string.


@c page
@node strings spec pred
@subsection Predicates


@defun string? @var{obj}
@rnrs{5} Return @true{} if @var{obj} is a string, otherwise return
@false{}.
@end defun


@defun string-null? @var{s}
Return @true{} if @var{obj} is the empty string, otherwise return
@false{}.
@end defun


@defun string-every @var{char/char-set/pred} @var{s} [@var{start} @var{end}]
@defunx string-any @var{char/char-set/pred} @var{s} [@var{start} @var{end}]
Check to see if the given criteria is true of every/any character in
@var{s}, proceeding from left (index @var{start}) to right (index
@var{end}).

If @var{char/char-set/pred} is a character, it is tested for equality
with the elements of @var{s}.

If @var{char/char-set/pred} is a character set, the elements of @var{s}
are tested for membership in the set.

If @var{char/char-set/pred} is a predicate procedure, it is applied to
the elements of @var{s}.  The predicate is ``witness--generating'':

@itemize
@item
If @func{string-any} returns true, the returned true value is the one
produced by the application of the predicate.

@item
If @func{string-every} returns true, the returned true value is the one
produced by the final application of the predicate to @code{s[end]}.  If
@func{string-every} is applied to an empty sequence of characters, it
simply returns @true{}.
@end itemize

If @func{string-every} or @func{string-any} apply the predicate to the
final element of the selected sequence (i.e. @code{s[end-1]}), that
final application is a tail call.

The names of these procedures do not end with a question mark; this is
to indicate that, in the predicate case, they do not return a simple
boolean (@true{} or @false{}), but a general value.
@end defun



@c page
@node strings spec cons
@subsection Constructors


@defun make-string @var{len} [@var{char}]
@rnrs{5} Return a newly allocated string of length @var{len}.  If
@var{char} is given, then all elements of the string are initialized to
@var{char}, otherwise the contents of the string are unspecified.
@end defun


@defun string @var{char1} ...
@rnrs{5} Return a newly allocated string composed of the argument
characters.
@end defun


@defun string-tabulate @var{proc} @var{len}
@var{proc} is an @func{integer->char} procedure.  Construct a string of
size @var{len} by applying @var{proc} to each index to produce the
corresponding string element. The order in which @var{proc} is applied
to the indices is not specified.
@end defun



@c page
@node strings spec list
@subsection List and string conversion


@defun string->list @var{s} [@var{start} @var{end}]
@defunx list->string @var{char-list}
@rnrs{5}+ @func{string->list} returns a newly allocated list of the
characters that make up the given string.  @func{list->string} returns a
newly allocated string formed from the characters in the list
@var{char-list}, which must be a list of characters.
@func{string->list} and @func{list->string} are inverses so far as
@func{equal?} is concerned.

@func{string->list} is extended from the @rnrs{5} definition to take
optional @var{start}/@var{end} arguments.
@end defun


@defun reverse-list->string @var{char-list}
An efficient implementation of @code{(compose list->string reverse)}:

@example
(reverse-list->string '(#\a #\B #\c))
=> "cBa"
@end example

This is a common idiom in the epilog of string--processing loops that
accumulate an answer in a reverse--order list.  See also
@func{string-concatenate-reverse} for the ``chunked'' variant.
@end defun


@defun string-join @var{string-list} [@var{delimiter} @var{grammar}]
This procedure is a simple unparser: it pastes strings together using
the @var{delimiter} string.

The @var{grammar} argument is a symbol that determines how the delimiter
is used, and defaults to @code{infix}.  Supported values for
@var{grammar} are:

@table @code
@item infix
Means an infix or separator grammar: insert the delimiter between list
elements.  An empty list will produce an empty string; note, however,
that parsing an empty string with an infix or separator grammar is
ambiguous: Is it an empty list, or a list of one element, the empty
string?

@item strict-infix
Means the same as @code{infix}, but will raise an error if given an
empty list.

@item suffix
Means a suffix or terminator grammar: insert the delimiter after every
list element.  This grammar has no ambiguities.

@item prefix
Means a prefix grammar: insert the delimiter before every list element.
This grammar has no ambiguities.
@end table

The delimiter is the string used to delimit elements; it defaults to a
single space.

Examples:

@example
(string-join '("foo" "bar" "baz") ":")
=> "foo:bar:baz"

(string-join '("foo" "bar" "baz") ":" 'suffix)
=> "foo:bar:baz:"

;; Infix grammar is ambiguous wrt empty list vs. empty string,
(string-join '()   ":") => ""
(string-join '("") ":") => ""

;; but suffix & prefix grammars are not.
(string-join '()   ":" 'suffix) => ""
(string-join '("") ":" 'suffix) => ":"
@end example
@end defun



@c page
@node strings spec select
@subsection Selection


@defun string-length @var{s}
@rnrs{5} Return the number of characters in the string @var{s}.
@end defun


@defun string-ref @var{s} @var{i}
@rnrs{5} Return character @code{s[i]} using zero--origin indexing.
@var{i} must be a valid index of @var{s}.
@end defun


@defun string-copy @var{s} [@var{start} @var{end}]
@defunx substring/shared @var{s} @var{start} [@var{end}]
@rnrs{5}+ @func{substring/shared} returns a string whose contents are
the characters of @var{s} beginning with index @var{start} (inclusive)
and ending with index @var{end} (exclusive).  It differs from the
@rnrs{5} @func{substring} in two ways:

@itemize
@item
The @var{end} parameter is optional, not required.

@item
@func{substring/shared} may return a value that shares memory with
@var{s} or is @func{eq?} to @var{s}.
@end itemize

@func{string-copy} is extended from its @rnrs{5} definition by the
addition of its optional @var{start}/@var{end} parameters.  In contrast
to @func{substring/shared}, it is guaranteed to produce a
freshly--allocated string.

Use @func{string-copy} when you want to indicate explicitly in your code
that you wish to allocate new storage; use @func{substring/shared} when
you don't care if you get a fresh copy or share storage with the
original string.

Examples:

@example
(string-copy "Beta substitution")
=> "Beta substitution"

(string-copy "Beta substitution" 1 10)
=> "eta subst"

(string-copy "Beta substitution" 5)
=> "substitution"
@end example
@end defun


@defun string-copy! @var{target} @var{tstart} @var{s} [@var{start} @var{end}]
Copy the sequence of characters from index range @code{[start,end)} in
the string @var{s} to the string @var{target}, beginning at index
@var{tstart}.  The characters are copied left--to--right or
right--to--left as needed; the copy is guaranteed to work, even if
@var{target} and @var{s} are the same string.

It is an error if the copy operation runs off the end of the target
string, e.g.

@example
(string-copy! (string-copy "Microsoft") 0
              "Regional Microsoft Operating Companies")
=> error
@end example
@end defun


@defun string-take @var{s} @var{nchars}
@defunx string-drop @var{s} @var{nchars}
@defunx string-take-right @var{s} @var{nchars}
@defunx string-drop-right @var{s} @var{nchars}
@func{string-take} returns the first @var{nchars} of @var{s}.

@func{string-drop} returns all but the first @var{nchars} of @var{s}.

@func{string-take-right} returns the last @var{nchars} of @var{s}.

@func{string-drop-right} returns all but the last @var{nchars} of
@var{s}.

If these procedures produce the entire string, they may return either
@var{s} or a copy of @var{s}; in some implementations, proper substrings
may share memory with @var{s}.

Examples:

@example
(string-take "Pete Szilagyi" 6) => "Pete S"
(string-drop "Pete Szilagyi" 6) => "zilagyi"

(string-take-right "Beta rules" 5) => "rules"
(string-drop-right "Beta rules" 5) => "Beta "
@end example

It is an error to take or drop more characters than are in the string:

@example
(string-take "foo" 37) => error
@end example
@end defun


@defun string-pad @var{s} @var{len} [@var{char} @var{start} @var{end}]
@defunx string-pad-right @var{s} @var{len} [@var{char} @var{start} @var{end}]
Build a string of length @var{len} comprised of @var{s} padded on the
left (right) by as many occurrences of the character @var{char} as
needed.  If @var{s} has more than len chars, it is truncated on the left
(right) to length @var{len}.  @var{char} defaults to @code{#\space}.

If @code{len <= (end - start)}, the returned value is allowed to share
storage with @var{s}, or be exactly @var{s} (if @code{len = (end -
start)}).

Examples:

@example
(string-pad     "325" 5) => "  325"
(string-pad   "71325" 5) => "71325"
(string-pad "8871325" 5) => "71325"
@end example
@end defun


@defun string-trim @var{s} [@var{char/char-set/pred} @var{start} @var{end}]
@defunx string-trim-right @var{s} [@var{char/char-set/pred} @var{start} @var{end}]
@defunx string-trim-both @var{s} [@var{char/char-set/pred} @var{start} @var{end}]
Trim @var{s} by skipping over all characters on the left/on the right/on
both sides that satisfy the second parameter @var{char/char-set/pred}:

@itemize
@item
if it is a character @var{char}, characters equal to @var{char} are
trimmed;

@item
if it is a char set @var{char-set}, characters contained in
@var{char-set} are trimmed;

@item
if it is a predicate @var{pred}, it is a test predicate that is applied
to the characters in @var{s}; a character causing it to return true is
skipped.
@end itemize

@var{char/char-set/pred} defaults to the character set
@code{char-set:whitespace} defined in @ansrfi{14}.

If no trimming occurs, these functions may return either @var{s} or a
copy of @var{s}; in some implementations, proper substrings may share
memory with @var{s}.

Example:

@example
(string-trim-both "  The outlook wasn't brilliant,  \n\r")
=> "The outlook wasn't brilliant,"
@end example
@end defun



@c page
@node strings spec modify
@subsection Modification


@defun string-set! @var{s} @var{i} @var{char}
@rnrs{5} @var{i} must be a valid index of @var{s}.  @func{string-set!}
stores @var{char} in element @var{i} of @var{s}.  Constant string
literals appearing in code are immutable; it is an error to use them in
a @func{string-set!}.

Example:

@example
(define (f) (make-string 3 #\*))
(define (g) "***")
(string-set! (f) 0 #\?)                ==>  unspecified
(string-set! (g) 0 #\?)                ==>  error
(string-set! (symbol->string 'immutable)
             3
             #\?)                      ==>  error
@end example
@end defun


@defun string-fill! @var{s} @var{char} [@var{start} @var{end}]
@rnrs{5} Store @var{char} in every element of @var{s}.

@func{string-fill} is extended from the @rnrs{5} definition to take
optional @var{start}/@var{end} arguments.
@end defun



@c page
@node strings spec compar
@subsection Comparison


@defun string-compare @var{s1} @var{s2} @var{proc<} @var{proc=} @var{proc>} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-compare-ci @var{s1} @var{s2} @var{proc<} @var{proc=} @var{proc>} [@var{start1} @var{end1} @var{start2} @var{end2}]
Apply @var{proc<}, @var{proc=}, or @var{proc>} to the mismatch index,
depending upon whether @var{s1} is less than, equal to, or greater than
@var{s2}.  The ``mismatch index'' is the largest index @var{i} such that
for every @code{0 <= j < i}, @code{s1[j] = s2[j]}; that is, @var{i} is
the first position that doesn't match.

@func{string-compare-ci} is the case--insensitive variant.

The optional @var{start}/@var{end} indices restrict the comparison to
the indicated substrings of @var{s1} and @var{s2}.  The mismatch index
is always an index into @var{s1}; in the case of @var{proc=}, it is
always @var{end1}; we observe the protocol in this redundant case for
uniformity.

@example
(string-compare "The cat in the hat" "abcdefgh"
                values values values
                4 6         ; Select "ca"
                2 4)        ; & "cd"
=> 5    ; Index of S1's "a"
@end example

True text collation is not handled by this @srfi{}.
@end defun


@defun string= @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string<> @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string< @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string> @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string<= @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string>= @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
These procedures are the lexicographic extensions to strings of the
corresponding orderings on characters.  For example, @func{string<} is
the lexicographic ordering on strings induced by the ordering
@func{char<?} on characters.  If two strings differ in length but are
the same up to the length of the shorter string, the shorter string is
considered to be lexicographically less than the longer string.

The optional @var{start}/@var{end} indices restrict the comparison to
the indicated substrings of @var{s1} and @var{s2}.

True text collation is not handled by this @srfi{}.
@end defun


@defun string-ci= @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-ci<> @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-ci< @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-ci> @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-ci<= @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-ci>= @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
Case--insensitive variants.
@end defun


@defun string-hash @var{s} [@var{bound} @var{start} @var{end}]
@defunx string-hash-ci @var{s} [@var{bound} @var{start} @var{end}]
Compute a hash value for the string @var{s}.  @var{bound} is a
non--negative exact integer specifying the range of the hash function.
A positive value restricts the return value to the range @code{[0,
bound)}.

If @var{bound} is either zero or not given, the implementation may use
an implementation--specific default value, chosen to be as large as is
efficiently practical.  For instance, the default range might be chosen
for a given implementation to map all strings into the range of integers
that can be represented with a single machine word.

The optional @var{start}/@var{end} indices restrict the hash operation
to the indicated substring of @var{s}.

@func{string-hash-ci} is the case--insensitive variant.

Invariants:

@example
(<= 0 (string-hash s b) (- b 1)) ; When B > 0.
(string=    s1 s2)  =>  (= (string-hash s1 b)    (string-hash s2 b))
(string-ci= s1 s2)  =>  (= (string-hash-ci s1 b) (string-hash-ci s2 b))
@end example

A legal but nonetheless discouraged implementation:

@example
(define (string-hash    s . other-args) 1)
(define (string-hash-ci s . other-args) 1)
@end example

Rationale: allowing the user to specify an explicit bound simplifies
user code by removing the mod operation that typically accompanies every
hash computation, and also may allow the implementation of the hash
function to exploit a reduced range to efficiently compute the hash
value.  E.g., for small bounds, the hash function may be computed in a
fashion such that intermediate values never overflow into bignum
integers, allowing the implementor to provide a fixnum--specific ``fast
path'' for computing the common cases very rapidly.
@end defun



@c page
@node strings spec prefix
@subsection Prefixes and suffixes


@defun string-prefix-length @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-suffix-length @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-prefix-length-ci @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-suffix-length-ci @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
Return the length of the longest common prefix/suffix of the two
strings.  For prefixes, this is equivalent to the ``mismatch index'' for
the strings (modulo the @var{starti} index offsets).

The optional @var{start}/@var{end} indices restrict the comparison to
the indicated substrings of @var{s1} and @var{s2}.

@func{string-prefix-length-ci} and @func{string-suffix-length-ci} are
the case--insensitive variants.
@end defun


@defun string-prefix? @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-suffix? @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-prefix-ci? @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-suffix-ci? @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
Return @true{} if @var{s1} is a prefix/suffix of @var{s2}; otherwise
return @false{}.  The optional @var{start}/@var{end} indices restrict
the comparison to the indicated substrings of @var{s1} and @var{s2}.

@func{string-prefix-ci?} and @func{string-suffix-ci?} are the
case--insensitive variants.
@end defun



@c page
@node strings spec search
@subsection Searching


@defun string-index @var{s} @var{char/char-set/pred} [@var{start} @var{end}]
@defunx string-index-right @var{s} @var{char/char-set/pred} [@var{start} @var{end}]
@defunx string-skip @var{s} @var{char/char-set/pred} [@var{start} @var{end}]
@defunx string-skip-right @var{s} @var{char/char-set/pred} [@var{start} @var{end}]
@func{string-index} (@func{string-index-right}) searches through the
string from the left (right), returning the index of the first
occurrence of a character which

@itemize
@item
equals @var{char/char-set/pred} if it is a character;

@item
is in @var{char/char-set/pred} if it is a character set;

@item
satisfies the predicate @var{char/char-set/pred} if it is a procedure.
@end itemize

If no match is found, the functions return @false{}.

The @var{start} and @var{end} parameters specify the beginning and end
indices of the search; the search includes the @var{start} index, but
not the @var{end} index.  Be careful of ``fencepost'' considerations:
when searching right--to--left, the first index considered is
@var{end-1}, whereas when searching left--to--right, the first index
considered is @var{start}

That is, the @var{start}/@var{end} indices describe a same half--open
interval @code{[start,end)} in these procedures that they do in all the
other @ansrfi{13} procedures.

The skip functions are similar, but use the complement of the criteria:
they search for the first char that does @strong{nor} satisfy the test.
E.g., to skip over initial whitespace, say:

@example
(cond [(string-skip s char-set:whitespace) =>
       (lambda (i) ...)] ; s[i] is not whitespace.
      ...)
@end example
@end defun


@defun string-count @var{s} @var{char/char-set/pred} [@var{start} @var{end}]
Return a count of the number of characters in @var{s} that satisfy the
@var{char/char-set/pred} argument.  If this argument is a procedure, it
is applied to the character as a predicate; if it is a character set,
the character is tested for membership; if it is a character, it is used
in an equality test.
@end defun


@defun string-contains @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
@defunx string-contains-ci @var{s1} @var{s2} [@var{start1} @var{end1} @var{start2} @var{end2}]
Return true if the string @var{s1} contains string @var{s2}; otherwise
return @false{}.  Return the index in @var{s1} where @var{s2} occurs as
a substring.  The optional @var{start}/@var{end} indices restrict the
operation to the indicated substrings.

The returned index is in the range @code{[start1,end1)}.  A successful
match must lie entirely in the @code{[start1,end1)} range of @var{s1}.

Example:

@example
;; Searches "a geek"
(string-contains "eek -- what a geek." "ee" 12 18)
=> 15
@end example

@func{string-contains-ci} is the case--insensitive variant.
@end defun



@c page
@node strings spec case-map
@subsection Alphabetic case mapping


@defun string-titlecase @var{s} [@var{start} @var{end}]
@defunx string-titlecase! @var{s} [@var{start} @var{end}]
For every character @var{c} in the selected range of @var{s}, if @var{c}
is preceded by a cased character, it is downcased; otherwise it is
titlecased.

@func{string-titlecase} returns the result string and does not alter its
s parameter.  @func{string-titlecase!} is the in--place side--effecting
variant.

Examples:

@example
(string-titlecase "--capitalize tHIS sentence.")
=> "--Capitalize This Sentence."

(string-titlecase "see Spot run. see Nix run.")
=> "See Spot Run. See Nix Run."

(string-titlecase "3com makes routers.")
=> "3Com Makes Routers."
@end example

Note that if a @var{start} index is specified, then the character
preceding @code{s[start]} has no effect on the titlecase decision for
character @code{s[start]}:

@example
(string-titlecase "greasy fried chicken" 2)
=> "Easy Fried Chicken"
@end example

Titlecase and cased information must be compatible with the Unicode
specification.
@end defun


@defun string-upcase @var{s} [@var{start} @var{end}]
@defunx string-upcase! @var{s} [@var{start} @var{end}]
@defunx string-downcase @var{s} [@var{start} @var{end}]
@defunx string-downcase! @var{s} [@var{start} @var{end}]
Raise or lower the case of the alphabetic characters in the string.

@func{string-upcase} and @func{string-downcase} return the result string
and do not alter their s parameter.  @func{string-upcase!} and
@func{string-downcase!} are the in--place side--effecting variants.
@end defun



@c page
@node strings spec append
@subsection Reverse and append


@defun string-reverse @var{s} [@var{start} @var{end}]
@defunx string-reverse! @var{s} [@var{start} @var{end}]
Reverse the string.  @func{string-reverse} returns the result string and
does not alter its s parameter.  @func{string-reverse!} is the in--place
side--effecting variant.

Examples:

@example
(string-reverse "Able was I ere I saw elba.")
=> ".able was I ere I saw elbA"

;;; In-place rotate-left, the Bell Labs way:
(lambda (s i)
  (let ([i (modulo i (string-length s))])
    (string-reverse! s 0 i)
    (string-reverse! s i)
    (string-reverse! s)))
@end example

Unicode note: Reversing a string simply reverses the sequence of
code--points it contains.  So a zero--width accent character a coming
after a base character @var{b} in string @var{s} would come out before
@var{b} in the reversed result.
@end defun


@defun string-append @var{s1} ...
@rnrs{5} Return a newly allocated string whose characters form the
concatenation of the given strings.
@end defun


@defun string-concatenate @var{string-list}
Append the elements of @var{string-list} together into a single string.
Guaranteed to return a freshly allocated string.

Note that the @code{(apply string-append string-list)} idiom is not
robust for long lists of strings, as some Scheme implementations limit
the number of arguments that may be passed to an n--ary procedure.
@end defun


@defun string-concatenate/shared @var{string-list}
@defunx string-append/shared @var{s1} ...
These two procedures are variants of @func{string-concatenate} and
@func{string-append} that are permitted to return results that share
storage with their parameters.  In particular, if
@func{string-append/shared} is applied to just one argument, it may
return exactly that argument, whereas @func{string-append} is required
to allocate a fresh string.
@end defun


@defun string-concatenate-reverse @var{string-list} [@var{final-string} @var{end}]
@defunx string-concatenate-reverse/shared @var{string-list} [@var{final-string} @var{end}]
With no optional arguments, these functions are equivalent to:

@example
(string-concatenate (reverse string-list))
@end example

@noindent
and:

@example
(string-concatenate/shared (reverse string-list))
@end example

@noindent
respectively.

If the optional argument @func{final-string} is specified, it is consed
onto the beginning of @var{string-list} before performing the
@func{list-reverse} and @func{string-concatenate} operations.

If the optional argument @var{end} is given, only the first end
characters of @var{final-string} are added to the string list, thus
producing:

@example
(string-concatenate
  (reverse (cons (substring/shared final-string 0 end)
                 string-list)))
@end example

Example:

@example
(string-concatenate-reverse '(" must be" "Hello, I") " going.XXXX" 7)
=> "Hello, I must be going."
@end example

This procedure is useful in the construction of procedures that
accumulate character data into lists of string buffers, and wish to
convert the accumulated data into a single string when done.

Unicode note: Reversing a string simply reverses the sequence of
code--points it contains.  So a zero--width accent character @var{ac}
coming after a base character @var{bc} in string @var{s} would come out
before @var{bc} in the reversed result.
@end defun



@c page
@node strings spec fold
@subsection Fold, unfold and map


@defun string-map @var{proc} @var{s} [@var{start} @var{end}]
@defunx string-map! @var{proc} @var{s} [@var{start} @var{end}]
@var{proc} is a @code{char->char} procedure; it is mapped over @var{s}.
@func{string-map} returns the result string and does not alter its
@var{s} parameter.  @func{string-map!} is the in--place side--effecting
variant.

Note: The order in which @var{proc} is applied to the elements of
@var{s} is not specified.
@end defun


@defun string-fold @var{kons} @var{knil} @var{s} [@var{start} @var{end}]
@defunx string-fold-right @var{kons} @var{knil} @var{s} [@var{start} @var{end}]
These are the fundamental iterators for strings.

The left--fold operator maps the @var{kons} procedure across the string
from left to right:

@example
(... (kons s[2] (kons s[1] (kons s[0] knil))))
@end example

@noindent
in other words, @func{string-fold} obeys the (tail) recursion:

@example
(string-fold kons knil s start end) =
   (string-fold kons (kons s[start] knil) start+1 end)
@end example

The right--fold operator maps the @var{kons} procedure across the string
from right to left:

@example
(kons s[0] (... (kons s[end-3] (kons s[end-2] (kons s[end-1] knil)))))
@end example

@noindent
obeying the (tail) recursion:

@example
(string-fold-right kons knil s start end) =
   (string-fold-right kons (kons s[end-1] knil) start end-1)
@end example

Examples:

@example
;;; Convert a string to a list of chars.
(string-fold-right cons '() s)

;;; Count the number of lower-case characters in a string.
(string-fold (lambda (c count)
               (if (char-lower-case? c)
                   (+ count 1)
                 count))
              0
              s)

;;; Double every backslash character in S.
(let* ([ans-len (string-fold (lambda (c sum)
                               (+ sum (if (char=? c #\\) 2 1)))
                             0 s)]
       [ans (make-string ans-len)])
  (string-fold (lambda (c i)
                 (let ([i (if (char=? c #\\)
                              (begin (string-set! ans i #\\) (+ i 1))
                            i)])
                    (string-set! ans i c)
                    (+ i 1)))
               0 s)
  ans)
@end example

The right--fold combinator is sometimes called a ``catamorphism''.
@end defun


@defun string-unfold @var{p} @var{f} @var{g} @var{seed} [@var{base} @var{make-final}]
This is a fundamental constructor for strings.

@table @var
@item g
Is used to generate a series of ``seed'' values from the initial seed:

@example
seed, (g seed), (g2 seed), (g3 seed), ...
@end example

@item p
Tells us when to stop; when it returns true when applied to one of the
seed values.

@item f
Maps each seed value to the corresponding character in the result
string.  These chars are assembled into the string in a left--to--right
order.

@item base
Is the optional initial/leftmost portion of the constructed string; it
defaults to the empty string.

@item make-final
Is applied to the terminal seed value (on which @var{p} returns true) to
produce the final/rightmost portion of the constructed string.  It
defaults to @code{(lambda (x) "")}.
@end table

More precisely, the following (simple, inefficient) definitions hold:

@example
;;; Iterative
(define (string-unfold p f g seed base make-final)
  (let lp ([seed seed]
           [ans base])
    (if (p seed)
        (string-append ans (make-final seed))
      (lp (g seed) (string-append ans (string (f seed)))))))

;;; Recursive
(define (string-unfold p f g seed base make-final)
  (string-append base
                 (let recur ([seed seed])
                   (if (p seed)
                       (make-final seed)
                     (string-append (string (f seed))
                                    (recur (g seed)))))))
@end example

@func{string-unfold} is a fairly powerful string constructor; we can use
it to convert a list to a string, read a port into a string, reverse a
string, copy a string, and so forth.  Examples:

@example
(port->string p) = (string-unfold eof-object? values
                                  (lambda (x) (read-char p))
                                    (read-char p))

(list->string lis) = (string-unfold null? car cdr lis)

(string-tabulate f size) = (string-unfold (lambda (i)
                                            (= i size))
                                          f add1 0)
@end example

@noindent
to map @var{f} over a list @var{lis}, producing a string:

@example
(string-unfold null? (compose f car) cdr lis)
@end example

Interested functional programmers may enjoy noting that
@func{string-fold-right} and @func{string-unfold} are in some sense
inverses.  That is, given operations @var{knull?}, @var{kar}, @var{kdr},
@var{kons}, and @var{knil} satisfying:

@example
(kons (kar x) (kdr x)) = x  and (knull? knil) = #t
@end example

@noindent
then:

@example
(string-fold-right kons knil (string-unfold knull? kar kdr x)) = x
@end example

@noindent
and:

@example
(string-unfold knull? kar kdr (string-fold-right kons knil s)) = s.
@end example

The final string constructed does not share storage with either
@var{base} or the value produced by @var{make-final}.

This combinator sometimes is called an ``anamorphism''.

Note: implementations should take care that runtime stack limits do not
cause overflow when constructing large (e.g., megabyte) strings with
@func{string-unfold}.
@end defun


@defun string-unfold-right @var{p} @var{f} @var{g} @var{seed} [@var{base} @var{make-final}]
This is a fundamental constructor for strings.

@table @var
@item g
Is used to generate a series of ``seed'' values from the initial seed:

@example
seed, (g seed), (g2 seed), (g3 seed), ...
@end example

@item p
Tells us when to stop; when it returns true when applied to one of these
seed values.

@item f
Maps each seed value to the corresponding character in the result
string.  These chars are assembled into the string in a right--to--left
order.

@item base
Is the optional initial/rightmost portion of the constructed string; it
defaults to the empty string.

@item make-final
Is applied to the terminal seed value (on which @var{p} returns true) to
produce the final/leftmost portion of the constructed string.  It
defaults to @code{(lambda (x) "")}.
@end table

More precisely, the following (simple, inefficient) definitions hold:

@example
;;; Iterative
(define (string-unfold-right p f g seed base make-final)
  (let lp ([seed seed]
           [ans base])
    (if (p seed)
        (string-append (make-final seed) ans)
      (lp (g seed) (string-append (string (f seed)) ans)))))

;;; Recursive
(define (string-unfold-right p f g seed base make-final)
  (string-append (let recur ([seed seed])
                   (if (p seed)
                       (make-final seed)
                     (string-append (recur (g seed))
                                    (string (f seed)))))
                 base))
@end example

Interested functional programmers may enjoy noting that
@func{string-fold} and @func{string-unfold-right} are in some sense
inverses. That is, given operations @var{knull?}, @var{kar}, @var{kdr},
@var{kons}, and @var{knil} satisfying:

@example
(kons (kar x) (kdr x)) = x and (knull? knil) = #t
@end example

@noindent
then:

@example
(string-fold kons knil (string-unfold-right knull? kar kdr x)) = x
@end example

@noindent
and:

@example
(string-unfold-right knull? kar kdr (string-fold kons knil s)) = s.
@end example

The final string constructed does not share storage with either
@var{base} or the value produced by @func{make-final}.

Note: implementations should take care that runtime stack limits do not
cause overflow when constructing large (e.g., megabyte) strings with
@func{string-unfold-right}.
@end defun


@defun string-for-each @var{proc} @var{s} [@var{start} @var{end}]
Apply @var{proc} to each character in @var{s}.  @func{string-for-each}
is required to iterate from start to end in increasing order.
@end defun


@defun string-for-each-index @var{proc} @var{s} [@var{start} @var{end}]
Apply @var{proc} to each index of @var{s}, in order.  The optional
@var{start}/@var{end} pairs restrict the endpoints of the loop.  This is
simply a method of looping over a string that is guaranteed to be safe
and correct.  Example:

@example
(let* ([len (string-length s)]
       [ans (make-string len)])
  (string-for-each-index
      (lambda (i) (string-set! ans (- len i) (string-ref s i)))
      s)
  ans)
@end example
@end defun



@c page
@node strings spec replicate
@subsection Replicate and rotate


@defun xsubstring @var{s} @var{from} [@var{to} @var{start} @var{end}]
This is the ``extended substring'' procedure that implements replicated
copying of a substring of some string.

@var{s} is a string; @var{start} and @var{end} are optional arguments
that demarcate a substring of @var{s}, defaulting to 0 and the length of
@var{s} (i.e. the whole string).

This function replicates the selected substring ``up and down'' index
space, in both the positive and negative directions.  For example, if
@code{s = "abcdefg"}, @code{start=3}, and @code{end=6}, then we have the
conceptual bidirectionally--infinite string:

@example
...  d  e  f  d  e  f  d  e  f  d  e  f  d  e  f  d  e  f  d  ...
... -9 -8 -7 -6 -5 -4 -3 -2 -1  0 +1 +2 +3 +4 +5 +6 +7 +8 +9  ...
@end example

@noindent
that is @code{defg} repeated in both directions.

@func{xsubstring} returns the substring of this string beginning at
index @var{from}, and ending at @var{to} which defaults to @code{from +
(end - start)}.

We can use @func{xsubstring} to perform a variety of tasks:

@itemize
@item
To rotate a string left: @code{(xsubstring "abcdef" 2) => "cdefab"}.

@item
To rotate a string right: @code{(xsubstring "abcdef" -2) => "efabcd"}.

@item
To replicate a string: @code{(xsubstring "abc" 0 7) => "abcabca"}.
@end itemize

Note that:

@itemize
@item
The @var{from}/@var{to} indices give a half--open range; the characters
from index @var{from} up to, but not including, index @var{to}.

@item
The @var{from}/@var{to} indices are not in terms of the index space for
string @var{s}.  They are in terms of the replicated index space of the
substring defined by @var{s}, @var{start}, and @var{end}.
@end itemize

It is an error if @code{start = end}; although this is allowed by
special dispensation when @code{from = to}.
@end defun


@defun string-xcopy! @var{target} @var{tstart} @var{s} @var{sfrom} [@var{sto} @var{start} @var{end}]
Exactly the same as @func{xsubstring}, but the extracted text is written
into the string @var{target} starting at index @var{tstart}.  This
operation is not defined if @code{(eq? target s)} or these two arguments
share storage; we cannot copy a string on top of itself.
@end defun



@c page
@node strings spec misc
@subsection Miscellaneous: intertion, parsing


@defun string-replace @var{s1} @var{s2} @var{start1} @var{end1} [@var{start2} @var{end2}]
Return:

@example
(string-append (substring/shared s1 0 start1)
               (substring/shared s2 start2 end2)
               (substring/shared s1 end1 (string-length s1)))
@end example

That is, the segment of characters in @var{s1} from @var{start1} to
@var{end1} is replaced by the segment of characters in @var{s2} from
@var{start2} to @var{end2}.  If @code{start1 = end1}, this simply
splices the @var{s2} characters into @var{s1} at the specified index.

Examples:

@example
(string-replace "The TCL programmer endured daily ridicule."
                "another miserable perl drone" 4 7 8 22 )
=> "The miserable perl programmer endured daily ridicule."

(string-replace "It's easy to code it up in Scheme." "lots of fun" 5 9)
=> "It's lots of fun to code it up in Scheme."

(define (string-insert s i t) (string-replace s t i i))

(string-insert "It's easy to code it up in Scheme." 5 "really ")
=> "It's really easy to code it up in Scheme."
@end example
@end defun


@defun string-tokenize @var{s} [@var{token-set} @var{start} @var{end}]
Split the string @var{s} into a list of substrings, where each substring
is a maximal non--empty contiguous sequence of characters from the
character set @var{token-set}.

@itemize
@item
@var{token-set} defaults to @code{char-set:graphic} (see @ansrfi{14} for
more on character sets and @code{char-set:graphic}).

@item
If @var{start} or @var{end} indices are provided, they restrict
@func{string-tokenize} to operating on the indicated substring of
@var{s}.
@end itemize

This function provides a minimal parsing facility for simple
applications.  More sophisticated parsers that handle quoting and
backslash effects can easily be constructed using regular--expression
systems; be careful not to use @func{string-tokenize} in contexts where
more serious parsing is needed.

@example
(string-tokenize "Help make programs run, run, RUN!")
=> ("Help" "make" "programs" "run," "run," "RUN!")
@end example
@end defun



@c page
@node strings spec filter
@subsection Filtering and deleting


@defun string-filter @var{char/char-set/pred} @var{s} [@var{start} @var{end}]
@defunx string-delete @var{char/char-set/pred} @var{s} [@var{start} @var{end}]
Filter the string @var{s}, retaining only those characters that
satisfy/do not satisfy the @var{char/char-set/pred} argument.  If this
argument is a procedure, it is applied to the character as a predicate;
if it is a char--set, the character is tested for membership; if it is a
character, it is used in an equality test.

If the string is unaltered by the filtering operation, these functions
may return either @var{s} or a copy of @var{s}.
@end defun


@c page
@node strings spec parsing
@subsection Start/end optional--argument parsing and checking utilities


@defun {string-parse-start+end} @var{proc} @var{s} @var{args}
@defunx {string-parse-final-start+end} @var{proc} @var{s} @var{args}
@func{string-parse-start+end} may be used to parse a pair of optional
start/end arguments from an argument list, defaulting them to 0 and the
length of some string @var{s}, respectively.

Let the length of string @var{s} be @var{slen}.

@itemize
@item
If @code{args = ()}, the function returns @code{(values '() 0 slen)}.

@item
If @code{args = (i)}, @var{i} is checked to ensure it is an exact
integer, and that @code{0 <= i <= slen}.  The function returns
@code{(values (cdr args) i slen)}.

@item
If @code{args = (i j ...)}, @var{i} and @var{j} are checked to ensure
they are exact integers, and that @code{0 <= i <= j <= slen}.  The
function returns @code{(values (cddr args) i j)}.
@end itemize

If any of the checks fail, an error condition is raised, and @var{proc}
is used as part of the error condition; it should be the client
procedure whose argument list @func{string-parse-start+end} is parsing.

@func{string-parse-final-start+end} is exactly the same, except that the
@var{args} list passed to it is required to be of length two or less; if
it is longer, an error condition is raised.  It may be used when the
optional start/end parameters are final arguments to the procedure.

Note that in all cases, these functions ensure that @var{s} is a string
(by necessity, since all cases apply @func{string-length} to @var{s}
either to default end or to bounds-check it).
@end defun


@deffn Syntax let-string-start+end (@var{start} @var{end} [@var{rest}]) @var{proc-exp} @var{s-exp} @var{args-exp} @var{body} ...
Syntactic sugar for an application of @func{string-parse-start+end} or
@func{string-parse-final-start+end}.  If a @var{rest} variable is given,
the form is equivalent to:

@example
(call-with-values
    (lambda ()
      (string-parse-start+end proc-exp s-exp args-exp))
  (lambda (rest start end)
    body ...))
@end example

If no @var{rest} variable is given, the form is equivalent to:

@example
(call-with-values
    (lambda ()
      (string-parse-final-start+end proc-exp s-exp args-exp))
  (lambda (start end)
    body ...))
@end example
@end deffn


@defun check-substring-spec @var{proc} @var{s} @var{start} @var{end}
@defunx substring-spec-ok? @var{s} @var{start} @var{end}
Check values @var{s}, @var{start} and @var{end} to ensure they specify a
valid substring.  This means that @var{s} is a string, @var{start} and
@var{end} are exact integers, and:

@example
0 <= start <= end <= (string-length s)
@end example

If the values are not proper:

@itemize
@item
@func{check-substring-spec} raises an error condition.  @var{proc} is
used as part of the error condition, and should be the procedure whose
parameters we are checking.

@item
@func{substring-spec-ok?} returns @false{}.
@end itemize

Otherwise, @func{substring-spec-ok?} returns @true{}, and
@func{check-substring-spec} simply returns (what it returns is not
specified).
@end defun



@c page
@node strings spec knuth
@subsection Knuth-Morris-Pratt searching


The Knuth--Morris--Pratt string--search algorithm is a method of rapidly
scanning a sequence of text for the occurrence of some fixed string.  It
has the advantage of never requiring backtracking; hence, it is useful
for searching not just strings, but also other sequences of text that do
not support backtracking or random--access, such as input ports.

The following routines package up the initialisation and searching
phases of the algorithm for general use.  They also support searching
through sequences of text that arrive in buffered chunks, in that
intermediate search state can be carried across applications of the
search loop from the end of one buffer application to the next.

A second critical property of @acronym{KMP} search is that it requires
the allocation of auxiliary memory proportional to the length of the
pattern, but constant in the size of the character type.  Alternate
searching algorithms frequently require the construction of a table with
an entry for every possible character; which can be prohibitively
expensive in a 16-bit or 32-bit character representation.


@defun make-kmp-restart-vector @var{s} [@var{c=} @var{start} @var{end}]
Build a Knuth--Morris--Pratt ``restart vector'', which is useful for
quickly searching character sequences for the occurrence of string
@var{s} (or the substring of @var{s} demarcated by the optional
@var{start}/@var{end} parameters, if provided).

@var{c=} is a character--equality function used to construct the restart
vector.  It defaults to @func{char=?}; use @func{char-ci=?}  instead for
case--folded string search.

The definition of the restart vector @var{rv} for string @var{s} is: If
we have matched chars @code{0..i-1} of @var{s} against some search
string @var{ss}, and @code{s[i]} doesn't match @code{ss[k]}, then reset
@code{i := rv[i]}, and try again to match @code{ss[k]}.  If @code{rv[i]
= -1}, then punt @code{ss[k]} completely, and move on to @code{ss[k+1]}
and @code{s[0]}.

In other words, if you have matched the first @var{i} chars of @var{s},
but the @var{i+1}'th char doesn't match, @code{rv[i]} tells you what the
next--longest prefix of @var{s} is that you have matched.

The following string--search function shows how a restart vector is used
to search.  Note the attractive feature of the search process: it is
``on line'', that is, it never needs to back up and reconsider
previously seen data.  It simply consumes characters one--at--a--time
until declaring a complete match or reaching the end of the sequence.
Thus, it can be easily adapted to search other character sequences (such
as ports) that do not provide random access to their contents.

@example
(define (find-substring pattern source start end)
  (let ([plen (string-length pattern)]
        [rv (make-kmp-restart-vector pattern)])

    ;; The search loop. SJ & PJ are redundant state.
    (let lp ([si start]
             [pi 0]
             [sj (- end start)]     ; (- end si)  -- how many chars left.
             [pj plen])             ; (- plen pi) -- how many chars left.
       (if (= pi plen)
           (- si plen)                             ; Win.
         (and (<= pj sj)                           ; Lose.
              (if [char=? (string-ref source si)           ; Test.
                          (string-ref pattern pi)]
                  (lp (+ 1 si) (+ 1 pi) (- sj 1) (- pj 1)) ; Advance.
                (let ([pi (vector-ref rv pi)])             ; Retreat.
                  (if (= pi -1)
                      (lp (+ si 1)  0   (- sj 1)  plen)    ; Punt.
                    (lp si          pi  sj        (- plen pi))))))))))
@end example

The optional @var{start}/@var{end} parameters restrict the restart
vector to the indicated substring of @var{pat}; @var{rv} is @code{end -
start} elements long.  If @code{start > 0}, then @var{rv} is offset by
start elements from @var{pat}.  That is, @code{rv[i]} describes pattern
element @code{pat[i + start]}.  Elements of @var{rv} are themselves
indices that range just over @code{[0, end-start)}, not @code{[start,
end)}.

Rationale: the actual value of @var{rv} is ``position independent''; it
does not depend on where in the pat string the pattern occurs, but only
on the actual characters comprising the pattern.
@end defun


@defun kmp-step @var{pat} @var{rv} @var{c} @var{i} @var{c=} @var{p-start}
This function encapsulates the work performed by one step of the
@acronym{KMP} string search; it can be used to scan strings, input
ports, or other on--line character sources for fixed strings.

@var{pat} is the non--empty string specifying the text for which we are
searching.  @var{rv} is the Knuth--Morris--Pratt restart vector for the
pattern, as constructed by @func{make-kmp-restart-vector}.  The pattern
begins at @code{pat[p-start]}, and is @code{(string-length rv)}
characters long.  @var{c=} is the character--equality function used to
construct the restart vector, typically @func{char=?} or
@func{char-ci=?}.

Suppose the pattern is @var{n} characters in length:

@example
pat[p-start, p-start + n)
@end example

We have already matched i characters:

@example
pat[p-start, p-start + i)
@end example

@noindent
@var{p-start} is typically zero.  @var{c} is the next character in the
input stream.  @func{kmp-step} returns the new @var{i} value; that is,
how much of the pattern we have matched, including character @var{c}.
When @var{i} reaches @var{n}, the entire pattern has been matched.

Thus a typical search loop looks like this:

@example
(let loop ([i 0])
  (or (= i n)                           ; Win -- #t
      (and (not (end-of-stream))        ; Lose -- #f
           (loop (kmp-step pat rv (get-next-character)
                           i char=? 0)))))
@end example

Example:

@example
;; Read chars from IPORT until we find string PAT or hit EOF.
(define (port-skip pat iport)
  (let* ([rv     (make-kmp-restart-vector pat)]
         [patlen (string-length pat)])
    (let loop ([i       0]
              [nchars   0])
      (if (= i patlen)
          nchars                        ; Win -- nchars skipped
        (let ([c (read-char iport)])
          (if (eof-object? c)
              c                         ; Fail -- EOF
            (loop (kmp-step pat rv c i char=? 0) ; Continue
                  (+ nchars 1))))))))
@end example

This procedure could be defined as follows:

@example
(define (kmp-step pat rv c i c= p-start)
  (let loop ([i i])
    (if (c= c (string-ref pat (+ i p-start)))   ; Match =>
        (+ i 1)                                 ;   Done.
      (let ([i (vector-ref rv i)])              ; Back up in PAT.
        (if (= i -1)
            0                                   ; Can't back up more.
          (loop i)))))))                        ; Keep going.
@end example

Rationale: this procedure takes no optional arguments because it is
intended as an inner--loop primitive and we do not want any run--time
penalty for optional--argument parsing and defaulting, nor do we wish
barriers to procedure integration/inlining.
@end defun


@defun string-kmp-partial-search @var{pat} @var{rv} @var{s} @var{i} [@var{c=} @var{p-start} @var{s-start} @var{s-end}]
Apply @func{kmp-step} across @var{s}; optional @var{s-start}/@var{s-end}
bounds parameters restrict search to a substring of @var{s}.  The
pattern is @code{(vector-length rv)} characters long; optional
@var{p-start} index indicates non--zero start of pattern in @var{pat}.

Suppose @code{plen = (vector-length rv)} is the length of the pattern.
@var{i} is an integer index into the pattern (that is @code{0 <= i <
plen}) indicating how much of the pattern has already been matched.
This means the pattern must be non-empty: @code{plen > 0}.

@itemize
@item
On success, return @code{-j}, where @var{j} is the index in @var{s}
bounding the end of the pattern; e.g. a value that could be used as the
end parameter in a call to @func{substring/shared}.

@item
On continue, return the current search state @code{i'} (an index into
@var{rv}) when the search reached the end of the string.  This is a
non--negative integer.
@end itemize

Hence:

@itemize
@item
A negative return value indicates success, and says where in the string
the match occured.

@item
A non--negative return value provides the @var{i} to use for continued
search in a following string.
@end itemize

This utility is designed to allow searching for occurrences of a fixed
string that might extend across multiple buffers of text.  This is why,
for example, we do not provide the index of the start of the match on
success; it may have occurred in a previous buffer.

To search a character sequence that arrives in ``chunks'', write a loop
of this form:

@example
(let loop ([i 0])
  (and (not (end-of-data?))             ; Lose -- return #f.
       (let* ([buf (get-next-chunk)]    ; Get or fill up the buffer.
              [i   (string-kmp-partial-search pat rv buf i)])
         (if (< i 0)
             (- i)                      ; Win -- return end index.
           (loop i)))))                 ; Keep looking.
@end example

Modulo @var{start}/@var{end} optional-argument parsing, this procedure
could be defined as follows:

@example
(define (string-kmp-partial-search pat rv s i c= p-start s-start s-end)
  (let ([patlen (vector-length rv)])
    (let loop ([si s-start]       ; An index into S.
               [vi i])            ; An index into RV.
      (cond [(= vi patlen) (- si)]      ; Win.
            [(= si end) vi]             ; Ran off the end.
            [else (loop (+ si 1)        ; Match s[si] & loop.
                      (kmp-step pat rv (string-ref s si)
                                vi c= p-start))]))))
@end example
@end defun



@c page
@node strings ack
@section Acknowledgments


The design of this library benefited greatly from the feedback provided
during the @srfi{} discussion phase.  Among those contributing
thoughtful commentary and suggestions, both on the mailing list and by
private discussion, were Paolo Amoroso, Lars Arvestad, Alan Bawden, Jim
Bender, Dan Bornstein, Per Bothner, Will Clinger, Brian Denheyer, Mikael
Djurfeldt, Kent Dybvig, Sergei Egorov, Marc Feeley, Matthias Felleisen,
Will Fitzgerald, Matthew Flatt, Arthur A. Gleckler, Ben Goetter, Sven
Hartrumpf, Erik Hilsdale, Richard Kelsey, Oleg Kiselyov, Bengt Kleberg,
Donovan Kolbly, Bruce Korb, Shriram Krishnamurthi, Bruce Lewis, Tom
Lord, Brad Lucier, Dave Mason, David Rush, Klaus Schilling, Jonathan
Sobel, Mike Sperber, Mikael Staldal, Vladimir Tsyshevsky, Donald Welsh,
and Mike Wilson.  I am grateful to them for their assistance.

I am also grateful the authors, implementors and documentors of all the
systems mentioned in the introduction.  Aubrey Jaffer and Kent Pitman
should be noted for their work in producing Web--accessible versions of
the @rnrs{5} and Common Lisp spec, which was a tremendous aid.

This is not to imply that these individuals necessarily endorse the
final results, of course.

During this document's long development period, great patience was
exhibited by Mike Sperber, who is the editor for the @srfi{}, and by
Hillary Sullivan, who is not.


@c page
@node strings references
@section References


@emph{Case mappings}.  Unicode Technical Report 21.

@center @url{http://www.unicode.org/unicode/reports/tr21/}

@noindent
@emph{Common Lisp: the Language}.  Guy L. Steele Jr. (editor).  Digital
Press, Maynard, Mass., second edition 1990.  Available at:

@center @url{http://www.elwood.com/alu/table/references.htm#cltl2}

@noindent
@emph{The Common Lisp ``HyperSpec''}, produced by Kent Pitman, is
essentially the @ansi{} spec for Common Lisp:

@center @url{http://www.harlequin.com/education/books/HyperSpec/}

@noindent
The following URLs provide documentation on relevant Java classes.

@example
http://java.sun.com/products/jdk/1.2/docs/api/java/lang/Character.html
http://java.sun.com/products/jdk/1.2/docs/api/java/lang/String.html
http://java.sun.com/products/jdk/1.2/docs/api/java/lang/StringBuffer.html
http://java.sun.com/products/jdk/1.2/docs/api/java/text/Collator.html
http://java.sun.com/products/jdk/1.2/docs/api/java/text/package-summary.html
@end example

@noindent
MIT-Scheme:

@center @url{http://www.swiss.ai.mit.edu/projects/scheme/}

@noindent
@emph{Revised^5 report on the algorithmic language Scheme}.  R. Kelsey,
W. Clinger, J. Rees (editors).  Higher--Order and Symbolic Computation,
Vol. 11, No. 1, September, 1998; and ACM SIGPLAN Notices, Vol. 33,
No. 9, October, 1998.  Available at:

@center @url{http://www.schemers.org/Documents/Standards/}

@noindent
The SRFI web site.

@center @url{http://srfi.schemers.org/}

@noindent
@ansrfi{14}: Character--set library.  The @ansrfi{14} char--set library
defines a character--set data type, which is used by some procedures in
this library.

@center @url{http://srfi.schemers.org/srfi-14/}

@noindent
The Unicode site:

@center @url{http://www.unicode.org/}

@noindent
The Unicode character database.

@example
ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt
ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.html
@end example



@c page
@node case-lambda
@chapter Syntax for procedures of variable arity


@cindex @srfi{} case-lambda


The @library{srfi case-lambda} library has been written by Lars T Hansen
as the reference implementation for @ansrfi{16}.


@menu
* case-lambda license::         Original license.
* case-lambda abstract::        Abstract.
* case-lambda rationale::       Rationale.
* case-lambda spec::            Specification.
@end menu


@c page
@node case-lambda license
@section Original license


Copyright @copyright{} 1999 Lars T Hansen.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



@c page
@node case-lambda abstract
@section Abstract


@func{case-lambda}, a syntax for procedures with a variable number of
arguments, is introduced.


@c page
@node case-lambda rationale
@section Rationale


@func{case-lambda} reduces the clutter of procedures that execute
different code depending on the number of arguments they were passed; it
is a pattern--matching mechanism that matches on the number of
arguments.  @func{case-lambda} is available in some Scheme systems.

While @func{case-lambda} can be implemented as a macro using only
facilities available in @rnrs{5} Scheme, it admits considerable
implementation--specific optimization.


@c page
@node case-lambda spec
@section Specification


@deffn Syntax case-lambda @var{clause} ...
Eeach @var{clause} has the format @code{(formals body)}, were
@var{formals} is a formal arguments list as for @func{lambda} (cf
section 4.1.4 of the @rnrs{5}).  Each @var{body} is a @code{tail-body}
(cf section 3.5 of the @rnrs{5}).

A @func{case-lambda} expression evaluates to a procedure that accepts a
variable number of arguments and is lexically scoped in the same manner
as procedures resulting from @func{lambda} expressions.

When the procedure is called with some arguments @var{V1}, ...,
@var{Vk}, then the first clause for which the arguments agree with
@var{formals} is selected, where agreement is specified as for the
@var{formals} of a LAMBDA expression.

The variables of @var{formals} are bound to fresh locations, the values
@var{V1}, ..., @var{Vk} are stored in those locations, the @var{body} is
evaluated in the extended environment, and the results of @var{body} are
returned as the results of the procedure call.

It is an error for the arguments not to agree with the @var{formals} of
any @var{clause}.

Error:

@example
(define plus
  (case-lambda
    [()         0]
    [(x)        x]
    [(x y)      (+ x y)]
    [(x y z)    (+ (+ x y) z)]
    [args       (apply + args)]))

(plus)                     => 0
(plus 1)                   => 1
(plus 1 2 3)               => 6

((case-lambda
   [(a)         a]
   [(a b)       (* a b)])
 1 2 3)                    => error
@end example
@end deffn



@c page
@node time
@chapter Time data types and procedures


@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro


@cindex @srfi{} time


The @library{srfi time} has been written by Will Fitzgerald as the
reference implementation for @ansrfi{19}.

@menu
* time license::                Original license.
* time abstract::               Abstract.
* time rationale::              Rationale.
* time spec::                   Specification.
* time ack::                    Acknowledgements.
@end menu

@c page
@node time license
@section Original license


Copyright @copyright{} 2000 Neodesic Corporation.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



@c page
@node time abstract
@section Abstract


Points in time are represented a the number of seconds (with nanosecond
precision) since ``the epoch'', a zero point in time.  Several standard
variants are defined, including @utc{} (Universal Coordinated Time),
@tai{} (international atomic time), and monotonic time.  A point in time
can also be represented as a Julian Day or Modified Julian Day number.

Time durations, including time spent in a process or thread, are
defined.  Conversion routines are provided.  The procedure
@func{current-time} queries the current time in a specified variant,
with a system--dependent resolution.  Procedures for time arithmetic and
time comparisons are also provided.

A date is a representation of a point in time in the Gregorian calendar,
a 24 hour clock (with nanosecond precision) and a time zone offset from
@utc{}.  Procedures for converting between time and dates are provided,
as well as for reading and writing string representations of dates.


@c page
@node time rationale
@section Rationale


@rnrs{5} Scheme does not provide standard data types for time.  This
@srfi{} addresses this lack by specifying data types for time and
associated procedures.


@c page
@node time spec
@section Specification


@menu
* time spec intro::             Introduction.
* time spec const::             Constants.
* time spec current::           Current time and clock resolution.
* time spec timeobj::           Time object and accessors.
* time spec timeobj compar::    Time object comparison procedures.
* time spec timeobj arithm::    Time object arithmetic procedures.
* time spec dateobj::           Date object and accessors.
* time spec julian::            Time/Date/Julian Day/Modified
                                Julian Day Converters.
* time spec string::            Date to string/string to date
                                converters.
@end menu


@c page
@node time spec intro
@subsection Introduction


A @emph{Time} object, which is distinct from all existing types, defines
a point in time or a time duration in some standard time system.  The
standard time systems are:

@itemize
@item
Universal Coordinated Time (@utc{}),

@item
International Atomic Time (@tai{}),

@item
monotonic time (a monotonically increasing point in time from some
epoch, which is implementation--dependent),

@item
@cpu{} time in current thread (implementation dependent),

@item
@cpu{} time in current process (implementation dependent),

@item
time duration.
@end itemize

Implementations are required to implement @utc{}, monotonic time, @cpu{}
time in current process, and time duration.  Implementations are allowed
to create extensions (for example, amount of time spent in garbage
collection).

A @emph{Time} object consists of three components:

@table @emph
@item Time type
A symbol representing the time system representation used.  The
constants @code{TIME-TAI}, @code{TIME-UTC}, @code{TIME-MONOTONIC},
@code{TIME-THREAD}, @code{TIME-PROCESS}, and @code{TIME-DURATION} must
be provided for these symbols.  Implementations should provide constants
for time type extensions.

@item Second
An integer representing the number of whole seconds from ``the epoch''.

@item Nanosecond
An integer of the number of nanoseconds in the fractional portion.
Although a time object has nanosecond precision, clocks may have a lower
resolution.
@end table

A @emph{Date} object, which is distinct from all existing types,
represents a point in time as represented by the Gregorian calendar as
well as by a time zone.  @emph{Date} objects are immutable.  A
@emph{Date} object consists of the following components:

@table @emph
@item Nanosecond
An integer between 0 and 9,999,999, inclusive.

@item Second
An integer 0 and 60, inclusive, (60 represents a leap second).

@item Minute
An integer between 0 and 59, inclusive.

@item Hour
An integer between 0 and 23, inclusive.

@item Day
An integer between 0 and 31, inclusive, the upper limit depending on the
month and year of the point in time.

@item Month
An integer between 1 and 12, inclusive; in which 1 means January, 2
February, and so on.

@item Year
An integer representing the year.

@item Time zone
A integer the number of seconds east of GMT for this timezone.
@end table

A @emph{Julian Day} represents a point in time as a real number of days
since -4714-11-24T12:00:00Z (November 24, -4714 at noon, @utc{}).

A @emph{Modified Julian Day} represents a point in time as a real number
of days since 1858-11-17T00:00:00Z (November 17, 1858 at midnight, UTC).


@c page
@node time spec const
@subsection Constants


The following constants are required:

@deffn Constant time-duration
Symbol representing @emph{Time} duration.
@end deffn


@deffn Constant time-monotonic
Symbol representing monotonic time.
@end deffn


@deffn Constant time-process
Symbol representing time spent in current process.
@end deffn


@deffn Constant time-tai
Symbol representing @tai{} time.
@end deffn


@deffn Constant time-thread
Symbol representing time spent in current thread.
@end deffn


@deffn Constant time-utc
Symbol representting @utc{} time.
@end deffn


@c page
@node time spec current
@subsection Current time and clock resolution


The following procedures are required.


@defun current-date [@var{tz-offset}]
Return a @emph{Date} corresponding to the current @utc{} time.
@end defun

@defun current-julian-day
Current Julian Day.
@end defun


@defun current-modified-julian-day
Current Modified Julian Day.
@end defun


@defun current-time [@var{time-type}]
Current time, of type @var{time-type} system, which defaults to
@code{time-utc}.
@end defun


@defun time-resolution [@var{time-type}]
Return an exact integer representing the clock resolution, in
nanoseconds, of the system clock of type type @var{time-type} system,
which defaults to @code{time-utc}.
@end defun


@c page
@node time spec timeobj
@subsection Time object and accessors


The following procedures are required:


@defun make-time @var{time-type} @var{nanosecond} @var{second}
Return a new time object.
@end defun


@defun time? @var{object}
@true{} if @var{object} is a @emph{Time} object, otherwise, @false{}.
@end defun


@defun time-type @var{time}
Return the @var{Time type} symbol of @var{time}.  @ref{time spec intro}
for details.
@end defun


@defun time-nanosecond @var{time}
Return the @emph{Nanosecond} component of @var{time}.
@end defun


@defun time-second @var{time}
Return the @emph{Second} component of @var{time}.
@end defun


@defun set-time-type! @var{time} @var{time-type}
Set the @emph{Time type} component of @var{time} to @var{time-type},
which must be one of the time type symbols.  @ref{time spec intro} for
details.

Note: This changes the semantics of the time object.  To convert a time
to another system of representation, use one of the conversion
procedures.
@end defun


@defun set-time-nanosecond! @var{time} @var{integer}
Set the @emph{Nanosecond} component of @var{time} to @var{integer}.
@end defun


@defun set-time-second! time integer
Set the @emph{Second} component of @var{time} to @var{integer}.
@end defun


@defun copy-time @var{time}
Create a new time object, with the same @emph{Time type},
@emph{nanosecond}, and @emph{Second} as @var{time}.
@end defun



@c page
@node time spec timeobj compar
@subsection Time object comparison procedures


All of the time comparison procedures require the time objects to be of
the same type.  It is an error to use these procedures on time objects
of different types.  For the point--in--time measurements (e.g.
@code{time-tai} and @code{time-utc}), the semantics are described in
plain text.  For durations (e.g. @code{time-duration}, @code{time-cpu})
the semantics are described in parentheses.

The following procedures are required.


@defun time<=? @var{time1} @var{time2}
@true{} if @var{time1} is before or at (less than or equal to)
@var{time2}, @false{} otherwise.
@end defun


@defun time<? @var{time1} @var{time2}
@true{} if @var{time1} is before (less than) @var{time2}, @false{}
otherwise.
@end defun


@defun time=? @var{time1} @var{time2}
@true{} if @var{time1} at (equal) @var{time2}, @false{} otherwise.
@end defun


@defun time>=? @var{time1} @var{time2}
@true{} if @var{time1} is at or after (greater than or equal to)
@var{time2}, @false{} otherwise.
@end defun


@defun time>? @var{time1} @var{time2}
@true{} if @var{time1} is after (greater than) @var{time2}, @false{}
otherwise.
@end defun


@c page
@node time spec timeobj arithm
@subsection Time object arithmetic procedures


The following procedures are required.


@defun time-difference @var{time1} @var{time2}
Return the time duration between @var{time1} and @var{time2}.  It is an
error if @var{time1} and @var{time2} are of different time types.  A new
time object is created.
@end defun


@defun time-difference! @var{time1} @var{time2}
Return the time duration between @var{time1} and @var{time2}.  It is an
error if @var{time1} and @var{time2} are of different time types.
@var{time1} may be used to create the resulting @code{time-duration}
object.
@end defun


@defun add-duration @var{time1} @var{time-duration}
Return the time resulting from adding @var{time-duration} to
@var{time1}, which is a time object of the same time type as
@var{time1}.  A new time object is created.
@end defun


@defun add-duration! @var{time1} @var{time-duration}
Return the time resulting from adding @var{time-duration} to
@var{time1}, which is a time object of the same time type as
@var{time1}.  @var{time1} may used to create the resulting time object.
@end defun


@defun subtract-duration @var{time1} @var{time-duration}
Return the time resulting from subtracting @var{time-duration} to
@var{time1}, which is a time object of the same time type as
@var{time1}.  A new time object is created.
@end defun


@defun subtract-duration! @var{time1} @var{time-duration}
The time resulting from subtracting @var{time-duration} to @var{time1},
which is a time object of the same time type as @var{time1}.
@var{time1} may used to create the resulting time object.
@end defun


@c page
@node time spec dateobj
@subsection Date object and accessors


Date objects are immutable once created.  The following procedures are
required.


@defun make-date @var{nanosecond} @var{second} @var{minute} @var{hour} @var{day} @var{month} @var{year} @var{zone-offset}
Creates a date object.
@end defun


@defun date? @var{object}
Return @true{} if @var{object} is a @emph{Date} object; otherwise return
@false{}.
@end defun


@defun date-nanosecond @var{date}
Return the @emph{Nanosecond} component of @var{date}.
@end defun


@defun date-second @var{date}
Return the @emph{Second} component of @var{date}.
@end defun


@defun date-minute @var{date}
Return the @emph{Minute} component of @var{date}.
@end defun


@defun date-hour @var{date}
Return the @emph{Hour} component of @var{date}.
@end defun


@defun date-day @var{date}
Return the @emph{Date} component of @var{date}.
@end defun


@defun date-month @var{date}
Return the @emph{Month} component of @var{date}.
@end defun


@defun date-year @var{date}
Return the @emph{Year} component of @var{date}.
@end defun


@defun date-zone-offset @var{date}
Return the @emph{Time zone} component of @var{date}.
@end defun


@defun date-year-day @var{date}
Return the ordinal day of the year of this date.  January 1 is 1, etc.
@end defun


@defun date-week-day @var{date}
Return the day of the week of this date, where Sunday=0, Monday=1, etc.
@end defun


@defun date-week-number date day-of-week-starting-week
Return the ordinal week of the year which holds this date, ignoring a
first partial week.  @var{day-of-week-starting-week} is the integer
corresponding to the day of the week which is to be considered the first
day of the week (Sunday=0, Monday=1, etc.).
@end defun


@c page
@node time spec julian
@subsection Time/Date/Julian Day/Modified Julian Day Converters


The following conversion procedures are required.


@defun date->julian-day @var{date}
Convert date to @emph{Julian Day}.
@end defun


@defun date->modified-julian-day @var{date}
Convert date to @emph{Modified Julian Day}.
@end defun


@defun date->time-monotonic @var{date}
Convert date to monotonic time.
@end defun


@defun date->time-tai @var{date}
Convert date to @tai{} time.
@end defun


@defun date->time-utc @var{date}
Convert date to @utc{} time.
@end defun


@defun julian-day->date @var{jd} [@var{tz-offset}]
Convert a @emph{Julian Day} to a date, using a time zone offset, which
defaults to the local time zone.
@end defun


@defun julian-day->time-monotonic @var{jd}
Convert a @emph{Julian Day} to monotonic time.
@end defun


@defun julian-day->time-tai @var{jd}
Convert a @emph{Julian Day} to @tai{} time.
@end defun


@defun julian-day->time-utc @var{jd}
Convert a @emph{Julian Day} to @utc{} time.
@end defun


@defun modified-julian-day->date @var{mjd} [@var{tz-offset}]
Convert a @emph{Modified Julian Day} to adate, using a time zone offset,
which defaults to the local time zone.
@end defun


@defun modified-julian-day->time-monotonic @var{mjd}
Convert @emph{Modified Julian Day} to monotonic time.
@end defun


@defun modified-julian-day->time-tai @var{mjd}
Convert a @emph{Modified Julian Day} to @tai{} time.
@end defun


@defun modified-julian-day->time-utc @var{mjd}
Convert @emph{Modified Julian Day} to @utc{} time.
@end defun


@defun time-monotonic->date time-monotonic [@var{tz-offset}]
Convert monotonic time to date, using time zone offset, which defaults
to the local time zone.
@end defun


@defun time-monotonic->julian-day @var{time-monotonic}
Convert monotonic time to @emph{Julian Day}.
@end defun


@defun time-monotonic->modified-julian-day time-monotonic
Convert monotonic time to @emph{Modified Julian Day}.
@end defun


@defun time-monotonic->time-tai @var{time-monotonic}
Convert monotonic time to @tai{} time.
@end defun


@defun time-monotonic->time-tai! @var{time-monotonic}
Convert monotonic time to @tai{} time.  The @emph{Time} structure may be
reused.
@end defun


@defun time-monotonic->time-utc @var{time-monotonic}
Convert monotonic time to @utc{} time.
@end defun


@defun time-monotonic->time-utc! @var{time-monotonic}
Convert monotonic time to @utc{} time.  The @emph{Time} structure may be
reused.
@end defun


@defun time-tai->date @var{time-tai} [@var{tz-offset}]
Convert @tai{} time to date, using time zone offset, which defaults to
the local time zone.
@end defun


@defun time-tai->julian-day @var{time-tai}
Convert @tai{} time to @emph{Julian Day}.
@end defun


@defun time-tai->modified-julian-day @var{time-tai}
Convert @tai{} time to @emph{Modified Julian Day}.
@end defun


@defun time-tai->time-monotonic @var{time-tai}
Convert @tai{} time to monotonic time.
@end defun


@defun time-tai->time-monotonic! @var{time-tai}
Convert @tai{} time to monotonic time.  The @emph{Time} structure may be
reused.
@end defun


@defun time-tai->time-utc @var{time-tai}
Convert @tai{} time to monotonic time.
@end defun


@defun time-tai->time-utc! @var{time-tai}
Convert @tai{} time to monotonic time.  The @emph{time} structure may be
reused.
@end defun


@defun time-utc->date @var{time-utc} [@var{tz-offset}]
Convert @utc{} time to date, using time zone offset, which defaults to
the local time zone.
@end defun


@defun time-utc->julian-day @var{time-utc}
Convert @utc{} time to @emph{Julian Day}.
@end defun


@defun time-utc->modified-julian-day @var{time-utc}
Convert @utc{} time to @emph{Modified Julian Day}.
@end defun


@defun time-utc->time-monotonic @var{time-utc}
Convert @utc{} time to monotonic time.
@end defun


@defun time-utc->time-monotonic! @var{time-utc}
Convert @utc{} time to monotonic time.  The @emph{Time} structure may be
reused.
@end defun


@defun time-utc->time-tai @var{time-utc}
Convert @utc{} time to @tai{} time.
@end defun


@defun time-utc->time-tai! @var{time-utc}
Convert @utc{} time to @tai{} time.  The @emph{Time} structure may be
reused.
@end defun


@c page
@node time spec string
@subsection Date to string/string to date converters


The following procedures provide conversion to and from strings.  They
are required.  The specification below describes a ``locale''; the
specification of locales is beyond this @srfi{}.


@defun date->string @var{date} [@var{format-string}]
Converts a date to a string, using the format string.  The format string
is copied as is; except escape characters (indicated by the tilde) are
replaced with specfic conversions.  The following table lists the
required conversion specifiers; implementations are free to extend this
list.

@multitable {Escape Char} {scrappy dappy doo, scrappy dappy doo, scappy dappy}
@headitem Escape Char @tab Conversion
@item ~~ @tab a literal ~
@item ~a @tab locale's abbreviated weekday name (Sun...Sat)
@item ~A @tab locale's full weekday name (Sunday...Saturday)
@item ~b @tab locale's abbreviate month name (Jan...Dec)
@item ~B @tab locale's full month day (January...December)
@item ~c @tab locale's date and time (e.g., "Fri Jul 14 20:28:42-0400 2000")
@item ~d @tab day of month, zero padded (01...31)
@item ~D @tab date (mm/dd/yy)
@item ~e @tab day of month, blank padded ( 1...31)
@item ~f @tab seconds+fractional seconds, using locale's decimal separator (e.g. 5.2).
@item ~h @tab same as ~b
@item ~H @tab hour, zero padded, 24-hour clock (00...23)
@item ~I @tab hour, zero padded, 12-hour clock (01...12)
@item ~j @tab day of year, zero padded
@item ~k @tab hour, blank padded, 24-hour clock (00...23)
@item ~l @tab hour, blank padded, 12-hour clock (01...12)
@item ~m @tab month, zero padded (01...12)
@item ~M @tab minute, zero padded (00...59)
@item ~n @tab new line
@item ~N @tab nanosecond, zero padded
@item ~p @tab locale's AM or PM
@item ~r @tab time, 12 hour clock, same as "~I:~M:~S ~p"
@item ~s @tab number of full seconds since "the epoch" (in UTC)
@item ~S @tab second, zero padded (00...60)
@item ~t @tab horizontal tab
@item ~T @tab time, 24 hour clock, same as "~H:~M:~S"
@item ~U @tab week number of year with Sunday as first day of week (00...53)
@item ~V @tab week number of year with Monday as first day of week (01...52)
@item ~w @tab day of week (0...6)
@item ~W @tab week number of year with Monday as first day of week (01...52)
@item ~x @tab week number of year with Monday as first day of week (00...53)
@item ~X @tab locale's date representation, for example: "07/31/00"
@item ~y @tab last two digits of year (00...99)
@item ~Y @tab year
@item ~z @tab time zone in RFC-822 style
@item ~Z @tab symbol time zone (not--implemented)
@item ~1 @tab @iso{}--8601 year--month--day format
@item ~2 @tab @iso{}--8601 hour--minute--second-timezone format
@item ~3 @tab @iso{}--8601 hour--minute--second format
@item ~4 @tab @iso{}--8601 year--month--day--hour--minute--second--timezone format
@item ~5 @tab @iso{}--8601 year--month--day--hour--minute--second format
@end multitable
@end defun


@defun string->date @func{input-string} @func{template-string}
Converts an input string to a date, using the template string.  The
input string must match the template string as is; except escape
characters (preceded by a the tilde) indicate special converters which
(1) move to the next character in the input string fulfilling a
criterion; (2) read a value, and (3) act on this value in some way. The
table below lists the required converters; implementations are free to
extend this list.

@multitable {Escape} {char-alphabetic?} {Scrappy dappy doo, scrappy} {Scrappy dappy}
@headitem Escape @tab Skip to @tab Read @tab Contract
@item ~~ @tab any @tab read literal ~ @tab nothing
@item ~a @tab char-alphabetic? @tab abbreviated weekday in locale @tab nothing
@item ~A @tab char-alphabetic? @tab full weekday in locale @tab nothing
@item ~b @tab char-alphabetic? @tab abbreviated month name in locale @tab nothing
@item ~B @tab char-alphabetic? @tab full month name in locale @tab nothing
@item ~d @tab char-numeric? @tab day of month  @tab date--day
@item ~e @tab any @tab day of month, blank padded @tab date--day
@item ~h @tab char-alphabetic? @tab same as ~b @tab nothing
@item ~H @tab char-numeric? @tab hour @tab date--hour
@item ~k @tab any @tab hour, blank padded @tab date--hour
@item ~m @tab char-numeric? @tab month @tab date--month
@item ~M @tab char-numeric? @tab minute @tab date--minute
@item ~S @tab char-numeric? @tab second @tab date--second
@item ~y @tab any @tab 2--digit year @tab date--year within 50 years
@item ~Y @tab char-numeric? @tab year @tab date-year
@item ~z @tab any @tab time zone @tab date--zone--offset
@end multitable
@end defun

@c page
@node time ack
@section Acknowledgements


Claus Toendering's Frequently Asked Questions about calendars was a very
useful resource.  The implementation of Julian Day, Modified Julian Day,
and Year Day comes from his @acronym{FAQ}.  Markus Kuhn has a useful
description of the @iso{} Standard 8601 for Date/Time notation.  The W3
Consortium also has a useful Note.

Mike Sperber, Marc Feely, Dave Mason, and ``Prfnoff'' all made useful
comments on previous versions of this draft.  Thanks to Shriram
Krishnamurthi for his editing help.

The @func{date->string} procedure uses a format string, based on @gnu{}
C's @cfunc{date} procedure, as well as Scsh's @code{format-date}
procedure.


@c page
@node cut
@chapter Notation for specializing parameters without currying


@cindex @srfi{} cut


The @library{srfi cut} has been written by Sebastian Egner as the
reference implementation for @ansrfi{26}.


@menu
* cut license::                 Original license.
* cut abstract::                Abstract.
* cut rationale::               Rationale.
* cut spec::                    Specification.
* cut design::                  Rationale design.
* cut ack::                     Acknowledgements.
@end menu


@c page
@node cut license
@section Original license


Copyright @copyright{} 2002 Sebastian Egner.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node cut abstract
@section Abstract


When programming in functional style, it is frequently necessary to
specialize some of the parameters of a multi--parameter procedure.  For
example, from the binary operation @func{cons} one might want to obtain
the unary operation @code{(lambda (x) (cons 1 x))}.  This specialization
of parameters is also known as ``partial application'', ``operator
section'' or ``projection''.

The mechanism proposed here allows to write this sort of specialization
in a simple and compact way.  The mechanism is best explained by a few
examples:

@example
(cut cons (+ a 1) <>)   = (lambda (x2) (cons (+ a 1) x2))
(cut list 1 <> 3 <> 5)  = (lambda (x2 x4) (list 1 x2 3 x4 5))
(cut list)              = (lambda () (list))
(cut list 1 <> 3 <...>) = (lambda (x2 . xs) (apply list 1 x2 3 xs))
(cut <> a b)            = (lambda (f) (f a b))
@end example

As you see, the macro @func{cut} specializes some of the parameters of
its first argument.  The parameters that are to show up as formal
variables of the result are indicated by the symbol @code{<>}, pronouced
as ``slot''.  In addition, the symbol @code{<...>}, pronounced as
``rest--slot'', matches all residual arguments of a variable argument
procedure.  As you can see from the last example above, the first
argument can also be a slot, as one should expect in Scheme.

In addition to @func{cut}, there is a variant called @func{cute} (a
mnemonic for ``@func{cut} with evaluated non--slots'') which evaluates
the non--slot expressions at the time the procedure is specialized, not
at the time the specialized procedure is called.  For example:

@example
(cute cons (+ a 1) <>) = (let ([a1 (+ a 1)])
                           (lambda (x2)
                             (cons a1 x2)))
@end example

As you see from comparing this example with the first example above, the
@func{cute}--variant will evaluate @code{(+ a 1)} once, while the
@func{cut}--variant will evaluate it during every invocation of the
resulting procedure.

The mechanism proposed in this @srfi{} allows specializing any subset
of the variables of a procedure.  The result can be of fixed arity or of
variable arity.  The mechanism does not allow permutation, omission,
duplication or any other processing of the arguments; for this it is
necessary to write to use a different mechanism such as @func{lambda}.



@c page
@node cut rationale
@section Rationale


A particularly elegant way to deal with specialization is known as
currying (Schoenfinkel 1924, Curry 1958).  The idea of currying is to
reduce multi--argument functions to single--argument functions by
regarding an @var{n}--ary function as a unary function mapping its first
argument into an (@var{n-1})--ary function (which is curried in turn).
This point of view, apart from its theoretical elegance, allows an
extremely compact notation for specializing the first argument of a
function.  In the first example, one could simply write @code{(cons 1)}.

Yet, Scheme is not a curried language---the number of arguments passed
to a procedure must match the number of its parameters at all times.
This allows zero--arity and variable--arity procedures but in order to
specialize parameters one usually has to write down a lambda--expression
and invent some irrelevant identifiers for its formal variables (@var{x}
in the examples in the Abstract).  For this reason, the mechanism
proposed in this @srfi{} provides a simple and compact notation for
specializing any subset of the parameters of a procedure.

Note: @emph{The mechanism proposed here is not currying!}

The purpose of the mechanism proposed here is to make the benefits of
currying available within the programming language Scheme.  There are
two primary benefits of currying in practice: Higher--order types are
substantially simplified and there is a simple notation for specializing
parameters.  The type aspect is irrelevant as Scheme has latent typing.
The specialization aspect is largly covered with this @srfi{}.

Here are a few more examples for illustration:

@example
(map (cut * 2 <>) '(1 2 3 4))
(map (cut vector-set! x <> 0) indices)
(for-each (cut write <> port) exprs)
(map (cut <> x y z) (list min max))
(for-each (cut <>) thunks)
@end example



@c page
@node cut spec
@section Specification


@findex cut
@findex cute

The formal syntax of a specialized expression, in the style of the
Revised^5 Report on the Algorithmic Language Scheme:

@example
<cut-expression> -->  (cut  <slot-or-expr> <slot-or-expr>*)
                    | (cut  <slot-or-expr> <slot-or-expr>* <...>)
                    | (cute <slot-or-expr> <slot-or-expr>*)
                    | (cute <slot-or-expr> <slot-or-expr>* <...>)

<slot-or-expr>   -->  <>              ; a "slot"
                    | <expression>    ; a "non-slot expression"
@end example

The macro @func{cut} transforms a @code{<cut-expression>} into a
@code{<lambda expression>} with as many formal variables as there are
slots in the list @code{<slot-or-expr>*}.  The body of the resulting
@code{<lambda expression>} calls the first @code{<slot-or-expr>} with
arguments from @code{<slot-or-expr>*} in the order they appear.

In case there is a rest--slot symbol, the resulting procedure is also of
variable arity, and the body calls the first @code{<slot-or-expr>} with
all arguments provided to the actual call of the specialized procedure.

The macro @func{cute} is similar to the macro @func{cut}, except that it
first binds new variables to the result of evaluating the non--slot
expressions (in an unspecific order) and then substituting the variables
for the non--slot expressions.  In effect, @func{cut} evaluates
non--slot expressions at the time the resulting procedure is called,
whereas @func{cute} evaluates the non--slot expressions at the time the
procedure is constructed.



@c page
@node cut design
@section Rationale design


@subsubheading Why not real currying/uncurrying?

It is possible in Scheme to implement a macro turning a multi--argument
procedure into a nesting of single--argument procedures and back.  These
operations are usually called ``curry'' and ``uncurry'' in other
programming languages.

Yet, Scheme remains an inherently uncurried language and is not prepared
to deal with curried procedures in a convenient way.  Hence, a ``by the
book'' implementation of currying would only be useful if you apply it
in the sequence ``curry, specialize some arguments, and uncurry again'',
which is exactly the purpose of the macro @func{cut} specified in this
document.  The primary relevance of currying/uncurrying in Scheme is to
teach concepts of combinatory logic.

@c ------------------------------------------------------------

@subsubheading Why not a more general mechanism, also allowing permutation omission and duplication of arguments?

The reason is that I, the author of this @srfi{}, consider more general
mechanisms too dangerous to mix them with the mechanism proposed here.
In particular, as soon as parameters are being rearranged it is usually
necessary to be aware of the meaning of the parameters; unnamed
variables can be quite harmful then.  The mechanism proposed here is
designed to prevent this.

Please refer to the discussion threads ``OK, how about...,'' (Alan
Bawden), ``is that useful?'' (Walter C.  Pelissero), and ``l, the
ultimate curry that is not curry'' (Al Petrofsky).

@c ------------------------------------------------------------

@subsubheading Why are the macro called @func{cut}/@func{cute} and not [enter your favourite here]?

Well, the original name proposed for this @srfi{} was @func{curry}
which immediately stirred some emotions as it does not what is commonly
known as currying.  Some alternatives have been discussed, such as:

@example
section         specialise      specialize,
partial-apply   partial-call    partial-lambda,
_j              _i              $
&               srfi-26         foobar
xyz             schoenfinkelize curry-which-isnt-curry
tandoori
@end example

@noindent
and it has also been suggested to pick a five letter symbol uniformly at
random and fix this as a name.  To be fair, not all of these name have
been put forward as serious proposals, some of them were merely to
illustrate a point in the discussion.  In addition, I have played with
the game of the name quite a bit and considered other candidates not
listed here.

Despite the fact that the discussion list only represents a highly
biased random sample of people's opinion (motivation to post a message
is higher if you disagree, for example) it told me that the @srfi{}
could potentially benefit from a different name; however impractical it
may be to go for unanimous popularity.

The name @func{cut} refers to ``operator section'', as the concept is
often called in other programming languages, but I tend to remember it
as the acronym for ``Curry Upon This''. ;-) The names for the evaluating
version of @func{cut} that have been proposed were @func{cut!},
@func{cutlet}, @func{cut*}, and @func{cute}.

@c ------------------------------------------------------------

@subsubheading Is it possible to implement the @srfi{} without macros?

Not really.  As Stephan Houben has pointed out during the discussion
(refer to ``Implementing it as a procedure'') it is possible to
implement the @func{cute}--mechanism as a procedure.  Refer also to Al
Petrofsky's posting ``Problems with @emph{curry}'s formal
specification'' for details.

However, the procedural implementation comes with a slight performance
penalty and it is not possible the implement the @func{cut}--mechanism
as a procedure, too.

As both are needed, we rely on macros to implement the @srfi{}.  Why is
there another symbol for the rest--slot when @func{lambda}--expressions
use the dotted notation for variable length argument lists?  There are
two reasons.  The first one is the existence of a procedural
implementation of a related mechanism (refer to the previous paragraph).
For a procedure, however, it is not possible to have dotted notation.
The second reason is the way the hygienic macro mechanism in @rnrs{5} is
defined to deal with dotted notation, as Felix Winkelmann has pointed
out.  Refer to the discussion threads ``Improper lists in macros [WAS:
none]''.

@c ------------------------------------------------------------

@subsubheading Why is it impossible to specify when a non--slot is evaluate individually per non--slot?

@func{cut} evaluates all non--slots at the time the specialized
procedure is called and @func{cute} evaluates all non--slots at the time
the procedure is being specialized.  These are only the two extremes and
it is possible to define a syntax that allows to choose per non--slot.
However, I am convinced that the benefit of the greater flexibility is
not worth the risk of confusion.  If a piece of code really depends on
the distinction, it might be better to make this explicit through
@func{let} and @func{lambda}.

@c ------------------------------------------------------------

@subsubheading Why is @code{(cut if <> 0 1)} etc. illegal?

It is specified that a @code{<slot-or-expr>} must be either the slot
symbol or an @func{<expression>} in the sense of @rnrs{5}, Section
7.1.3.  As if is no @func{<expression>}, the above case is illegal.  The
reason why @func{cut} and @func{cute} are restricted in this sense is
the difficulty of defining the meaning of such generalized expressions.
Please refer to the discussion archive for details.


@c page
@node cut ack
@section Acknowledgements


An important part of this @srfi{} is based on the contribution of other
people, mostly through the discussion archive.  In particular, the
semantics and the design rationale have been greatly improved in the
course of the discussion.  I would like to thank all who have
contributed.


@c page
@node random
@chapter Sources of random bits


@cindex @srfi{} random


The @library{srfi random} library has been written by Sebastian Egner as
the reference implementation for @ansrfi{27}.


@menu
* random license::              Original license.
* random abstract::             Abstract.
* random rationale::            Rationale.
* random spec::                 Specification.
* random design::               Design rationale.
* random usage::                Recommended usage patterns.
* random ack::                  Acknowledgements.
* random references::           References.
@end menu


@c page
@node random license
@section Random document license


Copyright @copyright{} 2002 Sebastian Egner.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



@c page
@node random abstract
@section Abstract


This document specifies an interface to sources of random bits, or
``random sources'' for brevity.  In particular, there are three
different ways to use the interface, with varying demands on the quality
of the source and the amout of control over the production process:

@itemize
@item
The ``no fuss'' interface specifies that @code{(random-integer n)}
produces the next random integer in @code{@{0, ..., n-1@}} and
@func{(random-real)} produces the next random real number between zero
and one.  The details of how these random values are produced may not be
very relevant, as long as they appear to be sufficiently random.

@item
For simulation purposes, on the contrary, it is usually necessary to
know that the numbers are produced deterministically by a pseudo random
number generator of high quality and to have explicit access to its
state.  In addition, one might want to use several independent sources
of random numbers at the same time and it can be useful to have some
simple form of randomization.

@item
For security applications a serious form of true randomization is
essential, in the sense that it is difficult for an adversary to exploit
or introduce imperfections into the distribution of random bits.
Moreover, the linear complexity of the stream of random bits is more
important than its statistical properties.  In these applications, an
entropy source (producing truly random bits at a low rate) is used to
randomize a pseudo random number generator to increase the rate of
available bits.
@end itemize

Once random sources provide the infrastructure to obtain random bits,
these can be used to construct other random deviates.  Most important
are floating point numbers of various distributions and random discrete
structures, such as permutations or graphs.  As there is an essentially
unlimited number of such objects (with limited use elsewhere), we do not
include them in this @srfi{}.  In other words, this @srfi{} is not
about making all sorts of random objects; it is about obtaining random
bits in a portable, flexible, reliable, and efficient way.


@c page
@node random rationale
@section Rationale


This @srfi{} defines an interface for sources of random bits computed
by a pseudo random number generator.  The interface provides
range--limited integer and real numbers.  It allows accessing the state
of the underlying generator.  Moreover, it is possible to obtain a large
number of independent generators and to invoke a mild form of true
randomization.

The design aims at sufficient flexibility to cover the usage patterns of
many applications as diverse as discrete structures, numerical
simulations, and cryptographic protocols.  At the same time, the
interface aims at simplicity, which is important for occasional use.  As
there is no ``one size fits all'' random number generator, the design
necessarily represents some form of compromise between the needs of the
various applications.

Although strictly speaking not part of the specification, the emphasis
of this proposal is on high quality random numbers and on high
performance.  As the state of the art in pseudo random number generators
is still advancing considerably, the choice of method for the reference
implementation should essentially be considered preliminary.


@c page
@node random spec
@section Specification


@defun random-integer @var{n}
The next integer @var{x} in @code{@{0, ..., n-1@}} obtained from
@func{default--random--source}.  Subsequent results of this procedure
appear to be independent uniformly distributed over the range @code{@{0,
..., n-1@}}.  The argument @var{n} must be a positive integer, otherwise
an error is signalled.
@end defun


@defun random-real
The next number @code{0 < x < 1} obtained from
@func{default-random-source}.  Subsequent results of this procedure
appear to be independent uniformly distributed.  The numerical type of
the results and the quantization of the output range depend on the
implementation; refer to @func{random-source-make-reals} for details.
@end defun


@defvar default-random-source
A random source from which @func{random-integer} and @func{random-real}
have been derived using @func{random-source-make-integers} and
@func{random-source-make-reals}.

Note that an assignment to @func{default-random-source} does not change
the already built @func{random-integer} or @func{random-real}; it is
also strongly recommended not to assign a new value.
@end defvar


@defun make-random-source
Create a new random source @var{s}.  Implementations may accept
additional, optional arguments in order to create different types of
random sources.  A random source created with @func{make-random-source}
represents a deterministic stream of random bits generated by some form
of pseudo random number generator.  Each random source obtained as
@code{(make-random-source)} generates the same stream of values, unless
the state is modified with one of the procedures below.
@end defun


@defun random-source? @var{obj}
Tests if @var{obj} is a random source.  Objects of type random source
are distinct from all other types of objects.
@end defun


@defun random-source-state-ref @var{s}
@defunx random-source-state-set! @var{s} @var{state}
Get and set the current state of a random source @var{s}.  The structure
of the object state depends on the implementation; the only portable use
of it is as argument to @func{random-source-state-set!}.  It is,
however, required that a state possess an external representation.
@end defun


@defun random-source-randomize! @var{s}
Makes an effort to set the state of the random source s to a truly
random state.  The actual quality of this randomization depends on the
implementation but it can at least be assumed that the procedure sets s
to a different state for each subsequent run of the Scheme system.
@end defun


@defun random-source-pseudo-randomize! @var{s} @var{i} @var{j}
Changes the state of the random source @var{s} into the initial state of
the (@var{i}, @var{j})--th independent random source, where @var{i} and
@var{j} are non--negative integers.  This procedure provides a mechanism
to obtain a large number of independent random sources (usually all
derived from the same backbone generator), indexed by two integers.  In
contrast to @func{random-source-randomize!}, this procedure is entirely
deterministic.
@end defun


@defun random-source-make-integers @var{s}
Obtains a procedure @var{rand} to generate random integers using the
random source @var{s}.  @var{rand} takes a single argument @var{n},
which must be a positive integer, and returns the next uniformly
distributed random integer from the interval @code{@{0, ..., n-1@}} by
advancing the state of the source @var{s}.

If an application obtains and uses several generators for the same
random source @var{s}, a call to any of these generators advances the
state of @var{s}.  Hence, the generators do not produce the same
sequence of random integers each but rather share a state.  This also
holds for all other types of generators derived from a fixed random
source.  Implementations that support concurrency make sure that the
state of a generator is properly advanced.
@end defun


@defun random-source-make-reals @var{s}
@defunx random-source-make-reals @var{s} @var{unit}
Obtains a procedure @var{rand} to generate random real numbers @code{0 <
x < 1} using the random source @var{s}.  The procedure @var{rand} is
called without arguments.

The optional parameter @var{unit} determines the type of numbers being
produced by @var{rand} and the quantization of the output.  @var{unit}
must be a number such that @code{0 < unit < 1}.  The numbers created by
rand are of the same numerical type as unit and the potential output
values are spaced by at most @var{unit}.

One can imagine @var{rand} to create numbers as @code{x*unit} where
@var{x} is a random integer in @code{@{1, ..., floor(1/unit)-1@}}.
Note, however, that this need not be the way the values are actually
created and that the actual resolution of @var{rand} can be much higher
than @var{unit}.  In case @var{unit} is absent it defaults to a
reasonably small value (related to the width of the mantissa of an
efficient number format).
@end defun



@c page
@node random design
@section Design rationale


@subsubheading Why not combine @func{random-integer} and @func{random-real?}

The two procedures are not combined into a single variable--arity
procedures to save a little time and space during execution.  Although
some Scheme systems can deal with variable arity as efficiently as with
fixed arity this is not always the case and time efficiency is very
important here.

@c ------------------------------------------------------------

@subsubheading Why not some object--oriented interface?

There are many alternatives to the interface as specified in this
@srfi{}.  In particular, every framework for object--orientation can be
used to define a class for random sources and specify the interface for
the methods on random sources.  However, as the object--oriented
frameworks differ considerably in terms of syntax and functionality,
this @srfi{} does not make use of any particular framework.

@c ------------------------------------------------------------

@subsubheading Why is there not just a generator with a fixed range?

A bare fixed--range generator is of very limited use.  Nearly every
application has to add some functionality to make use of the random
numbers.  The most fundamental task in manipulating random numbers is to
change the range and quantization.  This is exactly what is provided by
@func{random-integer} and @func{random-real}.  In addition, is saves the
user from the pitfall of changing the range with a simple
modulo-computation which may substantially reduce the quality of the
numbers being produced.

The design of the interface is based on three prototype applications:

@itemize
@item
Repeatedly choose from relatively small sets: As the size of the set is
likely to vary from call to call, @func{random-integer} accepts a range
argument @var{n} in every call.  The implementation should try to avoid
boxing/unboxing of values if the ranges fit into immediate integers.

@item
Generate a few large integers with a fixed number of bits: As generating
the random number itself is expensive, passing the range argument in
every call does not hurt performance.  Hence, the same interface as in
the first application can be used.

@item
Generate real numbers: Unlike the choose--from--set case, the range and
the quantization is constant over a potentially very large number of
calls.  In addition, there are usually just a few distinct instances of
quantization and number type, most likely corresponding to underlying
@code{float} and @code{double} representations.  Therefore,
@func{random-real} does not accept any parameters but the procedure
@func{random-source-make-reals} creates a properly configured
@func{random-real} procedure.
@end itemize

@c ------------------------------------------------------------

@subsubheading Why bother about floating point numbers at all?

A proper floating point implementation of a random number generator is
potentially much more efficient that an integer implementation because
it can use more powerful arithmetics hardware.  If in addition the
application needs floating point random numbers it would be an
intolerable waste to run an integer generator to produce floating point
random numbers.  A secondary reason is to save the user from the ``not
as easy as it seems'' task of converting an integer generator into a
real generator.

@c ------------------------------------------------------------

@subsubheading Why are zero and one excluded from @func{random-real}?

The procedure @func{random-real} does not return @code{x = 0} or @code{x
= 1} in order to allow @code{(log x)} and @code{(log (- 1 x))} without
the danger of a numerical exception.

@c page
@node random usage
@section Recommended usage patterns


Unless the functionality defined in this @srfi{} is sufficient, an
application has to implement more procedures to construct other random
deviates.  This section contains some recommendation on how to do this
technically by presenting examples of increasing difficulty with respect
to the interface.  Note that the code below is not part of the
specification, it is merely meant to illustrate the spirit

@c ------------------------------------------------------------

@subsubheading Generating Random Permutations

The following code defines procedures to generate random permutations of
the set @code{@{0, ..., n-1@}}.  Such a permutation is represented by a
vector of length @var{n} for the images of the points.

Observe that the implementation first defines the procedure
@func{random-source-make-permutations} to turn a random source @var{s}
into a procedure to generate permutations of given degree @var{n}.  In a
second step, this is applied to the default source to define a
ready--to--use procedure for permutations: @code{(random-permutation n)}
constructs a random permutation of degree @var{n}.

@example
(define (random-source-make-permutations s)
  (let ([rand (random-source-make-integers s)])
    (lambda (n)
      (let ([x (make-vector n 0)])
        (do ([i 0 (+ i 1)])
            ([= i n])
          (vector-set! x i i))
        (do ([k n (- k 1)])
            ([= k 1] x)
          (let* ([i (- k 1)]
                 [j (rand k)]
                 [xi (vector-ref x i)]
                 [xj (vector-ref x j)])
            (vector-set! x i xj)
            (vector-set! x j xi)))))))

(define random-permutation
  (random-source-make-permutations default-random-source))
@end example

For the algorithm refer to Knuth's ``The Art of Computer Programming'',
Vol. II, 2nd ed., Algorithm P of Section 3.4.2.

@c ------------------------------------------------------------

@subsubheading Generating Exponentially-Distributed Random Numbers

The following code defines procedures to generate exponentially
Exp(mu)--distributed random numbers.  The technical difficulty of the
interface addressed here is how to pass optional arguments to
@func{random-source-make-reals}.

@example
(define (random-source-make-exponentials s . unit)
  (let ((rand (apply random-source-make-reals s unit)))
    (lambda (mu)
      (- (* mu (log (rand)))))))

(define random-exponential
  (random-source-make-exponentials default-random-source))
@end example

The algorithm is folklore.  Refer to Knuth's ``The Art of Computer
Programming'', Vol. II, 2nd ed., Section 3.4.1.D.

@c ------------------------------------------------------------

@subsubheading Generating Normally-Distributed Random Numbers

The following code defines procedures to generate normal N(mu,
sigma)--distributed real numbers using the polar method.

The technical difficulty of the interface addressed here is that the
polar method generates two results per computation.  We return one of
the result and store the second one to be returned by the next call to
the procedure.  Note that this implies that
@func{random-source-state-set!} (and the other procedures modifying the
state) does not necessarily affect the output of @func{random-normal}
immediately!

@example
(define (random-source-make-normals s . unit)
  (let ([rand (apply random-source-make-reals s unit)]
        [next #f])
    (lambda (mu sigma)
      (if next
          (let ([result next])
            (set! next #f)
            (+ mu (* sigma result)))
        (let loop ()
          (let* ([v1 (- (* 2 (rand)) 1)]
                 [v2 (- (* 2 (rand)) 1)]
                 [s (+ (* v1 v1) (* v2 v2))])
            (if (>= s 1)
                (loop)
              (let ([scale (sqrt (/ (* -2 (log s)) s))])
                (set! next (* scale v2))
                (+ mu (* sigma scale v1))))))))))

(define random-normal
  (random-source-make-normals default-random-source))
@end example

For the algorithm refer to Knuth's ``The Art of Computer Programming'',
Vol. II, 2nd ed., Algorithm P of Section 3.4.1.C.


@c page
@node random ack
@section Acknowledgements


I would like to thank all people who have participated in the
discussion, in particular Brad Lucier and Pierre l'Ecuyer.  Their
contributions have greatly improved the design of this @srfi{}.
Moreover, Brad has optimized the Gambit implementation quite
substantially.

@c page
@node random references
@section References


@emph{Diehard----Testsuite for Random Number Generators}.  G. Marsaglia.
Also contains some generators that do pass Diehard.

@center @url{stat.fsu.edu/~geo/diehard.html}

@noindent
@emph{The Art of Computer Programming; Volume II Seminumerical
Algorithms. 2nd ed.}  D. E. Knuth. Addison-Wesley, 1981.  The famous
chapter on random number generators.

@noindent
@emph{Software for Uniform Random Number Generation: Distinguishing the
Good and the Bad}.  P. L'Ecuyer.  Proceedings of the 2001 Winter
Simulation Conference, @acronym{IEEE} Press, Dec. 2001, 95--105.
Profound discussion of random number generators.

@center @url{www.iro.umontreal.ca/~lecuyer/myftp/papers/wsc01rng.pdf}

@noindent
@emph{Good Parameter Sets for Combined Multiple Recursive Random Number
Generators}.  P. L'Ecuyer.  Shorter version in Operations Research, 47,
1 (1999), 159--164.  Actual numbers for good generators.

@center @url{www.iro.umontreal.ca/~lecuyer/myftp/papers/combmrg2.ps}

@noindent
@emph{@acronym{MIT} Scheme v7.6}.  A mechanism to run a fixed
unspecified generator.

@center @url{http://www.swiss.ai.mit.edu/projects/scheme/documentation/scheme_5.html#SEC53}

@noindent
@emph{SLIB 2d2 with @code{(require 'random)}}.  A. Jaffer.

@center @url{http://swiss.csail.mit.edu/~jaffer/slib_5.html#SEC108}

@noindent
@emph{Scheme 48 v0.57}.  R. Kelsey, J. Rees.  Internal procedures of
Scheme48; a fixed 28-bit generator.

@noindent
@emph{@acronym{PLT} MzScheme Version 200alpha1}.  M. Flatt.  A mechanism
to run a generator and to exchange the generator.

@center @url{http://download.plt-scheme.org/doc/200alpha1/html/mzscheme/mzscheme-Z-H-3.html#%_idx_144}

@noindent
@emph{Structure and Interpretation of Computer Programs}.  H. Abelson,
G. J. Sussmann, J. Sussman.  The rand--example shows a textbook way to
define a random number generator.

@center @url{http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-20.html#%_idx_2934}

@noindent
@emph{A portable random-number generator}.  John David Stone.  An
implementation of a linear congruental generator in Scheme.

@center @url{http://www.math.grin.edu/~stone/events/scheme-workshop/random.html}

@noindent
@emph{RFC1750: Randomness Recommendations for Security}. Network Working
Group.  A serious discussion of serious randomness for serious security.

@center @url{http://www.cis.ohio-state.edu/htbin/rfc/rfc1750.html}

@noindent
Resources on random number generators and randomness:

@center @url{http://www.random.org/essay.html}
@center @url{http://www.taygeta.com/random/randrefs.html}



@c page
@node rec
@chapter A special form @func{rec} for recursive evaluation


@cindex @srfi{} rec


The @library{srfi rec} library has been written by Mirko Luedde
@email{Mirko.Luedde@@SAP.com} as the reference implementation for
@ansrfi{31}.


@menu
* rec license::                 Original license.
* rec abstract::                Abstract.
* rec rationale::               Rationale.
* rec spec::                    Specification.
* rec ack::                     Acknowledgements.
* rec references::              References.
@end menu

@c page
@node rec license
@section Original license


Copyright @copyright{} 2002 Dr. Mirko Luedde.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



@c page
@node rec abstract
@section Abstract


We propose the implementation of a special form called @func{rec}.  This
form is a generalization and combination of the forms @func{rec} and
@func{named-lambda} of [Clinger1985].  It allows the simple and
non--imperative construction of self--referential expressions.

As an important special case, it extends the A. Church form
@func{lambda} such that it allows the direct definition of recursive
procedures without using further special forms like @func{let} or
@func{letrec}, without using advanced constructions like the H. B. Curry
combinator and, unlike @func{define}, without introducing variable
bindings into the external environment.



@c page
@node rec rationale
@section Rationale


@subheading General


Among the prominent features of the Scheme programming language as
defined in [KCR1998] are the following:

@itemize
@item
it has simple syntax;

@item
it encourages recursive definitions, e.g. by ensuring memory efficient
tail recursion;

@item
it supports non--imperative programming.
@end itemize

Nevertheless Scheme does not provide a syntax for recursive evaluations
with the properties of:

@itemize
@item
being as simple, intuitive and close to the mathematical standard
notation as possible;

@item
allowing general recursion;

@item
being non--imperative.
@end itemize

@c ------------------------------------------------------------

@subheading Example

@subsubheading Problem 1

Let us look at the factorial function.  In mathematical notation this
function is expressed as:

@example
(F : N |--> 1,            if N = 0;
            N * F(N - 1), otherwise
@end example

This expression is a term and not a definition or proposition.

We investigate some approaches to express the factorial function in
Scheme.

@itemize
@item
The simplest way perhaps is as:

@example
(define (F N)
  (if (zero? N)
      1
    (* N (F (- N 1)))))
@end example

But this expression is not a term.  It binds the factorial function to
the variable @var{f}.  The expression itself may not occur in a
syntactical context where a name of the factorial is required.

@item
We list several ways to express the factorial as a function term.

@enumerate
@item
@example
(let ()
  (define (F N)
    (if (zero? N)
        1
      (* N (F (- N 1)))))
      F)
@end example

@item
@example
(lambda (N)
  (let F ([N N])
    (if (zero? N)
        1
      (* N (F (- N 1))))))
@end example

@item
@example
(letrec ([F (lambda (N)
              (if (zero? N)
                  1
                (* N (F (- N 1)))))])
  F)
@end example

@item
@example
((lambda (F)
   (F F))
 (lambda (G)
   (lambda (N)
     (if (zero? N)
         1
       (* N ((G G) (- N 1)))))))
@end example
@end enumerate

All these expressions define the factorial anonymously, not binding it
to a variable.  However, all these expressions are more verbose than it
seems necessary and they are less intuitive than it seems desirable.
@end itemize

@c ------------------------------------------------------------

@subsubheading Solution 1

A solution to our problem was already provided in [Clinger1985] by the
form @func{named-lambda}.  An even earlier solution with a slightly
different syntax was implemented in Kent Dybvig's Chez Scheme system.
Using this special form, we can denote the factorial simply by:

@example
(named-lambda (F N)
  (if (zero? N)
      1
    (* N (F (- N 1)))))
@end example

This expression is a function term that denotes the factorial in the
appropriate brevity.

However, the form @func{named-lambda} has been dropped from later
versions of the Scheme Report.  Also it is missing in
state--of--the--art implementations such as Chez Scheme (6.0a) and
@acronym{MIT} Scheme (7.7.0).  (The latter actually knows a form
@func{named-lambda} with different semantics.)

@c ------------------------------------------------------------

@subsubheading Problem 2

The constant stream of ones can be defined via:

@example
(define S (cons 1 (delay S)))
@end example

As in the case of the factorial, we are able to define the recursive
object at the price of spending an externally bound name.  Remedying
this with let or letrec leads to similar objections as above.

@subsubheading Solution 2

@noindent
This particular case of the self--referential problem was solved by the
@func{rec} form in [Clinger1985].  This form allows writing:

@example
(rec S (cons 1 (delay S)))
@end example

This expression is non--imperative and does not introduce an external
variable binding.

Also this form has been dropped from later versions of the Scheme
Report.  Moreover, from our point of view this form alone is not capable
of solving Problem 1.  The respective definition would look like:

@example
(rec F
  (lambda (N)
    (if (zero? N)
        1
      (* N (F (- N 1))))))
@end example

This again does not seem quite as simple and intuitive as the
mathematical notation.

@c ------------------------------------------------------------

@subheading Proposal

We therefore propose to implement the @func{rec} special form in a
generalized way that combines the advantages of the @func{named-lambda}
and @func{rec} forms.  The factorial function could be written:

@example
(rec (F N)
  (if (zero? N)
      1
    (* N (F (- N 1)))))
@end example


@c page
@node rec spec
@section Specification


@findex rec


@subsubheading Syntax

The following production rules are to be added to those of [KCR1998] (we
reuse names of non--terminals).

@example
<derived expression> --> <rec expression>
<rec expression>     --> (rec <variable>    <expression>)
<rec expression>     --> (rec (<variable>+) <body>)
@end example

@c ------------------------------------------------------------

@subsubheading Semantics

Scheme versions such as [KCR1998] providing @func{define-syntax},
@func{syntax-rules}, @func{letrec} and @func{lambda} might implement
@func{rec} as follows.

@example
(define-syntax rec
  (syntax-rules ()
    [(rec (NAME . VARIABLES) . BODY)
     (letrec ( (NAME (lambda VARIABLES . BODY)) ) NAME)]
    [(rec NAME EXPRESSION)
     (letrec ( (NAME EXPRESSION) ) NAME)]))
@end example

@c ------------------------------------------------------------

@subsubheading Test

The following session shows in which way @func{rec} allows a
tail--recursive implementation of the factorial function.

@example
> (define F (rec (F N)
                ((rec (G K L)
                   (if (zero? K) L
                     (G (- K 1) (* K L)))) N 1)))
> F
#<procedure>
> (F 0)
1
> (F 10)
3628800
@end example


@c page
@node rec ack
@section Acknowledgements


The author thanks Al Petrofsky for the final solution and Hal Abelson,
Chris Hanson and others for their input.  The work of the maintainers of
the @srfi{} forum is highly appreciated.


@c page
@node rec references
@section References


[Clinger1985] @emph{Draft of Report of the October 1984 Workshop on
Scheme}.  W. Clinger.  Proceedings Brandeis Workshop Oct. 22--23, 1984.
March, 1985.

@center @url{http://www.swiss.ai.mit.edu/ftpdir/scheme-mail/HTML/rrrs-1985}

@noindent
[KCR1998] @emph{Revised^5 Report on the Algorithmic Language Scheme}.
R. Kelsey, W. Clinger, J. Rees.  Higher--Order and Symbolic Computation,
volume 11, number 1, September 1998.


@c page
@node args-fold
@chapter A program argument processor


@cindex @srfi{} args-fold


The @library{srfi args-fold} has been written by Anthony Carrico as the
reference implementation for @ansrfi{37}.

@menu
* args-fold license::           Original license.
* args-fold abstract::          Abstract.
* args-fold rationale::         Rationale.
* args-fold spec::              Specification.
@end menu


@c page
@node args-fold license
@section Original license


Copyright @copyright{} 2002 Anthony Carrico (2002).  All Rights
Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node args-fold abstract
@section Abstract


Many operating systems make the set of argument strings used to invoke a
program available (often following the program name string in an array
called @code{argv}).  Most programs need to parse and process these
argument strings in one way or another.  This @srfi{} describes a set
of procedures that support processing program arguments according to
@posix{} and @gnu{} C Library Reference Manual guidelines.


@c page
@node args-fold rationale
@section Rationale


Program arguments are the primary interface to many programs, so
processing arguments is a common programming task.  There are many common
(often conflicting) ways take care of this task, so a custom processor
is often necessary; however, many programmers (and their users) would
welcome a convenient interface supporting common guidelines.

@posix{} provides several guidelines for the specification of program
options, option--arguments, and operands.  It also notes historical
exceptions to these guidelines.  The @gnu{} C Library Reference Manual
describes long option extensions to the @posix{} guidelines.

This @srfi{} supports creating programs following the guidelines
mentioned above by:

@itemize
@item
parsing short--options and long--options in any order and possibly
repeated;

@item
option-arguments (possibly required or forbidden);

@item
operands (non-option argument strings);

@item
recognizing option processing termination.
@end itemize

It parses argument strings according to the following rules:

@enumerate
@item
each short--option name is a single character;

@item
one or more short--options are accepted in a single argument string when
grouped behind one @code{-} delimiter character; examples: @code{-a},
@code{-bcd};

@item
a short--option--argument is accepted in a separate argument string
immediately following a short--option; examples: @code{-a foo},
@code{-bcd bar};

@item
also (for historical reasons) a short--option--argument is accepted
immediately following the last short--option in a single argument
string; examples: @code{-afoo}, @code{-bcdbar};

@item
each long--option name is one or more characters;

@item
one long--option is accepted in a single argument string when preceded
by two @code{-} delimiter characters; example: @code{--help};

@item
in a single argument string, a long--option followed by one @code{=}
delimiter character followed by a long--option--argument is accepted;
example: @code{--speed=fast};

@item
the first @code{--} argument string is accepted as a delimiter
indicating the end of options; it is not treated as an option or an
operand; any argument strings following this delimiter are treated as
operands, even if they begin with the @code{-} character;

@item
all other argument strings are treated as operands; this includes
argument strings consisting of a single - character;

@item
operands may be intermingled with options in any order.
@end enumerate

Preliminary versions of this interface are already available for some
Scheme implementations: here for Chicken, and here for Scsh.



@c page
@node args-fold spec
@section Specification


@findex args-fold


@func{args-fold} is an iterator similar to @ansrfi{1} fold procedure
(``the fundamental list iterator'').  As it parses options and operands,
it calls their corresponding operand and option processors.  Unlike
mapping, folding passes state, called seeds, from one processor to the
next.

For example, a program may need a list of operands and a table of
options.  To build these, @func{args-fold} could be seeded with an empty
operand list, and an empty option table.  The operand processor could
add the operands to the operand list, and the option processors could
add the options to the option table.  Along the way, some option
processors might even take immediate action for options like
@code{--version} or @code{--help}.  This kind of heterogeneous
processing is appropriate for program arguments, and folding allows a
functional implementation if desired.


@deffn {Procedure Prototype} option-processor @var{option} @var{name} @var{arg} @var{seeds} ...
Prototype for an option--processor.  It should return the next seeds as
values.  @var{option} will be the option.  @var{name} will be one of the
@var{OPTION}'s option--names as encountered by @func{args-fold}.
@var{arg} will be a string, or @false{} if @func{args-fold} didn't
encounter an option--argument.
@end deffn


@deffn {Procedure Prototype} operand-processor @var{operand} @var{seeds}
Prototype for an operand--processor.  It should return the next seeds as
values.  @var{operand} will be a string.
@end deffn


@defun option @var{names} @var{required-arg?} @var{optional-arg?} @var{option-proc}
Return an option.  @var{names} is a list of short (character) and long
(string) option names.  @var{required-arg?} specifies if this options
requires an option--argument (boolean).  @var{optional-arg?} specifies
if this option can accept an option--argument (boolean).
@var{option-proc} is a procedure (following the option--processor
prototype) used to process this option.
@end defun


@defun option-names @var{option}
@defunx option-required-arg? @var{option}
@defunx option-optional-arg? @var{option}
@defunx option-processor @var{option}
Return the contents of corresponding fields of @var{option}.
@end defun


@defun args-fold @var{args} @var{options} @var{unrecognized-option-proc} @var{operand-proc} @var{seeds} ...
Parse argument strings left--to--right, calling the appropriate
processors in--order (for the parsed known options, unknown options, and
operands), passing the seed values from one processor to the next and
returning the final seeds values as results.

@var{args} is a list of strings.  @var{options} is a list of options.
@var{unrecognized-option-proc} is a procedure (following the
@code{option-processor} prototype) for unrecognized options.
@func{operand-proc} is a procedure (following the
@code{operand-processor} prototype) for operands.

@emph{Note:} @func{args-fold} will create temporary options as necessary
for the @func{unrecognized-option-proc}.
@end defun



@c page
@node parameters
@chapter Parameter objects


@cindex @srfi{} parameters


The @library{srfi parameters} library has been written by Marc Feeley as
the reference implementation for @ansrfi{39}.


@menu
* parameters license::          Document license.
* parameters abstract::         Abstract.
* parameters rationale::        Rationale.
* parameters spec::             Specification.
@end menu


@c page
@node parameters license
@section Original license


Copyright @copyright{} 2002 Marc Feeley.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node parameters abstract
@section Abstract


This @srfi{} defines parameter objects, the procedure
@func{make-parameter} to create parameter objects and the
@func{parameterize} special form to dynamically bind parameter objects.

In the dynamic environment, each parameter object is bound to a cell
containing the value of the parameter.  When a procedure is called the
called procedure inherits the dynamic environment from the caller.  The
@func{parameterize} special form allows the binding of a parameter
object to be changed for the dynamic extent of its body.


@c page
@node parameters rationale
@section Rationale


The @emph{dynamic environment} is the structure which allows the system
to find the value returned by the @rnrs{5} procedures
@func{current-input-port} and @func{current-output-port}.  The @rnrs{5}
procedures @func{with-input-from-file} and @func{with-output-to-file}
extend the dynamic environment to produce a new dynamic environment
which is in effect for the dynamic extent of the call to the thunk
passed as their last argument.

These procedures are essentially special purpose dynamic binding
operations on hidden dynamic variables (one for
@func{current-input-port} and one for @func{current-output-port}).  The
purpose of this @srfi{} is to generalize this dynamic binding mechanism
(which exists in all @rnrs{5} compliant systems) to allow the user to
introduce new dynamic variables and dynamically bind them.

General dynamic binding mechanisms exist in several implementations of
Scheme under various names, including ``fluid'' variables and parameter
objects.  The parameter objects specified in this @srfi{} are
compatible with the semantics of all implementations of Scheme we know
which currently support parameter objects (in the sense that it is
possible to implement this @srfi{} so that old code works the same as
before).  We believe Chez--Scheme was the first implementation of Scheme
to have used parameter objects.

In the presence of threads, the dynamic binding mechanism does not
behave the same way in all implementations of Scheme supporting dynamic
binding.  The issue is the relationship between the dynamic environments
of the parent and child threads when a thread is created.  In Scheme 48
the child gets a fresh dynamic environment where (typically but not
necessarily) all the bindings are to their initial value.

In MzScheme and Gambit--C the child is given a dynamic environment
inherited from the parent.  In this inherited dynamic environment the
dynamic variables have the same values as the parent's dynamic
environment.  However, in MzScheme the cells bound to the dynamic
variables in the child are distinct from those of the parent (i.e. an
assignment of a value to a dynamic variable is not visible in the other
thread).  In Gambit--C the child and parent dynamic environment share
the same cells (i.e. an assignment of a value to a dynamic variable is
visible in the other thread).  Note that in the absence of assignment to
dynamic variables the MzScheme and Gambit--C approaches are equivalent.

Given that there are semantic differences in the presence of threads and
that there are valid reasons for choosing each semantics, this @srfi{}
does not specify the semantics of parameter objects in the presence of
threads.  It is left to the implementation and other @srfi{}s which
extend this @srfi{} to specify the interaction between parameter
objects and threads.



@c page
@node parameters spec
@section Specification


The @emph{dynamic environment} is composed of two parts: the @emph{local
dynamic environment} and the @emph{global dynamic environment}.  The
global dynamic environment is used to lookup parameter objects that
can't be found in the local dynamic environment.  When parameter objects
are created, their initial binding is put in the global dynamic
environment (by mutation).  The local dynamic environment is only
extended by the @func{parameterize} form.

@emph{Parameter objects} are created with the @func{make-parameter}
procedure which takes one or two arguments.  The second argument is a
one argument conversion procedure.  If only one argument is passed to
@func{make-parameter} the identity function is used as a conversion
procedure.  The global dynamic environment is updated to associate the
parameter object to a new cell.  The initial content of the cell is the
result of applying the conversion procedure to the first argument of
@func{make-parameter}.

A @emph{parameter object} is a procedure which accepts zero or one
argument.  The cell bound to a particular parameter object in the
dynamic environment is accessed by calling the parameter object.  When
no argument is passed, the content of the cell is returned.  When one
argument is passed the content of the cell is updated with the result of
applying the parameter object's conversion procedure to the argument.

The @func{parameterize} special form, when given a parameter object and
a value, binds for the dynamic extent of its body the parameter object
to a new cell.  The initial content of the cell is the result of
applying the parameter object's conversion procedure to the value.  The
parameterize special form behaves analogously to let when binding more
than one parameter object (that is the order of evaluation is
unspecified and the new bindings are only visible in the body of the
parameterize special form).

Note that the conversion procedure can be used for guaranteeing the type
of the parameter object's binding and/or to perform some conversion of
the value.

Because it is possible to implement the @rnrs{5} procedures
@func{current-input-port} and @func{current-output-port} as parameter
objects and this offers added functionnality, it is required by this
@srfi{} that they be implemented as parameter objects created with
@func{make-parameter}.


@defun make-parameter @var{init} [@var{converter}]
Returns a new parameter object which is bound in the global dynamic
environment to a cell containing the value returned by the call
@code{(converter init)}.  If the conversion procedure converter is not
specified the identity function is used instead.

The parameter object is a procedure which accepts zero or one argument.
When it is called with no argument, the content of the cell bound to
this parameter object in the current dynamic environment is returned.
When it is called with one argument, the content of the cell bound to
this parameter object in the current dynamic environment is set to the
result of the call @code{(converter arg)}, where @var{arg} is the
argument passed to the parameter object, and an unspecified value is
returned.

@example
(define radix
  (make-parameter 10))

(define write-shared
  (make-parameter #f
    (lambda (x)
      (if (boolean? x)
          x
        (error "only booleans are accepted by write-shared")))))

(radix)           =>  10
(radix 2)
(radix)           =>  2
(write-shared 0)  gives an error

(define prompt
  (make-parameter 123
    (lambda (x)
      (if (string? x)
          x
        (with-output-to-string (lambda () (write x)))))))

(prompt)       =>  "123"
(prompt ">")
(prompt)       =>  ">"
@end example
@end defun


@deffn Syntax parameterize ((@var{expr1} @var{expr2}) ...) @var{body})
The expressions @var{expr1} and @var{expr2} are evaluated in an
unspecified order.  The value of the @var{expr1} expressions must be
parameter objects.  For each @var{expr1} expression and in an
unspecified order, the local dynamic environment is extended with a
binding of the parameter object @var{expr1} to a new cell whose content
is the result of the call @code{(converter val)}, where @var{val} is the
value of @var{expr2} and @var{converter} is the conversion procedure of
the parameter object.

The resulting dynamic environment is then used for the evaluation of
@var{body} (which refers to the @rnrs{5} grammar nonterminal of that
name).  The result(s) of the parameterize form are the result(s) of the
@var{body}.

With reference to thte example above:

@example
(radix)
=>  2

(parameterize ([radix 16])
  (radix))
=>  16

(radix)
=>  2

(define (f n)
  (number->string n (radix)))

(f 10)
=>  "1010"

(parameterize ([radix 8])
  (f 10))
=>  "12"

(parameterize ([radix 8]
               [prompt (f 10)])
  (prompt))
=>  "1010"
@end example
@end deffn



@c page
@node streams
@chapter Streams


@cindex @srfi{} streams

The following libraries:

@example
(srfi streams)
(srfi streams primitive)
(srfi streams derived)
@end example

@noindent
are written by Philip L. Bewig as the reference implementation for
@ansrfi{41}.


@menu
* streams license::             Streams document license.
* streams abstract::            Abstract.
* streams rationale::           Rationale.
* streams primitive::           The @library{streams primitive} library.
* streams primitive example::   Streams primitive library example.
* streams derived::             The @library{streams derived} library.
* streams utilities::           Utilities.
* streams examples::            Examples.
* streams ack::                 Acknowledgments.
* streams references::          References.
@end menu


@c page
@node streams license
@section Streams document license


Copyright @copyright{} 2007, 2008 by Philip L. Bewig.  All Rights
Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



@c page
@node streams abstract
@section Abstract


@cindex @srfi{} streams abstract


Streams, sometimes called lazy lists, are a sequential data structure
containing elements computed only on demand.  A stream is either null or
is a pair with a stream in its cdr.  Since elements of a stream are
computed only when accessed, streams can be infinite.  Once computed, the
value of a stream element is cached in case it is needed again.

Streams without memoization were first described by Peter Landin in
1965.  Memoization became accepted as an essential feature of streams
about a decade later.  Today, streams are the signature data type of
functional programming languages such as Haskell.

This Scheme Request for Implementation describes two libraries for
operating on streams: a canonical set of stream primitives and a set of
procedures and syntax derived from those primitives that permits
convenient expression of stream operations.  They rely on facilities
provided by @rnrs{6}, including libraries, records, and error reporting.



@c page
@node streams rationale
@section Rationale


@cindex @srfi{} streams rationale


Harold Abelson and Gerald Jay Sussman discuss streams at length, giving
a strong justification for their use.  The streams they provide are
represented as a cons pair with a promise to return a stream in its cdr;
for instance, a stream with elements the first three counting numbers is
represented conceptually as:

@example
(cons 1 (delay (cons 2 (delay (cons 3 (delay '()))))))
@end example

Philip Wadler, Walid Taha and David MacQueen describe such streams as
odd because, regardless of their length, the parity of the number of
constructors (@func{delay}, @func{cons}, @code{(quote ())}) in the
stream is odd.

The streams provided here differ from those of Abelson and Sussman,
being represented as promises that contain a cons pair with a stream in
its cdr; for instance, the stream with elements the first three counting
numbers is represented conceptually as:

@example
(delay (cons 1 (delay (cons 2 (delay (cons 3 (delay '())))))))
@end example

@noindent
this is an even stream because the parity of the number of constructors
in the stream is even.

Even streams are more complex than odd streams in both definition and
usage, but they offer a strong benefit: they fix the off--by--one error
of odd streams.  Wadler, Taha and MacQueen show, for instance, that an
expression like:

@example
(stream->list 4 (stream-map / (stream-from 4 -1)))
@end example

@noindent
evaluates to @code{(1/4 1/3 1/2 1)} using even streams but fails with a
divide--by--zero error using odd streams, because the next element in
the stream, which will be 1/0, is evaluated before it is accessed.  This
extra bit of laziness is not just an interesting oddity; it is vitally
critical in many circumstances, as will become apparent below.

When used effectively, the primary benefit of streams is improved
modularity.  Consider a process that takes a sequence of items,
operating on each in turn.  If the operation is complex, it may be
useful to split it into two or more procedures in which the
partially--processed sequence is an intermediate result.  If that
sequence is stored as a list, the entire intermediate result must reside
in memory all at once; however, if the intermediate result is stored as
a stream, it can be generated piecemeal, using only as much memory as
required by a single item.  This leads to a programming style that uses
many small operators, each operating on the sequence of items as a
whole, similar to a pipeline of unix commands.

In addition to improved modularity, streams permit a clear exposition of
backtracking algorithms using the ``stream of successes'' technique, and
they can be used to model generators and co--routines.  The implicit
memoization of streams makes them useful for building persistent data
structures, and the laziness of streams permits some multi--pass
algorithms to be executed in a single pass.  Savvy programmers use
streams to enhance their programs in countless ways.

There is an obvious space/time trade--off between lists and streams;
lists take more space, but streams take more time (to see why, look at
all the type conversions in the implementation of the stream
primitives).  Streams are appropriate when the sequence is truly
infinite, when the space savings are needed, or when they offer a
clearer exposition of the algorithms that operate on the sequence.



@c page
@node streams primitive
@section The @library{streams primitive} library


@cindex @srfi{} streams primitive library


The @library{streams primitive} library provides two mutually--recursive
abstract data types: An object of the @code{stream} abstract data type
is a promise that, when forced, is either @code{stream-null} or is an
object of type @code{stream-pair}.  An object of the @code{stream-pair}
abstract data type contains a @code{stream-car} and a @code{stream-cdr},
which must be a @code{stream}.  The essential feature of streams is the
systematic suspensions of the recursive promises between the two data
types.

@example
alpha stream
  :: (promise stream-null)
  |  (promise (alpha stream-pair))

alpha stream-pair
  :: (promise alpha) x (promise (alpha stream))
@end example

The object stored in the @code{stream-car} of a @code{stream-pair} is a
promise that is forced the first time the @code{stream-car} is accessed;
its value is cached in case it is needed again.  The object may have any
type, and different stream elements may have different types.  If the
@code{stream-car} is never accessed, the object stored there is never
evaluated.  Likewise, the @code{stream-cdr} is a promise to return a
stream, and is only forced on demand.

This library provides eight operators: constructors for
@code{stream-null} and @code{stream-pairs}, type recognizers for streams
and the two kinds of streams, accessors for both fields of a
@code{stream-pair}, and a lambda that creates procedures that return
streams.


@defun stream-null
Return a promise that, when forced, is a single object, distinguishable
from all other objects, that represents the null stream.
@func{stream-null} is immutable and unique.
@end defun


@deffn Syntax stream-cons @var{object} @var{stream}
A macro that accepts an object and a stream and creates a
newly--allocated stream containing a promise that, when forced, is a
@code{stream-pair} with the object in its @code{stream-car} and the
stream in its @code{stream-cdr}.

@func{stream-cons} must be syntactic, not procedural, because neither
@var{object} nor @var{stream} is evaluated when @func{stream-cons} is
called.  Since @var{stream} is not evaluated, when the
@code{stream-pair} is created, it is not an error to call
@func{stream-cons} with a @var{stream} argument that is not of type
@code{stream}; however, doing so will cause an error later when the
@code{stream-cdr} of the @code{stream-pair} is accessed.

Once created, a @code{stream-pair} is immutable; there is @strong{no}
@func{stream-set-car!} or @func{stream-set-cdr!} that modifies an
existing @code{stream-pair}.  There is no dotted--pair or improper
stream as with lists.
@end deffn


@defun stream? @var{object}
Return @true{} if the @var{object} is a @code{stream} and @false{}
otherwise.  If @var{object} is a @code{stream}, @func{stream?} does not
force its promise.

If @code{(stream? obj)} is @true{}, then one of @code{(stream-null?
obj)} and @code{(stream-pair? obj)} will be @true{} and the other will
be @false{}; if @code{(stream? obj)} is @false{}, both
@code{(stream-null?  obj)} and @code{(stream-pair?  obj)} will be
@false{}.
@end defun


@defun stream-null? @var{object}
Return @true{} if the @var{object} is the distinguished null stream and
@false{} otherwise.  If @var{object} is a @code{stream},
@func{stream-null?} must force its promise in order to distinguish
@code{stream-null} from @code{stream-pair}.
@end defun


@defun stream-pair? @var{object}
Take an @var{object} and return @true{} if it is a @code{stream-pair}
constructed by @func{stream-cons} and @false{} otherwise.  If
@var{object} is a @code{stream}, @func{stream-pair?} must force its
promise in order to distinguish @code{stream-null} from
@code{stream-pair}.
@end defun


@defun stream-car @var{stream}
Return the object stored in the @code{stream-car} of @var{stream}.
@func{stream-car} signals an error if the object passed to it is not a
@code{stream-pair}.  Calling @func{stream-car} causes the object stored
there to be evaluated if it has not yet been; the object's value is
cached in case it is needed again.
@end defun


@defun stream-cdr @var{stream}
Return the stream stored in the @code{stream-cdr} of @var{stream}.
@func{stream-cdr} signals an error if the object passed to it is not a
@code{stream-pair}.  Calling @func{stream-cdr} does not force the
promise containing the stream stored in the @code{stream-cdr} of the
stream.
@end defun


@deffn Syntax stream-lambda @var{args} . @var{body}
Create a procedure that returns a promise to evaluate the body of the
procedure.  The last body expression to be evaluated must yield a
stream.

As with normal lambda, @var{args} may be a single variable name, in
which case all the formal arguments are collected into a single list, or
a list of variable names, which may be null if there are no arguments,
proper if there are an exact number of arguments, or dotted if a fixed
number of arguments is to be followed by zero or more arguments
collected into a list.

@var{body} must contain at least one expression, and may contain
internal definitions preceding any expressions to be evaluated.
@end deffn



@c page
@node streams primitive example
@section Streams primitive library example


@example
(define strm123
  (stream-cons 1
    (stream-cons 2
      (stream-cons 3
        stream-null))))

(stream-car strm123) => 1

(stream-car (stream-cdr strm123) => 2

(stream-pair?
  (stream-cdr
    (stream-cons (/ 1 0) stream-null))) => #f

(stream? (list 1 2 3)) => #f

(define iter
  (stream-lambda (f x)
    (stream-cons x (iter f (f x)))))

(define nats (iter (lambda (x) (+ x 1)) 0))

(stream-car (stream-cdr nats)) => 1

(define stream-add
  (stream-lambda (s1 s2)
    (stream-cons
      (+ (stream-car s1) (stream-car s2))
      (stream-add (stream-cdr s1)
                  (stream-cdr s2)))))

(define evens (stream-add nats nats))

(stream-car evens) => 0

(stream-car (stream-cdr evens)) => 2

(stream-car (stream-cdr (stream-cdr evens))) => 4
@end example



@c page
@node streams derived
@section The @library{streams derived} library


@cindex @srfi{} streams derived library


The @library{streams derived} library provides useful procedures and
syntax that depend on the primitives defined in @ref{streams primitive}.


@deffn Syntax define-stream (@var{name} @var{args}) . @var{body}
Create a procedure that returns a @code{stream}, and may appear anywhere
a normal @func{define} may appear, including as an internal definition,
and may have internal definitions of its own, including other
@func{define-streams}.  The defined procedure takes arguments in the
same way as @func{stream-lambda}.

@func{define-stream} is syntactic sugar on @func{stream-lambda}; see
also @func{stream-let}, which is also a sugaring of
@func{stream-lambda}.

The following example is a simple version of @func{stream-map} that
takes only a single input stream calls itself recursively:

@example
(define-stream (stream-map proc strm)
  (if (stream-null? strm)
      stream-null
      (stream-cons
        (proc (stream-car strm))
        (stream-map proc (stream-cdr strm))))))
@end example
@end deffn


@defun list->stream @var{list-of-objects}
Return a newly--allocated @code{stream} containing in its elements the
objects in the list.  Since the objects are given in a list, they are
evaluated when @func{list->stream} is called, before the @code{stream}
is created.  If the list of objects is null, as in @code{(list->stream
'())}, the null @code{stream} is returned.  See also @func{stream}.

Example:

@example
(define strm123 (list->stream '(1 2 3)))

; fails with divide-by-zero error
(define s (list->stream (list 1 (/ 1 0) -1)))
@end example
@end defun


@defun port->stream [@var{port}]
Return a newly--allocated @code{stream} containing in its elements the
characters on the @var{port}.  If @var{port} is not given it defaults to
the current input port.  The returned @code{stream} has finite length
and is terminated by @code{stream-null}.

It looks like one use of @func{port->stream} would be this:

@example
(define s ;wrong!
  (with-input-from-file filename
    (lambda () (port->stream))))
@end example

@noindent
but that fails, because @func{with-input-from-file} is eager, and closes
the input port prematurely, before the first character is read.  To read
a file into a stream, use:

@example
(define-stream (file->stream filename)
  (let ((p (open-input-file filename)))
    (stream-let loop ((c (read-char p)))
      (if (eof-object? c)
          (begin (close-input-port p)
                 stream-null)
          (stream-cons c
            (loop (read-char p)))))))
@end example
@end defun


@deffn Syntax stream @var{object} ...
Take zero or more objects and create a newly--allocated @code{stream}
containing in its elements the objects, in order.  Since @func{stream}
is syntactic, the objects are evaluated when they are accessed, not when
the @code{stream} is created.  If no objects are given, as in
@code{(stream)}, the null stream is returned.  See also
@func{list->stream}.

Example:

@example
(define strm123 (stream 1 2 3))

; (/ 1 0) not evaluated when stream is created
(define s (stream 1 (/ 1 0) -1))
@end example
@end deffn


@defun stream->list [@var{n}] @var{stream}
Take a natural number @var{n} and a @var{stream} and return a
newly--allocated list containing in its elements the first @var{} items
in the @var{stream}.  If the @var{stream} has less than @var{n} items
all the items in the @var{stream} will be included in the returned list.
If @var{n} is not given it defaults to infinity, which means that unless
@var{stream} is finite @func{stream->list} will never return.

Example:

@example
(stream->list 10
  (stream-map (lambda (x) (* x x))
    (stream-from 0)))
  => (0 1 4 9 16 25 36 49 64 81)
@end example
@end defun


@defun stream-append @var{stream} ...
Return a newly--allocated @code{stream} containing in its elements those
elements contained in its input streams, in order of input.  If any of
the input streams is infinite, no elements of any of the succeeding
input streams will appear in the output stream; thus, if @var{x} is
infinite, @code{(stream-append x y)} is identical to @var{x}.  See also
@func{stream-concat}.

Example: quicksort can be used to sort a @code{stream}, using
@func{stream-append} to build the output; the sort is lazy; so if only
the beginning of the output stream is needed, the end of the stream is
never sorted.

@example
(define-stream (qsort lt? strm)
  (if (stream-null? strm)
      stream-null
      (let ((x (stream-car strm))
            (xs (stream-cdr strm)))
        (stream-append
          (qsort lt?
            (stream-filter
              (lambda (u) (lt? u x))
              xs))
          (stream x)
          (qsort lt?
            (stream-filter
              (lambda (u) (not (lt? u x)))
              xs))))))
@end example

Note also that, when used in tail position as in @func{qsort},
@func{stream-append} does not suffer the poor performance of
@func{append} on lists.  The list version of @func{append} requires
re--traversal of all its list arguments except the last each time it is
called.  But @func{stream-append} is different.  Each recursive call to
@func{stream-append} is suspended; when it is later forced, the
preceding elements of the result have already been traversed, so
tail--recursive loops that produce streams are efficient even when each
element is appended to the end of the result stream.  This also implies
that during traversal of the result only one promise needs to be kept in
memory at a time.
@end defun


@defun stream-concat @var{stream}
Take a @var{stream} consisting of one or more streams and return a
newly--allocated stream containing all the elements of the input
streams.  If any of the streams in the input stream is infinite, any
remaining streams in the input stream will never appear in the output
stream.  See also @func{stream-append}.

Example:

@example
(stream->list
  (stream-concat
    (stream
      (stream 1 2) (stream) (stream 3 2 1))))
  => (1 2 3 2 1)
@end example

Example: the permutations of a finite stream can be determined by
interleaving each element of the stream in all possible positions within
each permutation of the other elements of the stream; @func{interleave}
returns a stream of streams with @var{x} inserted in each possible
position of @var{yy}:

@example
(define-stream (interleave x yy)
  (stream-match yy
    [() (stream (stream x))]
    [(y .  ys)
      (stream-append
        (stream (stream-cons x yy))
        (stream-map
          (lambda (z) (stream-cons y z))
          (interleave x ys)))]))

(define-stream (perms xs)
  (if (stream-null? xs)
      (stream (stream))
      (stream-concat
        (stream-map
          (lambda (ys)
            (interleave (stream-car xs) ys))
          (perms (stream-cdr xs))))))
@end example
@end defun


@defun stream-constant @var{object} ...
Take one or more objects and return a newly--allocated @code{stream}
containing in its elements the objects, repeating the objects in
succession forever.

Example:

@example
(stream-constant 1) => 1 1 1 ...

(stream-constant #t #f) => #t #f #t #f #t #f ...
@end example
@end defun


@defun stream-drop @var{n} @var{stream}
Return the suffix of the input stream that starts at the next element
after the first @var{n} elements.  The output stream shares structure
with the input stream; thus, promises forced in one instance of the
stream are also forced in the other instance of the stream.  If the
input stream has less than @var{n} elements, @func{stream-drop} returns
the null stream.  See also @func{stream-take}.

Example:

@example
(define (stream-split n strm)
  (values (stream-take n strm)
          (stream-drop n strm)))
@end example
@end defun


@defun stream-drop-while @var{pred?} @var{stream}
Return the suffix of the input stream that starts at the first element
@var{x} for which @code{(pred? x)} is @false{}.  The output stream
shares structure with the input stream.  See also
@func{stream-take-while}.

Example: @func{stream-unique} creates a new stream that retains only the
first of any sub--sequences of repeated elements.

@example
(define-stream (stream-unique eql? strm)
  (if (stream-null? strm)
      stream-null
      (stream-cons (stream-car strm)
        (stream-unique eql?
          (stream-drop-while
            (lambda (x)
              (eql? (stream-car strm) x))
            strm)))))
@end example
@end defun


@defun stream-filter @var{pred?} @var{stream}
Return a newly--allocated stream that contains only those elements
@var{x} of the input stream for which @code{(pred? x)} is non--@false{}.

Example:

@example
(stream-filter odd? (stream-from 0))
   => 1 3 5 7 9 ...
@end example
@end defun


@defun stream-fold @var{proc} @var{base} @var{stream}
Apply a binary procedure to @var{base} and the first element of
@var{stream} to compute a new base, then apply the procedure to the new
base and the next element of @var{stream} to compute a succeeding base,
and so on, accumulating a value that is finally returned as the value of
@func{stream-fold} when the end of the @var{stream} is reached.

@var{stream} must be finite, or @func{stream-fold} will enter an
infinite loop.  See also @func{stream-scan}, which is similar to
@func{stream-fold}, but useful for infinite streams.

For readers familiar with other functional languages, this is a
left--fold; there is no corresponding right--fold, since right--fold
relies on finite streams that are fully--evaluated, at which time they
may as well be converted to a list.

Example: @func{stream-fold} is often used to summarize a stream in a
single value, for instance, to compute the maximum element of a stream.

@example
(define (stream-maximum lt? strm)
  (stream-fold
    (lambda (x y) (if (lt? x y) y x))
    (stream-car strm)
    (stream-cdr strm)))
@end example

Example: sometimes, it is useful to have @func{stream-fold} defined only
on non--null streams:

@example
(define (stream-fold-one proc strm)
  (stream-fold proc
    (stream-car strm)
    (stream-cdr strm)))
@end example

@noindent
@func{stream-minimum} can then be defined as:

@example
(define (stream-minimum lt? strm)
  (stream-fold-one
    (lambda (x y) (if (lt? x y) x y))
    strm))
@end example

Example: @func{stream-fold} can also be used to build a stream:

@example
(define-stream (isort lt? strm)
    (define-stream (insert strm x)
      (stream-match strm
        [() (stream x)]
        [(y .  ys)
          (if (lt? y x)
              (stream-cons y (insert ys x))
              (stream-cons x strm))]))
    (stream-fold insert stream-null strm))
@end example
@end defun


@defun stream-for-each @var{proc} @var{stream} ...
Apply a procedure element--wise to corresponding elements of the input
streams for its side--effects; return nothing.  @func{stream-for-each}
stops as soon as any of its input streams is exhausted.

Example: the following procedure displays the contents of a file:

@example
(define (display-file filename)
  (stream-for-each display
    (file->stream filename)))
@end example
@end defun


@defun stream-from @var{first} [@var{step}]
Create a newly--allocated stream that contains @var{first} as its first
element and increments each succeeding element by @var{step}.  If
@var{step} is not given it defaults to @code{1}.  @var{first} and
@var{step} may be of any numeric type.  @func{stream-from} is frequently
useful as a generator in @func{stream-of} expressions.  See also
@func{stream-range} for a similar procedure that creates finite streams.

@func{stream-from} could be implemented as:

@example
(stream-iterate (lambda (x) (+ x step)) first)
@end example

Example:

@example
(define nats (stream-from 0)) => 0 1 2 ...
(define odds (stream-from 1 2)) => 1 3 5 ...
@end example
@end defun


@defun stream-iterate @var{proc} @var{base}
Create a newly--allocated stream containing @var{base} in its first
element and apply @var{proc} to each element in turn to determine the
succeeding element.  See also @func{stream-unfold} and
@func{stream-unfolds}.

Examples:

@example
(stream-iterate (lambda (x) (+ x 1)) 0)
  => 0 1 2 3 4 ...

(stream-iterate (lambda (x) (* x 2)) 1)
  => 1 2 4 8 16 ...
@end example

Given a seed between 0 and 232, exclusive, the following expression
creates a stream of pseudo--random integers between 0 and 232,
exclusive, beginning with seed, using the method described by Stephen
Park and Keith Miller:

@example
(stream-iterate
  (lambda (x) (modulo (* x 16807) 2147483647))
  seed)
@end example

Example: successive of the following stream approach the value of the
``golden ratio'' 1.618...:

@example
(stream-iterate (lambda (x) (+ 1 (/ x))) 1)
@end example
@end defun


@defun stream-length @var{stream}
Take an input stream and return the number of elements in the stream; it
does not evaluate its elements.  @func{stream-length} may only be used
on finite streams; it enters an infinite loop with infinite streams.

Example:

@example
(stream-length strm123) => 3
@end example
@end defun


@deffn Syntax stream-let @var{tag} ((@var{var} @var{expr}) ...) @var{body}
Create a local scope that binds each variable to the value of its
corresponding expression.  Additionally bind @var{tag} to a procedure
which takes the bound variables as arguments and @var{body} as its
defining expressions, binding the tag with @func{stream-lambda}.
@var{tag} is in scope within @var{body}, and may be called recursively.

When the expanded expression defined by @func{stream-let} is evaluated,
@func{stream-let} evaluates the expressions in its body in an
environment containing the newly--bound variables, returning the value
of the last expression evaluated, which must yield a stream.

@func{stream-let} provides syntactic sugar on @func{stream-lambda}, in
the same manner as normal @func{let} provides syntactic sugar on normal
@func{lambda}.  However, unlike normal @func{let}, the @var{tag} is
required, not optional, because unnamed @func{stream-let} is
meaningless.

Example: @func{stream-member} returns the first @code{stream-pair} of
the input @var{strm} with a @code{stream-car} @var{x} that satisfies
@code{(eql? obj x)}, or the null stream if @var{x} is not present in
@var{strm}.

@example
(define-stream (stream-member eql? obj strm)
  (stream-let loop ((strm strm))
    (cond [(stream-null? strm) strm]
          [(eql? obj (stream-car strm)) strm]
          [else (loop (stream-cdr strm))])))
@end example
@end deffn


@defun stream-map @var{proc} @var{stream} ...
Apply a procedure element--wise to corresponding elements of the input
streams, returning a newly--allocated stream containing elements that
are the results of those procedure applications.  The output stream has
as many elements as the minimum--length input stream, and may be
infinite.

Example:

@example
(define (square x) (* x x))

(stream-map square (stream 9 3)) => 81 9

(define (sigma f m n)
  (stream-fold + 0
    (stream-map f (stream-range m (+ n 1)))))

(sigma square 1 100) => 338350
@end example

In some functional languages, @func{stream-map} takes only a single
input stream, and @func{stream-zipwith} provides a companion function
that takes multiple input streams.
@end defun


@deffn Syntax stream-match @var{stream} @var{clause} ...
Provide the syntax of pattern--matching for streams.  The input
@var{stream} is an expression that evaluates to a stream.  @var{clause}
arguments are of the form @code{(pattern [fender] expr)}, consisting of
a pattern that matches a stream of a particular shape, an optional
fender that must succeed if the pattern is to match, and an expression
that is evaluated if the pattern matches.  There are four types of
patterns:

@table @code
@item ()
matches the null stream;

@item (pat0 pat1 ...)
matches a finite stream with length exactly equal to the number of
pattern elements;

@item (pat0 pat1 ...  . patrest)
matches an infinite stream, or a finite stream with length at least as
great as the number of pattern elements before the literal dot;

@item pat
matches an entire stream; should always appear last in the list of
nclauses; it's not an error to appear elsewhere, but subsequent clauses
could never match.
@end table

Each pattern element @var{pati} may be either:

@table @emph
@item an identifier
matches any stream element; additionally, the value of the stream
element is bound to the variable named by the identifier, which is in
scope in the fender and expression of the corresponding clause; each
identifier in a single pattern must be unique;

@item a literal underscore
matches any stream element, but creates no bindings.
@end table

The patterns are tested in order, left--to--right, until a matching
pattern is found; if @var{fender} is present, it must evaluate as
non--@false{} for the match to be successful.  Pattern variables are
bound in the corresponding fender and expression.  Once the matching
pattern is found, the corresponding expression is evaluated and returned
as the result of the match.  An error is signaled if no pattern matches
the input stream.

@func{stream-match} is often used to distinguish null streams from
non--null streams, binding head and tail:

@example
(define (len strm)
  (stream-match strm
    [() 0]
    [(head .  tail) (+ 1 (len tail))]))
@end example

Fenders can test the common case where two stream elements must be
identical; the else pattern is an identifier bound to the entire stream,
not a keyword as in @func{cond}.

@example
(stream-match strm
  [(x y .  _) (equal? x y) 'ok]
  [else 'error])
@end example

A more complex example uses two nested matchers to match two different
stream arguments; @code{(stream-merge lt? .  strms)} stably merges two
or more streams ordered by the @var{lt?} predicate:

@example
(define-stream (stream-merge lt? .  strms)
  (define-stream (merge xx yy)
    (stream-match xx (() yy) ((x .  xs)
      (stream-match yy (() xx) ((y .  ys)
        (if (lt? y x)
            (stream-cons y (merge xx ys))
          (stream-cons x (merge xs yy))))))))
  (stream-let loop ((strms strms))
    (cond [(null? strms) stream-null]
          [(null? (cdr strms)) (car strms)]
          [else (merge (car strms)
                       (apply stream-merge lt?
                         (cdr strms)))])))
@end example
@end deffn


@deffn Syntax stream-of @var{expr} @var{clause} ...
Provide the syntax of stream comprehensions, which generate streams by
means of looping expressions.  The result is a stream of objects of the
type returned by @var{expr}.  There are four types of @var{clause}
arguments:

@table @code
@item (var in stream-expr)
loop over the elements of @var{stream-expr}, in order from the start of
the stream, binding each element of the stream in turn to @var{var}.
@func{stream-from} and @func{stream-range} are frequently useful as
generators for @var{stream-expr};

@item (var is expr)
bind @var{var} to the value obtained by evaluating @var{expr};

@item (pred? expr)
include in the output stream only those elements @var{x} for which
@code{(pred? x)} is non--@false{}.
@end table

The scope of variables bound in the stream comprehension is the clauses
to the right of the binding clause (but not the binding clause itself)
plus the result expression.

When two or more generators are present, the loops are processed as if
they are nested from left to right; that is, the rightmost generator
varies fastest.  A consequence of this is that only the first generator
may be infinite and all subsequent generators must be finite.  If no
generators are present, the result of a stream comprehension is a stream
containing the result expression; thus, @code{(stream-of 1)} produces a
finite stream containing only the element @code{1}.

@example
(stream-of (* x x)
  (x in (stream-range 0 10))
  (even? x))
  => 0 4 16 36 64

(stream-of (list a b)
  (a in (stream-range 1 4))
  (b in (stream-range 1 3)))
  => (1 1) (1 2) (2 1) (2 2) (3 1) (3 2)

(stream-of (list i j)
  (i in (stream-range 1 5))
  (j in (stream-range (+ i 1) 5)))
  => (1 2) (1 3) (1 4) (2 3) (2 4) (3 4)
@end example
@end deffn


@defun stream-range @var{first} @var{past} [@var{step}]
Create a newly--allocated stream that contains @var{first} as its first
element and increments each succeeding element by @var{step}.  The
stream is finite and ends before @var{past}, which is not an element of
the stream.  If @var{step} is not given it defaults to @code{1} if
@var{first} is less than @var{past} and @code{-1} otherwise.

@var{first}, @var{past} and @var{step} may be of any numeric type.

@func{stream-range} is frequently useful as a generator in
@func{stream-of} expressions.  See also @func{stream-from} for a similar
procedure that creates infinite streams.

Examples:

@example
(stream-range 0 10)     => 0 1 2 3 4 5 6 7 8 9
(stream-range 0 10 2)   => 0 2 4 6 8
@end example

Successive elements of the stream are calculated by adding @var{step} to
@var{first}, so if any of @var{first}, @var{past} or @var{step} are
inexact, the length of the output stream may differ from:

@example
(ceiling (- (/ (- past first) step) 1)
@end example
@end defun


@defun stream-ref @var{stream} @var{n}
Return the @var{n}-th element of @var{stream}, counting from zero.  An
error is signaled if @var{n} is greater than or equal to the length of
@var{stream}.

Example:

@example
(define (fact n)
  (stream-ref
    (stream-scan * 1 (stream-from 1))
    n))
@end example
@end defun


@defun stream-reverse @var{stream}
Return a newly--allocated stream containing the elements of the input
@var{stream} but in reverse order.  @func{stream-reverse} may only be
used with finite streams; it enters an infinite loop with infinite
streams.  @func{stream-reverse} does not force evaluation of the
elements of the stream.

@example
(define s (stream 1 (/ 1 0) -1))
(define r (stream-reverse s))
(stream-ref r 0)
(stream-ref r 2)        => 1
(stream-ref r 1)        => error: division by zero
@end example
@end defun


@defun stream-scan @var{proc} @var{base} @var{stream}
Accumulate the partial folds of an input @var{stream} into a
newly--allocated output stream.  The output stream is the @var{base}
followed by:

@example
(stream-fold proc base (stream-take i stream))
@end example

@noindent
for each of the first i elements of @var{stream}.

Examples:

@example
(stream-scan + 0 (stream-from 1))
  => (stream 0 1 3 6 10 15 ...)

(stream-scan * 1 (stream-from 1))
  => (stream 1 1 2 6 24 120 ...)
@end example
@end defun


@defun stream-take @var{n} @var{stream}
Take a non--negative integer @var{n} and a @var{stream} and return a
newly--allocated stream containing the first @var{f}n elements of the
input stream.  If the input stream has less than @var{n} elements, so
does the output stream.  See also @func{stream-drop}.

Example: @func{merge-sort} splits a stream into two equal--length
pieces, sorts them recursively and merges the results:

@example
(define-stream (merge-sort lt? strm)
  (let* ([n     (quotient (stream-length strm) 2)]
         [ts    (stream-take n strm)]
         [ds    (stream-drop n strm)])
    (if (zero? n)
        strm
      (stream-merge lt? (msort < ts) (msort < ds)))))
@end example
@end defun


@defun stream-take-while @var{pred?} @var{stream}
Take a predicate and a stream and return a newly--allocated stream
containing those elements @var{x} that form the maximal prefix of the
input stream for which @code{(pred? x)} is non--@false{}.  See also
@func{stream-drop-while}.

@example
(stream-car
  (stream-reverse
    (stream-take-while
      (lambda (x) (< x 1000))
      primes)))
  => 997
@end example
@end defun


@defun stream-unfold @var{map} @var{pred?} @var{gen} @var{base}
@func{stream-unfold} is the fundamental recursive stream constructor.
It constructs a stream by repeatedly applying @var{gen} to successive
values of @var{base}, in the manner of @func{stream-iterate}, then
applying @var{map} to each of the values so generated, appending each of
the mapped values to the output stream as long as @code{(pred? base)} is
non--@false{}.  See also @func{stream-iterate} and
@func{stream-unfolds}.

Example: the expression below creates the finite stream:

@example
0 1 4 9 16 25 36 49 64 81
@end example

@noindent
initially the base is @code{0}, which is less than @code{10}, so
@var{map} squares the base and the mapped value becomes the first
element of the output stream; then @var{gen} increments the base by
@code{1}, so it becomes @code{1}; this is less than @code{10}, so
@var{map} squares the new base and @code{1} becomes the second element
of the output stream; and so on, until the base becomes @code{10}, when
@var{pred?}  stops the recursion and @code{stream-null} ends the output
stream.

@example
(stream-unfold
  (lambda (x) (expt x 2)) ; map
  (lambda (x) (< x 10))   ; pred?
  (lambda (x) (+ x 1))    ; gen
  0)                      ; base
@end example
@end defun


@defun stream-unfolds @var{proc} @var{seed}
Return @var{n} newly--allocated streams containing those elements
produced by successive calls to the generator @var{proc}, which takes
the current @var{seed} as its argument and returns @code{n+1} values:

@example
(proc seed) -> seed result0 ...  resultn-1
@end example

@noindent
where the returned @var{seed} is the input @var{seed} to the next call
to the generator and @var{resulti} indicates how to produce the next
element of the ith result stream:

@table @code
@item (value)
@var{value} is the next car of the result stream;

@item #f
no value produced by this iteration of the generator @var{proc} for the
result stream;

@item ()
the end of the result stream.
@end table

It may require multiple calls of @var{proc} to produce the next element
of any particular result stream.  See also @func{stream-iterate} and
@func{stream-unfold}.

@func{stream-unfolds} is especially useful when writing expressions that
return multiple streams.  For instance, @code{(stream-partition pred?
strm)} is equivalent to:

@example
(values
  (stream-filter pred? strm)
  (stream-filter
    (lambda (x) (not (pred? x))) strm))
@end example

@noindent
but only tests @func{pred?} once for each element of @var{strm}.

Example:

@example
(define (stream-partition pred? strm)
  (stream-unfolds
    (lambda (s)
      (if (stream-null? s)
          (values s '() '())
        (let ([a (stream-car s)]
              [d (stream-cdr s)])
          (if (pred? a)
              (values d (list a) #f)
            (values d #f (list a))))))
    strm))

(call-with-values
  (lambda ()
    (stream-partition odd?
      (stream-range 1 6)))
  (lambda (odds evens)
    (list (stream->list odds)
          (stream->list evens))))
  => ((1 3 5) (2 4))
@end example
@end defun


@defun stream-zip @var{stream} ...
Take one or more input streams and return a newly--allocated stream in
which each element is a list (not a stream) of the corresponding
elements of the input streams.  The output stream is as long as the
shortest input stream, if any of the input streams is finite, or is
infinite if all the input streams are infinite.

A common use of @func{stream-zip} is to add an index to a stream, as in:

@example
(stream-finds eql? obj strm)
@end example

@noindent
which returns all the zero--based indices in @var{strm} at which
@var{obj} appears; @code{(stream-find eql? obj strm)} returns the first
such index, or @false{} if @var{obj} is not in @var{strm}.

@example
(define-stream (stream-finds eql? obj strm)
  (stream-of (car x)
    (x in (stream-zip (stream-from 0) strm))
    (eql? obj (cadr x))))

(define (stream-find eql? obj strm)
  (stream-car
    (stream-append
      (stream-finds eql? obj strm)
      (stream #f))))

(stream-find char=? #\l
  (list->stream
    (string->list "hello")))
  => 2

(stream-find char=? #\l
  (list->stream
    (string->list "goodbye")))
  => #f
@end example

@func{stream-find} is not as inefficient as it looks; although it calls
@func{stream-finds}, which finds all matching indices, the matches are
computed lazily, and only the first match is needed for
@func{stream-find}.
@end defun



@c page
@node streams utilities
@section Utilities


@cindex @srfi{} streams utilities


Streams, being the signature structured data type of functional
programming languages, find useful expression in conjunction with
higher--order functions.  Some of these higher--order functions, and
their relationship to streams, are described below.

The identity and constant procedures are frequently useful as the
recursive base for maps and folds; @code{(identity obj)} always returns
@var{obj}, and @code{(const obj)} creates a procedure that takes any
number of arguments and always returns the same @var{obj}, no matter its
arguments:

@example
(define (identity obj) obj)

(define (const obj) (lambda x obj))
@end example

Many of the stream procedures take a unary predicate that accepts an
element of a stream and returns a boolean.  Procedure @code{(negate
pred?)}  takes a unary predicate and returns a new unary predicate that,
when called, returns the opposite boolean value as the original
predicate.

@example
(define (negate pred?)
  (lambda (x) (not (pred? x))))
@end example

@func{negate} is useful for procedures like @func{stream-take-while}
that take a predicate, allowing them to be used in the opposite
direction from which they were written; for instance, with the predicate
reversed, @func{stream-take-while} becomes @func{stream-take-until}.
@func{stream-remove} is the opposite of @func{stream-filter}:

@example
(define-stream (stream-remove pred? strm)
  (stream-filter (negate pred?) strm))
@end example

A section is a procedure which has been partially applied to some of its
arguments; for instance, @code{(double x)}, which returns twice its
argument, is a partial application of the multiply operator to the
number 2.  Sections come in two kinds:

@itemize
@item
left sections partially apply arguments starting from the left;
@item
right sections partially apply arguments starting from the right;
@end itemize

@noindent
the procedure @func{lsec} takes a procedure and some prefix of its
arguments and returns a new procedure in which those arguments are
partially applied; the procedure @func{rsec} takes a procedure and some
reversed suffix of its arguments and returns a new procedure in which
those arguments are partially applied:

@example
(define (lsec proc . args)
  (lambda x (apply proc (append args x))))

(define (rsec proc . args)
  (lambda x
    (apply proc (reverse (append (reverse args) (reverse x))))))
@end example

Since most of the stream procedures take a stream as their last
(rightmost) argument, left sections are particularly useful in
conjunction with streams.

@example
(define stream-sum (lsec stream-fold + 0))
@end example

Function composition creates a new function by partially applying
multiple functions, one after the other.  In the simplest case there are
only two functions, @var{f} and @var{g}, composed as @code{(compose f
g)}; the composition can be bound to create a new function, as in:

@example
(define fg (compose f g))
@end example

@noindent
The procedure @func{compose} takes one or more procedures and returns a
new procedure that performs the same action as the individual procedures
would if called in succession:

@example
(define (compose . fns)
  (let comp ((fns fns))
    (cond
      [(null? fns) 'error]
      [(null? (cdr fns)) (car fns)]
      [else
        (lambda args
          (call-with-values
            (lambda ()
              (apply
                (comp (cdr fns))
                args))
            (car fns)))])))
@end example

@func{compose} works with sections to create succinct but highly
expressive procedure definitions.  The expression to compute the squares
of the integers from 1 to 10 given above at @func{stream-unfold} could
be written by composing @func{stream-map}, @func{stream-take-while}, and
@func{stream-iterate}:

@example
([compose
  (lsec stream-map (rsec expt 2))
  (lsec stream-take-while (negate (rsec > 10)))
  (lsec stream-iterate (rsec + 1))]
 1)
@end example



@c page
@node streams examples
@section Examples


@cindex @srfi{} streams examples


The examples below show a few of the myriad ways streams can be
exploited, as well as a few ways they can trip the unwary user.  All the
examples are drawn from published sources; it is instructive to compare
the Scheme versions to the originals in other languages.

@menu
* streams examples infinite::   Infinite streams.
* streams examples generators:: Generators and co--routines.
* streams examples pipeline::   A pipeline of procedures.
* streams examples persistent:: Persistent data.
* streams examples passes::     Reducing two passes to one.
* streams examples pitfalls::   Pitfalls.
@end menu


@c page
@node streams examples infinite
@subsection Infinite streams


As a simple illustration of infinite streams, consider this definition
of the natural numbers:

@example
(define nats
  (stream-cons 0
    (stream-map add1 nats)))
@end example

@noindent
the recursion works because it is offset by one from the initial
@func{stream-cons}.  Another sequence that uses the offset trick is this
definition of the Fibonacci numbers:

@example
(define fibs
  (stream-cons 1
    (stream-cons 1
      (stream-map +
        fibs
        (stream-cdr fibs)))))
@end example

Yet another sequence that uses the same offset trick is the Hamming
numbers, named for the mathematician and computer scientist Richard
Hamming, defined as all numbers that have no prime factors greater than
5; in other words, Hamming numbers are all numbers expressible as

@example
2i x 3j x 5k
@end example

@noindent
where @var{i}, @var{j} and @var{k} are non--negative integers.  The
Hamming sequence starts with 1 2 3 4 5 6 8 9 10 12 and is computed
starting with 1, taking 2, 3 and 5 times all the previous elements with
@func{stream-map}, then merging @func{sub-streams} and eliminating
duplicates:

@example
(define hamming
  (stream-cons 1
    (stream-unique =
      (stream-merge <
        (stream-map (lsec * 2) hamming)
        (stream-map (lsec * 3) hamming)
        (stream-map (lsec * 5) hamming)))))
@end example

It is possible to have an infinite stream of infinite streams. Consider
the definition of @func{power-table}:

@example
(define power-table
  (stream-of
    (stream-of (expt m n)
      (m in (stream-from 1)))
      (n in (stream-from 2))))
@end example

@noindent
which evaluates to an infinite stream of infinite streams:

@example
(stream
  (stream 1 4 9 16 25 ...)
  (stream 1 8 27 64 125 ...)
  (stream 1 16 81 256 625 ...)
  ...)
@end example

But even though it is impossible to display @func{power-table} in its
entirety, it is possible to select just part of it:

@example
(stream->list 10 (stream-ref power-table 1))
  => (1 8 27 64 125 216 343 512 729 1000)
@end example

This example clearly shows that the elements of a stream are computed
lazily, as they are needed; @code{(stream-ref power-table 0)} is not
computed, even when its successor is displayed, since computing it would
enter an infinite loop.

Chris Reade shows how to calculate the stream of prime numbers according
to the sieve of Eratosthenes, using a method that eliminates multiples
of the sifting base with addition rather than division:

@example
(define primes (let ()
  (define-stream (next base mult strm)
    (let ((first (stream-car strm))
          (rest (stream-cdr strm)))
      (cond ((< first mult)
              (stream-cons first
                (next base mult rest)))
            ((< mult first)
              (next base (+ base mult) strm))
            (else (next base
                    (+ base mult) rest)))))
  (define-stream (sift base strm)
    (next base (+ base base) strm))
  (define-stream (sieve strm)
    (let ((first (stream-car strm))>
          (rest (stream-cdr strm)))
      (stream-cons first
        (sieve (sift first rest)))))
  (sieve (stream-from 2))))
@end example

A final example of infinite streams is a functional pearl from Jeremy
Gibbons, David Lester and Richard Bird that enumerates the positive
rational numbers without duplicates:

@example
(define rats
  (stream-iterate
    (lambda (x)
      (let* ((n (floor x)) (y (- x n)))
        (/ (- n -1 y))))
    1))
@end example


@c page
@node streams examples generators
@subsection Generators and co--routines


It is possible to model generators and co--routines using streams.
Consider the task, due to Carl Hewitt, of determining if two trees have
the same sequence of leaves:

@example
(same-fringe? = '(1 (2 3)) '((1 2) 3))  => #t

(same-fringe? = '(1 2 3) '(1 (3 2)))    => #f
@end example

The simplest solution is to flatten both trees into lists and compare
them element--by--element:

@example
(define (flatten tree)
  (cond [(null? tree) '()]
        [(pair? (car tree))
         (append (flatten (car tree))
                 (flatten (cdr tree)))]
        [else (cons (car tree)
                    (flatten (cdr tree)))]))

(define (same-fringe? eql? tree1 tree2)
  (let loop ([t1 (flatten tree1)]
             [t2 (flatten tree2)])
    (cond [(and (null? t1) (null? t2)) #t]
          [(or (null? t1) (null? t2)) #f]
          [(not (eql? (car t1) (car t2))) #f]
          [else (loop (cdr t1) (cdr t2))])))
@end example

That works, but requires time to flatten both trees and space to store
the flattened versions; if the trees are large, that can be a lot of
time and space, and if the fringes differ, much of that time and space
is wasted.

Hewitt used a generator to flatten the trees one element at a time,
storing only the current elements of the trees and the machines needed
to continue flattening them, so @func{same-fringe?} could stop early if
the trees differ.  Dorai Sitaram presents both the generator solution
and a co--routine solution, which both involve tricky calls to
@func{call-with-current-continuation} and careful coding to keep them
synchronized.

An alternate solution flattens the two trees to streams instead of
lists, which accomplishes the same savings of time and space, and
involves code that looks little different than the list solution
presented above:

@example
(define-stream (flatten tree)
  (cond [(null? tree) stream-null]
        [(pair? (car tree))
         (stream-append
           (flatten (car tree))
           (flatten (cdr tree)))]
        [else (stream-cons
                (car tree)
                (flatten (cdr tree)))]))

(define (same-fringe? eql? tree1 tree2)
  (let loop ([t1 (flatten tree1)]
             [t2 (flatten tree2)])
    (cond [(and (stream-null? t1)
                (stream-null? t2)) #t]
          [(or  (stream-null? t1)
                (stream-null? t2)) #f]
          [(not (eql? (stream-car t1)
                      (stream-car t2))) #f]
          [else (loop (stream-cdr t1)
                      (stream-cdr t2))])))
@end example

Note that streams, a data structure, replace generators or co--routines,
which are control structures, providing a fine example of how lazy
streams enhance modularity.


@c page
@node streams examples pipeline
@subsection A pipeline of procedures


Another way in which streams promote modularity is enabling the use of
many small procedures that are easily composed into larger programs, in
the style of Unix pipelines, where streams are important because they
allow a large dataset to be processed one item at a time.  Bird and
Wadler provide the example of a text formatter.  Their example uses
right--folds:

@example
(define (stream-fold-right f base strm)
  (if (stream-null? strm)
      base
    (f (stream-car strm)
       (stream-fold-right f base
         (stream-cdr strm)))))

(define (stream-fold-right-one f strm)
  (stream-match strm
    [(x) x]
    [(x . xs)
     (f x (stream-fold-right-one f xs))]))
@end example

Bird and Wadler define text as a stream of characters, and develop a
standard package for operating on text, which they derive mathematically
(this assumes the line--separator character is a single
@code{#\newline}):

@example
(define (breakon a)
  (stream-lambda (x xss)
    (if (equal? a x)
        (stream-append (stream (stream)) xss)
      (stream-append
        (stream (stream-append
            (stream x) (stream-car xss)))
        (stream-cdr xss)))))

(define-stream (lines strm)
  (stream-fold-right
    (breakon #\newline)
    (stream (stream))
    strm))

(define-stream (words strm)
  (stream-filter stream-pair?
    (stream-fold-right
      (breakon #\space)
      (stream (stream))
      strm)))

(define-stream (paras strm)
  (stream-filter stream-pair?
    (stream-fold-right
      (breakon stream-null)
      (stream (stream))
      strm)))

(define (insert a)
  (stream-lambda (xs ys)
    (stream-append xs (stream a) ys)))

(define unlines
  (lsec stream-fold-right-one
    (insert #\newline)))

(define unwords
  (lsec stream-fold-right-one
    (insert #\space)))

(define unparas
  (lsec stream-fold-right-one
    (insert stream-null)))
@end example

These versatile procedures can be composed to count words, lines and
paragraphs; the @func{normalize} procedure squeezes out multiple spaces
and blank lines:

@example
(define countlines
  (compose stream-length lines))

(define countwords
  (compose stream-length
           stream-concat
           (lsec stream-map words)
           lines))

(define countparas
  (compose stream-length paras lines))

(define parse
  (compose (lsec stream-map
             (lsec stream-map words))
           paras
           lines))

(define unparse
  (compose unlines
           unparas
           (lsec stream-map
             (lsec stream-map unwords))))

(define normalize (compose unparse parse))
@end example

More useful than normalization is text--filling, which packs as many
words onto each line as will fit.

@example
(define (greedy m ws)
  (- (stream-length
       (stream-take-while (rsec <= m)
         (stream-scan
           (lambda (n word)
             (+ n (stream-length word) 1))
           -1
           ws))) 1))

(define-stream (fill m ws)
  (if (stream-null? ws)
      stream-null
    (let* ([n (greedy m ws)]
           [fstline (stream-take n ws)]
           [rstwrds (stream-drop n ws)])
      (stream-append
        (stream fstline)
        (fill m rstwrds)))))

(define linewords
  (compose stream-concat
           (lsec stream-map words)))

(define textparas
  (compose (lsec stream-map linewords)
           paras
           lines))

(define (filltext m strm)
  (unparse (stream-map (lsec fill m) (textparas strm))))
@end example

To display filename in lines of @var{n} characters, say:

@example
(stream-for-each display
  (filltext n (file->stream filename)))
@end example

Though each operator performs only a single task, they can be composed
powerfully and expressively.  The alternative is to build a single
monolithic procedure for each task, which would be harder and involve
repetitive code.  Streams ensure procedures are called as needed.


@c page
@node streams examples persistent
@subsection Persistent data


Queues are one of the fundamental data structures of computer science.
In functional languages, queues are commonly implemented using two
lists, with the front half of the queue in one list, where the head of
the queue can be accessed easily, and the rear half of the queue in
reverse order in another list, where new items can easily be added to
the end of a queue.  The standard form of such a queue holds that the
front list can only be null if the rear list is also null:

@example
(define queue-null (cons '() '())

(define (queue-null? obj)
  (and (pair? obj) (null? (car obj))))

(define (queue-check f r)
  (if (null? f)
      (cons (reverse r) '())
    (cons f r)))

(define (queue-snoc q x)
  (queue-check (car q) (cons x (cdr q))))

(define (queue-head q)
  (if (null? (car q))
      (error "empty queue: head")
    (car (car q))))

(define (queue-tail q)
  (if (null? (car q))
      (error "empty-head: tail")
    (queue-check (cdr (car q)) (cdr q))))
@end example

This queue operates in amortized constant time per operation, with two
conses per element, one when it is added to the rear list, and another
when the rear list is reversed to become the front list.
@func{queue-snoc} and @func{queue-head} operate in constant time;
@func{queue-tail} operates in worst--case linear time when the front
list is empty.

Chris Okasaki points out that, if the queue is used persistently, its
time--complexity rises from linear to quadratic since each persistent
copy of the queue requires its own linear--time access.  The problem can
be fixed by implementing the front and rear parts of the queue as
streams, rather than lists, and rotating one element from rear to front
whenever the rear list is larger than the front list:

@example
(define queue-null
  (cons stream-null stream-null))

(define (queue-null? x)
  (and (pair? x) (stream-null (car x))))

(define (queue-check f r)
  (if (< (stream-length r) (stream-length f))
      (cons f r)
    (cons (stream-append f (stream-reverse r))
          stream-null)))

(define (queue-snoc q x)
  (queue-check (car q) (stream-cons x (cdr q))))

(define (queue-head q)
  (if (stream-null? (car q))
      (error "empty queue: head")
    (stream-car (car q))))

(define (queue-tail q)
  (if (stream-null? (car q))
      (error "empty queue: tail")
    (queue-check (stream-cdr (car q)) (cdr q))))
@end example

Memoization solves the persistence problem; once a queue element has
moved from rear to front, it needs never be moved again in subsequent
traversals of the queue.  Thus, the linear time--complexity to access
all elements in the queue, persistently, is restored.


@c page
@node streams examples passes
@subsection Reducing two passes to one


The final example is a lazy dictionary, where definitions and uses may
occur in any order; in particular, uses may precede their corresponding
definitions.  This is a common problem.

Many programming languages allow procedures to be used before they are
defined.  Macro processors must collect definitions and emit uses of
text in order.  An assembler needs to know the address that a linker
will subsequently give to variables.  The usual method is to make two
passes over the data, collecting the definitions on the first pass and
emitting the uses on the second pass.  But Chris Reade shows how streams
allow the dictionary to be built lazily, so that only a single pass is
needed.  Consider a stream of requests:

@example
(define requests
  (stream
    '(get 3)
    '(put 1 "a")    ; use follows definition
    '(put 3 "c")    ; use precedes definition
    '(get 1)
    '(get 2)
    '(put 2 "b")    ; use precedes definition
    '(put 4 "d")))  ; unused definition
@end example

We want a procedure that will display cab, which is the result of
@code{(get 3)}, @code{(get 1)}, and @code{(get 2)}, in order.  We first
separate the request stream into gets and puts:

@example
(define (get? obj) (eq? (car obj) 'get))

(define-stream (gets strm)
  (stream-map cadr (stream-filter get? strm)))

(define-stream (puts strm)
  (stream-map cdr  (stream-remove get? strm)))
@end example

Now, @func{run-dict} inserts each element of the puts stream into a lazy
dictionary, represented as a stream of key/value pairs (an association
stream), then looks up each element of the gets stream with
@func{stream-assoc}:

@example
(define-stream (run-dict requests)
  (let ([dict (build-dict (puts requests))])
    (stream-map (rsec stream-assoc dict)
      (gets requests))))

(define (stream-assoc key dict)
    (cond [(stream-null? dict) #f]
          [(equal? key (car (stream-car dict)))
           (stream-car dict)]
          [else (stream-assoc key
                  (stream-cdr dict))]))
@end example

@var{dict} is created in the @func{let}, but nothing is initially added
to it.  Each time @func{stream-assoc} performs a lookup, enough of
@var{dict} is built to satisfy the lookup, but no more.  We are assuming
that each item is defined once and only once.  All that is left is to
define the procedure that inserts new items into the dictionary, lazily:

@example
(define-stream (build-dict puts)
  (if (stream-null? puts)
      stream-null
    (stream-cons
      (stream-car puts)
      (build-dict (stream-cdr puts)))))

@end example

Now we can run the requests and print the result:

@example
(stream-for-each display
  (stream-map cadr (run-dict requests)))
@end example

The @code{(put 4 "d")} definition is never added to the dictionary
because it is never needed.


@c page
@node streams examples pitfalls
@subsection Pitfalls


Programming with streams, or any lazy evaluator, can be tricky, even for
programmers experienced in the genre.  Programming with streams is even
worse in Scheme than in a purely functional language, because, though
the streams are lazy, the surrounding Scheme expressions in which they
are embedded are eager.  The impedance between lazy and eager can
occasionally lead to astonishing results.  Thirty--two years ago,
William Burge warned:

@quotation
Some care must be taken when a stream is produced to make sure that its
elements are not really a list in disguise, in other words, to make sure
that the stream elements are not materialized too soon.
@end quotation

For example, a simple version of @func{stream-map} that returns a stream
built by applying a unary procedure to the elements of an input stream
could be defined like this:

@example
(define-stream (stream-map proc strm) ;wrong!
  (let loop ([strm strm])
    (if (stream-null? strm)
        stream-null
      (stream-cons
        (proc (stream-car strm))
        (loop (stream-cdr strm))))))
@end example

That looks right.  It properly wraps the procedure in
@func{stream-lambda}, and the two legs of the @func{if} both return
streams, so it type--checks.  But it fails because the named @func{let}
binds @var{loop} to a procedure using normal @func{lambda} rather than
@func{stream-lambda}, so even though the first element of the result
stream is lazy, subsequent elements are eager.  @func{stream-map} can be
written using @func{stream-let}:

@example
(define-stream (stream-map proc strm)
  (stream-let loop ([strm strm])
    (if (stream-null? strm)
        stream-null
      (stream-cons
        (proc (stream-car strm))
        (loop (stream-cdr strm))))))
@end example

Here, @func{stream-let} assures that each element of the result stream
is properly delayed, because each is subject to the @func{stream-lambda}
that is implicit in @func{stream-let}, so the result is truly a stream,
not a ``list in disguise''.  Another version of this procedure was given
previously at the description of @func{define-stream}.

Another common problem occurs when a stream--valued procedure requires
the next stream element in its definition.  Consider this definition of
@func{stream-unique}:

@example
(define-stream (stream-unique eql? strm) ;wrong!
  (stream-match strm
    [() strm]
    [(_) strm]
    [(a b . _)
     (if (eql? a b)
         (stream-unique eql?
           (stream-cdr strm))
       (stream-cons a
         (stream-unique eql?
           (stream-cdr strm))))]))
@end example

@noindent
the @code{(a b . _)} pattern requires the value of the next stream
element after the one being considered.  Thus, to compute the nth
element of the stream, one must know the n+1st element, and to compute
the n+1st element, one must know the n+2nd element, and to compute...
The correct version, given above in the description of
@func{stream-drop-while}, only needs the current stream element.

A similar problem occurs when the stream expression uses the previous
element to compute the current element:

@example
(define (nat n)
  (stream-ref
    (stream-let loop ([s (stream 0)])
      (stream-cons (stream-car s)
        (loop (stream (add1 (stream-car s))))))
    n))
@end example

@noindent
this program traverses the stream of natural numbers, building the
stream as it goes.  The definition is correct: @code{(nat 15)} evaluates
to 15; but it needlessly uses unbounded space because each stream
element holds the value of the prior stream element in the binding to
@var{s}.

When traversing a stream, it is easy to write the expression in such a
way that evaluation requires unbounded space, even when that is not
strictly necessary.  During the discussion of @ansrfi{40}, Joe Marshall
created this infamous procedure:

@example
(define (times3 n)
  (stream-ref
    (stream-filter
      (lambda (x)
        (zero? (modulo x n)))
      (stream-from 0))
    3))
@end example

@noindent
@code{(times3 5)} evaluates to 15 and @code{(times3 #e1e9)} evaluates to
three billion, though it takes a while.  In either case, @func{times3}
should operate in bounded space, since each iteration mutates the
promise that holds the next value.  But it is easy to write
@func{times3} so that it does not operate in bounded space, as the
follies of @ansrfi{40} showed.

The common problem is that some element of the stream (often the first
element) is bound outside the expression that is computing the stream,
so it holds the head of the stream, which holds the second element, and
so on.  In addition to testing the programmer, this procedure tests the
stream primitives (it caught several errors during development) and also
tests the underlying Scheme system (it found a bug in one
implementation).

Laziness is no defense against an infinite loop; for instance, the
expression below never returns, because the @func{odd?} predicate never
finds an odd stream element.

@example
(stream-null?
  (stream-filter odd?
    (stream-from 0 2)))
@end example

Ultimately, streams are defined as promises, which are implemented as
thunks (lambda with no arguments).  Since a stream is a procedure,
comparisons such as @func{eq?}, @func{eqv?} and @func{equal?} are not
meaningful when applied to streams.  For instance, the expression

@example
(define s ((stream-lambda () stream-null)))
@end example

@noindent
defines @var{s} as the null stream, and @code{(stream-null? s)} is
@true{}, but @code{(eq?  s stream-null)} is @false{}.

To determine if two streams are equal, it is necessary to evaluate the
elements in their common prefixes, reporting @false{} if two elements
ever differ and @true{} if both streams are exhausted at the same time.

@example
(define (stream-equal? eql? xs ys)
  (cond [(and (stream-null? xs)
              (stream-null? ys)) #t]
        [(or (stream-null? xs)
             (stream-null? ys)) #f]
        [(not (eql? (stream-car xs)
                    (stream-car ys))) #f]
        [else (stream-equal? eql?
                (stream-cdr xs)
                (stream-cdr ys))]))
@end example

It is generally not a good idea to mix lazy streams with eager
side--effects, because the order in which stream elements are evaluated
determines the order in which the side--effects occur.  For a simple
example, consider this side--effecting version of @func{strm123}:

@example
(define strm123-with-side-effects
  (stream-cons (begin (display "one") 1)
    (stream-cons (begin (display "two") 2)
      (stream-cons (begin (display "three") 3)
        stream-null))))
@end example

The stream has elements @code{1 2 3}.  But depending on the order in
which stream elements are accessed, @code{"one"}, @code{"two"} and
@code{"three"} could be printed in any order.

Since the performance of streams can be very poor, normal (eager) lists
should be preferred to streams unless there is some compelling reason to
the contrary.  For instance, computing pythagorean triples with streams:

@example
(stream-ref
  (stream-of (list a b c)
    (n in (stream-from 1))
    (a in (stream-range 1 n))
    (b in (stream-range a n))
    (c is (- n a b))
    (= (+ (* a a) (* b b)) (* c c)))
  50)
@end example

@noindent
is about two orders of magnitude slower than the equivalent expression
using loops:

@example
(do ([n 1 (+ n 1)]) ([> n 228])
  (do ([a 1 (+ a 1)]) ([> a n])
    (do ([b a (+ b 1)]) ([> b n])
      (let ([c (- n a b)])
        (if (= (+ (* a a) (* b b)) (* c c))
            (display (list a b c)))))))
@end example


@c page
@node streams ack
@section Acknowledgments


Jos Koot sharpened my thinking during many email discussions, suggested
several discussion points in the text, and contributed the final version
of @func{stream-match}. Michael Sperber and Abdulaziz Ghuloum gave
advice on @rnrs{6}.


@c page
@node streams references
@section References


All cited web pages visited during September 2007.


@noindent
Harold Abelson and Gerald Jay Sussman with Julie Sussman.
@emph{Structure and Interpretation of Computer Programs}.  @acronym{MIT}
Press, Cambridge, Massachusetts.  Second edition, 1996.  The classic
text on computer science.  Section 3.5 includes extensive discussion of
odd streams.

@center @url{mitpress.mit.edu/sicp}

@noindent
Anne L. Bewig.  @emph{Golden Ratio} (personal communication).  Homework
for the high school course Calculus.  Teaching my daughter how to
calculate the 200th element of a continued fraction was a moment of
sheer joy in the development of the stream libraries.

@noindent
Philip L. Bewig.  @emph{Scheme Request for Implementation 40: A Library
of Streams}.  August, 2004.  Describes an implementation of the stream
data type.

@center @url{srfi.schemers.org/srfi-40}

@noindent
Richard Bird and Philip Wadler.  @emph{Introduction to Functional
Programming}.  Prentice Hall, 1988.  The classic text on functional
programming.  Even streams are discussed in the context of purely
functional programming.

@noindent
William H. Burge.  @emph{Recursive Programming Techniques}.
Addison--Wesley, 1975.  An early text on functional programming, and
still one of the best, though the terminology is dated.  Discusses even
streams in Section 3.10.

@noindent
Jeremy Gibbons, David Lester and Richard Bird, @emph{Functional Pearl:
Enumerating the Rationals,} under consideration for publication in
Journal of Functional Programming.  Discusses a series of expressions
that enumerate the rational numbers without duplicates.

@center @url{http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/rationals.pdf}

@noindent
Carl Hewitt.  @emph{Viewing control structures as patterns of passing
messages,} in Journal of Artificial Intelligence, Volume 8, Number 3
(June, 1977), pp 323-364.  Also published as Artificial Intelligence
Memo 410 by the Massachusetts Institute of Technology.  Describes the
Actor message-passing system; one of the examples used is the
@func{same-fringe?} problem.

@center @url{ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-410.pdf}

@noindent
Peter J. Landin.  @emph{A correspondence between ALGOL 60 and Church's
lambda-notation: Part I,} Communications of the ACM, Volume 8, Number 2,
February 1965, pages 89-101.  The seminal description of streams.

@noindent
Joe Marshall.  "Stream problem redux", from Usenet comp.lang.scheme,
June 28, 2002.  The original post on comp.lang.scheme that describes the
times3 problem.

@center @url{groups.google.com/group/comp.lang.scheme/msg/db4b4a1f33e3eea8}

@noindent
Chris Okasaki.  @emph{Purely Functional Data Structures}.  Cambridge
University Press, 2003.  Revised version of Okasaki's thesis Purely
Functional Data Structures, Carnegie--Mellon University, 1996.  Provides
a strong defense of laziness, and describes several data structures that
exploit laziness, including streams and queues.

@center @url{www.cs.cmu.edu/~rwh/theses/okasaki.pdf}

@noindent
Stephen K. Park and Keith W. Miller.  @emph{Random number generators:
good ones are hard to find}, Communications of the ACM, Volume 31, Issue
10 (October 1988), pages 1192--1201.  Describes a minimal standard
random number generator.

@noindent
Simon Peyton--Jones, et al, editors.  @emph{Haskell 98: Haskell 98
Language and Libraries: The Revised Report}.  December 2002.  Haskell is
the prototypical purely functional language, and includes even streams,
which it calls lists, as its fundamental structured data type.

@center @url{www.haskell.org/onlinereport}

@noindent
Chris Reade.  @emph{Elements of Functional Programming}.
Addison--Wesley, April 1989.  A textbook on functional programming.

@noindent
Antoine de Saint--Exupery.  Chapter III @emph{"L'Avion" of Terre des
Hommes}.  1939.  ``Perfection is achieved, not when there is nothing
more to add, but when there is nothing left to take away.''

@noindent
Dorai Sitaram.  @emph{Teach Yourself Scheme in Fixnum Days}.  A useful
introduction to Scheme; includes generator and co--routine solutions to
the @func{same-fringe?} problem.

@center @url{www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html}

@noindent
Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton von Straaten,
editors.  @emph{Revised6 Report on the Algorithmic Language Scheme}.
September 26, 2007.  @url{www.r6rs.org}.  The standard definition of the
Scheme programming language.

@noindent
Andre van Tonder.  @emph{Scheme Request for Implementation 45:
Primitives for Expressing Iterative Lazy Algorithms}.  April, 2004.
Describes the problems inherent in the promise data type of @rnrs{5}
(also present in @rnrs{6}), and provides the alternate promise data type
used in the stream primitives.

@center @url{srfi.schemers.org/srfi-45}

@noindent
Philip Wadler.  @emph{How to replace failure by a list of successes}, in
Proceedings of the conference on functional programming languages and
computer architecture, Nancy, France, 1985, pages 113--128.  Describes
the ``list of successes'' technique for implementing backtracking
algorithms using streams.

@noindent
Philip Wadler, Walid Taha, and David MacQueen.  @emph{How to add
laziness to a strict language without even being odd.} 1998 ACM SIGPLAN
Workshop on @acronym{ML}, pp. 24ff.  Describes odd and even styles of
lazy evaluation, and shows how to add lazy evaluation to the strict
functional language @acronym{SML}.

@center @url{homepages.inf.ed.ac.uk/wadler/papers/lazyinstrict/lazyinstrict.ps}



@c page
@node eager-comp
@chapter Eager comprehensions


@cindex @srfi{} eager-comp


The @library{srfi eager-comprehensions} library has been written by
Sebastian Egner as the reference implementation for @ansrfi{42}.


@menu
* eager-comp license::          Original license.
* eager-comp abstract::         Abstract.
* eager-comp rationale::        Rationale.
* eager-comp spec::             Specification.
* eager-comp design::           Design rationale.
* eager-comp ack::              Related work and acknowledgements.
* eager-comp references::       References.
@end menu


@c page
@node eager-comp license
@section Original license


Copyright @copyright{} 2003 Sebastian Egner.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



@c page
@node eager-comp abstract
@section Abstract


This @srfi{} defines a modular and portable mechanism for eager
comprehensions extending the algorithmic language Scheme.  An eager
comprehension is a convenient notation for one or more nested or
parallel loops generating a sequence of values, and accumulating this
sequence into a result.  In its most simple form, a comprehension
according to this @srfi{} looks like this:

@example
(list-ec (: i 5)
  (* i i))
=> (0 1 4 9 16)
@end example

@noindent
Here, @var{i} is a local variable that is sequentially bound to the
values 0, 1, @dots{}, 4, and the squares of these numbers are collected
in a list.  The following example illustrates most conventions of this
@srfi{} with respect to nesting and syntax:

@example
(list-ec (: n 1 4)
         (: i n)
  (list n i))
=> ((1 0) (2 0) (2 1) (3 0) (3 1) (3 2))
@end example

@noindent
In the example, the variable @var{n} is first bound to 1 then to 2 and
finally to 3, and for each binding of @var{n} the variable @var{i} is
bound to the values 0, 1, ..., @var{n}-1 in turn.  The expression
@code{(list n i)} constructs a two--element list for each bindings, and
the comprehension @func{list-ec} collects all these results in a list.

The mechanism defined in this @srfi{} has the following properties:

@itemize
@item
The set of comprehensions defined for this @srfi{} is inspired by those
procedures and macros of @rnrs{5} leading to natural comprehensions such
as @func{list-ec}, @func{append-ec}, @func{sum-ec}, @func{min-ec},
@func{every?-ec}, @func{do-ec}, and others.  Some other natural
comprehensions (e.g. @func{gcd-ec}) have not been included into this
@srfi{} due to their low significance for most applications.  On the
other hand, a few comprehensions (@func{fold-ec}, @func{fold3-ec}) not
inspired by @rnrs{5} have been included due to their broad
applicability.

@item
There are typed generators (@code{:list}, @code{:string}, @dots{})
expecting certain types of objects for their arguments.  These
generators usually produce code as efficient as hand coded
@func{do}--loops.

@item
There is also the special generator @code{:} (read ``run through'')
dispatching on the value of its argument list at runtime.  In the
examples above, one or two integers were used to define a range.  The
convenience of omitting the type comes at a certain performance penalty,
both per iteration and during startup of the loop.

@item
Generators can be nested depth--first (as in the example above), run in
parallel (with an optional index variable or more generally with
@code{:parallel}), and can be stopped early before (@code{:while}) or
after (@code{:until}) producing the current value.

@item
The sequence of values can be filtered (@func{if}, @func{not},
@func{and}, @func{or}), intermediate commands can be evaluated between
generators (@func{begin}), and intermediate variables can be introduced
(@func{:let}).

@item
The mechanism is fully modular.  This means that no existing macro or
procedure needs to be modified when adding application--specific
comprehensions, application--specific typed generators, or
application--specific dispatching generators.

@item
Syntactically, this @srfi{} uses the @code{[outer .. inner | expr]}
convention, meaning that the most right generator (@var{inner}) spins
fastest and is followed by the result expression over which the
comprehension ranges (@var{expr}).  @ref{eager-comp design} for details.
Moreover, the syntax is strictly prefix and the naming convention
@code{my-comprehension-ec}, @code{:my-generator} is used systematically.
@end itemize

@ignore
The remainder of this document is organized as follows.  In section
Rationale a brief introduction is given what the motivation is for this
@srfi{}.  The following section Specification defines the mechanism.
Section Suggestions for Application-specific Extensions presents some
ideas how extensions using this @srfi{} could look like.  The section
Design Rationale contains some considerations that went into the design
of the mechanism as defined in the specification.  The following section
Related Work and Acknowledgements briefly reviews other proposals
related to Scheme and comprehensions or loops.  Finally, the section
Reference Implementation gives source code for a reference
implementation together with a collection of runnable examples and a few
examples on extensions.
@end ignore



@c page
@node eager-comp rationale
@section Rationale


The purpose of this @srfi{} is to provide a compact notation for many
common cases of loops, in particular those constructing values for
further computation.  The origin of this @srfi{} is my frustration that
there is no simple way to iterate the list of integers from 0 to
@var{n}-1.  With this @srfi{} it is @func{(list-ec (: i n) i)}.  Refer
to the collection of examples for the reference implementation to
understand what it can be used for, and what it should not be used for.
To give a practically useful example, the following procedure computes
the sorted list of all prime numbers below a certain bound (you may want
to run it yourself to get an idea of its efficiency):

@example
;; primes in @{2..n-1@} for n >= 1
(define (eratosthenes n)
  (let ([p? (make-string n #\1)])
    (do-ec (:range k 2 n)
           (if (char=? (string-ref p? k) #\1))
           (:range i (* 2 k) n k)
      (string-set! p? i #\0))
    (list-ec (:range k 2 n)
             (if (char=? (string-ref p? k) #\1))
      k)))
@end example

Apart from making simple things simple, there is no other paradigm
involved for this @srfi{}.  In particular, it is not the ambition to
implement the powerful lazy list comprehensions of other functional
programming languages in Scheme.  If you are looking for that you may
want to refer to @ansrfi{41}.  (The usual definition of the stream of all
primes does in fact also use Eratosthenes' sieve method.  It is
instructive to compare.)

The main focus of the design of this @srfi{} is portability under
@rnrs{5} and modularity for extension.  Portability is achieved by
limiting the features included.  Modularity for generators is achieved
by a special implementation technique using Continuation Passing Style
for macros (which I learned from Richard Kelsey's implementation of
``Macros for writing loops'') and by limiting the expressive power of
generators.  Modularity for comprehensions requires no additional
effort.  As modularity was a major design goal, I hope many people will
find it easy to define their own comprehensions and generators.  As a
starting point for doing so, I have included several suggestions for
extensions.

@ref{eager-comp design} for a detailed motivation of the design
decisions.



@c page
@node eager-comp spec
@section Specification


A comprehensions is a hygienic referentially transparent macro in the
sense of @rnrs{5} Section 4.3.  The macros extend the
@code{<expression>}--syntax defined in @rnrs{5} Section 7.1.3.  The main
syntactic pattern used for defining a comprehension is
@code{<qualifier>}, representing a generator or a filter.  It is defined
in Section ``Qualifiers''.

The most important instances of @code{<qualifier>} are generators.
These are defined in Section ``Generators''.  Generators come in three
flavors, as typed generators (@code{:list}, @code{:range}, etc.), as the
dispatching generator @code{:} (pronounced as ``run through''), and as
combined and modified generators (@code{:parallel}, @code{:while},
@code{:until}).  Most generators in this @srfi{} also support an
optional index variable counting the values being generated.

Finally, it is explained how to add a new application--specific
comprehension, how to add a new application--specific typed generator,
and how to add a new application--specific dispatching generator.  As
this concerns code unknown at the time this is being written, the
explanation should not be taken as a specification in the literal sense.
It rather suggests a convention to follow in order to ensure new
comprehensions and generators blend seamlessly with the ones defined in
this @srfi{}.

@menu
* eager-comp spec comprehensions::      Comprehensions.
* eager-comp spec qualifiers::          Qualifiers.
* eager-comp spec generators::          Generators.
* eager-comp spec suggest::             Suggestions for application
                                        specific extensions.
@end menu

@c page
@node eager-comp spec comprehensions
@subsection Comprehensions


@deffn Syntax do-ec @var{qualifier*} @var{command}
Evaluate the @var{command} exactly once for each binding in the sequence
defined by the qualifiers.  If there are no qualifiers @var{command} is
evaluated exactly once.  The expression is evaluated for its
side--effects only.  The result of the comprehension is unspecified.
@end deffn


@deffn Syntax list-ec @var{qualifier*} @var{expression}
The list of values obtained by evaluating @var{expression} once for each
binding in the sequence defined by the qualifiers.  If there are no
qualifiers the result is the list with the value of @var{expression}.
@end deffn


@deffn Syntax append-ec @var{qualifier*} @var{expression}
The list obtained by appending all values of @var{expression}, which
must all be lists.  Think of it as:

@example
(apply append (list-ec @var{qualifier*} @var{expression}))
@end example
@end deffn


@deffn Syntax string-ec @var{qualifier*} @var{expression}
The string of all values of @var{expression}.  Think of it as:

@example
(list->string (list-ec @var{qualifier*} @var{expression}))
@end example
@end deffn


@deffn Syntax string-append-ec @var{qualifier*} @var{expression}
The string obtained by appending all values of @var{expression}, which
must all be strings.  Think of it as:

@example
(apply string-append (list-ec @var{qualifier*} @var{expression}))
@end example
@end deffn


@deffn Syntax vector-ec @var{qualifier*} @var{expression}
The vector of all values of @var{expression}.  Think of it as:

@example
(list->vector (list-ec @var{qualifier*} @var{expression}))
@end example
@end deffn


@deffn Syntax vector-of-length-ec @var{k} @var{qualifier*} @var{expression}
The vector of all values of @var{expression}, of which there must be
exactly @var{k}.  This comprehension behaves like @func{vector-ec} but
can be implemented more efficiently.
@end deffn


@deffn Syntax sum-ec @var{qualifier*} @var{expression}
The sum of all values of @var{expression}.  Think of it as:

@example
(apply + (list-ec @var{qualifier*} @var{expression}))
@end example
@end deffn


@deffn Syntax product-ec @var{qualifier*} @var{expression}
The product of all values of @var{expression}.  Think of it as:

@example
(apply * (list-ec @var{qualifier*} @var{expression}))
@end example
@end deffn


@deffn Syntax min-ec @var{qualifier*} @var{expression}
@deffnx Syntax max-ec @var{qualifier*} @var{expression}
The minimum and maximum of all values of @var{expression}.  The sequence
of values must be non-empty.  Think of these as

@example
(apply min (list-ec @var{qualifier*} @var{expression}))
(apply max (list-ec @var{qualifier*} @var{expression}))
@end example

If you want to return a default value in case the sequence is empty you
may want to consider:

@example
(fold3-ec 'infinity @var{qualifier*} @var{expression} min min)
@end example
@end deffn


@deffn Syntax any?-ec @var{qualifier*} @var{test}
Tests whether any value of @var{test} in the sequence of bindings
specified by the qualifiers is non--@false{}.  If this is the case,
@true{} is returned, otherwise @false{}.  If there are no bindings at
all, in the sequence specified by the qualifiers, then the result is
@false{}.  The enumeration of values stops after the first non--@false{}
encountered.
@end deffn


@deffn Syntax every?-ec @var{qualifier*} @var{test}
Tests whether all values of @var{test} are non--@false{}.  If this is
the case, @true{} is returned, otherwise @false{}.  If the sequence is
empty the result is @true{}.  Enumeration stops after the first
@false{}.
@end deffn


@deffn Syntax first-ec @var{default} @var{qualifier*} @var{expression}
@deffnx Syntax last-ec  @var{default} @var{qualifier*} @var{expression}
The first or last value of @var{expression} in the sequence of bindings
specified by the qualifiers.  Before enumeration, the result is
initialized with the value of @var{default}; so this will be the result
if the sequence is empty.  Enumeration is terminated in @func{first-ec}
when the first value has been computed.
@end deffn


@deffn Syntax fold-ec  @var{x0} @var{qualifier*} @var{expression} @var{f2})
@deffnx Syntax fold3-ec @var{x0} @var{qualifier*} @var{expression} @var{f1} @var{f2})
Reduce the sequence @var{x}[0], @var{x}[1], @dots{}, @var{x}[n-1] of
values obtained by evaluating @var{expression} once for each binding as
specified by @var{qualifier*}.  The arguments @var{x0}, @var{f2}, and
@var{f1}, all syntactically equivalent to @var{expression}, specify the
reduction process.

The reduction process for @func{fold-ec} is defined as follows.  A
reduction variable @var{x} is initialized to the value of @var{x0}, and
for each @var{k} in @code{@{0, ..., n-1@}} the command:

@example
(set! x (f2 x[k] x))
@end example

@noindent
is evaluated.  Finally, @var{x} is returned as the value of the
comprehension.

The reduction process for @func{fold3-ec} is different.  If and only if
@code{n = 0}, i.e. the sequence is empty, then @var{x0} is evaluated and
returned as the value of the comprehension.  Otherwise, a reduction
variable @var{x} is initialized to the value of @code{(f1 x[0])}, and
for each @var{k} in @code{@{1, ..., n-1@}} the command:

@example
(set! x (f2 x[k] x))
@end example

@noindent
is evaluated.  Finally, @var{x} is returned as the value of the
comprehension.

As the order of the arguments suggests, @var{x0} is evaluated outside
the scope of the qualifiers, whereas the reduction expressions involving
@var{f1} and @var{f2} are inside the scope of the qualifiers (so they
may depend on any variable introduced by the qualifiers).  Note that
@var{f2} is evaluated repeatedly, with any side--effect or overhead this
might have.

The main purpose of these comprehensions is implementing other
comprehensions as special cases.  They are generalizations of the
procedures @func{fold} and @func{reduce} in the sense of @ansrfi{1}.
(Concerning naming and argument order, please refer to the discussion
archive of @ansrfi{1}, in particular the posting [Folds].)  Note that
@func{fold3-ec} is defined such that @var{x0} is only evaluated in case
the sequence is empty.  This allows raising an error for the empty
sequence, as in the example definition of @func{min-ec} below.
@end deffn

@c ------------------------------------------------------------

@subsubheading Application--specific comprehension


An important aspect of this @srfi{} is a modular mechanism to define
application--specific comprehensions.  To create a new comprehension a
hygienic macro with that name is defined.  The macro transforms the new
comprehension patterns into instances of @func{do-ec}, which is the most
fundamental eager comprehension, or any other comprehension already
defined.  For example, the following code defines @func{list-ec} and
@func{min-ec} in terms of @func{fold-ec} and @func{fold3-ec}:

@example
(define-syntax list-ec
  (syntax-rules ()
    [(list-ec etc1 etc ...)
     (reverse (fold-ec '() etc1 etc ... cons))]))

(define-syntax min-ec
  (syntax-rules ()
    [(min-ec etc1 etc ...)
     (fold3-ec (min) etc1 etc ... min min)]))
@end example

Note that the pattern @code{@var{etc1} ...} matches the syntax
@var{qualifier*} @var{expression} without separate access to
@var{qualifier*} and @var{expression}.  In order to define a
comprehension that does need explicit access to the @var{expression}
part, the following method is used.

First, all qualifiers are collected into a nested--qualifier, and then
the ``exactly one qualifier'' case is implemented.  For illustration,
the following code defines @func{fold3-ec} in terms of @func{do-ec}:

@example
(define-syntax fold3-ec
  (syntax-rules (nested)
    [(fold3-ec x0 (nested q1 ...) q etc1 etc2 etc3 etc ...)
     (fold3-ec x0 (nested q1 ... q) etc1 etc2 etc3 etc ...)]
    [(fold3-ec x0 q1 q2 etc1 etc2 etc3 etc ...)
     (fold3-ec x0 (nested q1 q2) etc1 etc2 etc3 etc ...)]
    [(fold3-ec x0 expression f1 f2)
     (fold3-ec x0 (nested) expression f1 f2)]

    [(fold3-ec x0 qualifier expression f1 f2)
     (let ([result #f]
           [empty  #t])
       (do-ec qualifier
         (let ([value expression]) ; don't duplicate code
           (if empty
               (begin
                 (set! result (f1 value))
                 (set! empty #f))
             (set! result (f2 value result)))))
       (if empty x0 result))]))
@end example

Finally, observe that the newly defined @func{fold3-ec} comprehension
inherits all types of qualifiers supported by @func{do-ec}, including
all application--specific generators; no further definitions are
necessary.



@c page
@node eager-comp spec qualifiers
@subsection Qualifiers


This section defines the syntax @var{qualifier}.  The nesting of
qualifiers is from left (outer) to right (inner).  In other words, the
rightmost generator spins fastest.  The nesting also defines the scope
of the variables introduced by the generators.  This implies that inner
generators may depend on the variables of outer generators.  The
sequence of enumeration of values is strictly depth first.  These
conventions are illustrated by the first example.

The syntax @var{qualifier} consists of the following alternatives.

@deffn Qualifier @var{generator}
Enumerate a sequence of bindings of one or more variables.  The scope of
the variables starts at the generator and extends over all subsequent
qualifiers and expressions in the comprehension.  @ref{eager-comp spec
generators}.
@end deffn


@deffn Qualifier if @var{test}
Filters the sequence of bindings by testing if @var{test} evaluates to
non--@false{}.  Only for those bindings for which this is the case, the
subsequent qualifiers of the comprehension are evaluated.
@end deffn


@deffn Qualifier not @var{test}
@deffnx Qualifier and @var{test}*
@deffnx Qualifier or @var{test}*
Abbreviated notations for filters of the form @code{(if (not
@var{test}))}, @code{(if (and @var{test}*))}, and @code{(if (or
@var{test}*))}.  These represent frequent cases of filters.
@end deffn


@deffn Qualifier begin @var{sequence}
Evaluate @var{sequence}, consisting of @code{@var{command}*
@var{expression}}, once for each binding of the variables defined by the
previous qualifiers in the comprehension.  Using this qualifier, side
effects can be inserted into the body of a comprehension.
@end deffn


@deffn Qualifier nested @var{qualifier}*
A syntactic construct to group qualifiers.  The meaning of a qualifier
according to the @func{nested} syntax is the same as inserting
@var{qualifier}* into the enclosing comprehension.  This construct can
be used to reduce comprehensions with several qualifiers into a form
with exactly one qualifier.
@end deffn



@c page
@node eager-comp spec generators
@subsection Generators


This section defines the syntax @var{generator}.  Each generator defines
a sequence of bindings through which one or more variables are run.  The
scope of the variables begins after the closing parenthesis of the
generator expression and extends to the end of the comprehension it is
part of.

The variables defined by the generators are specified using the syntax:

@example
<vars> --> <variable1> [ (index <variable2>) ]
@end example

@noindent
where @var{variable1} runs through the values in the sequence defined by
the generator, and the optional @var{variable2} is an exact
integer--valued index variable counting the values (starting from 0).
The names of the variables must be distinct.  The following example
illustrates the index variable:

@example
(list-ec (: x (index i) "abc")
   (list x i))
=> ((#\a 0) (#\b 1) (#\c 2))
@end example

Unless defined otherwise, all generators make sure that the expressions
provided for their syntactic arguments are evaluated exactly once,
before enumeration begins.  Moreover, it may be assumed that the
generators do not copy the code provided for their arguments, because
that could lead to exponential growth in code size.  Finally, it is
possible to assign a value to the variables defined by a generator, but
the effect of this assignment is unspecified.

The syntax @var{generator} consists of the following alternatives.

@ignore
(Tue Oct 28, 2008, Info version 4.8) The ':' is not recognised by the
function index code as a valid function name.  No error is generated
when compiling this document, but the index reference does not work.
@end ignore
@deffn Generator {:} @var{vars} @var{arg1} @var{arg}*
First the expressions @var{arg1} @var{arg}* are evaluated into
@code{@var{a}[1]}, @code{@var{a}[2]}, @dots{}, @code{@var{a}[n]} and
then a global dispatch procedure is used to dispatch on the number and
types of the arguments and run the resulting generator.  Initially
(after loading the @srfi{}), the following cases are recognized:

@example
:list           if      for all i in @{1..n@}: (list? a[i])

:string         if      for all i in @{1..n@}: (string? a[i])

:vector         if      for all i in @{1..n@}: (vector? a[i])

:range          if      n in @{1..3@} and for all i in @{1..n@}:
                        (integer? a[i]) and (exact? a[i])

:real-range     if      n in @{1..3@} and for all i in @{1..n@}:
                        (real? a[i])

:char-range     if      n = 2 and for all i in @{1, 2@}:
                        (char? a[i])

:port           if      n in @{1, 2@} and (input-port? a[1])
                        and (procedure? a[2])
@end example

The current dispatcher can be retrieved as @code{(:-dispatch-ref)}, a
new dispatcher @var{d} can be installed by @code{(:-dispatch-set! d)}
yielding an unspecified result, and a copy of the initial dispatcher can
be obtained as @code{(make-initial-:-dispatch)}.  Please refer to the
section below for recommendation how to add cases to the dispatcher.
@end deffn


@deffn Generator {:list} @var{vars} @var{arg1} @var{arg}*
@deffnx Generator {:string} @var{vars} @var{arg1} @var{arg}*
@deffnx Generator {:vector} @var{vars} @var{arg1} @var{arg}*
Run through one or more lists, strings, or vectors.  First all
expressions in @var{arg1} @code{@var{arg}*} are evaluated and then all
elements of the resulting values are enumerated from left to right.  One
can think of it as first appending all arguments and then enumerating
the combined object.  As a clarifying example, consider:

@example
(list-ec (:string c (index i) "a" "b")
  (cons c i))
=> ((#\a . 0)
    (#\b . 1))
@end example
@end deffn


@deffn Generator {:integers} @var{vars}
Runs through the sequence @code{0}, @code{1}, @code{2}, @dots{} of
non--negative integers.  This is most useful in combination with
@code{:parallel}, @code{:while}, and @code{:until} or with a non--local
exit in the body of the comprehension.
@end deffn


@deffn Generator {:range} @var{vars} @var{stop}
@deffnx Generator {:range} @var{vars} @var{start} @var{stop}
@deffnx Generator {:range} @var{vars} @var{start} @var{stop} @var{step}
Runs through a range of exact rational numbers.

The form @code{(:range @var{vars} @var{stop})} evaluates the expression
@var{stop}, which must result in an exact integer @var{n}, and runs
through the finite sequence @code{0}, @code{1}, @code{2}, @dots{},
@code{@var{n}-1}.  If @var{n} is zero or negative the sequence is empty.

The form @code{(:range @var{vars} @var{start} @var{stop})} evaluates the
expressions @var{start} and @var{stop}, which must result in exact
integers @var{a} and @var{b}, and runs through the finite sequence
@var{a}, @code{@var{a}+1}, @code{@var{a}+2}, @dots{}, @code{@var{b}-1}.
If @var{b} is less or equal @var{a} then the sequence is empty.

The form @code{(:range @var{vars} @var{start} @var{stop} @var{step})}
first evaluates the expressions @var{start}, @var{stop}, and @var{step},
which must result in exact integers @var{a}, @var{b}, and @var{s} such
that @var{s} is unequal to zero.  Then the sequence @var{a},
@code{@var{a} + @var{s}}, @code{@var{a} + 2 @var{s}}, @dots{},
@code{@var{a} + (@var{n}-1) @var{s}} is enumerated where @code{@var{n} =
ceil((@var{b}-@var{a})/@var{s})}.  In other words, the sequence starts
at @var{a}, increments by @var{s}, and stops when the next value would
reach or cross @var{b}.  If @var{n} is zero or negative the sequence is
empty.
@end deffn


@deffn Generator {:real-range} @var{vars} @var{stop}
@deffnx Generator {:real-range} @var{vars} @var{start} @var{stop}
@deffnx Generator {:real-range} @var{vars} @var{start} @var{stop} @var{step}
Runs through a range of real numbers using an explicit index variable.
This form of range enumeration avoids accumulation of rounding errors
and is the one to use if any of the numbers defining the range is
inexact, not an integer, or a bignum of large magnitude.

Providing default value @code{0} for @var{start} and @code{1} for
@var{step}, the generator first evaluates @var{start}, @var{stop}, and
@var{step}, which must result in reals @var{a}, @var{b}, and @var{s}
such that @code{@var{n} = (@var{b}-@var{a})/@var{s}} is also
representable as a real.  Then the sequence @code{0}, @code{1},
@code{2}, @dots{} is enumerated while the current value @var{i} is less
than @var{n}, and the variable in @var{vars} is bound to the value
@code{@var{a} + @var{i} @var{s}}.  If any of the values @var{a},
@var{b}, or @var{s} is non--exact then all values in the sequence are
non--exact.
@end deffn


@deffn Generator {:char-range} @var{vars} @var{min} @var{max}
Run through a range of characters.  First @var{min} and @var{max} are
evaluated, which must result in two characters @var{a} and @var{b}.
Then the sequence of characters @var{a}, @code{@var{a}+1},
@code{@var{a}+2}, @dots{}, @var{b} is enumerated in the order defined by
@func{char<=?} in the sense of @rnrs{5} Section 6.3.4.  If @var{b} is
smaller than @var{a} then the sequence is empty.  (Note that @var{b} is
included in the sequence.)
@end deffn


@deffn Generator {:port} @var{vars} @var{port}
@deffnx Generator {:port} @var{vars} @var{port} @var{read-proc}
Read from the port until the eof--object is read.  Providing the default
read for @var{read-proc}, the generator first evaluates @var{port} and
@var{read-proc}, which must result in an input port @var{p} and a
procedure @var{r}.  Then the variable is run through the sequence
obtained by @code{(@var{r} @var{p})} while the result does not satisfy
@func{eof-object?}.
@end deffn


@deffn Generator {:dispatched} @var{vars} @var{dispatch} @var{arg1} @var{arg}*
Runs the variables through a sequence defined by @var{dispatch} and
@var{arg1} @var{arg}*.  The purpose of @code{:dispatched} is
implementing dispatched generators, in particular the predefined
dispatching generator @code{:}.

The working of @code{:dispatched} is as follows.  First @var{dispatch}
and @var{arg1} @var{arg}* are evaluated, resulting in a procedure
@var{d} (the ``dispatcher'') and the values @code{@var{a}[1]},
@code{@var{a}[2]}, @dots{}, @code{@var{a}[n]}.  Then:

@example
(d (list a[1] a[2] ... a[n]))
@end example

@noindent
is evaluated, resulting in a value @var{g}.  If @var{g} is not a
procedure then the dispatcher did not recognize the argument list and an
error is raised.  Otherwise the ``generator procedure'' @var{g} is used
to run @var{vars} through a sequence of values.

The sequence defined by @var{g} is obtained by repeated evaluation of
@code{(@var{g} @var{empty})} until the result is @var{empty}.  In other
words, @var{g} indicates the end of the sequence by returning its only
argument, for which the caller has provided an object distinct from
anything @var{g} can produce.  (Generator procedures are state based,
they are no such noble things as streams in the sense of @ansrfi{41}.)

The definition of dispatchers is greatly simplified by the macro
@code{:generator-proc} that constructs a generator procedure from a
typed generator.  Let @code{(@var{g} @var{var} @var{arg1} @var{arg}
...)} be an instance of the @var{generator} syntax, for example an
application--specific typed generator, with a single variable @var{var}
and no index variable.  Then:

@example
(:generator-proc (g arg1 arg ...))
=> g
@end example

@noindent
where the generator procedure @var{g} runs through the list:

@example
(list-ec (g var arg1 arg ...) var)
@end example

In order to define a new dispatching generator (say @code{:my}) first a
dispatching procedure (say @code{:my-dispatch}) is defined.  The
dispatcher will be called with a single (!) argument containing the list
of all values to dispatch on.  To enable informative error messages, the
dispatcher should return a descriptive object (e.g.  a symbol for the
module name) when it is called with the empty list.  Otherwise (if there
is at least one value to dispatch on), the dispatcher must either return
a generator procedure or @false{} (which means: no interest).  As an
example, the following skeleton code defines a dispatcher similar to the
initial dispatcher of @code{:}:

@example
(define (:my-dispatch args)
  (case (length args)
    [(0) 'SRFI-NN]
    [(1) (let ([a1 (car args)])
           (cond
            [(list? a1)
             (:generator-proc (:list a1))]
            [(string? a1)
             (:generator-proc (:string a1))]
            ...more unary cases...
            [else
             #f]))]
    [(2) (let ([a1 (car args)]
               [a2 (cadr args)])
           (cond
            [(and (list? a1) (list? a2))
             (:generator-proc (:list a1 a2))]
            ...more binary cases...
            [else
             #f]))]
    ...more arity cases...
    [else
     (cond
      [(every?-ec (:list a args) (list? a))
       (:generator-proc (:list (apply append args)))]
      ...more large variable arity cases...
      [else
       #f])]))
@end example

Once the dispatcher has been defined, the following macro implements the
new dispatching generator:

@example
(define-syntax :my
  (syntax-rules (index)
    [(:my cc var (index i) arg1 arg ...)
     (:dispatched cc var (index i) :my-dispatch arg1 arg ...)]
    [(:my cc var arg1 arg ...)
     (:dispatched cc var :my-dispatch arg1 arg ...)]))
@end example

This method of extension yields complete control of the dispatching
process.  Other modules can only add cases to @code{:my} if they have
access to @code{:my-dispatch}.

Extending the predefined dispatched generator.  An alternative to adding
a new dispatched generator is to extend the predefined generator
@code{:}.  Technically, extending @code{:} means installing a new global
dispatching procedure using @code{:-dispatch-set!} as described above.
In most cases, however, the already installed dispatcher should be
extended by new cases.  The following procedure is a utility for doing
so:

@example
(dispatch-union d1 d2)
=> d
@end example

@noindent
where the new dispatcher @var{d} recognizes the union of the cases
recognized by the dispatchers @var{d1} and @var{d2}.  The new dispatcher
always tries both component dispatchers and raises an error in case of
conflict.  The identification returned by @code{(d)} is the
concatenation of the component identifications @code{(d1)} and
@code{(d2)}, enclosed in lists if necessary.  For illustration, consider
the following code:

@example
(define (example-dispatch args)
  (cond
   [(null? args)
    'example]
   [(and (= (length args) 1) (symbol? (car args)) )
    (:generator-proc (:string (symbol->string (car args))))]
   [else
    #f]))

(:-dispatch-set! (dispatch-union (:-dispatch-ref) example-dispatch))
@end example

After evaluation of this code, the following example will work:

@example
(list-ec (: c 'abc)
  c)
=> (#\a #\b #\c)
@end example

Adding cases to @code{:} is particularly useful for frequent cases of
interactive input.  Be warned, however, that the advantage of global
extension also carries the danger of conflicts, unexpected
side--effects, and slow dispatching.
@end deffn


@deffn Generator :do (@var{lb}*) @var{ne1?} (@var{ls}*)
@deffnx Generator :do (let (@var{ob}*) @var{oc}*) (@var{lb}*) @var{ne1?} (let (@var{ib}*) @var{ic}*) @var{ne2?} (@var{ls}*)
Defines a generator in terms of a named--@func{let}, optionally
decorated with inner and outer lets.  This generator is for defining
other generators.  (In fact, the reference implementation transforms any
other generator into an instance of fully decorated @code{:do}.)

The generator is a compromise between expressive power (more flexible
loops) and fixed structure (necessary for merging and modifying
generators).

In the fully decorated form, the syntactic variables @var{ob} (outer
binding), @var{oc} (outer command), @var{lb} (loop binding), @var{ne1?}
(not-end1?), @var{ib} (inner binding), @var{ic} (inner command),
@var{ne2?}  (not-end2?), and @var{ls} (loop step) define the following
loop skeleton:

@example
(let (@var{ob}*)
  @var{oc}*
  (let loop (@var{lb}*)
    (if @var{ne1?}
        (let (@var{ib}*)
          @var{ic}*
          payload
          (if @var{ne2?}
              (loop @var{ls}*) )))))
@end example

@noindent
where @code{@var{oc}*} and @code{@var{ic}*} are syntactically equivalent
to @var{command}*, i.e. they do not begin with a @var{definition}.  The
latter requirement allows the code generator to produce more efficient
code for special cases by removing empty @func{let}--expressions
altogether.
@end deffn


@deffn Generator :let @var{vars} @var{expression}
Run through the sequence consisting of the value of @var{expression},
only.  This is the same as:

@example
(:list @var{vars} (list @var{expression}))
@end example

If an index variable is specified, its value is @code{0}.  The
@code{:let} generator can be used to introduce an intermediate variable
depending on outer generators.
@end deffn


@deffn Generator :parallel @var{generator}*
Run several generators in parallel.  This means that the next binding
in the sequence is obtained by advancing each generator in
@code{@var{generator}*} by one step.  The parallel generator terminates
when any of its component generators terminate.  The generators share a
common scope for the variables they introduce.  This implies that the
names of the variables introduced by the various generators must be
distinct.
@end deffn


@deffn Generator :while @var{generator} @var{expression}
Run @var{generator} while @var{expression} evaluates to non--@false{}.
The guarding expression is included in the scope of the variables
introduced by the generator.

Note the distinction between the filter @code{if} and the modified
generator expressed by @code{:while}.
@end deffn


@deffn Generator :until @var{generator} @var{expression}
Run @var{generator} until after @var{expression} has evaluated to
non--@false{}.  The guarding expression is included in the scope of the
variables introduced by the generator.

Note the distinction between @code{:while}, stopping at a certain
condition, and @code{:until}, stopping after a certain condition has
occurred.  The latter implies that the binding that has triggered
termination has been processed by the comprehension.
@end deffn

@c ------------------------------------------------------------

@subsubheading Application specific typed generator


An important aspect of this @srfi{} is a modular mechanism to define
new typed generators.  To define a new typed generator a hygienic
referentially transparent macro of the same name is defined to transform
the generator pattern into an instance of the @code{:do-generator}.  The
extension is fully modular, meaning that no other macro has to be
modified to add the new generator.  This is achieved by defining the new
macro in Continuation Passing Style.

Technically, this works as follows.  Assume the generator syntax:

@example
(:mygen @var{var} @var{arg})
@end example

@noindent
is to be implemented, for example running the variable @var{var} through
the list @code{(reverse @var{arg})}.  The following definition
implements @code{:mygen} in terms of @code{:list} using the additional
syntactic variable @var{cc} (read current continuation):

@example
(define-syntax :mygen
  (syntax-rules ()
    [(:mygen cc var arg)
     (:list cc var (reverse arg))]))
@end example

After this definition, any comprehension will accept the @code{:mygen}
generator and produce the proper code for it.  This works as follows.
When a comprehension sees something of the form @code{(@var{g} @var{arg}
...)} in the position of a @var{qualifier} then it will transform the
entire comprehension into:

@example
(@var{g} (continue ...) @var{arg} ...)
@end example

This effectively ``transfers control'' to the macro @var{g}, for example
@code{:mygen}.  The macro @var{g} has full control of the
transformation, but eventually it should transform the expression into:

@example
(:do (continue ...)  etc ...)
@end example

In the @code{:mygen} example this is done by the @code{:list-macro}.
The macro @code{:do} finally transforms into:

@example
(continue ... (:do etc ...))
@end example

As @code{continue} has been chosen by the macro implementing the
comprehension, it can regain control and proceed with other qualifiers.

In order to ensure consistency of new generators with the ones defined
in this @srfi{}, a few conventions are in order.  Firstly, the
generator patterns begin with one or more variables followed by
arguments defining the sequence.  Secondly, each generator except
@code{:do} can handle an optional index variable.  This is most easily
implemented using @code{:parallel} together with @code{:integers}.  In
case the payload generator needs an index anyhow (e.g. @code{:vector})
it is more efficient to add an index variable if none is given and to
implement the indexed case.  Finally, make sure that no syntactic
variable of the generator pattern ever gets duplicated in the code (to
avoid exponential code size in nested application), and introduce
sufficient intermediate variables to make sure expressions are evaluated
at the correct time.



@c page
@node eager-comp spec suggest
@subsection Suggestions for application specific extensions


@subsubheading Arrays in the sense of @ansrfi{25}

In order to create an array from a sequence of elements, a comprehension
with the following syntax would be useful:

@example
(array-ec @var{shape} @var{qualifier}* @var{expression})
@end example

The comprehension constructs a new array of the given shape by filling
it row--major with the sequence of elements as specified by the
qualifiers.  On the generator side, it would be most useful to have a
generator of the form:

@example
(:array @var{vars} @var{arg})
@end example

@noindent
running through the elements of the array in row--major.  For the
optional index variable, the extension @code{(index @var{k1} @var{k}*)}
could be defined where @var{k1} @code{@var{k}*} are variable names
indexing the various dimensions.

@c ------------------------------------------------------------

@subsubheading Random Numbers in the sense of @ansrfi{27}

In order to create a vector or list of random numbers, it would be
convenient to have generators of the following form:

@example
(:random-integer [ @var{range} [ @var{number} ] ] )
(:random-real    [ @var{number} ] )
@end example

@noindent
where @var{range} (default 2) indicates the range of the integers and
@var{number} (default infinity) specifies how many elements are to be
generated.  Derived from these basic generators, one could define
several other generators for other distributions (e.g. Gaussian).

@c ------------------------------------------------------------

@subsubheading Bitstrings in the sense of @ansrfi{33}

As eager comprehensions are efficient, they can be useful for operations
involving strings of bits.  It could be useful to have the following
comprehension:

@example
(bitwise-ec @var{qualifier}* @var{expression})
@end example

@noindent
which constructs an integer from bits obtained as values of
@var{expression} in the ordering defined by @ansrfi{33}.  In other words,
if the sequence of values is @code{@var{x}[0]}, @code{@var{x}[1]},
@dots{}, @code{@var{x}[n-1]} then the result is:

@example
x[0] + x[1] 2 + ... + x[n-1] 2^(n-1)
@end example

On the generator side, a generator of the form:

@example
(:bitwise @var{vars} @var{arg1} @var{arg}*)
@end example

@noindent
runs through the sequence of bits obtained by appending the binary
digits of the integers @var{arg1} @var{arg}*.

@c ------------------------------------------------------------

@subsubheading Streams in the sense of @ansrfi{41}

It is possible to ``lazify'' the eager comprehension @func{list-ec},
constructing a stream in the sense of @ansrfi{41}.  Clearly, such a
comprehension (@func{stream-ec}) is not eager at all since it only runs
the loops when results are requested.  It is also possible to define a
@code{:stream} generator with the same @api{} as @code{:list} but
running through streams instead of lists.

For what is worth, the file @file{srfi40-ec.scm} implements
@code{:stream} and @func{stream-ec} and gives an example.  The
implementation makes substantial use of
@func{call-with-current-continuation} to run the loop only when
necessary.  In some implementations of Scheme this may involve
considerable overhead.

@c ------------------------------------------------------------

@subsubheading Reading Text Files

Eager comprehensions can also be used to process files.  However, bear
in mind that an eager comprehension wants to read and process the entire
file right away.  Nevertheless, these generators would be useful for
reading through the lines of a file or through the characters of a file:

@example
(:lines-of-file @var{vars} @var{file})
(:chars-of-file @var{vars} [ (line @var{variable1}) ] [ (column @var{variable2}) ] @var{file})
@end example

Here @var{file} is either an input port or a string interpreted as a
filename.  In a similar fashion, generators reading from sockets defined
by @aurl{}s or other communication facilities could be defined.

@c ------------------------------------------------------------

@subsubheading The Scheme shell Scsh

In the Scheme--shell, Scsh, it could be useful to have certain
comprehensions and generators.  Candidates for comprehensions are
@func{begin-ec}, @func{|-ec}, @func{||-ec}, and @func{&&-ec}.

Concerning generators, it might be useful to have @code{:directory}
running through the records of a directory, and maybe a sophisticated
@code{:file-match-generator} could enumerate file record in a directory
structure.  Optional variables of the generators could give convenient
access frequent components of the file records (e.g. the filename).
Another candidate is @code{:env} to run through the environment
associations.  It is left to other authors and other @srfi{}s to define
a useful set of comprehensions and generators for Scsh.



@c page
@node eager-comp design
@section Design rationale


@subsubheading What is the difference between eager and lazy comprehensions?

A lazy comprehension, for example @func{stream-of} in the sense of
@ansrfi{41}, constructs an object representing a sequence of values.  They
are actually produced only at the time they are needed.  An eager
comprehension, on the other hand, is an instruction to run through a
certain sequence of values and do something with it, for example as in
@func{do-ec}.  In other words, it is nothing more sophisticated than a
loop, potentially with a more convenient notation.  This also explains
why @func{stream-of} is the most fundamental lazy comprehension, and all
others can be formulated in terms of it, whereas the most fundamental
eager comprehension is @func{do-ec}.

@c ------------------------------------------------------------

@subsubheading Why the @code{[@var{outer} .. @var{inner} | @var{expr}]} order of qualifiers?

In principle, there are six possible orders in which the qualifiers and
the expression of a comprehension can be written.  We denote the
different conventions with a pattern in which @var{expr} denotes the
expression over which the comprehension ranges, @var{inner} denotes the
generator spinning fastest, and @var{outer} denotes the generator
spinning slowest.  For example, Haskell and Python use:

@example
[@var{expr} | @var{outer} .. @var{inner}]
@end example

Probably with sufficient persistence, instances for any of the
conventions can be found on the Internet.  In addition, there is the
common mathematical notation @code{@{f(x) | x in X@}}.

It is important to understand that the notational convention does not
only determine the order of enumeration but also the scope of the
variables introduced by the generators.  The scope of @var{inner}
includes @var{expr}, and the scope of @var{outer} should include
@var{inner} to allow @var{inner} generators to depend on @var{outer}
generators.  Eventually, the choice for a particular syntactic
convention is largely a matter of personal preferences.  However, there
are a few considerations that went into the choice made for this
@srfi{}:

@enumerate
@item
The mathematical notation is universally known and widely used.
However, the mathematical notation denotes a set of comprehensions in
which the order of the qualifiers is either irrelevant or must be
deduced from the context.  For the purpose of eager comprehensions as a
programming language construct, the order does matter and a simple
convention is a plus.  For these reasons, the mathematical notation as
such is undesirable, but its widespread use is in favor of:

@example
[@var{expr} | @var{inner} .. @var{outer}]
@end example

@noindent
and:

@example
[@var{expr} | @var{outer} .. @var{inner}]
@end example

@item
It is desirable to have the scope of the variables increase into one
direction, as in:

@example
[@var{expr} | @var{inner} .. @var{outer}]
@end example

@noindent
and:

@example
[@var{outer} .. @var{inner} | @var{expr}]
@end example

@noindent
and not change direction, as in:

@example
[@var{expr} | @var{outer} .. @var{inner}]
@end example

@noindent
where @var{expr} is in the scope of @var{inner} but @var{outer} is not.
This is even more important if the syntax in Scheme does not explicitly
contain the @code{|} separator.

@item
More complicated comprehensions with several nested generators
eventually look like nested loops and Scheme always introduces them
@var{outer} @dots{} @var{inner} as in @func{do} and named @func{let}.
This is in favor of:

@example
[@var{expr} | @var{outer} .. @var{inner}]
@end example

@noindent
and:

@example
[@var{outer} .. @var{inner} | @var{expr}]
@end example

Shorter comprehensions may look more naturally the other way around.
@end enumerate

Regarding these contradicting preferences, I regard linearity in scoping
(point 2) most important, followed by readability for more complicated
comprehensions (point 3).  This leads to:

@example
[@var{outer} .. @var{inner} | @var{expr}]
@end example

An example in Scheme syntax is:

@example
(list-ec (: x 10) (: y x) (f x y))
@end example

@noindent
which looks acceptable to me even without similarity to the mathematical
notation.  As a downside, the convention clashes with other the
convention used in other languages (e.g. Haskell and Python).

@c ------------------------------------------------------------

@subsubheading You forgot @emph{choose your favorite here}--@code{ec!}

I tried to construct a reasonably useful set of tools according to what
@rnrs{5} specifies.  Nevertheless, the choice about what to include and
what to leave out is a matter of personal preference.

When ``packing the toolbox'' I went for travelling light; this @srfi{}
does not include everything imaginable or even everything useful.  I
oriented myself at the standard procedures of @rnrs{5}, with a few
omissions and additions.  A notable omission are @func{gcd-ec} and
@func{lcm-ec} because they are one--liners, and more severely, of
questionable value in practice.  Notable additions are @func{fold-ec}
and @func{fold3-ec}, providing a mechanism to define lots of useful
one--liners.  The other notable addition is @func{first-ec}, which is
the fundamental ``early stopping'' comprehension.  It is used to define
@func{any?-ec} and @func{every?-ec} which are among the most frequent
comprehensions.

Concerning the generators, the same principle has been used.  Additions
include @code{:range} and friends because they are universally needed,
and @code{:dispatched} which is primarily intended for implementing
@code{:}.

@c ------------------------------------------------------------

@subsubheading Why is the order of enumeration specified?

For the purpose of this @srfi{}, every generator runs through its
sequence of bindings in a well specified order, and nested generators
run through the Cartesian product in the order of nested loops.  The
purpose of this definition is making the sequence as easily predictable
as possible.  On the other hand, many mechanisms for lazy comprehensions
do not specify the order in which the elements are enumerated.  When it
comes to infinite streams, this has the great advantage that a
comprehension may interleave an inner and an outer enumeration, a method
also known as ``dove--tailing'' or ``diagonalizing''.  Interleaving
ensures that any value of the resulting stream is produced after a
finite amount of time, even if one or more inner streams are infinite.

@c ------------------------------------------------------------

@subsubheading Why both typed and dispatching generators?

The reason for typed generators is runtime efficiency.  In fact, the
code produced by @code{:range} and others will run as fast as a
hand--coded @func{do} loop.  The primary purpose of the dispatching
generator is convenience.  It comes at the price of reduced runtime
performance, both for loop iteration and startup.

@c ------------------------------------------------------------

@subsubheading Why the @func{something-ec} and @code{:type} naming?

The purpose of the @code{:type} convention is to keep many common
comprehensions down to one--liners.  In my opinion, the fundamental
nature of eager comprehensions justifies a single character naming
convention.  The @func{something-ec} convention is primarily intended to
stay away from the widely used @func{something-of}.  It reduces
confusion and conflict with related mechanisms.

@c ------------------------------------------------------------

@subsubheading Why combine variable binding and sequence definition?

The generators of this @srfi{} do two different things with a single
syntactic construct: They define a sequence of values to enumerate and
they specify a variable (within a certain scope) to run through that
sequence.  An alternative is to separate the two, for example as it has
been done in @ansrfi{41}.

The reason for combining sequence definition and enumeration for the
purpose of this @srfi{} is threefold.  Firstly, sequences of values are
not explicitly represented as objects in the typed generators; the
generators merely manipulate an internal state.  Secondly, this @srfi{}
aims at a most concise notation for common comprehensions and reduces
syntax to the naked minimum.  Thirdly, this @srfi{} aims at the highest
possible performance for typed generators, which is achieved if the
state being manipulated is represented by the loop variable itself.

@c ------------------------------------------------------------

@subsubheading Why is @code{(: @var{vars})} illegal?

It is reasonable and easy to define:

@example
(: @var{vars})
@end example

@noindent
as:

@example
(:integers @var{vars})
@end example

@noindent
enumerating the non--negative integers.  However, it turned out that a
frequent mistake in using the eager comprehensions is to forget either
the variable or an argument for the enumeration.  As this would lead to
an infinite loop (not always equally pleasant in interactive sessions),
it is not allowed.

@c ------------------------------------------------------------

@subsubheading Why is there no @code{:sequential}?

Just like @code{:parallel} enumerates generators in parallel, a
@code{:sequential} generator could enumerate a concatenation of several
generator, starting the next one when the previous has finished.  The
reason for not having such a qualifier is that the generators should use
all the same variable name and there is no hygienic and referentially
transparent way of enforcing this (or even knowing the variable).

@c ------------------------------------------------------------

@subsubheading Why is there no general @func{let} qualifier?

It is easy to add @func{let}, @func{let*}, and @func{letrec} as cases to
@var{qualifier}.  This would allow more sophisticated local variables
and expressions than possible with:

@example
(:let @var{vars} @var{expression})
@end example

@noindent
and:

@example
(begin @var{sequence}*)
@end example

In particular, a local @var{definition} in the sense of @rnrs{5} Section
7.1.5 would be possible.

There are two reasons for not including @func{let} and friends as
qualifiers.  The first reason concerns readability.  A qualifier of the
form:

@example
(let (@var{binding-spec}*) @var{body})
@end example

@noindent
only makes sense if the scope of the new variables ends at the end of
the comprehension, and not already after @var{body}.  The similarity
with ordinary @func{let} expressions would be very confusing.  The
second reason concerns the design rationale.  If sophisticated
@func{let} qualifiers involving recursion or local definitions are
needed, it is likely that eager comprehensions are being overused.  In
that case it might be better to define a procedure for the task.  So
including an invitation to overuse the mechanism would be a serious
violation of the Keep It Simple and Stupid principle.

@c ------------------------------------------------------------

@subsubheading Why is there no @code{:nested} generator?

The specification above defines nested as a qualifier but
@code{:parallel} as a generator.  In particular, this makes it
impossible to make parallel generators from nested ones.

This design simply reflects an implementability limitation.  All
component generators of @code{:parallel} are transformed into
@code{:do-generators} and these can be merged into a parallel generator.
However, nested generators cannot be merged easily without losing the
type of the generator, which would seriously hurt modularity and
performance.

@c ------------------------------------------------------------

@subsubheading Is @func{any?-ec} eager?

Yes, it is still eager because it immediately starts to run through the
sequence.

In fact, the reference implementation makes sure @func{first-ec},
@func{any?-ec}, and @func{every?-ec} execute efficiently so they can be
used conveniently as in:

@example
(every?-ec (:list x my-list) (pred? x))
@end example

@c ------------------------------------------------------------

@subsubheading Why this whole @code{:dispatched} business?

It is specified above that the dispatching generator, called @code{:},
is just a special case of @code{:dispatched} using a global dispatching
procedure.  Alternatively, a simple fixed global mechanism to extend
@code{:} could have been used.  This is much simpler but does not
support the definition of new dispatched generators.

The purpose of @code{:dispatched} and its utilities
(@code{:generator-proc} and @func{dispatch-union}) is the following.
Assume @code{:} is to be used inside a module but it is essential that
no other module can spoil it, e.g. by installing a very slow dispatcher.
The recommended way to proceed in this case is to define a local copy of
the original dispatching generator @code{:}, for example with the
following code:

@example
(define :my-dispatch
  (make-initial-:-dispatch))

(define-syntax :my
  (syntax-rules (index)
    [(:my cc var (index i) arg1 arg ...)
     (:dispatched cc var (index i) :my-dispatch arg1 arg ...)]
    [(:my cc var arg1 arg ...)
     (:dispatched cc var :my-dispatch arg1 arg ...)]))
@end example

@noindent
and to use the new generator @code{:my} instead of @code{:}.

An alternative for the dispatching mechanism as defined in this @srfi{}
is the use of parameter objects in the sense of @ansrfi{39}.  The
dispatching generator would then access a dynamically scoped variable to
find the dispatcher, allowing full control over dispatching.  However,
this approach does not solve the dilemma that it is sometimes useful
that @code{:} is global and sometimes undesired.  The approach specified
for this @srfi{} addresses this dilemma by offering options.

Another alternative for dealing with the dispatching problem is adding
an optional argument to the syntax of @code{:} through which the
dispatcher can be passed explicitly.  However, as @code{:} has variable
arity and the identifier for the variable cannot be distinguished from
any value for a dispatcher, this is syntactically problematic.

@c ------------------------------------------------------------

@subsubheading Why is there no local mechanism for adding to @code{:}?

According to @rnrs{5} Section 7.1.6 macros can only be defined at the
level of the @code{<program>} syntax.  This implies that the scope of
typed generators cannot easily be limited to local scopes.  As typed and
dispatched generators go together, there is also no strong need for a
limited scope of dispatched generators either.  Furthermore, locally
extendable dispatchers are another major headache to those trying to
understand other people's code.

@c ------------------------------------------------------------

@subsubheading Why are dispatchers unary?

As defined in @code{:dispatched}, a dispatching procedure is called with
a single argument being the list of values to dispatch on.  An
alternative is to apply the dispatcher to the list of values to dispatch
on, which would be more natural in Scheme.

The reason for not using apply is a minor improvement in efficiency.
Every time @var{apply} is used on a procedure of variable arity, an
object containing the argument list is allocated on the heap.  As a
dispatcher may call many other dispatchers, this will add to the
overhead of dispatching, which is relevant in inner loops.

@c ------------------------------------------------------------

@subsubheading Why are there two fold comprehensions?

The reason for having two fold comprehensions (@func{fold-ec} and
@func{fold3-ec}) is efficiency.

Clearly, the more general construction is @func{fold3-ec} as it allows
individual treatment of the empty sequence case and the singleton
sequence case.  However, this comes at the price of more book--keeping
as can be seen from the implementation example.  As the overhead is
located within inner loops, it makes sense to define another fold
comprehension for the case where the added flexibility is not needed.
This is @func{fold-ec}.

The names @func{fold-ec} and @func{fold3-ec} have been chosen for the
comprehensions in order to stay clear any other 'fold' that may be
around.

@c ------------------------------------------------------------

@subsubheading Why is @code{:char-range} not defined by @func{integer->char}?

The definition of @code{:char-range} specifies a sequence of adjacent
characters ordered by @code{char<=?}.  The reason for not using
@func{char->integer} and @func{integer->char} is the fact that @rnrs{5}
Section 6.3.4 leaves it to the implementation whether the integers
representing characters are consecutive or not.  In effect, this
underspecification is inherited by @code{:char-range}.



@c page
@node eager-comp ack
@section Related work and acknowledgements


Several other proposals related to the mechanism specified here exists.
The following mechanisms are made for and in Scheme (or at least a
specific dialect thereof).

First of all, the report @rnrs{5} of Scheme itself defines two
constructs for writing loops: @func{do} and named @func{let}.  Both
constructs express a single loop (not nested), possibly with several
variables running in parallel, based on explicit manipulation of the
state variables.  For example:

@example
(do ([x 0 (+ x 1)])
    ([= x 10])
  (display x))
@end example

@noindent
explicitly mentions how to obtain the next binding of @var{x}.

Richard Kelsey's ``Macros for writing loops'', are an extension to
Scheme48 to simplify the formulation of loops.  The basic idea is to
stick with a @func{do}--like syntax for more sophisticated loop
constructs, not necessarily manipulating a state variable explicitly.
For example:

@example
(list* x '(1 2 3))
@end example

@noindent
expresses an enumeration of the variable @var{x} through the list
@code{(1 2 3)} without explicit state manipulation.  The iteration
constructs of MWL, @func{named} @func{iterate} and @func{reduce},
express a single (not nested) loop (@func{iterate}) or comprehension
(@func{reduce}) with any number of parallel enumerations.

A most important feature of the MWL--concept is a modular way to add
sequence types (generators).  In effect, the addition of a new sequence
type does not require a modification of the existing macros.  This is
achieved by carefully limiting the expressive power of the loop
constructs and by using the macros in Continuation Passing Style to call
other macros.  The MWL--concept, and its implementation, were most
influential for this @srfi{}.

Another related mechanism is the library of streams recently submitted
by Phil L. Bewig as @srfi{40} (superseded by @srfi{41}).  The library
contains a data type to represent even streams (both car and cdr
potentially delayed) and defines procedures for manipulating these
streams.  Moreover, the macro @func{stream-of} defines a lazy
comprehension resulting in the stream of values of an expression subject
to generators and filters.

A fixed set of generators (lists, vector, string, port, and naturally:
streams) is supported; extending the list of generators requires
changing @func{stream-of}.  Nevertheless, modularity is high since it is
easy to define a procedure producing a stream object and this can be
used for enumeration.  The order of enumeration is left unspecified to
allow interleaving of generators (also refer to above).

Before Phil submitted his @srfi{}s, we had a short discussion in which
we clarified the semantic and syntactic differences of our approaches.
It turned out that the mechanisms are sufficiently different not to
unify them.  The most important difference is the design rationale: Phil
created his library to support the stream paradigm in Scheme, inspired
by the work done for Haskell and other lazy languages, and intrigued by
the beauty of programming with infinite streams.  My work only aims at a
convenient way of expressing frequent patterns of loops in a compact
way.  For what it is worth, section @srfi{40}-ec contains a suggestion
for extending the eager comprehension mechanism for @srfi{41} streams.

Phil's work on streams and lazy comprehensions in Scheme triggered Eli
Barzilay to implement a library of eager comprehensions for
@acronym{PLT}--Scheme.  The mechanism implemented by Eli is in essence
very similar to the one proposed in this @srfi{}, and the two efforts
have been independent until recently.  Syntactically, Eli uses infix
operators for generators, whereas this @srfi{} is purely prefix, and Eli
uses the:

@example
[@var{expr} | @var{outer} .. @var{inner}]
@end example

@noindent
convention for nesting, whereas this @srfi{} uses the:

@example
[outer .. inner | expr]
@end example

@noindent
convention.  Semantically, Eli's mechanism defines more flexible loops
than this @srfi{}.  Comprehensions are regarded as generalized
collection processes like @func{fold} and @func{reduce}.  The mechanism
in this @srfi{} is more restricted with respect to control flow (there
is no general @func{while}) and more extensive with respect to
generators and comprehensions.  Despite the strong conceptual
similarity, the design rationales are different.  This @srfi{} focuses
on portability and modular extension, whatever that may cost in terms of
expressive power.

Finally, I would like to thank Mike Sperber for his encouragement to
proceed with the @srfi{} and for several discussions of the matter.  In
particular, the dispatching mechanism evolved rapidly during discussions
with Mike.



@c page
@node eager-comp references
@section References


@noindent
@emph{Revised(5) Report on the Algorithmic Language Scheme}.  Richard
Kelsey, William Clinger, and Jonathan Rees (eds.).  February 20, 1998.
Higher--Order and Symbolic Computation, Vol. 11, No. 1, September
1998.

@center @url{http://schemers.org/Documents/Standards/R5RS/}

@noindent
@emph{The Incomplete Scheme48 Reference Manual for Release 0.57 (July
15, 2001)}.  Richard Kelsey, Jonathan Rees. Section ``Macros for writing
loops''.

@center @url{http://s48.org/0.57/manual/s48manual_49.html}

@noindent
@emph{@ansrfi{1} List library}.  Olin Shivers.

@center @url{http://srfi.schemers.org/srfi-1/}

@noindent
@emph{@ansrfi{23} Error reporting mechanism}.  Stephan Houben:.

@center @url{http://srfi.schemers.org/srfi-23/}

@noindent
@emph{@ansrfi{25} Multi--dimensional Array Primitives}.  Jussi
Piitulainen.

@center @url{http://srfi.schemers.org/srfi-25/}

@noindent
@emph{@ansrfi{27} Sources of Random Bits}.  Sebastian Egner.

@center @url{http://srfi.schemers.org/srfi-27/}

@noindent
@emph{@ansrfi{33} Integer Bitwise-operation Library}.  Olin Shivers.

@center @url{http://srfi.schemers.org/srfi-33/}

@noindent
@emph{@ansrfi{39} Parameter objects}.  Marc Feeley.

@center @url{http://srfi.schemers.org/srfi-39/}

@noindent
@emph{@ansrfi{41} A Library of Streams}. Philip L. Bewig.

@center @url{http://srfi.schemers.org/srfi-41/}

@noindent
@emph{Documentation for @file{misc.ss}}.  Eli Barzilay.  2002.

@center @url{http://www.cs.cornell.edu/eli/Swindle/misc-doc.html#collect}

@noindent
@emph{Folds and reductions}.  John David Stone.  Posting in relation to
@ansrfi{1} on 8-Jan-1999.

@center @url{http://srfi.schemers.org/srfi-1/mail-archive/msg00021.html}

@noindent
@emph{The Haskell 98 Report 1 February 1999}.  Simon L. Peyton Jones,
John Hughes.  Section 3.11 ``List Comprehensions''.

@center @url{http://www.haskell.org/onlinereport/exps.html#sect3.11}

@noindent
@emph{Python Reference Manual}.  Guido van Rossum, Fred L. Drake
Jr. (eds.).  Section 5.2.4 ``List displays''.  Release 2.2, December 21,
2001.

@center @url{http://python.org/doc/2.2/ref/lists.html}

@noindent
@emph{Structure and Interpretation of Computer Programs}.  Harold
Abelson, Gerald J. Sussman, Julie Sussman.  @acronym{MIT} Press,
1985.

@center @url{http://mitpress.mit.edu/sicp/}

@noindent
@emph{List Comprehensions (Chapter 7)}.  Philip Wadler.  In: Simon
L. Peyton Jones: The Implementation of Functional Programming Languages.
Prentice Hall, 1987.

@noindent
@emph{Scheme48 Release 0.57 (July 15, 2001)}.  Richard Kelsey, Jonathan
Rees.

@center @url{http://s48.org/}

@noindent
@emph{SCM Scheme Implementation. Version 5d7 (November 27, 2002)}.
Aubrey Jaffer.

@center @url{http://www.swiss.ai.mit.edu/~jaffer/SCM.html}

@noindent
@emph{@acronym{PLT} Scheme, DrScheme Version 203}.  @acronym{PLT}
People.

@center @url{http://www.plt-scheme.org/}

@noindent
@emph{Scsh Reference Manual}.  Olin Shivers, Brian D. Carlstrom, Martin
Gasbichler, Mike Sperber.  For scsh release 0.6.3.

@center @url{http://scsh.net/}


@c page
@node vector
@chapter Vector library


@cindex @srfi{} vector


The @library{srfi vector} library has been written by Taylor Campbell as
the reference implementation for @ansrfi{43}.


@menu
* vector license::              Original license.
* vector abstract::             Abstract.
* vector rationale::            Rationale.
* vector spec::                 Specification.
* vector ack::                  Acknowledgements.
* vector references::           References.
@end menu


@c page
@node vector license
@section Original license


Copyright @copyright{} 2003 Taylor Campbell.  All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



@c page
@node vector abstract
@section Abstract


This @srfi{} proposes a comprehensive and complete library of vector
operations accompanied by a freely available and complete reference
implementation.  The reference implementation is unencumbered by
copyright, and useable with no modifications on any Scheme system that
is @rnrs{5}--compliant.  It also provides several hooks for
implementation-specific optimization as well.

Because this @srfi{} is more of a library or module specification than a
request for additions to readers or any other internal implementation
detail, in an implementation that supports a module or structure or
package or library or unit (et cetera) systems, these procedures should
be contained in a module/structure/package/library/unit called
@code{vector-lib}.


@c page
@node vector rationale
@section Rationale


@rnrs{5} provides very few list--processing procedures, for which reason
@srfi{1} exists.  However, @rnrs{5} provides even fewer vector
operations; while it provides mapping, appending, et cetera operations
for lists, it specifies only nine vector manipulation operations:

@example
vector?         make-vector     vector
vector-length   vector-ref      vector-set!
vector->list    list->vector    vector-fill!
@end example

Many Scheme implementations provide several vector operations beyond the
minuscule set that @rnrs{5} defines (the typical @func{vector-append},
@func{vector-map}, et cetera), but often these procedures have different
names, take arguments in different orders, don't take the same number of
arguments, or have some other flaw that makes them unportable.  For this
reason, this @srfi{} is proposed.

It should be noted that no vector sorting procedures are provided by
this @srfi{}, because there already is a @srfi{} for such a purpose,
@srfi{32}, which includes routines for sorting not only vectors but also
lists.


@c page
@node vector spec
@section Specification


@menu
* vector spec intro::           Introduction.
* vector spec cons::            Constructors.
* vector spec pred::            Predicates.
* vector spec select::          Selectors.
* vector spec iter::            Iteration.
* vector spec search::          Searching.
* vector spec mutators::        Mutators.
* vector spec conv::            Conversion.
@end menu


@c page
@node vector spec intro
@subsection Introduction


In this section containing specifications of procedures, the following
notation is used to specify parameters and return values:

@table @code
@item (f arg1 arg2 ) -> something
Indicates a function @var{f} takes the parameters @var{arg1},
@var{arg2}, @dots{} and returns a value of the type @var{something}. If
@var{something} is unspecified, then what @var{f} returns is
implementation--dependant; this @srfi{} does not specify what it
returns, and in order to write portable code, the return value should be
ignored.

@item vec
The argument in this place must be a vector, i.e. it must satisfy the
predicate @func{vector?}.

@item i, j, start, size
The argument in this place must be a nonnegative integer, i.e. it must
satisfy the predicates @func{integer?} and either @func{zero?} or
@func{positive?}.  The third case of it indicates the index at which
traversal begins; the fourth case of it indicates the size of a vector.

@item end
The argument in this place must be a positive integer, i.e. it must
satisfy the predicates @func{integer?} and @func{positive?}.  This
indicates the index directly before which traversal will stop;
processing will occur until the the index of the vector is end.  It is
the closed right side of a range.

@item f
The argument in this place must be a function of one or more arguments,
returning exactly one value.

@item pred?
The argument in this place must be a function of one or more arguments
that returns one value, which is treated as a boolean.

@item x, y, z, seed, knil, fill, key, value
The argument in this place may be any Scheme value.

@item [something]
Indicates that @var{something} is an optional argument; it needn't
necessarily be applied.  Something needn't necessarily be one thing; for
example, this usage of it is perfectly valid:

@example
[start [end]]
@end example

@noindent
and is indeed used quite often.

@item something 
Indicates that zero or more somethings are allowed to be arguments.

@item something1 something2 
Indicates that at least one something must be arguments.

@item something1 something2  somethingn
Exactly equivalent to the previous argument notation, but this also
indicates that @var{n} will be used later in the procedure description.
@end table

It should be noted that all of the procedures that iterate across
multiple vectors in parallel stop iterating and produce the final result
when the end of the shortest vector is reached.  The sole exception is
@func{vector=}, which automatically returns @false{} if the vectors'
lengths vary.



@c page
@node vector spec cons
@subsection Constructors


@defun make-vector @var{size} [@var{fill}] -> vector
@rnrs{5} Create and return a vector of size @var{size}, optionally
filling it with @var{fill}.  The default value of @var{fill} is
unspecified.

Example:

@example
(make-vector 5 3)
=> #(3 3 3 3 3)
@end example
@end defun


@defun vector @var{x} ... -> vector
@rnrs{5} Create and return a vector whose elements are @var{x} ...

Example:

@example
(vector 0 1 2 3 4)
=> #(0 1 2 3 4)
@end example
@end defun


@defun vector-unfold @var{f} @var{length} @var{initial-seed} ... -> vector
The fundamental vector constructor.  Create a vector whose length is
@var{length} and iterates across each index @var{k} between 0 and
@var{length}, applying @var{f} at each iteration to the current index
and current seeds, in that order, to receive @code{@var{n} + 1} values:
first, the element to put in the @var{k}-th slot of the new vector and
@var{n} new seeds for the next iteration.  It is an error for the number
of seeds to vary between iterations.

Examples:

@example
(vector-unfold (lambda (i x)
                 (values x (- x 1)))
               10 0)
=> #(0 -1 -2 -3 -4 -5 -6 -7 -8 -8)

;; construct a vector of the sequence of integers
;; in the range [0,n)
(vector-unfold values n)
=> #(0 1 2  n-2 n-1)

;; copy a vector
(vector-unfold (lambda (i)
                 (vector-ref vector i))
               (vector-length vector))
@end example
@end defun


@defun vector-unfold-right @var{f} @var{length} @var{initial-seed} ... -> vector
Like @func{vector-unfold}, but it uses @var{f} to generate elements from
right--to--left, rather than left--to--right.

Examples:

@example
;; Construct a vector in reverse of the integers
;; in the range [0,n).
(vector-unfold-right (lambda (i x)
                       (values x (+ x 1)))
                     n 0)
=> #(n-1 n-2  2 1 0)

;; Reverse vector.
(vector-unfold-right (lambda (i x)
                       (values (vector-ref vector x) (+ x 1)))
                     (vector-length vector)
                     0)
@end example
@end defun


@defun vector-copy @var{vec} [@var{start} [@var{end} [@var{fill}]]] -> vector
Allocate a new vector whose length is @code{@var{end} - @var{start}} and
fills it with elements from @var{vec}, taking elements from @var{vec}
starting at index @var{start} and stopping at index @var{end}.

@var{start} defaults to 0 and @var{end} defaults to the value of
@code{(vector-length @var{vec})}.

If @var{end} extends beyond the length of @var{vec}, the slots in the
new vector that obviously cannot be filled by elements from @var{vec}
are filled with @var{fill}, whose default value is unspecified.

Examples:

@example
(vector-copy '#(a b c d e f g h i))
=> #(a b c d e f g h i)

(vector-copy '#(a b c d e f g h i) 6)
=> #(g h i)

(vector-copy '#(a b c d e f g h i) 3 6)
=> #(d e f)

(vector-copy '#(a b c d e f g h i) 6 12 'x)
=> #(g h i x x x)
@end example
@end defun


@defun vector-reverse-copy @var{vec} [@var{start} [@var{end}]] -> vector
Like @func{vector-copy}, but it copies the elements in the reverse order
from @var{vec}.

Example:

@example
(vector-reverse-copy '#(5 4 3 2 1 0) 1 5)
=> #(1 2 3 4)
@end example
@end defun


@defun vector-append @var{vec} ... -> vector
Returns a newly allocated vector that contains all elements in order
from the subsequent locations in @var{vec} ...

Examples:

@example
(vector-append '#(x) '#(y))
=> #(x y)

(vector-append '#(a) '#(b c d))
=> #(a b c d)

(vector-append '#(a #(b)) '#(#(c)))
=> #(a #(b) #(c))
@end example
@end defun


@defun vector-concatenate @var{list-of-vectors} -> vector
Appends each vector in @var{list-of-vectors}.  This is equivalent to:

@example
(apply vector-append list-of-vectors)
@end example

@noindent
however, it may be implemented better.

Example:

@example
(vector-concatenate '(#(a b) #(c d)))
=> #(a b c d)
@end example
@end defun



@c page
@node vector spec pred
@subsection Predicates


@defun vector? @var{x} -> boolean
@rnrs{5} Disjoint type predicate for vectors: return @true{} if @var{x}
is a vector, and @false{} otherwise.

Examples:

@example
(vector? '#(a b c))
=> #t

(vector? '(a b c))
=> #f

(vector? #t)
=> #f

(vector? '#())
=> #t

(vector? '())
=> #f
@end example
@end defun


@defun vector-empty? @var{vec} -> boolean
Return @true{} if @var{vec} is empty, i.e. its length is 0, otherwise
@false{}.

Examples:

@example
(vector-empty? '#(a))
=> #f

(vector-empty? '#(()))
=> #f

(vector-empty? '#(#()))
=> #f

(vector-empty? '#())
=> #t
@end example
@end defun


@defun vector= @var{elt=?} @var{vec} ... -> boolean
Vector structure comparator, generalized across user--specified element
comparators.  Vectors @var{a} and @var{b} are considered equal by
@func{vector=} if, and only if, their lengths are the same, and for each
respective elements @var{Ea} and @var{Eb}, @code{(@var{elt=?} @var{Ea}
@var{Eb})} returns a true value.

@var{elt=?} is always applied to two arguments.

Element comparison must be consistent with @func{eq?}; that is, if
@code{(eq?  @var{Ea} @var{Eb})} results in a true value, then
@code{(@var{elt=?} @var{Ea} @var{Eb})} must also result in a true value.
This may be exploited to avoid unnecessary element comparisons.  (The
reference implementation does, but it does not consider the situation
where @var{elt=?} is in fact itself @func{eq?} to avoid yet more
unnecessary comparisons.)

If there are only zero or one vector arguments, @true{} is automatically
returned.

The dynamic order in which comparisons of elements and of vectors are
performed is left completely unspecified; do not rely on a particular
order.

Examples:

@example
(vector= eq? '#(a b c d) '#(a b c d))
=> #t

(vector= eq? '#(a b c d) '#(a b d c))
=> #f

(vector= = '#(1 2 3 4 5) '#(1 2 3 4))
=> #f

(vector= = '#(1 2 3 4) '#(1 2 3 4))
=> #t
@end example

@noindent
the two trivial cases:

@example
(vector= eq?)
=> #t

(vector= eq? '#(a))
=> #t
@end example

Note the fact that we don't use vector literals in the next two; it is
unspecified whether or not literal vectors with the same external
representation are @func{eq?}:

@example
(vector= eq? (vector (vector 'a)) (vector (vector 'a)))
=> #f

(vector= equal? (vector (vector 'a)) (vector (vector 'a)))
=> #t
@end example
@end defun



@c page
@node vector spec select
@subsection Selectors


@defun vector-ref @var{vec} @var{i} -> value
@rnrs{5} Vector element dereferencing: return the value that the
location in @var{vec} at @var{i} is mapped to in the store.  Indexing is
based on zero.  The argument @var{i} must be within the range: @code{[0,
(vector-length @var{vec}))}.

Example:

@example
(vector-ref '#(a b c d) 2)
=> c
@end example
@end defun


@defun vector-length @var{vec} -> exact nonnegative integer
@rnrs{5} Return the length of @var{vec}, the number of locations
reachable from @var{vec}.  (The careful word ``reachable'' is used to
allow for ``vector slices'', whereby @var{vec} refers to a larger vector
that contains more locations that are unreachable from @var{vec}.  This
@srfi{} does not define vector slices, but later @srfi{}s may.)

Example:

@example
(vector-length '#(a b c))
=> 3
@end example
@end defun



@c page
@node vector spec iter
@subsection Iteration


@defun vector-fold @var{kons} @var{knil} @var{vec1} @var{vec2} ... -> value
The fundamental vector iterator.  @var{kons} is iterated over each index
in all of the vectors, stopping at the end of the shortest; @var{kons}
is applied as:

@example
(@var{kons} @var{i} @var{state}
            (vector-ref @var{vec1} @var{i})
            (vector-ref @var{vec2} @var{i})
            )
@end example

@noindent
where @var{state} is the current state value; the current state value
begins with @var{knil}, and becomes whatever @var{kons} returned at the
respective iteration; and @var{i} is the current index.

The iteration is strictly left--to--right.

Examples:

@example
;; Find the longest string's length in vector-of-strings.
(vector-fold (lambda (index len str)
               (max (string-length str) len))
             0 vector-of-strings)

;; Produce a list of the reversed elements of vec.
(vector-fold (lambda (index tail elt)
               (cons elt tail))
             '() vec)

;; Count the number of even numbers in vec.
(vector-fold (lambda (index counter n)
               (if (even? n) (+ counter 1) counter))
             0 vec)
@end example
@end defun


@defun vector-fold-right @var{kons} @var{knil} @var{vec1} @var{vec2} ... -> value
Similar to @func{vector-fold}, but it iterates right to left instead of
left to right.

Example:

@example
;; Convert a vector to a list.
(vector-fold-right (lambda (index tail elt)
                     (cons elt tail))
                   '() '#(a b c d))
=> (a b c d)
@end example
@end defun


@defun vector-map @var{f} @var{vec1} @var{vec2} ... -> vector
Construct a new vector of the shortest size of the vector arguments.
Each element at index @var{i} of the new vector is mapped from the old
vectors by:

@example
(@var{f} @var{i} (vector-ref @var{vec1} @var{i})
                 (vector-ref @var{vec2} @var{i})
                 )
@end example

The dynamic order of application of @var{f} is unspecified.

Examples:

@example
(vector-map (lambda (i x) (* x x))
              (vector-unfold (lambda (i x)
                               (values x (+ x 1)))
                             4 1))
=> #(1 4 9 16)

(vector-map (lambda (i x y) (* x y))
              (vector-unfold (lambda (i x)
                               (values x (+ x 1)))
                             5 1)
              (vector-unfold (lambda (i x)
                               (values x (- x 1)))
                             5 5))
=> #(5 8 9 8 5)

(let ([count 0])
  (vector-map (lambda (ignored-index ignored-elt)
                (set! count (+ count 1))
                count)
              '#(a b)))
=> #(1 2) OR #(2 1)

(vector-map (lambda (i elt)
              (+ i elt))
            '#(1 2 3 4))
=> #(1 3 5 7)
@end example
@end defun


@defun vector-map! @var{f} @var{vec1} @var{vec2} ... -> unspecified
Similar to @func{vector-map}, but rather than mapping the new elements
into a new vector, the new mapped elements are destructively inserted
into @var{vec1}.  The dynamic order of application of @var{f}
unspecified, so it is dangerous for @var{f} to apply either
@func{vector-ref} or @func{vector-set!} to @var{vec1} in @var{f}.
@end defun


@defun vector-for-each @var{f} @var{vec1} @var{vec2} ... -> unspecified
Simple vector iterator: apply @var{f} to each index in the range
@code{[0, @var{length})}, where @var{length} is the length of the
smallest vector argument passed, and the respective list of parallel
elements from @var{vec1}, @var{vec2}, @dots{} at that index.  In
contrast with @func{vector-map}, @var{f} is reliably applied to each
subsequent elements, starting at index 0, in the vectors.

Example:

@example
(vector-for-each (lambda (i x)
                   (display x)
                   (newline))
=> '#("foo" "bar" "baz" "quux" "zot"))
@end example

@noindent
displays:

@example
foo
bar
baz
quux
zot
@end example
@end defun


@defun vector-count @var{pred?} @var{vec1} @var{vec2} ... -> exact nonnegative integer
Count the number of parallel elements in the vectors that satisfy
@var{pred?}, which is applied, for each index @var{i} in the range
@code{[0, @var{length})}, where @var{length} is the length of the
smallest vector argument, to @var{i} and each parallel element in the
vectors at that index, in order.

Examples:

@example
(vector-count (lambda (i elt)
                (even? elt))
              '#(3 1 4 1 5 9 2 5 6))
=> 3

(vector-count (lambda (i x y)
                (< x y))
              '#(1 3 6 9)
              '#(2 4 6 8 10 12))
=> 2
@end example
@end defun



@c page
@node vector spec search
@subsection Searching


@defun vector-index @var{pred?} @var{vec1} @var{vec2} ... -> exact nonnegative integer or #f
Find and return the index of the first elements in @var{vec1},
@var{vec2}, @dots{} that satisfy @var{pred?}.  If no matching element is
found by the end of the shortest vector, @false{} is returned.

Examples:

@example
(vector-index even? '#(3 1 4 1 5 9))
=> 2

(vector-index < '#(3 1 4 1 5 9 2 5 6) '#(2 7 1 8 2))
=> 1

(vector-index = '#(3 1 4 1 5 9 2 5 6) '#(2 7 1 8 2))
=> #f
@end example
@end defun


@defun vector-index-right @var{pred?} @var{vec1} @var{vec2} ... -> exact nonnegative integer or #f
Like @func{vector-index}, but it searches right--to--left, rather than
left--to--right, and all of the vectors must have the same length.
@end defun


@defun vector-skip @var{pred?} @var{vec1} @var{vec2} ... -> exact nonnegative integer or #f
Find and return the index of the first elements in @var{vec1},
@var{vec2}, @dots{} that do not satisfy @var{pred?}.  If all the values
in the vectors satisfy @var{pred?} until the end of the shortest vector,
this returns @false{}.  This is equivalent to:

@example
(vector-index (lambda (x1 x2 )
                (not (pred? x1 x1 )))
              vec1 vec2 ...)
@end example

Example:

@example
(vector-skip number? '#(1 2 a b 3 4 c d))
=> 2
@end example
@end defun


@defun vector-skip-right @var{pred?} @var{vec1} @var{vec2} ... -> exact nonnegative integer or #f
Like @func{vector-skip}, but it searches for a non--matching element
right--to--left, rather than left--to--right, and all of the vectors
must have the same length.  This is equivalent to:

@example
(vector-index-right (lambda (x1 x2 ...)
                      (not (pred? x1 x1 ...)))
                    vec1 vec2 ...)
@end example
@end defun


@defun vector-binary-search @var{vec} @var{value} @var{cmp} -> exact nonnegative integer or #f
Similar to @func{vector-index} and @func{vector-index-right}, but
instead of searching left to right or right to left, this performs a
binary search.  @var{cmp} should be a procedure of two arguments and
return: a negative integer, which indicates that its first argument is
less than its second; zero, which indicates that they are equal; a
positive integer, which indicates that the first argument is greater
than the second argument.  An example @var{cmp} might be:

@example
(lambda (char1 char2)
  (cond [(char<? char1 char2) -1]
        [(char=? char1 char2) 0]
        [else 1]))
@end example
@end defun


@defun vector-any @var{pred?} @var{vec1} @var{vec2} ... -> value or #f
Find the first set of elements in parallel from @var{vec1}, @var{vec2},
... for which @var{pred?} returns a true value.  If such a parallel set
of elements exists, @func{vector-any} returns the value that @var{pred?}
returned for that set of elements.  The iteration is strictly
left--to--right.
@end defun


@defun vector-every @var{pred?} @var{vec1} @var{vec2} ... -> value or #f
If, for every index @var{i} between 0 and the length of the shortest
vector argument, the set of elements:

@example
(vector-ref @var{vec1} @var{i})
(vector-ref @var{vec2} @var{i})
 
@end example

@noindent
satisfies @var{pred?}, @func{vector-every} returns the value that
@var{pred?}  returned for the last set of elements, at the last index of
the shortest vector.  The iteration is strictly left--to--right.
@end defun



@c page
@node vector spec mutators
@subsection Mutators


@defun vector-set! @var{vec} @var{i} @var{value} -> unspecified
@rnrs{5} Assign the contents of the location at @var{i} in @var{vec} to
@var{value}.
@end defun


@defun vector-swap! @var{vec} @var{i} @var{j} -> unspecified
Swap or exchange the values of the locations in @var{vec} at @var{i} and
@var{j}.
@end defun


@defun vector-fill! @var{vec} @var{fill} [@var{start} [@var{end}]] -> unspecified
@rnrs{5}+ Assign the value of every location in @var{vec} between
@var{start}, which defaults to 0 and @var{end}, which defaults to the
length of @var{vec}, to @var{fill}.
@end defun


@defun vector-reverse! @var{vec} [@var{start} [@var{end}]] -> unspecified
Destructively reverse the contents of the sequence of locations in
@var{vec} between @var{start} and @var{end}.  Start defaults to 0 and
end defaults to the length of @var{vec}.  Note that this does not deeply
reverse.
@end defun


@defun vector-copy! @var{target} @var{tstart} @var{source} [@var{sstart} [@var{send}]] -> unspecified
Copy a block of elements from @var{source} to @var{target}, both of
which must be vectors, starting in @var{target} at @var{tstart} and
starting in @var{source} at @var{sstart}, ending when @code{@var{send} -
@var{sstart}} elements have been copied.  It is an error for
@var{target} to have a length less than:

@example
@var{tstart} + (@var{send} - @var{sstart})
@end example

@var{sstart} defaults to 0 and send defaults to the length of
@var{source}.
@end defun


@defun vector-reverse-copy! @var{target} @var{tstart} @var{source} [@var{sstart} [@var{send}]] -> unspecified
Like @func{vector-copy!}, but this copies the elements in the reverse
order.  It is an error if @var{target} and @var{source} are identical
vectors and the @var{target} and @var{source} ranges overlap; however,
if @code{@var{tstart} = @var{sstart}}, @func{vector-reverse-copy!}
behaves as:

@example
(vector-reverse! @var{target} @var{tstart} @var{send})
@end example

@noindent
would.
@end defun



@c page
@node vector spec conv
@subsection Conversion


@defun vector->list @var{vec} [@var{start} [@var{end}]] -> proper-list
@rnrs{5} Create a list containing the elements in @var{vec} between
@var{start}, which defaults to 0, and @var{end}, which defaults to the
length of @var{vec}.
@end defun


@defun reverse-vector->list @var{vec} [@var{start} [@var{end}]] -> proper-list
Like @func{vector->list}, but the resulting list contains the elements
in reverse between the the specified range.
@end defun


@defun list->vector @var{proper-list} -> vector
@rnrs{5} Create a vector of elements from @var{proper-list}.
@end defun


@defun reverse-list->vector @var{proper-list} -> vector
Like @func{list->vector}, but the resulting list contains the elements
in reverse of @var{proper-list}.
@end defun



@c page
@node vector ack
@section Acknowledgements


Thanks to Olin Shivers for his wonderfully complete list and string
packages; to all the members of the @code{#scheme} @acronym{IRC} channel
on Freenode who nitpicked a great deal, but also helped quite a lot in
general, and helped test the reference implementation in various Scheme
systems; to Michael Burschik for his numerous comments; to Sergei Egorov
for helping to narrow down the procedures; to Mike Sperber for putting
up with an extremely overdue draft; to Felix Winkelmann for continually
bugging me about finishing up the @srfi{} so that it would be only
overdue and not withdrawn; and to everyone else who gave questions,
comments, thoughts, or merely attention to the @srfi{}.


@c page
@node vector references
@section References


@emph{The Revised5 Report on Scheme}.  R. Kelsey, W. Clinger, J. Rees
(editors).  Higher--Order and Symbolic Computation, Vol. 11, No. 1,
September, 1998, and ACM SIGPLAN Notices, Vol. 33, No. 9, October, 1998.

@center @url{http://www.schemers.org/Documents/Standards/R5RS/}

@noindent
@emph{@srfi{}: Scheme Request for Implementation}.  The @srfi{} website
can be found at:

@center @url{http://srfi.schemers.org/}

@noindent
@emph{@srfi{1}: List Library}.  A @srfi{} of list processing procedures,
written by Olin Shivers.

@center @url{http://srfi.schemers.org/srfi-1/}

@noindent
@emph{@srfi{13}: String Library}.  A @srfi{} of string processing
procedures, written by Olin Shivers.

@center @url{http://srfi.schemers.org/srfi-13/}

@noindent
@emph{@srfi{23}: Error Reporting Mechanism}.  A @srfi{} that defines a
new primitive (error) for reporting that an error occurred, written by
Stephan Houben.

@center @url{http://srfi.schemers.org/srfi-23/}

@noindent
@emph{@srfi{32}: Sort Libraries (draft)}.  A @srfi{} of list and vector
sorting routines, written by Olin Shivers.

@center @url{http://srfi.schemers.org/srfi-32/}


@c page
@node general-cond
@chapter A more general @func{cond} clause


@cindex @srfi{} general-cond


The @library{srfi general-cond} has been written by Taylor Campbell as
the reference implementation for @ansrfi{61}.


@menu
* general-cond license::        Original license.
* general-cond abstract::       Abstract.
* general-cond rationale::      Rationale.
* general-cond spec::           Specification.
@end menu

@c page
@node general-cond license
@section Original license


Copyright @copyright{} 2004 Taylor Campbell.  All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node general-cond abstract
@section Abstract


This @srfi{} proposes an extension to the @func{cond} syntax to allow a
more general clause, one that allows binding the results of tests as in
the @code{=>} clauses and user--defined meaning of the success and
failure of tests.


@c page
@node general-cond rationale
@section Rationale


The present set of @func{cond} clauses is based on simple boolean
testing.  It is prohibitively inexpressive in that the condition part of
a @func{cond} clause that uses @code{=>} may pass only a single value to
the receiver, and it enforces a semantics whereby @false{} implies
failure of the condition.

Programmers frequently use different tokens to imply failure, such as in
@rnrs{5}'s I/O readers which return a distinguished ``EOF object'' to
denote failure, and a successful condition may produce more than one
useful value.  This simple extension allows any meaning of ``failure''
to be assigned on a per--clause basis, and it also allows the condition
to return multiple values to be passed to the receiver.


@c page
@node general-cond spec
@section Specification


@findex cond

The @code{<cond clause>} production in the formal syntax of Scheme as
written by @rnrs{5} Section 7.1.3 is extended with a new option:

@example
<cond clause> --->
    ...
  | (<generator> <guard> => <receiver>)
@end example

@noindent
where @code{<generator>}, @code{<guard>} and @code{<receiver>} are all
@code{<expression>}.

Clauses of this form have the following semantics: @code{<generator>} is
evaluated and it may return arbitrarily many values.  @code{<guard>} is
applied to an argument list containing the values in order that
@code{<generator>} returned.  If @code{<guard>} returns a true value for
that argument list, @code{<receiver>} is applied with an equivalent
argument list.  If @code{<guard>} returns a false value, however, the
clause is abandoned and the next one is tried.

@c ------------------------------------------------------------

@subsubheading Examples


This @func{port->char-list} procedure accepts an input port and returns
a list of all the characters it produces until the end.

@example
(define (port->char-list port)
  (cond [(read-char port)
            char?
         => (lambda (c)
              (cons c (port->char-list port)))]
        [else '()]))
@end example

Consider now a hypothetical @func{table-entry} procedure that accepts
two arguments, a table (perhaps a hash table) and a key to an entry that
may be in the table; it returns two values: a boolean that denotes
whether or not an entry with the given key was in the table and, if it
was, the value associated with the key.  Also, a hypothetical
@var{proj0} combinator (projection of argument 0) returns its 0th
argument and ignores all others.  One might conditionally branch to a
certain body of code if the table contains the desired entry like so
with the new type of @func{cond} clause:

@example
(cond ...
      [(table-entry <table> <key>) proj0
       => (lambda (present? value)
            ...[VALUE is bound to the value of the entry]...)]
      ...)
@end example



@c page
@node lightweight-testing
@chapter Lightweight testing


@cindex @srfi{} lightweight-testing

The @library{srfi lightweight-testing} has been written by Sebastian
Egner as the reference implementation for @ansrfi{78}.


@menu
* lightweight-testing license::         Original license.
* lightweight-testing abstract::        Abstract.
* lightweight-testing rationale::       Rationale.
* lightweight-testing spec::            Specification.
* lightweight-testing references::      References.
@end menu

@c page
@node lightweight-testing license
@section Original license


Copyright @copyright{} 2005--2006 Sebastian Egner.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


@c page
@node lightweight-testing abstract
@section Abstract


A simple mechanism is defined for testing Scheme programs.  As a most
primitive example, the expression:

@example
(check (+ 1 1) => 3)
@end example

@noindent
evaluates the expression @code{(+ 1 1)} and compares the result with the
expected result @code{3} provided after the syntactic keyword @code{=>}.
Then the outcome of this comparison is reported in human--readable form
by printing a message of the form:

@example
(+ 1 1) => 2 ; *** failed ***
; expected result: 3
@end example

Moreover, the outcome of any executed check is recorded in a global
state counting the number of correct and failed checks and storing the
first failed check.  At the end of a file, or at any other point, the
user can print a summary using @func{check-report}.

In addition to the simple test above, it is also possible to execute a
parametric sequence of checks.  Syntactically, this takes the form of an
eager comprehension in the sense of @ansrfi{42}.  For example:

@example
(check-ec (:range e 100)
          (:let x (expt 2.0 e))
  (= (+ x 1) x) => #f (e x))
@end example

This statement runs the variable e through @code{@{0..99@}} and for each
binding defines @var{x} as @code{(expt 2.0 e)}.  Then it is checked if
@code{(+ x 1)} is equal to @var{x}, and it is expected that this is not
the case (i.e. expected value is @false{}).  The trailing @code{(e x)}
tells the reporting mechanism to print the values of both @var{e} and
@var{x} in case of a failed check.  The output could look like this:

@example
(let ((e 53) (x 9007199254740992.0)) (= (+ x 1) x)) => #t ; *** failed ***
; expected result: #f
@end example

The specification of bindings to report, @code{(e x)} in the example, is
optional but very informative.  Other features of this @srfi{} are:

@itemize
@item
a way to specify a different equality predicate (default is
@func{equal?});

@item
controlling the amount of reporting being printed;

@item
switching off the execution and reporting of checks entriely;

@item
retrieving a boolean if all checks have been executed and passed.
@end itemize



@c page
@node lightweight-testing rationale
@section Rationale


The mechanism defined in this @srfi{} should be available in every
Scheme system because it has already proven useful for interactive
development----of @srfi{}s.

Although it is extremely straightforward, the origin of the particular
mechanism described here is the @file{examples.scm} file accompanying
the reference implementation of @ansrfi{42}.  The same mechanism has been
reimplemented for the reference implementation of @srfi{67}, and a
simplified version is yet again found in the reference implementation of
@ansrfi{77}.

The mechanism in this @srfi{} does not replace more sophisticated
approaches to unit testing, like @srfi{64} or SchemeUnit.  These
systems provide more control of the testing, separate the definition of
a test, its execution, and its reports, and provide several other
features.

Neil Van Dyke's Testeez library is very close in spirit to this
@srfi{}.  In Testeez, tests are disabled by (re--)defining a macro.
The advantage of this method is that the code for the test cases can be
removed entirely, and hence even the dependency on the Testeez library.
This @srfi{} on the other hand, uses a Scheme conditional @code{(cond,
if)} to prevent execution of the testing code.  This method is more
dynamic but retains dead testing code, unless a compiler and a module
system are used to apply constant folding and dead code elimination.
The only major addition in @srfi{} over Testeez is the comprehension
for formulating parametric tests.

Design considerations for this @srfi{} include the following:

@itemize
@item
Reporting is human--readable and as specific as possible, i.e. not just
``assertion failed'' but the expression with actual and expected value,
and if possibly the relevant part of the bindings environment.

@item
An effort is made to print closed Scheme expressions, i.e. expressions
that can directly be copy/pasted into a @repl{} for further analysis
(e.g. the let expression in the abstract).

@item
By default the checks report both correct and failed checks.  However,
it is possible to reduce the output, or even to switch off the execution
of checks.  It has turned out useful to be able to run only some subset
checks for the features currently under development.  This can be done
by changing the reporting mode between differnt sections.

@item
The global state (correct/failed count) is not made available to the
user program.  This reduces the dependencies between different checks
because it is not possible to use the state.

@item
Ocassionally, it is useful to check that a certain expression does not
yield an ordinary result but raises an error.  However, @rnrs{5} does
not specify the mechanism by which this occurs (e.g. raising exception,
breaking into a @repl{}, aborting the program, etc.).  For this reason,
this @srfi{} is restricted to the case that the checked expressions
evaluate normally.

@item
Though usually I am very much in favor of strictly prefix syntax, for
this @srfi{} I make an exception because the infix @code{=>} syntax is
widely used and intuitive.
@end itemize



@c page
@node lightweight-testing spec
@section Specification


@deffn Syntax check @var{expr} (=> @var{equal}) @var{expected}
@deffnx Syntax check @var{expr} => @var{expected}
Evaluate @var{expr} and compare the value to the value of @var{expected}
using the predicate @var{equal}, which is @func{equal?} when omitted.
Then a report is printed according to the current mode setting (see
below) and the outcome is recorded in a global state to be used in
@func{check-report}.

The precise order of evaluation is that first @var{equal} and
@var{expected} are evaluated (in unspecified order) and then @var{expr}
is evaluated.  Example: @code{(check (+ 1 1) => 2)}.
@end deffn


@deffn Syntax check-ec @var{qualifier*} @var{expr} (=> @var{equal}) @var{expected} (@var{argument*}))
@deffnx Syntax check-ec @var{qualifier*} @var{expr} => @var{expected} (@var{argument*})
@deffnx Syntax check-ec @var{qualifier*} @var{expr} (=> @var{equal}) @var{expected}
@deffnx Syntax check-ec @var{qualifier*} @var{expr} => @var{expected}
An eager comprehension for executing a parametric sequence of checks.

Enumerate the sequence of bindings specified by @var{qualifier*}.  For
each binding evaluate @var{equal} and @var{expected} in unspecified
order. Then evaluate @var{expr} and compare the value obtained to the
value of @var{expected} using the value of @var{equal} as predicate,
which is @func{equal?} when omitted.

The comprehension stops after the first failed check, if there is any.
Then a report is printed according to the current mode setting (see
below) and the outcome is recorded in a global state to be used in
@func{check-report}.  The entire @func{check-ec} counts as a single
check.

In case the check fails @var{argument*} is used for constructing an
informative message with the argument values.  Use @var{argument*} to
list the relevant free variables of @var{expr} (see examples) that you
want to have printed.

A @var{qualifier} is any qualifier of an eager comprehension as
specified in @srfi{42}.

Examples:

@example
(check-ec (: e 100)
          (positive? (expt 2 e))
          => #t (e)) ; fails on fixnums

(check-ec (: e 100)
          (:let x (expt 2.0 e))
          (= (+ x 1) x)
          => #f (x)) ; fails

(check-ec (: x 10)
          (: y 10)
          (: z 10)
          (* x (+ y z))
          => (+ (* x y) (* x z))
             (x y z)) ; passes with 10^3 cases checked
@end example
@end deffn


@defun check-report
Print a summary and the first failed check, if there is any, depending
on the current mode settings.
@end defun


@defun check-set-mode! @var{mode}
Set the current mode to @var{mode}, which must be a symbol among:
@code{off}, @code{summary}, @code{report-failed}, @code{report}; the
default is @code{report}.  Note that you can change the mode at any
time, and that @func{check}, @func{check-ec} and @func{check-report} use
the current value.

The mode symbols have the following meaning:

@table @code
@item off
do not execute any of the checks;

@item summary
print only summary in @func{check-report} and nothing else;

@item report-failed
report failed checks when they happen, and in summary;

@item report
report every example executed.
@end table
@end defun


@defun check-reset!
Reset the global state (counters of correct/failed examples) to the
state immediately after loading the module for the first time, i.e. no
checks have been executed.
@end defun


@defun check-passed? @var{expected-total-count}
Return @true{} if there were no failed checks and
@var{expected-total-count} correct checks, @false{} otherwise.

Rationale: This procedure can be used in automatized tests by
terminating a test program with the statement:

@example
(exit (if (check-passed? n) 0 1))
@end example
@end defun



@c page
@node lightweight-testing references
@section References


@emph{@ansrfi{64}: a Scheme @api{} for test suites}. Per Bothner. January,
2005.

@center @url{http://srfi.schemers.org/srfi-64}

@noindent
@emph{SchemeUnit}.  Noel Welsh.  February, 2003.

@center @url{http://schematics.sourceforge.net/schemeunit.html}

@noindent
@emph{Testeez, Lightweight Unit Test Mechanism for Scheme}.  Neil Van
Dyke.  May, 2005.

@center @url{http://www.neilvandyke.org/testeez}

@noindent
@emph{Revised^5 Report on the Algorithmic Language Scheme}.

@center @url{http://www.schemers.org/Documents/Standards/R5RS/}

@noindent
@emph{@ansrfi{42}: eager comprehensions}.  Sebastian Egner.

@center @url{http://srfi.schemers.org/srfi-42}


@c page
@node environment-variables
@chapter Environment variables


@cindex @srfi{} environment-variables

The @library{srfi environment-variables} library has been written by
Taro Minowa (Higepon) as the reference implementation for @ansrfi{98}.


@menu
* environment-variables license::       Original license.
* environment-variables abstract::      Abstract.
* environment-variables rationale::     Rationale.
* environment-variables spec::          Specification.
* environment-variables issues::        Issues.
* environment-variables ack::           Acknowledgements.
@end menu


@c page
@node environment-variables license
@section Original license


Copyright @copyright{} 2008 Taro Minowa (Higepon).  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
``Software''), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

@c page
@node environment-variables abstract
@section Abstract


This @srfi{} specifies the procedure @func{get-environment-variable},
which gets the value of the specified environment variable, and the
procedure @func{get-environment-variables}, which gets an association
list of all environment-variables.


@c page
@node environment-variables rationale
@section Rationale


Most operating systems provide a mechanism for passing auxiliary
parameters implicitly to child processes.  Usually, this mechanism is
called ``the environment'', and is conceptually a map from string names
to string values.  The string names are called environment variables.

Some applications rely on environment variables to modify their behavior
according to local settings.  Also, various established protocols rely
on environment variables as a form of interprocess communication.  For
example, most implementations of the common gateway interface
(@acronym{CGI}) use environment variables to pass Meta--Variables from
the server to the script.  Environment variables are also required by
@ansrfi{96} @acronym{SLIB} Prerequisites.  Providing a means to access
environment variables is therefore indispensable for writing practical
programs in Scheme.

Most widely--used Scheme implementations provide a function for getting
the value of a specified environment variable.  The name for this
function is usually getenv, but varies (see below).  Some
implementations also provide a way to get all the environment variables,
but others do not.

This @srfi{} specifies a uniform interface for accessing environment
variables.  That should make it easier to write portable programs that
need access to their environment.  For example, a @acronym{CGI} program
may portably obtain the values of the Meta--Variables
@env{QUERY_STRING}, @env{CONTENT_LENGTH} and @env{REQUEST_METHOD} as in
the following examples:

@example
(get-environment-variable "QUERY_STRING") => "foo=bar&huga=hige"
(get-environment-variable "CONTENT_LENGTH") => "512"
(get-environment-variable "REQUEST_METHOD") => "post"
@end example


@c page
@node environment-variables spec
@section Specification


The following two procedures belong to the @rnrs{6} library named
@library{system}.  This is a provisional library name until the naming
rules for @rnrs{6} @srfi{} libraries are specified.

@deffn Procedure get-environment-variable @var{name}
Return the value of the named environment variable as a string, or
@false{} if the named environment variable is not found.  The name
argument is expected to be a string.  @func{get-environment-variable}
may use locale--setting information to encode the name and decode the
value of the environment variable.  If @func{get-environment-variable}
can't decode the value, @func{get-environment-variable} may raise an
exception.

@example
(get-environment-variable "PATH")
=> "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin"
@end example
@end deffn


@deffn Procedure get-environment-variables
Return names and values of all the environment variables as an alist.
The same decoding considerations as for @func{get-environment-variable}
apply.

@example
(get-environment-variables)
=> (("PATH" . "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin")
    ("USERNAME" . "taro"))
@end example
@end deffn


@c page
@node environment-variables issues
@section Issues


@func{get-environment-variable} is expected to return a ``Scheme
string''.

Unfortunately, many current platforms, including @posix{}--like ones, do
not require environment variables to be interpretable as sequences of
characters.  In particular, environment variables can be used to name
files, and filenames on the system can amount to @code{NULL}--terminated
byte vectors, which, if the Scheme program were to collect uninterpreted
and pass to, say, the open call, would work just fine, but which might
not represent a string in the particular encoding the program expects.

While in principle it may be desirable to provide a mechanism for
accessing environment variables raw, this @srfi{} specifies a ``string''
return type because that best represents the consensus of existing
implementations, and captures the semantically desirable behavior in the
common case that the byte sequence is interpretable as a string.


@c page
@node environment-variables ack
@section Acknowledgements


Thanks to Shiro Kawai, Alexey Radul, jmuk, Kokosabu, leque and all the
members of the @code{#Lisp_Scheme} @acronym{IRC} channel on Freenode.


@c page
@node Documentation License
@appendix GNU Free Documentation License

@include fdl.texiinc


@c page
@node references
@appendix Bibliography and references


See the @srfi{} official site:

@center @url{http://srfi.schemers.org/}


@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
